{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPresum ( vector < int > a , vector < int > b ) { int X = max ( a [ 0 ] , 0 ) ; for ( int i = 1 ; i < a . size ( ) ; i ++ ) { a [ i ] += a [ i - 1 ] ; X = max ( X , a [ i ] ) ; } int Y = max ( b [ 0 ] , 0 ) ; for ( int i = 1 ; i < b . size ( ) ; i ++ ) { b [ i ] += b [ i - 1 ] ; Y = max ( Y , b [ i ] ) ; } return X + Y ; } int main ( ) { vector < int > A = { 2 , -1 , 4 , -5 } ; vector < int > B = { 4 , -3 , 12 , 4 , -3 } ; cout << maxPresum ( A , B ) << endl ; }", "docstring": "Maximum Prefix Sum possible by merging two given arrays | C ++ Program to implement the above approach ; Stores the maximum prefix sum of the array A [ ] ; Traverse the array A [ ] ; Stores the maximum prefix sum of the array B [ ] ; Traverse the array B [ ] ; Driver code", "dfg": [["i", 43, "comesFrom", ["i"], [39]], ["i", 51, "comesFrom", ["i"], [39]], ["i", 100, "comesFrom", ["i"], [96]], ["i", 108, "comesFrom", ["i"], [96]], ["i", 57, "comesFrom", ["i"], [39]], ["i", 114, "comesFrom", ["i"], [96]], ["i", 62, "comesFrom", ["i"], [39]], ["i", 119, "comesFrom", ["i"], [96]], ["i", 75, "comesFrom", ["i"], [39]], ["i", 132, "comesFrom", ["i"], [96]], ["X", 138, "comesFrom", ["X"], [67]], ["X", 71, "comesFrom", ["X"], [67]], ["Y", 140, "comesFrom", ["Y"], [124]], ["Y", 128, "comesFrom", ["Y"], [124]], ["a", 45, "comesFrom", ["a"], [14]], ["a", 28, "comesFrom", ["a"], [14]], ["a", 55, "comesFrom", ["a"], [14]], ["a", 60, "comesFrom", ["a"], [14]], ["a", 73, "comesFrom", ["a"], [14]], ["b", 102, "comesFrom", ["b"], [20]], ["b", 85, "comesFrom", ["b"], [20]], ["b", 112, "comesFrom", ["b"], [20]], ["b", 117, "comesFrom", ["b"], [20]], ["b", 130, "comesFrom", ["b"], [20]], ["A", 186, "comesFrom", ["A"], [152]], ["B", 188, "comesFrom", ["B"], [168]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sumOfTwoCubes ( int n ) { long long int lo = 1 , hi = ( long long int ) cbrt ( n ) ; while ( lo <= hi ) { long long int curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; } int main ( ) { int N = 28 ; if ( sumOfTwoCubes ( N ) ) { cout << \" True \" ; } else { cout << \" False \" ; } return 0 ; }", "docstring": "Check if a number can be represented as sum of two positive perfect cubes | C ++ program for the above approach ; Function to check if N can be represented as sum of two perfect cubes or not ; if it is same return true ; ; if the curr smaller than n increment the lo ; if the curr is greater than curr decrement the hi ; Driver Code ; Function call to check if N can be represented as sum of two perfect cubes or not", "dfg": [["lo", 35, "comesFrom", ["lo"], [17]], ["lo", 74, "comesFrom", ["lo"], [17]], ["lo", 50, "comesFrom", ["lo"], [17]], ["lo", 46, "comesFrom", ["lo"], [17]], ["lo", 48, "comesFrom", ["lo"], [17]], ["hi", 37, "comesFrom", ["hi"], [21]], ["hi", 78, "comesFrom", ["hi"], [21]], ["hi", 56, "comesFrom", ["hi"], [21]], ["hi", 52, "comesFrom", ["hi"], [21]], ["hi", 54, "comesFrom", ["hi"], [21]], ["N", 100, "comesFrom", ["N"], [92]], ["n", 30, "comesFrom", ["n"], [11]], ["n", 63, "comesFrom", ["n"], [11]], ["n", 72, "comesFrom", ["n"], [11]], ["curr", 61, "comesFrom", ["curr"], [43]], ["curr", 70, "comesFrom", ["curr"], [43]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sieve [ 1000000 ] ; void sieveOfPrimes ( ) { memset ( sieve , 1 , sizeof ( sieve ) ) ; int N = 1000000 ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( sieve [ i ] == 0 ) continue ; for ( int j = i * i ; j <= N ; j += i ) sieve [ j ] = 0 ; } } void getArray ( int * arr , int N ) { int A [ N ] = { 0 } ; vector < int > v ; sieveOfPrimes ( ) ; for ( int i = 2 ; i <= 1e5 ; i ++ ) if ( sieve [ i ] ) v . push_back ( i ) ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int ind = arr [ i ] ; if ( A [ i ] != 0 ) continue ; else if ( A [ ind ] != 0 ) A [ i ] = A [ ind ] ; else { int prime = v [ j ++ ] ; A [ i ] = prime ; A [ ind ] = A [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 4 , 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getArray ( arr , N ) ; return 0 ; }", "docstring": "Generate an N | C ++ program for the above approach ; Function to generate all prime numbers upto 10 ^ 6 ; Initialize sieve [ ] as 1 ; Iterate over the range [ 2 , N ] ; If current element is non - prime ; Make all multiples of i as 0 ; Function to construct an array A [ ] satisfying the given conditions ; Stores the resultant array ; Stores all prime numbers ; Sieve of Erastosthenes ; Append the integer i if it is a prime ; Indicates current position in list of prime numbers ; Traverse the array arr [ ] ; If already filled with another prime number ; If A [ i ] is not filled but A [ ind ] is filled ; Store A [ i ] = A [ ind ] ; If none of them were filled ; To make sure A [ i ] does not affect other values , store next prime number ; Print the resultant array ; Driver Code ; Function Call", "dfg": [["N", 46, "comesFrom", ["N"], [31]], ["N", 162, "comesFrom", ["N"], [97]], ["N", 246, "comesFrom", ["N"], [97]], ["N", 103, "comesFrom", ["N"], [97]], ["N", 307, "comesFrom", ["N"], [288]], ["N", 74, "comesFrom", ["N"], [31]], ["i", 48, "comesFrom", ["i"], [38]], ["i", 127, "comesFrom", ["i"], [123]], ["i", 131, "comesFrom", ["i"], [123]], ["i", 160, "comesFrom", ["i"], [156]], ["i", 164, "comesFrom", ["i"], [156]], ["i", 244, "comesFrom", ["i"], [240]], ["i", 248, "comesFrom", ["i"], [240]], ["i", 42, "comesFrom", ["i"], [38]], ["i", 44, "comesFrom", ["i"], [38]], ["i", 78, "comesFrom", ["i"], [38]], ["i", 138, "comesFrom", ["i"], [123]], ["i", 145, "comesFrom", ["i"], [123]], ["i", 68, "comesFrom", ["i"], [38]], ["i", 70, "comesFrom", ["i"], [38]], ["i", 173, "comesFrom", ["i"], [156]], ["i", 56, "comesFrom", ["i"], [38]], ["i", 180, "comesFrom", ["i"], [156]], ["i", 256, "comesFrom", ["i"], [240]], ["i", 199, "comesFrom", ["i"], [156]], ["i", 220, "comesFrom", ["i"], [156]], ["i", 232, "comesFrom", ["i"], [156]], ["j", 72, "comesFrom", ["j"], [66]], ["j", 82, "comesFrom", ["j"], [76]], ["j", 214, "comesFrom", ["j"], [149]], ["v", 141, "comesFrom", ["v"], [114]], ["v", 212, "comesFrom", ["v"], [114]], ["ind", 192, "comesFrom", ["ind"], [169]], ["ind", 204, "comesFrom", ["ind"], [169]], ["ind", 227, "comesFrom", ["ind"], [169]], ["prime", 223, "comesFrom", ["prime"], [210]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long findNthNumber ( long long N ) { long long result = 0 ; long long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; } int main ( ) { int N = 9 ; cout << findNthNumber ( N ) ; return 0 ; }", "docstring": "Nth natural number after removing all numbers consisting of the digit 9 | C ++ implementation of above approach ; Function to find Nth number in base 9 ; Stores the Nth number ; Iterate while N is greater than 0 ; Update result ; Divide N by 9 ; Multiply p by 10 ; Return result ; Driver Code", "dfg": [["result", 61, "comesFrom", ["result"], [35]], ["N", 30, "comesFrom", ["N"], [13]], ["N", 78, "comesFrom", ["N"], [70]], ["N", 49, "comesFrom", ["N"], [47]], ["N", 41, "comesFrom", ["N"], [13]], ["p", 55, "comesFrom", ["p"], [53]], ["p", 38, "comesFrom", ["p"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( int A , int B ) { if ( A == B ) { return 1 ; } int dig1 = floor ( log10 ( A ) + 1 ) ; int dig2 = floor ( log10 ( B ) + 1 ) ; if ( dig1 != dig2 ) { return 0 ; } int temp = A ; while ( 1 ) { int power = pow ( 10 , dig1 - 1 ) ; int firstdigit = A / power ; A = A - firstdigit * power ; A = A * 10 + firstdigit ; if ( A == B ) { return 1 ; } if ( A == temp ) { return 0 ; } } } int main ( ) { int A = 967 , B = 679 ; if ( check ( A , B ) ) cout << \" Yes \" ; else cout << \" No \" << endl ; return 0 ; }", "docstring": "Check if an integer is rotation of another given integer | C ++ implementation of the approach ; Function to check if the integer A is a rotation of the integer B ; Stores the count of digits in A ; Stores the count of digits in B ; If dig1 not equal to dig2 ; Stores position of first digit ; Stores the first digit ; Rotate the digits of the integer ; If A is equal to B ; If A is equal to the initial value of integer A ; Driver Code", "dfg": [["A", 19, "comesFrom", ["A"], [11]], ["A", 152, "comesFrom", ["A"], [140]], ["A", 90, "comesFrom", ["A"], [68]], ["A", 96, "comesFrom", ["A"], [94]], ["A", 112, "comesFrom", ["A"], [102]], ["A", 123, "comesFrom", ["A"], [102]], ["A", 104, "comesFrom", ["A"], [102]], ["A", 35, "comesFrom", ["A"], [11]], ["B", 21, "comesFrom", ["B"], [14]], ["B", 154, "comesFrom", ["B"], [144]], ["B", 114, "comesFrom", ["B"], [14]], ["B", 48, "comesFrom", ["B"], [14]], ["dig1", 56, "comesFrom", ["dig1"], [29]], ["dig1", 82, "comesFrom", ["dig1"], [29]], ["dig2", 58, "comesFrom", ["dig2"], [42]], ["power", 92, "comesFrom", ["power"], [76]], ["power", 100, "comesFrom", ["power"], [76]], ["firstdigit", 108, "comesFrom", ["firstdigit"], [88]], ["firstdigit", 98, "comesFrom", ["firstdigit"], [88]], ["temp", 125, "comesFrom", ["temp"], [66]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sameProductQuadruples ( int nums [ ] , int N ) { unordered_map < int , int > umap ; int res = 0 ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = i + 1 ; j < N ; ++ j ) { int prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } cout << res ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sameProductQuadruples ( arr , N ) ; return 0 ; }", "docstring": "Count of quadruples with product of a pair equal to the product of the remaining pair | C ++ program for the above approach ; Function to count the number of unique quadruples from an array that satisfies the given condition ; Hashmap to store the product of pairs ; Store the count of required quadruples ; Traverse the array arr [ ] and generate all possible pairs ; Store their product ; Pair ( a , b ) can be used to generate 8 unique permutations with another pair ( c , d ) ; Increment um [ prod ] by 1 ; Print the result ; Driver Code", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 44, "comesFrom", ["i"], [35]], ["i", 52, "comesFrom", ["i"], [35]], ["i", 69, "comesFrom", ["i"], [35]], ["N", 41, "comesFrom", ["N"], [16]], ["N", 139, "comesFrom", ["N"], [120]], ["N", 58, "comesFrom", ["N"], [16]], ["res", 96, "comesFrom", ["res"], [77]], ["j", 56, "comesFrom", ["j"], [50]], ["j", 61, "comesFrom", ["j"], [50]], ["j", 74, "comesFrom", ["j"], [50]], ["umap", 87, "comesFrom", ["umap"], [25]], ["umap", 81, "comesFrom", ["umap"], [25]], ["prod", 89, "comesFrom", ["prod"], [65]], ["prod", 83, "comesFrom", ["prod"], [65]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1000000007 ; int power ( int x , unsigned int y , int p = MOD ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * 1LL * x ) % p ; y = y >> 1 ; x = ( x * 1LL * x ) % p ; } return res ; } void totalWays ( int N , int M ) { int X = N / 2 ; int S = ( X * 1LL * ( X + 1 ) ) % MOD ; cout << power ( S , M , MOD ) << \" STRNEWLINE \" ; } int main ( ) { int N = 5 , M = 2 ; totalWays ( N , M ) ; return 0 ; }", "docstring": "Count ways to place M objects in distinct partitions of N boxes | C ++ implementation of the above Approach ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize Result ; Update x if x >= MOD to avoid multiplication overflow ; If y is odd , multiply x with result ; y = y / 2 ; Change x to x ^ 2 ; Utility function to find the Total Number of Ways ; Number of Even Indexed Boxes ; Number of partitions of Even Indexed Boxes ; Number of ways to distribute objects ; Driver Code ; N = number of boxes M = number of distinct objects ; Function call to get Total Number of Ways", "dfg": [["res", 85, "comesFrom", ["res"], [53]], ["res", 56, "comesFrom", ["res"], [53]], ["MOD", 26, "comesFrom", ["MOD"], [9]], ["MOD", 120, "comesFrom", ["MOD"], [9]], ["MOD", 130, "comesFrom", ["MOD"], [9]], ["x", 36, "comesFrom", ["x"], [34]], ["x", 78, "comesFrom", ["x"], [71]], ["x", 60, "comesFrom", ["x"], [34]], ["x", 74, "comesFrom", ["x"], [71]], ["y", 42, "comesFrom", ["y"], [21]], ["y", 49, "comesFrom", ["y"], [21]], ["y", 67, "comesFrom", ["y"], [65]], ["N", 101, "comesFrom", ["N"], [92]], ["N", 154, "comesFrom", ["N"], [144]], ["M", 156, "comesFrom", ["M"], [148]], ["M", 128, "comesFrom", ["M"], [95]], ["S", 126, "comesFrom", ["S"], [106]], ["X", 109, "comesFrom", ["X"], [99]], ["X", 114, "comesFrom", ["X"], [99]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void isCycleExists ( int arr [ ] , int N ) { bool valley = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { cout << \" Yes \" << endl ; return ; } } cout << \" No \" ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isCycleExists ( arr , N ) ; return 0 ; }", "docstring": "Check if a graph constructed from an array based on given conditions consists of a cycle or not | C ++ program for the above approach ; Function to check if the graph constructed from given array contains a cycle or not ; Traverse the array ; If arr [ i ] is less than arr [ i - 1 ] and arr [ i ] ; Driver Code ; Given array ; Size of the array", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 43, "comesFrom", ["i"], [27]], ["i", 55, "comesFrom", ["i"], [27]], ["i", 48, "comesFrom", ["i"], [27]], ["i", 60, "comesFrom", ["i"], [27]], ["N", 33, "comesFrom", ["N"], [16]], ["N", 127, "comesFrom", ["N"], [108]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMax ( int arr [ ] , int N , int K ) { for ( int i = 1 ; i < N ; i ++ ) { int cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } cout << arr [ 0 ] ; } int main ( ) { int arr [ ] = { 1 , 0 , 3 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; getMax ( arr , N , K ) ; return 0 ; }", "docstring": "Maximize first array element by performing given operations at most K times | C ++ program for the above approach ; Function to maximize the first array element ; Traverse the array ; Initialize cur_val to a [ i ] ; If all operations are not over yet ; If current value is greater than zero ; Incrementing first element of array by 1 ; Decrementing current value of array by 1 ; Decrementing number of operations by i ; If current value is zero , then break ; Print first array element ; Driver Code ; Given array ; Size of the array ; Given K ; Prints the maximum possible value of the first array element", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 49, "comesFrom", ["i"], [25]], ["i", 42, "comesFrom", ["i"], [25]], ["i", 81, "comesFrom", ["i"], [25]], ["N", 31, "comesFrom", ["N"], [16]], ["N", 142, "comesFrom", ["N"], [118]], ["K", 144, "comesFrom", ["K"], [134]], ["K", 47, "comesFrom", ["K"], [19]], ["K", 79, "comesFrom", ["K"], [77]], ["cur_val", 54, "comesFrom", ["cur_val"], [38]], ["cur_val", 73, "comesFrom", ["cur_val"], [71]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int DistinctValues ( int arr [ ] , int N ) { int max_value = INT_MIN ; for ( int i = 0 ; i < N ; ++ i ) { max_value = max ( max_value , arr [ i ] ) ; } int GCDArr = arr [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { GCDArr = gcd ( GCDArr , arr [ i ] ) ; } int answer = ( max_value / GCDArr ) + 1 ; return answer ; } int main ( ) { int arr [ ] = { 4 , 12 , 16 , 24 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << DistinctValues ( arr , N ) ; return 0 ; }", "docstring": "Count Non | C ++ program of the above approach ; Function to find the gcd of the two numbers ; Function to find distinct elements in the array by repeatidely inserting the absolute difference of all possible pairs ; Stores largest element of the array ; Traverse the array , arr [ ] ; Update max_value ; Stores GCD of array ; Traverse the array , arr [ ] ; Update GCDArr ; Stores distinct elements in the array by repeatidely inserting absolute difference of all possible pairs ; Driver Code ; Given array arr [ ]", "dfg": [["answer", 130, "comesFrom", ["answer"], [119]], ["b", 24, "comesFrom", ["b"], [14]], ["b", 29, "comesFrom", ["b"], [14]], ["i", 61, "comesFrom", ["i"], [57]], ["i", 66, "comesFrom", ["i"], [57]], ["i", 97, "comesFrom", ["i"], [93]], ["i", 102, "comesFrom", ["i"], [93]], ["i", 77, "comesFrom", ["i"], [57]], ["i", 113, "comesFrom", ["i"], [93]], ["N", 63, "comesFrom", ["N"], [46]], ["N", 99, "comesFrom", ["N"], [46]], ["N", 172, "comesFrom", ["N"], [154]], ["a", 19, "comesFrom", ["a"], [11]], ["a", 33, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]], ["max_value", 122, "comesFrom", ["max_value"], [69]], ["max_value", 73, "comesFrom", ["max_value"], [69]], ["GCDArr", 124, "comesFrom", ["GCDArr"], [105]], ["GCDArr", 109, "comesFrom", ["GCDArr"], [105]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSwaps ( vector < vector < int > > & b ) { int n = b . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( b [ 0 ] [ 0 ] ^ b [ 0 ] [ j ] ^ b [ i ] [ 0 ] ^ b [ i ] [ j ] ) return -1 ; } } int rowSum = 0 ; int colSum = 0 ; int rowSwap = 0 ; int colSwap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { rowSum += b [ i ] [ 0 ] ; colSum += b [ 0 ] [ i ] ; rowSwap += b [ i ] [ 0 ] == i % 2 ; colSwap += b [ 0 ] [ i ] == i % 2 ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return -1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return -1 ; if ( n % 2 == 1 ) { if ( colSwap % 2 ) colSwap = n - colSwap ; if ( rowSwap % 2 ) rowSwap = n - rowSwap ; } else { colSwap = min ( colSwap , n - colSwap ) ; rowSwap = min ( rowSwap , n - rowSwap ) ; } return ( rowSwap + colSwap ) / 2 ; } int main ( ) { vector < vector < int > > M = { { 0 , 1 , 1 , 0 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 0 , 1 } } ; int ans = minSwaps ( M ) ; cout << ans ; }", "docstring": "Minimum row or column swaps required to make every pair of adjacent cell of a Binary Matrix distinct | C ++ program for the above approach ; Function to return number of moves to convert matrix into chessboard ; Size of the matrix ; Traverse the matrix ; Initialize rowSum to count 1 s in row ; Initialize colSum to count 1 s in column ; To store no . of rows to be corrected ; To store no . of columns to be corrected ; Traverse in the range [ 0 , N - 1 ] ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if N is odd ; Check if column required to be corrected is odd and then assign N - colSwap to colSwap ; Check if rows required to be corrected is odd and then assign N - rowSwap to rowSwap ; Take min of colSwap and N - colSwap ; Take min of rowSwap and N - rowSwap ; Finally return answer ; Driver Code ; Given matrix ; Function Call ; Print answer", "dfg": [["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 126, "comesFrom", ["i"], [122]], ["i", 130, "comesFrom", ["i"], [122]], ["i", 151, "comesFrom", ["i"], [122]], ["i", 164, "comesFrom", ["i"], [122]], ["i", 178, "comesFrom", ["i"], [122]], ["i", 138, "comesFrom", ["i"], [122]], ["i", 175, "comesFrom", ["i"], [122]], ["i", 158, "comesFrom", ["i"], [122]], ["i", 88, "comesFrom", ["i"], [33]], ["i", 80, "comesFrom", ["i"], [33]], ["n", 39, "comesFrom", ["n"], [22]], ["n", 128, "comesFrom", ["n"], [22]], ["n", 54, "comesFrom", ["n"], [22]], ["n", 227, "comesFrom", ["n"], [22]], ["n", 187, "comesFrom", ["n"], [22]], ["n", 208, "comesFrom", ["n"], [22]], ["n", 242, "comesFrom", ["n"], [22]], ["n", 254, "comesFrom", ["n"], [22]], ["n", 194, "comesFrom", ["n"], [22]], ["n", 215, "comesFrom", ["n"], [22]], ["n", 267, "comesFrom", ["n"], [22]], ["n", 278, "comesFrom", ["n"], [22]], ["ans", 360, "comesFrom", ["ans"], [351]], ["j", 52, "comesFrom", ["j"], [48]], ["j", 56, "comesFrom", ["j"], [48]], ["j", 91, "comesFrom", ["j"], [48]], ["j", 75, "comesFrom", ["j"], [48]], ["rowSum", 185, "comesFrom", ["rowSum"], [134]], ["rowSum", 191, "comesFrom", ["rowSum"], [134]], ["colSum", 206, "comesFrom", ["colSum"], [144]], ["colSum", 212, "comesFrom", ["colSum"], [144]], ["rowSwap", 286, "comesFrom", ["rowSwap"], [272]], ["rowSwap", 248, "comesFrom", ["rowSwap"], [154]], ["rowSwap", 256, "comesFrom", ["rowSwap"], [252]], ["rowSwap", 276, "comesFrom", ["rowSwap"], [272]], ["rowSwap", 280, "comesFrom", ["rowSwap"], [272]], ["colSwap", 288, "comesFrom", ["colSwap"], [261]], ["colSwap", 236, "comesFrom", ["colSwap"], [168]], ["colSwap", 244, "comesFrom", ["colSwap"], [240]], ["colSwap", 265, "comesFrom", ["colSwap"], [261]], ["colSwap", 269, "comesFrom", ["colSwap"], [261]], ["M", 355, "comesFrom", ["M"], [306]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( 1 << i ) & N ) { result ++ ; } } cout << result << endl ; } int main ( ) { int N = 43 ; count_setbit ( N ) ; return 0 ; }", "docstring": "Minimum number of coins having value equal to powers of 2 required to obtain N | C ++ program for above approach ; Function to count of set bit in N ; Stores count of set bit in N ; Iterate over the range [ 0 , 31 ] ; If current bit is set ; Update result ; Driver Code", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 39, "comesFrom", ["i"], [22]], ["result", 52, "comesFrom", ["result"], [15]], ["result", 45, "comesFrom", ["result"], [15]], ["N", 69, "comesFrom", ["N"], [63]], ["N", 42, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE int ValOfTheExpression ( int n ) { int factorial [ n ] = { 0 } ; factorial [ 0 ] = factorial [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { factorial [ i ] = ( ( factorial [ i - 1 ] % mod ) * ( i % mod ) ) % mod ; } int dp [ n ] = { 0 } ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( ( dp [ i - 1 ] % mod ) * ( factorial [ i ] % mod ) ) % mod ; } return dp [ n ] ; } int main ( ) { int n = 4 ; cout << ValOfTheExpression ( n ) << \" STRNEWLINE \" ; }", "docstring": "Evaluate the expression ( N1 * ( N | C ++ program to implement the above approach ; Function to find the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; factorial [ i ] : Stores factorial of i ; Base Case for factorial ; Precompute the factorial ; dp [ N ] : Stores the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; Update dp [ i ] ; Return the answer . ; Driver Code ; Function call", "dfg": []}
{"code": "#include <iostream> NEW_LINE using namespace std ; void minChocolates ( int A [ ] , int N ) { int B [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { B [ i ] = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] > A [ i - 1 ] ) B [ i ] = B [ i - 1 ] + 1 ; else B [ i ] = 1 ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( A [ i ] > A [ i + 1 ] ) B [ i ] = max ( B [ i + 1 ] + 1 , B [ i ] ) ; else B [ i ] = max ( B [ i ] , 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += B [ i ] ; } cout << sum << \" STRNEWLINE \" ; } int main ( ) { int A [ ] = { 23 , 14 , 15 , 14 , 56 , 29 , 14 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minChocolates ( A , N ) ; }", "docstring": "Chocolate Distribution Problem | Set 2 | C ++ program for the above approach ; FUnction to print minimum number of candies required ; Distribute 1 chocolate to each ; Traverse from left to right ; Traverse from right to left ; Initialize sum ; Find total sum ; Return sum ; Driver Code ; Given array ; Size of the given array", "dfg": [["N", 22, "comesFrom", ["N"], [16]], ["N", 34, "comesFrom", ["N"], [16]], ["N", 57, "comesFrom", ["N"], [16]], ["N", 184, "comesFrom", ["N"], [16]], ["N", 253, "comesFrom", ["N"], [234]], ["N", 105, "comesFrom", ["N"], [16]], ["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 55, "comesFrom", ["i"], [51]], ["i", 59, "comesFrom", ["i"], [51]], ["i", 109, "comesFrom", ["i"], [103]], ["i", 113, "comesFrom", ["i"], [103]], ["i", 182, "comesFrom", ["i"], [178]], ["i", 186, "comesFrom", ["i"], [178]], ["i", 42, "comesFrom", ["i"], [28]], ["i", 194, "comesFrom", ["i"], [178]], ["i", 67, "comesFrom", ["i"], [51]], ["i", 79, "comesFrom", ["i"], [51]], ["i", 121, "comesFrom", ["i"], [103]], ["i", 133, "comesFrom", ["i"], [103]], ["i", 72, "comesFrom", ["i"], [51]], ["i", 94, "comesFrom", ["i"], [51]], ["i", 126, "comesFrom", ["i"], [103]], ["i", 156, "comesFrom", ["i"], [103]], ["i", 84, "comesFrom", ["i"], [51]], ["i", 149, "comesFrom", ["i"], [103]], ["i", 163, "comesFrom", ["i"], [103]], ["i", 140, "comesFrom", ["i"], [103]], ["sum", 200, "comesFrom", ["sum"], [190]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArrayWithGivenLCM ( int N ) { vector < int > newArr ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { newArr . push_back ( i ) ; if ( N / i != i ) { newArr . push_back ( N / i ) ; } } } sort ( newArr . begin ( ) , newArr . end ( ) ) ; for ( auto i : newArr ) { cout << i << \" ▁ \" ; } } int main ( ) { int N = 12 ; constructArrayWithGivenLCM ( N ) ; return 0 ; }", "docstring": "Construct longest possible sequence of unique elements with given LCM | C ++ program to implement the above approach ; Function to construct an array of unique elements whose LCM is N ; Stores array elements whose LCM is N ; Iterate over the range [ 1 , sqrt ( N ) ] ; If N is divisible by i ; Insert i into newArr [ ] ; If N is not perfect square ; Sort the array newArr [ ] ; Print array elements ; Driver Code ; Given N ; Function Call", "dfg": [["i", 92, "comesFrom", ["i"], [23]], ["i", 33, "comesFrom", ["i"], [23]], ["i", 27, "comesFrom", ["i"], [23]], ["i", 29, "comesFrom", ["i"], [23]], ["i", 99, "comesFrom", ["i"], [23]], ["i", 41, "comesFrom", ["i"], [23]], ["i", 50, "comesFrom", ["i"], [23]], ["i", 59, "comesFrom", ["i"], [23]], ["i", 57, "comesFrom", ["i"], [23]], ["i", 68, "comesFrom", ["i"], [23]], ["newArr", 94, "comesFrom", ["newArr"], [18]], ["newArr", 76, "comesFrom", ["newArr"], [18]], ["newArr", 82, "comesFrom", ["newArr"], [18]], ["newArr", 46, "comesFrom", ["newArr"], [18]], ["newArr", 62, "comesFrom", ["newArr"], [18]], ["N", 31, "comesFrom", ["N"], [11]], ["N", 119, "comesFrom", ["N"], [113]], ["N", 39, "comesFrom", ["N"], [11]], ["N", 55, "comesFrom", ["N"], [11]], ["N", 66, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll getPower ( int p ) { ll res = 1 ; while ( p -- ) { res *= 5 ; } return res ; } ll countNumbersUtil ( ll N ) { ll count = 0 ; vector < int > digits ; while ( N ) { digits . push_back ( N % 10 ) ; N /= 10 ; } reverse ( digits . begin ( ) , digits . end ( ) ) ; int D = digits . size ( ) ; for ( int i = 1 ; i <= D ; i ++ ) { ll res = getPower ( i ) ; if ( i == D ) { for ( int p = 1 ; p <= D ; p ++ ) { int x = digits [ p - 1 ] ; ll tmp = 0 ; if ( p % 2 == 0 ) { tmp = ( 5 - ( x / 2 + 1 ) ) * getPower ( D - p ) ; } else { tmp = ( 5 - ( x + 1 ) / 2 ) * getPower ( D - p ) ; } res -= tmp ; if ( p % 2 != x % 2 ) { break ; } } } count += res ; } return count ; } void countNumbers ( ll L , ll R ) { cout << ( countNumbersUtil ( R ) - countNumbersUtil ( L - 1 ) ) << endl ; } int main ( ) { ll L = 128 , R = 162 ; countNumbers ( L , R ) ; return 0 ; }", "docstring": "Count numbers from given range having odd digits at odd places and even digits at even places | C ++ program to implement the above approach ; Function to calculate 5 ^ p ; Stores the result ; Multiply 5 p times ; Return the result ; Function to count all numbers upto N having odd digits at odd places and even digits at even places ; Stores the count ; Stores the digits of N ; Insert the digits of N ; Reverse the vector to arrange the digits from first to last ; Stores count of digits of n ; Stores the count of numbers with i digits ; If the last digit is reached , subtract numbers eceeding range ; Iterate over all the places ; Stores the digit in the pth place ; Stores the count of numbers having a digit greater than x in the p - th position ; Calculate the count of numbers exceeding the range if p is even ; Calculate the count of numbers exceeding the range if p is odd ; Subtract the count of numbers exceeding the range from total count ; If the parity of p and the parity of x are not same ; Add count of numbers having i digits and satisfies the given conditions ; Return the total count of numbers till n ; Function to calculate the count of numbers from given range having odd digits places and even digits at even places ; Count of numbers in range [ L , R ] = Count of numbers till R - ; Count of numbers till ( L - 1 ) ; Driver Code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; } int main ( ) { int N = 6 ; cout << alternatingSumOfFirst_N ( N ) ; return 0 ; }", "docstring": "Sum of first N natural numbers with alternate signs | C ++ program to implement the above approach ; Function to find the sum of first N natural numbers with alternate signs ; Stores sum of alternate sign of first N natural numbers ; If is an even number ; Update alternateSum ; If i is an odd number ; Update alternateSum ; Driver Code", "dfg": [["alternateSum", 58, "comesFrom", ["alternateSum"], [51]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 36, "comesFrom", ["i"], [22]], ["i", 46, "comesFrom", ["i"], [22]], ["i", 53, "comesFrom", ["i"], [22]], ["N", 28, "comesFrom", ["N"], [11]], ["N", 75, "comesFrom", ["N"], [67]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int findSum ( unsigned int N ) { unsigned int sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { sum += i ; } } return sum ; } int main ( ) { int N = 5 ; cout << findSum ( N ) ; return 0 ; }", "docstring": "Sum of all numbers up to N that are co | C ++ program for the above approach ; Function to return gcd of a and b ; Base Case ; Recursive GCD ; Function to calculate the sum of all numbers till N that are coprime with N ; Stores the resultant sum ; Iterate over [ 1 , N ] ; If gcd is 1 ; Update sum ; Return the final sum ; Driver Code ; Given N ; Function Call", "dfg": [["sum", 85, "comesFrom", ["sum"], [78]], ["b", 24, "comesFrom", ["b"], [14]], ["b", 29, "comesFrom", ["b"], [14]], ["i", 58, "comesFrom", ["i"], [54]], ["i", 62, "comesFrom", ["i"], [54]], ["i", 80, "comesFrom", ["i"], [54]], ["i", 70, "comesFrom", ["i"], [54]], ["N", 60, "comesFrom", ["N"], [42]], ["N", 102, "comesFrom", ["N"], [94]], ["N", 72, "comesFrom", ["N"], [42]], ["a", 19, "comesFrom", ["a"], [11]], ["a", 33, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define int  long long int NEW_LINE using namespace std ; void solve ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( auto x : mp ) { cnt += ( ( x . second ) * ( x . second - 1 ) / 2 ) ; } int ans [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = cnt - ( mp [ arr [ i ] ] - 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << \" ▁ \" ; } } int32_t main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; solve ( arr , N ) ; return 0 ; }", "docstring": "Count all distinct pairs of repeating elements from the array for every array element | C ++ program for the above approach ; Function to print the required count of pairs excluding the current element ; Store the frequency ; Find all the count ; Delete the contribution of each element for equal pairs ; Print the answer ; Driver Code ; Given array arr [ ] ; Function Call", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMode ( int a [ ] , int n ) { map < int , int > mp ; int max = 0 ; int mode = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ a [ i ] ] ++ ; if ( mp [ a [ i ] ] >= max ) { max = mp [ a [ i ] ] ; mode = a [ i ] ; } cout << mode << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 2 , 7 , 3 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMode ( arr , n ) ; return 0 ; }", "docstring": "Mode in a stream of integers ( running integers ) | C ++ program to implement the above approach ; Function that prints the Mode values ; Map used to mp integers to its frequency ; To store the maximum frequency ; To store the element with the maximum frequency ; Loop used to read the elements one by one ; Updates the frequency of that element ; Checks for maximum Number of occurrence ; Updates the maximum frequency ; Updates the Mode ; Driver Code ; Function call", "dfg": [["i", 44, "comesFrom", ["i"], [40]], ["i", 48, "comesFrom", ["i"], [40]], ["i", 56, "comesFrom", ["i"], [40]], ["i", 88, "comesFrom", ["i"], [40]], ["i", 67, "comesFrom", ["i"], [40]], ["i", 80, "comesFrom", ["i"], [40]], ["n", 46, "comesFrom", ["n"], [16]], ["n", 144, "comesFrom", ["n"], [125]], ["mp", 52, "comesFrom", ["mp"], [25]], ["mp", 63, "comesFrom", ["mp"], [25]], ["mp", 76, "comesFrom", ["mp"], [25]], ["max", 71, "comesFrom", ["max"], [28]], ["mode", 94, "comesFrom", ["mode"], [84]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll modexp ( ll x , ll n , ll m ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 , m ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 , m ) % m ) ; } } ll modInverse ( ll x , ll m ) { return modexp ( x , m - 2 , m ) ; } void countNumbers ( string N ) { ll m = 1000000007 ; ll factorial [ 100001 ] ; factorial [ 0 ] = 1 ; for ( ll i = 1 ; i < 100001 ; i ++ ) { factorial [ i ] = ( factorial [ i - 1 ] * i ) % m ; } ll count [ 10 ] ; for ( ll i = 0 ; i < 10 ; i ++ ) { count [ i ] = 0 ; } ll length = N . length ( ) ; for ( ll i = 0 ; i < length ; i ++ ) count [ N [ i ] - '0' ] ++ ; ll result = factorial [ length ] ; for ( ll i = 0 ; i < 10 ; i ++ ) { result = ( result * modInverse ( factorial [ count [ i ] ] , m ) ) % m ; } cout << result ; } int main ( ) { string N = \"0223\" ; countNumbers ( N ) ; return 0 ; }", "docstring": "Count of distinct numbers formed by shuffling the digits of a large number N | C ++ program for the above approach ; Recursive function to return the value of ( x ^ n ) % m ; Base Case ; If N is even ; Else N is odd ; Function to find modular inverse of a number x under modulo m ; Using Fermat 's little theorem ; Function to count of numbers formed by shuffling the digits of a large number N ; Modulo value ; Array to store the factorials upto the maximum value of N ; Store factorial of i at index i ; To store count of occurrence of a digit ; Increment the count of digit occured ; Assign the factorial of length of input ; Multiplying result with the modulo multiplicative inverse of factorial of count of i ; Print the result ; Driver Code ; Given Number as string ; Function call", "dfg": []}
{"code": "#include <iostream> NEW_LINE #include <unordered_map> NEW_LINE #include <vector> NEW_LINE using namespace std ; int spf [ 10001 ] ; void spf_array ( int spf [ ] ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < 1000 ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < 1000 ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < 1000 ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < 1000 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } void frequent_prime ( int arr [ ] , int N , int K ) { spf_array ( spf ) ; unordered_map < int , int > Hmap ; vector < int > result ; int i = 0 ; int c = 0 ; for ( i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; while ( x != 1 ) { Hmap [ spf [ x ] ] = Hmap [ spf [ x ] ] + 1 ; x = x / spf [ x ] ; } } Hmap . erase ( 1 ) ; for ( auto x : Hmap ) { int primeNum = x . first ; int frequency = x . second ; if ( frequency % K == 0 ) { result . push_back ( primeNum ) ; } } if ( result . size ( ) > 0 ) { for ( auto & it : result ) { cout << it << ' ▁ ' ; } } else { cout << \" { } \" ; } } int main ( ) { int arr [ ] = { 1 , 4 , 6 } ; int K = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; frequent_prime ( arr , N , K ) ; }", "docstring": "Find prime factors of Array elements whose sum of exponents is divisible by K | C ++ program for the above approach ; To store the smallest prime factor till 10 ^ 5 ; Function to compute smallest prime factor array ; Initialize the spf array first element ; Marking smallest prime factor for every number to be itself ; Separately marking smallest prime factor for every even number as 2 ; Checking if i is prime ; Marking SPF for all numbers divisible by i ; Marking spf [ j ] if it is not previously marked ; Function that finds minimum operation ; Create a spf [ ] array ; Map created to store the unique prime numbers ; To store the result ; To store minimum operations ; To store every unique prime number ; Erase 1 as a key because it is not a prime number ; First Prime Number ; Frequency is divisible by K then insert primeNum in the result [ ] ; Print the elements if it exists ; Driver Code ; Given array arr [ ] ; Given K ; Function Call", "dfg": [["x", 253, "comesFrom", ["x"], [232]], ["x", 209, "comesFrom", ["x"], [200]], ["x", 261, "comesFrom", ["x"], [232]], ["x", 268, "comesFrom", ["x"], [232]], ["x", 234, "comesFrom", ["x"], [232]], ["x", 238, "comesFrom", ["x"], [232]], ["x", 218, "comesFrom", ["x"], [200]], ["x", 226, "comesFrom", ["x"], [200]], ["Hmap", 255, "comesFrom", ["Hmap"], [167]], ["Hmap", 243, "comesFrom", ["Hmap"], [167]], ["Hmap", 214, "comesFrom", ["Hmap"], [167]], ["Hmap", 222, "comesFrom", ["Hmap"], [167]], ["i", 42, "comesFrom", ["i"], [38]], ["i", 46, "comesFrom", ["i"], [38]], ["i", 63, "comesFrom", ["i"], [59]], ["i", 91, "comesFrom", ["i"], [81]], ["i", 191, "comesFrom", ["i"], [187]], ["i", 195, "comesFrom", ["i"], [187]], ["i", 54, "comesFrom", ["i"], [38]], ["i", 85, "comesFrom", ["i"], [81]], ["i", 87, "comesFrom", ["i"], [81]], ["i", 51, "comesFrom", ["i"], [38]], ["i", 73, "comesFrom", ["i"], [67]], ["i", 102, "comesFrom", ["i"], [81]], ["i", 120, "comesFrom", ["i"], [81]], ["i", 204, "comesFrom", ["i"], [187]], ["i", 99, "comesFrom", ["i"], [81]], ["i", 110, "comesFrom", ["i"], [81]], ["i", 112, "comesFrom", ["i"], [81]], ["i", 136, "comesFrom", ["i"], [81]], ["N", 193, "comesFrom", ["N"], [150]], ["N", 375, "comesFrom", ["N"], [356]], ["result", 307, "comesFrom", ["result"], [173]], ["result", 292, "comesFrom", ["result"], [173]], ["result", 281, "comesFrom", ["result"], [173]], ["K", 377, "comesFrom", ["K"], [351]], ["K", 276, "comesFrom", ["K"], [153]], ["j", 114, "comesFrom", ["j"], [108]], ["j", 129, "comesFrom", ["j"], [118]], ["j", 126, "comesFrom", ["j"], [118]], ["j", 133, "comesFrom", ["j"], [118]], ["frequency", 274, "comesFrom", ["frequency"], [266]], ["primeNum", 285, "comesFrom", ["primeNum"], [259]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Kmultiples ( int n , int k ) { int a = n ; for ( int i = 1 ; i <= k ; i ++ ) { cout << n << \" ▁ * ▁ \" << i << \" ▁ = ▁ \" << a << endl ; int j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } } int main ( ) { int N = 16 , K = 7 ; Kmultiples ( N , K ) ; return 0 ; }", "docstring": "Generate first K multiples of N using Bitwise operators | C ++ program to implement the above approach ; Function to print the first K multiples of N ; Print the value of N * i ; Iterate each bit of N and add pow ( 2 , pos ) , where pos is the index of each set bit ; Check if current bit at pos j is fixed or not ; For next set bit ; Driver Code", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 45, "comesFrom", ["i"], [25]], ["k", 31, "comesFrom", ["k"], [14]], ["N", 103, "comesFrom", ["N"], [93]], ["K", 105, "comesFrom", ["K"], [97]], ["a", 51, "comesFrom", ["a"], [18]], ["n", 62, "comesFrom", ["n"], [20]], ["n", 73, "comesFrom", ["n"], [20]], ["n", 39, "comesFrom", ["n"], [20]], ["j", 81, "comesFrom", ["j"], [56]], ["j", 67, "comesFrom", ["j"], [56]], ["j", 78, "comesFrom", ["j"], [56]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double calculateB ( int x [ ] , int y [ ] , int n ) { int sx = accumulate ( x , x + n , 0 ) ; int sy = accumulate ( y , y + n , 0 ) ; int sxsy = 0 ; int sx2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sxsy += x [ i ] * y [ i ] ; sx2 += x [ i ] * x [ i ] ; } double b = ( double ) ( n * sxsy - sx * sy ) / ( n * sx2 - sx * sx ) ; return b ; } void leastRegLine ( int X [ ] , int Y [ ] , int n ) { double b = calculateB ( X , Y , n ) ; int meanX = accumulate ( X , X + n , 0 ) / n ; int meanY = accumulate ( Y , Y + n , 0 ) / n ; double a = meanY - b * meanX ; cout << ( \" Regression ▁ line : \" ) << endl ; cout << ( \" Y ▁ = ▁ \" ) ; printf ( \" % .3f ▁ + ▁ \" , a ) ; printf ( \" % .3f ▁ * X \" , b ) ; } int main ( ) { int X [ ] = { 95 , 85 , 80 , 70 , 60 } ; int Y [ ] = { 90 , 80 , 70 , 65 , 60 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; leastRegLine ( X , Y , n ) ; }", "docstring": "Least Square Regression Line | C ++ program to find the regression line ; Function to calculate b ; sum of array x ; sum of array y ; for sum of product of x and y ; sum of square of x ; Function to find the least regression line ; Finding b ; Calculating a ; Printing regression line ; Driver code ; Statistical data", "dfg": [["b", 129, "comesFrom", ["b"], [103]], ["b", 235, "comesFrom", ["b"], [150]], ["b", 198, "comesFrom", ["b"], [150]], ["i", 69, "comesFrom", ["i"], [65]], ["i", 73, "comesFrom", ["i"], [65]], ["i", 81, "comesFrom", ["i"], [65]], ["i", 86, "comesFrom", ["i"], [65]], ["i", 93, "comesFrom", ["i"], [65]], ["i", 98, "comesFrom", ["i"], [65]], ["n", 71, "comesFrom", ["n"], [21]], ["n", 175, "comesFrom", ["n"], [146]], ["n", 191, "comesFrom", ["n"], [146]], ["n", 300, "comesFrom", ["n"], [279]], ["n", 158, "comesFrom", ["n"], [146]], ["n", 33, "comesFrom", ["n"], [21]], ["n", 47, "comesFrom", ["n"], [21]], ["n", 119, "comesFrom", ["n"], [21]], ["n", 170, "comesFrom", ["n"], [146]], ["n", 186, "comesFrom", ["n"], [146]], ["n", 109, "comesFrom", ["n"], [21]], ["meanY", 196, "comesFrom", ["meanY"], [178]], ["a", 226, "comesFrom", ["a"], [194]], ["meanX", 200, "comesFrom", ["meanX"], [162]], ["sx2", 121, "comesFrom", ["sx2"], [89]], ["sx", 123, "comesFrom", ["sx"], [25]], ["sx", 125, "comesFrom", ["sx"], [25]], ["sx", 113, "comesFrom", ["sx"], [25]], ["sxsy", 111, "comesFrom", ["sxsy"], [77]], ["sy", 115, "comesFrom", ["sy"], [39]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRepeatingDigits ( int N ) { int res = 0 ; int cnt [ 10 ] = { 0 } ; while ( N > 0 ) { int rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] > 1 ) { res ++ ; } } return res ; } int main ( ) { int N = 12 ; cout << countRepeatingDigits ( N ) ; return 0 ; }", "docstring": "Count of repeating digits in a given Number | C ++ program for the above approach ; Function that returns the count of repeating digits of the given number ; Initialize a variable to store count of Repeating digits ; Initialize cnt array to store digit count ; Iterate through the digits of N ; Retrieve the last digit of N ; Increase the count of digit ; Remove the last digit of N ; Iterate through the cnt array ; If frequency of digit is greater than 1 ; Increment the count of Repeating digits ; Return count of repeating digit ; Driver Code ; Given array arr [ ] ; Function Call", "dfg": [["res", 87, "comesFrom", ["res"], [15]], ["res", 81, "comesFrom", ["res"], [15]], ["i", 63, "comesFrom", ["i"], [59]], ["i", 67, "comesFrom", ["i"], [59]], ["i", 75, "comesFrom", ["i"], [59]], ["N", 31, "comesFrom", ["N"], [11]], ["N", 104, "comesFrom", ["N"], [96]], ["N", 39, "comesFrom", ["N"], [11]], ["N", 51, "comesFrom", ["N"], [49]], ["rem", 45, "comesFrom", ["rem"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTemperature ( int x , int y , int s ) { double Day1 , Day2 ; double diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; cout << \" Day1 ▁ : ▁ \" << Day1 << endl ; cout << \" Day2 ▁ : ▁ \" << Day2 << endl ; } int main ( ) { int x = 5 , y = 10 , s = 40 ; findTemperature ( x , y , s ) ; return 0 ; }", "docstring": "Find temperature of missing days using given sum and average | C ++ program for the above approach ; Function for finding the temperature ; Store Day1 - Day2 in diff ; Remaining from s will be Day1 ; Print Day1 and Day2 ; Driver Code ; Functions", "dfg": [["s", 48, "comesFrom", ["s"], [17]], ["s", 97, "comesFrom", ["s"], [87]], ["s", 41, "comesFrom", ["s"], [17]], ["Day2", 50, "comesFrom", ["Day2"], [36]], ["Day2", 68, "comesFrom", ["Day2"], [36]], ["Day1", 58, "comesFrom", ["Day1"], [46]], ["x", 93, "comesFrom", ["x"], [79]], ["x", 29, "comesFrom", ["x"], [11]], ["y", 95, "comesFrom", ["y"], [83]], ["y", 31, "comesFrom", ["y"], [14]], ["diff", 39, "comesFrom", ["diff"], [26]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int freqCount ( string str , char k ) { int count = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { if ( str [ i ] == k ) count ++ ; } return count ; } void findAandB ( int n , int k ) { int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freqCount ( to_string ( i ) , ( char ) ( k + 48 ) ) == 0 and freqCount ( to_string ( n - i ) , ( char ) ( k + 48 ) ) == 0 ) { cout << \" ( \" << i << \" , ▁ \" << n - i << \" ) \" ; flag = 1 ; break ; } } if ( flag == 0 ) cout << -1 ; } int main ( ) { int N = 100 ; int K = 0 ; findAandB ( N , K ) ; return 0 ; }", "docstring": "Find two numbers whose sum is N and does not contain any digit as K | C ++ program for the above approach ; Function to find two numbers whose sum is N and do not contain any digit as k ; Check every number i and ( n - i ) ; Check if i and n - i doesn 't  contain k in them print i and n-i ; Check if flag is 0 then print - 1 ; Driver Code ; Given N and K ; Function call", "dfg": [["count", 55, "comesFrom", ["count"], [18]], ["count", 50, "comesFrom", ["count"], [18]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 37, "comesFrom", ["i"], [25]], ["i", 80, "comesFrom", ["i"], [76]], ["i", 84, "comesFrom", ["i"], [76]], ["i", 45, "comesFrom", ["i"], [25]], ["i", 145, "comesFrom", ["i"], [76]], ["i", 137, "comesFrom", ["i"], [76]], ["i", 94, "comesFrom", ["i"], [76]], ["i", 115, "comesFrom", ["i"], [76]], ["n", 82, "comesFrom", ["n"], [62]], ["n", 143, "comesFrom", ["n"], [62]], ["n", 113, "comesFrom", ["n"], [62]], ["flag", 161, "comesFrom", ["flag"], [151]], ["N", 187, "comesFrom", ["N"], [176]], ["K", 189, "comesFrom", ["K"], [181]], ["str", 31, "comesFrom", ["str"], [11]], ["str", 43, "comesFrom", ["str"], [11]], ["k", 48, "comesFrom", ["k"], [14]], ["k", 101, "comesFrom", ["k"], [65]], ["k", 122, "comesFrom", ["k"], [65]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long calculate ( long long p , long long q ) { long long mod = 998244353 , expo ; expo = mod - 2 ; while ( expo ) { if ( expo & 1 ) { p = ( p * q ) % mod ; } q = ( q * q ) % mod ; expo >>= 1 ; } return p ; } int main ( ) { int p = 1 , q = 4 ; cout << calculate ( p , q ) << ' ' ; return 0 ; }", "docstring": "Find the value of P and modular inverse of Q modulo 998244353 | C ++ implementation to find the value of P . Q - 1 mod 998244353 ; Function to find the value of P * Q ^ - 1 mod 998244353 ; Loop to find the value until the expo is not zero ; Multiply p with q if expo is odd ; Reduce the value of expo by 2 ; Driver code ; Function Call", "dfg": [["p", 73, "comesFrom", ["p"], [46]], ["p", 94, "comesFrom", ["p"], [82]], ["p", 49, "comesFrom", ["p"], [46]], ["expo", 36, "comesFrom", ["expo"], [28]], ["expo", 41, "comesFrom", ["expo"], [28]], ["mod", 30, "comesFrom", ["mod"], [22]], ["mod", 65, "comesFrom", ["mod"], [22]], ["mod", 54, "comesFrom", ["mod"], [22]], ["q", 96, "comesFrom", ["q"], [86]], ["q", 60, "comesFrom", ["q"], [57]], ["q", 62, "comesFrom", ["q"], [57]], ["q", 51, "comesFrom", ["q"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxLCMWithGivenSum ( int X ) { int A , B ; if ( X & 1 ) { A = X / 2 ; B = X / 2 + 1 ; } else { if ( ( X / 2 ) % 2 == 0 ) { A = X / 2 - 1 ; B = X / 2 + 1 ; } else { A = X / 2 - 2 ; B = X / 2 + 2 ; } } cout << A << \" ▁ \" << B << endl ; } int main ( ) { int X = 30 ; maxLCMWithGivenSum ( X ) ; return 0 ; }", "docstring": "Find two numbers with given sum and maximum possible LCM | C ++ program of the above approach ; Function that print two numbers with the sum X and maximum possible LCM ; variables to store the result ; If X is odd ; If X is even ; If floor ( X / 2 ) is even ; If floor ( X / 2 ) is odd ; Print the result ; Driver Code ; Given Number ; Function call", "dfg": [["X", 21, "comesFrom", ["X"], [11]], ["X", 118, "comesFrom", ["X"], [112]], ["X", 28, "comesFrom", ["X"], [11]], ["X", 34, "comesFrom", ["X"], [11]], ["X", 46, "comesFrom", ["X"], [11]], ["X", 58, "comesFrom", ["X"], [11]], ["X", 66, "comesFrom", ["X"], [11]], ["X", 77, "comesFrom", ["X"], [11]], ["X", 85, "comesFrom", ["X"], [11]], ["B", 101, "comesFrom", ["B"], [83]], ["A", 95, "comesFrom", ["A"], [75]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxSubarrayLength ( int arr [ ] , int n , int k ) { int left = -1 ; int right ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % k ) != 0 ) { if ( left == -1 ) { left = i ; } right = i ; } sum += arr [ i ] ; } if ( ( sum % k ) != 0 ) { return n ; } else if ( left == -1 ) { return -1 ; } else { int prefix_length = left + 1 ; int suffix_length = n - right ; return n - min ( prefix_length , suffix_length ) ; } } int main ( ) { int arr [ ] = { 6 , 3 , 12 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << MaxSubarrayLength ( arr , n , K ) ; return 0 ; }", "docstring": "Length of longest subarray whose sum is not divisible by integer K | C ++ Program to find the length of the longest subarray whose sum is not divisible by integer K ; Function to find the longest subarray with sum is not divisible by k ; left is the index of the leftmost element that is not divisible by k ; right is the index of the rightmost element that is not divisible by k ; sum of the array ; Find the element that is not multiple of k ; left = - 1 means we are finding the leftmost element that is not divisible by k ; Updating the rightmost element ; update the sum of the array up to the index i ; Check if the sum of the array is not divisible by k , then return the size of array ; All elements of array are divisible by k , then no such subarray possible so return - 1 ; length of prefix elements that can be removed ; length of suffix elements that can be removed ; Return the length of subarray after removing the elements which have lesser number of elements ; Driver Code", "dfg": [["i", 42, "comesFrom", ["i"], [38]], ["i", 46, "comesFrom", ["i"], [38]], ["i", 78, "comesFrom", ["i"], [38]], ["i", 85, "comesFrom", ["i"], [38]], ["i", 73, "comesFrom", ["i"], [38]], ["i", 55, "comesFrom", ["i"], [38]], ["n", 44, "comesFrom", ["n"], [16]], ["n", 101, "comesFrom", ["n"], [16]], ["n", 191, "comesFrom", ["n"], [165]], ["n", 133, "comesFrom", ["n"], [16]], ["n", 128, "comesFrom", ["n"], [16]], ["K", 193, "comesFrom", ["K"], [181]], ["sum", 92, "comesFrom", ["sum"], [81]], ["k", 94, "comesFrom", ["k"], [19]], ["k", 58, "comesFrom", ["k"], [19]], ["left", 107, "comesFrom", ["left"], [71]], ["left", 66, "comesFrom", ["left"], [23]], ["left", 121, "comesFrom", ["left"], [71]], ["right", 130, "comesFrom", ["right"], [76]], ["prefix_length", 137, "comesFrom", ["prefix_length"], [119]], ["suffix_length", 139, "comesFrom", ["suffix_length"], [126]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) cout << 0 << endl ; else if ( Y % X == 0 ) cout << 1 << endl ; else cout << 2 << endl ; } int main ( ) { int X = 8 , Y = 13 ; solve ( X , Y ) ; return 0 ; }", "docstring": "Minimum steps to convert X to Y by repeated division and multiplication | C ++ implementation to find minimum steps to convert X to Y by repeated division and multiplication ; Check if X is greater than Y then swap the elements ; Check if X equals Y ; Driver code", "dfg": [["X", 19, "comesFrom", ["X"], [11]], ["X", 40, "comesFrom", ["X"], [29]], ["X", 89, "comesFrom", ["X"], [79]], ["X", 55, "comesFrom", ["X"], [29]], ["Y", 21, "comesFrom", ["Y"], [14]], ["Y", 42, "comesFrom", ["Y"], [33]], ["Y", 91, "comesFrom", ["Y"], [83]], ["Y", 31, "comesFrom", ["Y"], [14]], ["Y", 53, "comesFrom", ["Y"], [33]], ["temp", 35, "comesFrom", ["temp"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; ll countQuadraples ( ll N ) { ll cnt = 0 ; map < ll , ll > m ; for ( ll a = 1 ; a <= N ; a ++ ) { for ( ll b = 1 ; b <= N ; b ++ ) { ll x = a * a + b * b ; m [ x ] += 1 ; } } for ( ll c = 1 ; c <= N ; c ++ ) { for ( ll d = 1 ; d <= N ; d ++ ) { ll x = c * c + d * d ; if ( m . find ( x ) != m . end ( ) ) cnt += m [ x ] ; } } return cnt ; } int main ( ) { ll N = 2 ; cout << countQuadraples ( N ) << endl ; return 0 ; }", "docstring": "Count quadruplets ( A , B , C , D ) till N such that sum of square of A and B is equal to that of C and D | C ++ program for the above approach ; Function to count the quadruples ; Counter variable ; Map to store the sum of pair ( a ^ 2 + b ^ 2 ) ; Iterate till N ; Calculate a ^ 2 + b ^ 2 ; Increment the value in map ; Check if this sum was also in a ^ 2 + b ^ 2 ; Return the count ; Driver Code ; Given N ; Function Call", "dfg": [["cnt", 149, "comesFrom", ["cnt"], [139]], ["a", 40, "comesFrom", ["a"], [36]], ["a", 44, "comesFrom", ["a"], [36]], ["a", 66, "comesFrom", ["a"], [36]], ["a", 68, "comesFrom", ["a"], [36]], ["N", 42, "comesFrom", ["N"], [17]], ["N", 92, "comesFrom", ["N"], [17]], ["N", 57, "comesFrom", ["N"], [17]], ["N", 107, "comesFrom", ["N"], [17]], ["N", 166, "comesFrom", ["N"], [158]], ["c", 90, "comesFrom", ["c"], [86]], ["c", 94, "comesFrom", ["c"], [86]], ["c", 116, "comesFrom", ["c"], [86]], ["c", 118, "comesFrom", ["c"], [86]], ["b", 55, "comesFrom", ["b"], [51]], ["b", 59, "comesFrom", ["b"], [51]], ["b", 70, "comesFrom", ["b"], [51]], ["b", 72, "comesFrom", ["b"], [51]], ["d", 105, "comesFrom", ["d"], [101]], ["d", 109, "comesFrom", ["d"], [101]], ["d", 120, "comesFrom", ["d"], [101]], ["d", 122, "comesFrom", ["d"], [101]], ["m", 74, "comesFrom", ["m"], [31]], ["m", 141, "comesFrom", ["m"], [31]], ["m", 126, "comesFrom", ["m"], [31]], ["m", 133, "comesFrom", ["m"], [31]], ["x", 76, "comesFrom", ["x"], [64]], ["x", 130, "comesFrom", ["x"], [114]], ["x", 143, "comesFrom", ["x"], [114]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_pairs ( int a [ ] , int b [ ] , int N ) { int i , j ; int count = 0 ; for ( i = 0 ; i < ( N - 1 ) ; i ++ ) { for ( j = ( i + 1 ) ; j < N ; j ++ ) { if ( ( a [ i ] + a [ j ] ) > ( b [ i ] + b [ j ] ) ) { count ++ ; } } } return count ; } int main ( ) { int N = 5 ; int a [ N ] = { 1 , 2 , 3 , 4 , 5 } ; int b [ N ] = { 2 , 5 , 6 , 1 , 9 } ; cout << count_pairs ( a , b , N ) << endl ; return 0 ; }", "docstring": "Count of distinct index pair ( i , j ) such that element sum of First Array is greater | C ++ program for the above problem ; function to find the number of pairs satisfying the given cond . ; variables used for traversal ; count variable to store the count of possible pairs ; Nested loop to find out the possible pairs ; Check if the given condition is satisfied or not . If yes then increment the count . ; Return the count value ; Driver Code ; Size of the arrays ; Initialise the arrays ; function call that returns the count of possible pairs", "dfg": [["count", 104, "comesFrom", ["count"], [30]], ["count", 97, "comesFrom", ["count"], [30]], ["i", 40, "comesFrom", ["i"], [36]], ["i", 48, "comesFrom", ["i"], [36]], ["i", 57, "comesFrom", ["i"], [36]], ["i", 75, "comesFrom", ["i"], [36]], ["i", 87, "comesFrom", ["i"], [36]], ["N", 120, "comesFrom", ["N"], [113]], ["N", 138, "comesFrom", ["N"], [113]], ["N", 43, "comesFrom", ["N"], [21]], ["N", 64, "comesFrom", ["N"], [21]], ["N", 161, "comesFrom", ["N"], [113]], ["j", 62, "comesFrom", ["j"], [54]], ["j", 66, "comesFrom", ["j"], [54]], ["j", 80, "comesFrom", ["j"], [54]], ["j", 92, "comesFrom", ["j"], [54]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfPairs ( int * a , int * b , int n ) { int c [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = a [ i ] - b [ i ] ; } sort ( c , c + n ) ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( c [ i ] <= 0 ) continue ; int pos = lower_bound ( c , c + n , - c [ i ] + 1 ) - c ; answer += ( i - pos ) ; } return answer ; } int32_t main ( ) { int n = 5 ; int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int b [ ] = { 2 , 5 , 6 , 1 , 9 } ; cout << numberOfPairs ( a , b , n ) << endl ; return 0 ; }", "docstring": "Count of distinct index pair ( i , j ) such that element sum of First Array is greater | C ++ program of the above approach ; Function to find the number of pairs . ; Array c [ ] where c [ i ] = a [ i ] - b [ i ] ; Sort the array c ; Initialise answer as 0 ; Iterate from index 0 to n - 1 ; If c [ i ] <= 0 then in the sorted array c [ i ] + c [ pos ] can never greater than 0 where pos < i ; Find the minimum index such that c [ i ] + c [ j ] > 0 which is equivalent to c [ j ] >= - c [ i ] + 1 ; Add ( i - pos ) to answer ; return the answer ; Driver code ; Number of elements in a and b ; array a ; array b", "dfg": [["answer", 131, "comesFrom", ["answer"], [121]], ["n", 25, "comesFrom", ["n"], [19]], ["n", 37, "comesFrom", ["n"], [19]], ["n", 82, "comesFrom", ["n"], [19]], ["n", 65, "comesFrom", ["n"], [19]], ["n", 186, "comesFrom", ["n"], [140]], ["n", 108, "comesFrom", ["n"], [19]], ["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 80, "comesFrom", ["i"], [76]], ["i", 84, "comesFrom", ["i"], [76]], ["i", 45, "comesFrom", ["i"], [31]], ["i", 124, "comesFrom", ["i"], [76]], ["i", 50, "comesFrom", ["i"], [31]], ["i", 55, "comesFrom", ["i"], [31]], ["i", 92, "comesFrom", ["i"], [76]], ["i", 113, "comesFrom", ["i"], [76]], ["pos", 126, "comesFrom", ["pos"], [100]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int print_h_index ( int arr [ ] , int N ) { multiset < int > ms ; for ( int i = 0 ; i < N ; i ++ ) { ms . insert ( arr [ i ] ) ; if ( * ms . begin ( ) < ms . size ( ) ) { ms . erase ( ms . begin ( ) ) ; } cout << ms . size ( ) << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 9 , 10 , 7 , 5 , 0 , 10 , 2 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print_h_index ( arr , N ) ; return 0 ; }", "docstring": "Find K for every Array element such that at least K prefixes are â ‰¥ K | C ++ program for the above approach ; Function to find the K - value for every index in the array ; Multiset to store the array in the form of red - black tree ; Iterating over the array ; Inserting the current value in the multiset ; Condition to check if the smallest value in the set is less than it 's size ; Erase the smallest value ; h - index value will be the size of the multiset ; Driver Code ; array ; Size of the array ; function call", "dfg": [["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 46, "comesFrom", ["i"], [28]], ["N", 34, "comesFrom", ["N"], [16]], ["N", 140, "comesFrom", ["N"], [121]], ["ms", 40, "comesFrom", ["ms"], [23]], ["ms", 59, "comesFrom", ["ms"], [23]], ["ms", 66, "comesFrom", ["ms"], [23]], ["ms", 80, "comesFrom", ["ms"], [23]], ["ms", 53, "comesFrom", ["ms"], [23]], ["ms", 70, "comesFrom", ["ms"], [23]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int prefixProduct ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i ] * a [ i - 1 ] ; } for ( int j = 0 ; j < n ; j ++ ) { cout << a [ j ] << \" , ▁ \" ; } return 0 ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 5 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; prefixProduct ( arr , N ) ; return 0 ; }", "docstring": "Prefix Product Array | C ++ Program to generate Prefix Product Array ; Function to generate prefix product array ; Update the array with the product of prefixes ; Print the array ; Driver Code", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 36, "comesFrom", ["i"], [22]], ["i", 41, "comesFrom", ["i"], [22]], ["i", 46, "comesFrom", ["i"], [22]], ["n", 28, "comesFrom", ["n"], [16]], ["n", 61, "comesFrom", ["n"], [16]], ["j", 59, "comesFrom", ["j"], [55]], ["j", 63, "comesFrom", ["j"], [55]], ["j", 71, "comesFrom", ["j"], [55]], ["N", 125, "comesFrom", ["N"], [106]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; } int main ( ) { int N = 10 ; cout << countWays ( N ) ; return 0 ; }", "docstring": "Count of ways to distribute N items among 3 people with one person receiving maximum | C ++ program to find the number of ways to distribute N item among three people such that one person always gets the maximum value ; Function to find the number of ways to distribute N items among 3 people ; No distribution possible ; Total number of ways to distribute N items among 3 people ; Store the number of distributions which are not possible ; Count possibilities of two persons receiving the maximum ; If N is divisible by 3 ; Return the final count of ways to distribute ; Driver Code", "dfg": [["i", 54, "comesFrom", ["i"], [50]], ["i", 60, "comesFrom", ["i"], [50]], ["i", 73, "comesFrom", ["i"], [50]], ["i", 85, "comesFrom", ["i"], [50]], ["ans", 118, "comesFrom", ["ans"], [24]], ["s", 120, "comesFrom", ["s"], [111]], ["s", 106, "comesFrom", ["s"], [102]], ["s", 115, "comesFrom", ["s"], [111]], ["s", 89, "comesFrom", ["s"], [43]], ["N", 16, "comesFrom", ["N"], [11]], ["N", 56, "comesFrom", ["N"], [11]], ["N", 96, "comesFrom", ["N"], [11]], ["N", 137, "comesFrom", ["N"], [129]], ["N", 28, "comesFrom", ["N"], [11]], ["N", 34, "comesFrom", ["N"], [11]], ["N", 81, "comesFrom", ["N"], [11]], ["j", 71, "comesFrom", ["j"], [67]], ["j", 75, "comesFrom", ["j"], [67]], ["j", 87, "comesFrom", ["j"], [67]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool isMagnanimous ( int N ) { string s = to_string ( N ) ; int l = s . length ( ) ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l - 1 ; i ++ ) { string left = s . substr ( 0 , i + 1 ) ; string right = s . substr ( i + 1 ) ; int x = stoi ( left ) ; int y = stoi ( right ) ; if ( ! isPrime ( x + y ) ) return false ; } return true ; } int main ( ) { int N = 12 ; isMagnanimous ( N ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }", "docstring": "Magnanimous Numbers | C ++ implementation to check if a number is Magnanimous ; Function to check if n is prime ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is Magnanimous or not ; converting the number to string ; finding length of string ; number should not be of single digit ; loop to find all left and right part of the string ; Driver Code", "dfg": [["n", 59, "comesFrom", ["n"], [11]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 25, "comesFrom", ["n"], [11]], ["n", 34, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [11]], ["n", 69, "comesFrom", ["n"], [11]], ["n", 75, "comesFrom", ["n"], [11]], ["i", 132, "comesFrom", ["i"], [128]], ["i", 138, "comesFrom", ["i"], [128]], ["i", 55, "comesFrom", ["i"], [51]], ["i", 57, "comesFrom", ["i"], [51]], ["i", 63, "comesFrom", ["i"], [61]], ["i", 71, "comesFrom", ["i"], [61]], ["i", 151, "comesFrom", ["i"], [128]], ["i", 163, "comesFrom", ["i"], [128]], ["i", 78, "comesFrom", ["i"], [61]], ["l", 118, "comesFrom", ["l"], [108]], ["l", 134, "comesFrom", ["l"], [108]], ["N", 104, "comesFrom", ["N"], [96]], ["N", 214, "comesFrom", ["N"], [208]], ["s", 110, "comesFrom", ["s"], [100]], ["s", 145, "comesFrom", ["s"], [100]], ["s", 159, "comesFrom", ["s"], [100]], ["left", 173, "comesFrom", ["left"], [143]], ["right", 181, "comesFrom", ["right"], [157]], ["x", 189, "comesFrom", ["x"], [169]], ["y", 191, "comesFrom", ["y"], [177]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define limit  10000000 NEW_LINE using namespace std ; int position [ limit + 1 ] ; void sieve ( ) { position [ 0 ] = -1 , position [ 1 ] = -1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = -1 ; } } } int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } bool isHonakerPrime ( int n ) { int pos = position [ n ] ; if ( pos == -1 ) return false ; return getSum ( n ) == getSum ( pos ) ; } int main ( ) { sieve ( ) ; int N = 121 ; if ( isHonakerPrime ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; }", "docstring": "Honaker Prime Number | C ++ program for the above approach ; Function to precompute the position of every prime number using Sieve ; 0 and 1 are not prime numbers ; Variable to store the position ; Incrementing the position for every prime number ; Function to get sum of digits ; Function to check whether the given number is Honaker Prime number or not ; Driver Code ; Precompute the prime numbers till 10 ^ 6 ; Given Number ; Function Call", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 4 , M = 5 ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int takeSum ( int a [ N ] [ M ] ) { int s = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) s += a [ i ] [ j ] ; return s ; } int main ( ) { int a [ N ] [ M ] = { { 1 , 2 , 3 , 4 , 2 } , { 0 , 1 , 2 , 3 , 34 } , { 0 , 34 , 21 , 12 , 12 } , { 1 , 2 , 3 , 6 , 6 } } ; int sum = takeSum ( a ) ; if ( isPrime ( sum ) ) cout << \" YES \" << endl ; else cout << \" NO \" << endl ; return 0 ; }", "docstring": "Check if Matrix sum is prime or not | C ++ implementation to check if the sum of matrix is prime or not ; Function to check whether a number is prime or not ; Corner case ; Check from 2 to n - 1 ; Function for to find the sum of the given matrix ; Driver Code", "dfg": [["s", 122, "comesFrom", ["s"], [111]], ["i", 40, "comesFrom", ["i"], [36]], ["i", 47, "comesFrom", ["i"], [36]], ["i", 90, "comesFrom", ["i"], [86]], ["i", 94, "comesFrom", ["i"], [86]], ["i", 54, "comesFrom", ["i"], [36]], ["i", 115, "comesFrom", ["i"], [86]], ["N", 92, "comesFrom", ["N"], [9]], ["N", 71, "comesFrom", ["N"], [9]], ["N", 133, "comesFrom", ["N"], [9]], ["n", 26, "comesFrom", ["n"], [21]], ["n", 44, "comesFrom", ["n"], [21]], ["n", 52, "comesFrom", ["n"], [21]], ["M", 74, "comesFrom", ["M"], [13]], ["M", 106, "comesFrom", ["M"], [13]], ["M", 136, "comesFrom", ["M"], [13]], ["j", 104, "comesFrom", ["j"], [100]], ["j", 108, "comesFrom", ["j"], [100]], ["j", 118, "comesFrom", ["j"], [100]], ["sum", 201, "comesFrom", ["sum"], [190]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; static long sumOfSumSeries ( int N ) { long sum = 0L ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; } int main ( ) { int N = 5 ; cout << sumOfSumSeries ( N ) ; }", "docstring": "Sum of sum | C ++ program to implement the above approach ; Function to find the sum ; Calculate sum - series for every natural number and add them ; Driver code", "dfg": [["sum", 53, "comesFrom", ["sum"], [35]], ["sum", 37, "comesFrom", ["sum"], [35]], ["i", 27, "comesFrom", ["i"], [23]], ["i", 31, "comesFrom", ["i"], [23]], ["i", 40, "comesFrom", ["i"], [23]], ["i", 43, "comesFrom", ["i"], [23]], ["N", 29, "comesFrom", ["N"], [12]], ["N", 70, "comesFrom", ["N"], [62]]]}
{"code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; long sumOfSumSeries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } int main ( ) { int N = 5 ; cout << sumOfSumSeries ( N ) ; return 0 ; }", "docstring": "Sum of sum | C ++ program to implement the above approach ; Function to find the sum ; Driver code", "dfg": [["N", 51, "comesFrom", ["N"], [43]], ["n", 19, "comesFrom", ["n"], [14]], ["n", 28, "comesFrom", ["n"], [14]], ["n", 22, "comesFrom", ["n"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isContaindigit ( int n ) { while ( n > 0 ) { if ( ! ( n % 10 == 0 n % 10 == 1 n % 10 == 8 ) ) return false ; n = n / 10 ; } return true ; } bool ispalindrome ( int n ) { string temp = to_string ( n ) ; int l = temp . length ( ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) { if ( temp [ i ] != temp [ l - i - 1 ] ) return false ; } return true ; } bool isTetradic ( int n ) { if ( ispalindrome ( n ) && isContaindigit ( n ) ) return true ; return false ; } void printTetradicPrimesLessThanN ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; int p = 2 ; while ( p * p <= n ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = false ; } p += 1 ; } for ( p = 2 ; p < n + 1 ; p ++ ) { if ( prime [ p ] && isTetradic ( p ) ) cout << p << \" ▁ \" ; } } int main ( ) { int n = 1000 ; printTetradicPrimesLessThanN ( n ) ; return 0 ; }", "docstring": "Tetradic Primes | C ++ implementation to print all Tetradic primes smaller than or equal to N . ; Function to check if the number N having all digits lies in the set ( 0 , 1 , 8 ) ; Function to check if the number N is palindrome ; Function to check if a number N is Tetradic ; Function to generate all primes and checking whether number is Tetradic or not ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all Tetradic prime numbers ; Checking whether the given number is prime Tetradic or not ; Driver code", "dfg": [["i", 87, "comesFrom", ["i"], [83]], ["i", 93, "comesFrom", ["i"], [83]], ["i", 205, "comesFrom", ["i"], [199]], ["i", 101, "comesFrom", ["i"], [83]], ["i", 108, "comesFrom", ["i"], [83]], ["i", 217, "comesFrom", ["i"], [211]], ["p", 234, "comesFrom", ["p"], [230]], ["p", 240, "comesFrom", ["p"], [230]], ["p", 181, "comesFrom", ["p"], [175]], ["p", 183, "comesFrom", ["p"], [175]], ["p", 192, "comesFrom", ["p"], [175]], ["p", 213, "comesFrom", ["p"], [175]], ["p", 258, "comesFrom", ["p"], [230]], ["p", 248, "comesFrom", ["p"], [230]], ["p", 253, "comesFrom", ["p"], [230]], ["p", 201, "comesFrom", ["p"], [175]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 157, "comesFrom", ["n"], [151]], ["n", 185, "comesFrom", ["n"], [151]], ["n", 236, "comesFrom", ["n"], [151]], ["n", 278, "comesFrom", ["n"], [272]], ["n", 68, "comesFrom", ["n"], [60]], ["n", 47, "comesFrom", ["n"], [45]], ["n", 132, "comesFrom", ["n"], [125]], ["n", 137, "comesFrom", ["n"], [125]], ["n", 207, "comesFrom", ["n"], [151]], ["n", 35, "comesFrom", ["n"], [11]], ["n", 25, "comesFrom", ["n"], [11]], ["n", 30, "comesFrom", ["n"], [11]], ["l", 89, "comesFrom", ["l"], [72]], ["l", 106, "comesFrom", ["l"], [72]], ["temp", 74, "comesFrom", ["temp"], [64]], ["temp", 99, "comesFrom", ["temp"], [64]], ["temp", 104, "comesFrom", ["temp"], [64]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int concat ( int a , int b ) { string s1 = to_string ( a ) ; string s2 = to_string ( b ) ; string s = s1 + s2 ; int c = stoi ( s ) ; return c ; } bool isAstonishing ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += j ; if ( sum == n ) { int concatenation = concat ( i , j ) ; if ( concatenation == n ) { return true ; } } } } return false ; } int main ( ) { int n = 429 ; if ( isAstonishing ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Astonishing Numbers | C ++ implementation for the above approach ; Function to concatenate two integers into one ; Convert both the integers to string ; Concatenate both strings ; Convert the concatenated string to integer ; return the formed integer ; Function to check if N is a Astonishing number ; Loop to find sum of all integers from i till the sum becomes >= n ; variable to store sum of all integers from i to j and check if sum and concatenation equals n or not ; finding concatenation of i and j ; condition for Astonishing number ; Driver Code ; Given Number ; Function Call", "dfg": [["c", 49, "comesFrom", ["c"], [41]], ["i", 66, "comesFrom", ["i"], [62]], ["i", 70, "comesFrom", ["i"], [62]], ["i", 110, "comesFrom", ["i"], [84]], ["n", 68, "comesFrom", ["n"], [56]], ["n", 88, "comesFrom", ["n"], [56]], ["n", 147, "comesFrom", ["n"], [139]], ["n", 102, "comesFrom", ["n"], [56]], ["n", 119, "comesFrom", ["n"], [56]], ["s1", 36, "comesFrom", ["s1"], [18]], ["s2", 38, "comesFrom", ["s2"], [26]], ["a", 22, "comesFrom", ["a"], [11]], ["b", 30, "comesFrom", ["b"], [14]], ["s", 45, "comesFrom", ["s"], [34]], ["j", 86, "comesFrom", ["j"], [82]], ["j", 90, "comesFrom", ["j"], [82]], ["j", 96, "comesFrom", ["j"], [82]], ["j", 112, "comesFrom", ["j"], [82]], ["sum", 100, "comesFrom", ["sum"], [94]], ["concatenation", 117, "comesFrom", ["concatenation"], [106]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkSame ( int n , int b ) { map < int , int > m ; while ( n != 0 ) { int r = n % b ; n = n / b ; m [ r ] ++ ; } int last = -1 ; for ( auto i = m . begin ( ) ; i != m . end ( ) ; i ++ ) { if ( last != -1 && i -> second != last ) { return false ; } else { last = i -> second ; } } } int main ( ) { int n = 9 ; int base = 2 ; if ( checkSame ( n , base ) ) cout << \" Yes \" ; else cout << \" NO \" ; return 0 ; }", "docstring": "Digitally balanced numbers | C ++ implementation to check if a number is a digitally balanced number ; Function to check if the digits in the number is the same number of digits ; Loop to iterate over the digits of the number N ; Loop to iterate over the map ; Driver Code ; function to check", "dfg": [["i", 68, "comesFrom", ["i"], [60]], ["i", 76, "comesFrom", ["i"], [60]], ["i", 86, "comesFrom", ["i"], [60]], ["i", 101, "comesFrom", ["i"], [60]], ["n", 27, "comesFrom", ["n"], [11]], ["n", 127, "comesFrom", ["n"], [114]], ["n", 35, "comesFrom", ["n"], [11]], ["n", 41, "comesFrom", ["n"], [39]], ["m", 70, "comesFrom", ["m"], [23]], ["m", 45, "comesFrom", ["m"], [23]], ["m", 62, "comesFrom", ["m"], [23]], ["base", 129, "comesFrom", ["base"], [119]], ["b", 37, "comesFrom", ["b"], [14]], ["b", 43, "comesFrom", ["b"], [14]], ["r", 47, "comesFrom", ["r"], [33]], ["last", 82, "comesFrom", ["last"], [53]], ["last", 90, "comesFrom", ["last"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int seriesSum ( int n ) { int sum = 0 ; int currProd = 1 ; int currSum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; } int main ( ) { int N = 5 ; cout << seriesSum ( N ) << \" ▁ \" ; }", "docstring": "Sum of series formed by difference between product and sum of N natural numbers | C ++ program to implement the above approach ; Function to calculate the sum upto Nth term ; Stores the sum of the series ; Stores the product of natural numbers upto the current term ; Stores the sum of natural numbers upto the upto current term ; Generate the remaining terms and calculate sum ; Update the sum ; Return the sum ; Driver Program", "dfg": [["sum", 60, "comesFrom", ["sum"], [52]], ["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 46, "comesFrom", ["i"], [32]], ["i", 50, "comesFrom", ["i"], [32]], ["n", 38, "comesFrom", ["n"], [11]], ["currProd", 54, "comesFrom", ["currProd"], [44]], ["currSum", 56, "comesFrom", ["currSum"], [48]], ["N", 77, "comesFrom", ["N"], [69]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int count ( int a [ ] , int n ) { int countElements = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool flag = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; } int main ( ) { int arr [ ] = { 86 , 45 , 18 , 4 , 8 , 28 , 19 , 33 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << count ( arr , n ) ; return 0 ; }", "docstring": "Count of elements not divisible by any other elements of Array | C ++ program for the above approach ; Function to count the number of elements of array which are not divisible by any other element in the array arr [ ] ; Iterate over the array ; Check if the element is itself or not ; Check for divisibility ; Return the final result ; Driver Code ; Given array ; Function Call", "dfg": []}
{"code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int smallestNumber ( int N ) { return N * ceil ( pow ( 10 , ( N - 1 ) ) / N ) ; } int main ( ) { int N = 2 ; cout << smallestNumber ( N ) ; return 0 ; }", "docstring": "Smallest N digit number divisible by N | C ++ program for the above approach ; Function to find the smallest N - digit number divisible by N ; Return the smallest N - digit number calculated using above formula ; Driver Code ; Given N ; Function Call", "dfg": [["N", 18, "comesFrom", ["N"], [14]], ["N", 51, "comesFrom", ["N"], [43]], ["N", 33, "comesFrom", ["N"], [14]], ["N", 27, "comesFrom", ["N"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 8 , 2 , 3 , 1 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << ( CountPairs ( arr , n ) ) ; }", "docstring": "Count pairs in an array containing at least one even value | C ++ implementation to count pairs in an array such that each pair contains at least one even element ; Function to count the pairs in the array such as there is at least one even element in each pair ; Generate all possible pairs and increment then count if the condition is satisfied ; Driver code ; Function call", "dfg": [["count", 81, "comesFrom", ["count"], [20]], ["count", 75, "comesFrom", ["count"], [20]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 44, "comesFrom", ["i"], [27]], ["i", 60, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 50, "comesFrom", ["n"], [16]], ["n", 128, "comesFrom", ["n"], [109]], ["j", 48, "comesFrom", ["j"], [42]], ["j", 52, "comesFrom", ["j"], [42]], ["j", 68, "comesFrom", ["j"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountPairs ( int arr [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; } int main ( ) { int arr [ ] = { 8 , 2 , 3 , 1 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << CountPairs ( arr , n ) ; }", "docstring": "Count pairs in an array containing at least one even value | C ++ implementation to Count pairs in an array such that each pair contains at least one even element ; Function to count the pairs in the array such as there is at least one even element in each pair ; Store count of even and odd elements ; Check element is even or odd ; Driver Code", "dfg": [["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 47, "comesFrom", ["i"], [31]], ["n", 37, "comesFrom", ["n"], [16]], ["n", 125, "comesFrom", ["n"], [107]], ["even", 76, "comesFrom", ["even"], [20]], ["even", 54, "comesFrom", ["even"], [20]], ["even", 64, "comesFrom", ["even"], [20]], ["even", 67, "comesFrom", ["even"], [20]], ["odd", 78, "comesFrom", ["odd"], [24]], ["odd", 58, "comesFrom", ["odd"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } bool isGiugaNum ( int n ) { if ( ! ( isComposite ( n ) ) ) return false ; int N = n ; while ( n % 2 == 0 ) { if ( ( N / 2 - 1 ) % 2 != 0 ) return false ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( ( N / i - 1 ) % i != 0 ) return false ; n = n / i ; } } if ( n > 2 ) if ( ( N / n - 1 ) % n != 0 ) return false ; return true ; } int main ( ) { int N = 30 ; if ( isGiugaNum ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; }", "docstring": "Giuga Numbers | C ++ program for the above approach ; Function to check if n is a composite number ; Corner cases ; This is checked to skip middle 5 numbers ; Function to check if N is a Giuga Number ; N should be composite to be a Giuga Number ; Print the number of 2 s that divide n ; N must be odd at this point . So we can skip one element ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number > 2 ; Driver Code ; Given Number N ; Function Call", "dfg": [["n", 59, "comesFrom", ["n"], [11]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 25, "comesFrom", ["n"], [11]], ["n", 207, "comesFrom", ["n"], [197]], ["n", 119, "comesFrom", ["n"], [115]], ["n", 161, "comesFrom", ["n"], [143]], ["n", 34, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [11]], ["n", 145, "comesFrom", ["n"], [143]], ["n", 221, "comesFrom", ["n"], [197]], ["n", 69, "comesFrom", ["n"], [11]], ["n", 75, "comesFrom", ["n"], [11]], ["n", 105, "comesFrom", ["n"], [96]], ["n", 173, "comesFrom", ["n"], [143]], ["n", 199, "comesFrom", ["n"], [197]], ["n", 216, "comesFrom", ["n"], [197]], ["i", 157, "comesFrom", ["i"], [153]], ["i", 55, "comesFrom", ["i"], [51]], ["i", 57, "comesFrom", ["i"], [51]], ["i", 63, "comesFrom", ["i"], [61]], ["i", 166, "comesFrom", ["i"], [164]], ["i", 71, "comesFrom", ["i"], [61]], ["i", 175, "comesFrom", ["i"], [164]], ["i", 201, "comesFrom", ["i"], [164]], ["i", 78, "comesFrom", ["i"], [61]], ["i", 190, "comesFrom", ["i"], [164]], ["i", 185, "comesFrom", ["i"], [164]], ["N", 246, "comesFrom", ["N"], [238]], ["N", 214, "comesFrom", ["N"], [113]], ["N", 129, "comesFrom", ["N"], [113]], ["N", 183, "comesFrom", ["N"], [113]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDroll ( int n ) { if ( n == 1 ) return false ; int sum_even = 0 ; int sum_odd = 0 ; while ( n % 2 == 0 ) { sum_even += 2 ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { sum_odd += i ; n = n / i ; } } if ( n > 2 ) sum_odd += n ; return sum_even == sum_odd ; } int main ( ) { int N = 72 ; if ( isDroll ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Droll Numbers | C ++ program for the above approach ; Function to check droll numbers ; To store sum of even prime factors ; To store sum of odd prime factors ; Add the number of 2 s that divide n in sum_even ; N must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Condition to check droll number ; Driver Code ; Given Number N ; Function Call", "dfg": [["i", 60, "comesFrom", ["i"], [56]], ["i", 69, "comesFrom", ["i"], [67]], ["i", 78, "comesFrom", ["i"], [67]], ["i", 85, "comesFrom", ["i"], [67]], ["i", 91, "comesFrom", ["i"], [67]], ["sum_even", 106, "comesFrom", ["sum_even"], [42]], ["sum_odd", 108, "comesFrom", ["sum_odd"], [101]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 97, "comesFrom", ["n"], [87]], ["n", 103, "comesFrom", ["n"], [87]], ["n", 35, "comesFrom", ["n"], [11]], ["n", 64, "comesFrom", ["n"], [46]], ["n", 48, "comesFrom", ["n"], [46]], ["n", 76, "comesFrom", ["n"], [46]], ["n", 89, "comesFrom", ["n"], [87]], ["N", 125, "comesFrom", ["N"], [117]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; } int CountPairs ( int n ) { int cnt = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int div1 = i ; int div2 = n / i ; int sum = div1 + div2 ; if ( gcd ( sum , n ) == 1 ) cnt += 1 ; } } return cnt ; } int main ( ) { int n = 24 ; cout << CountPairs ( n ) << endl ; return 0 ; }", "docstring": "Count all pairs of divisors of a number N whose sum is coprime with N | C ++ program to count all pairs of divisors such that their sum is coprime with N ; Function to calculate GCD ; Function to count all valid pairs ; Initialize count ; Check if sum of pair and n are coprime ; Return the result ; Driver code", "dfg": [["cnt", 114, "comesFrom", ["cnt"], [107]], ["a", 24, "comesFrom", ["a"], [11]], ["a", 32, "comesFrom", ["a"], [11]], ["n", 62, "comesFrom", ["n"], [43]], ["n", 131, "comesFrom", ["n"], [123]], ["n", 70, "comesFrom", ["n"], [43]], ["n", 85, "comesFrom", ["n"], [43]], ["n", 102, "comesFrom", ["n"], [43]], ["i", 64, "comesFrom", ["i"], [54]], ["i", 58, "comesFrom", ["i"], [54]], ["i", 60, "comesFrom", ["i"], [54]], ["i", 72, "comesFrom", ["i"], [54]], ["i", 87, "comesFrom", ["i"], [80]], ["b", 19, "comesFrom", ["b"], [14]], ["b", 30, "comesFrom", ["b"], [14]], ["b", 34, "comesFrom", ["b"], [14]], ["div1", 92, "comesFrom", ["div1"], [78]], ["div2", 94, "comesFrom", ["div2"], [83]], ["sum", 100, "comesFrom", ["sum"], [90]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int A , int B ) { return ( A - B > 1 ) ; } int main ( ) { int A = 10 , B = 4 ; if ( isPossible ( A , B ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if A can be converted to B by reducing with a Prime number | C ++ implementation to find if it is possible to make a equal to b ; Function to find if it is possible to make A equal to B ; Driver Code ; Function Call", "dfg": [["A", 19, "comesFrom", ["A"], [11]], ["A", 45, "comesFrom", ["A"], [33]], ["B", 21, "comesFrom", ["B"], [14]], ["B", 47, "comesFrom", ["B"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sub [ 100005 ] ; int minDivisorDifference ( int n ) { int num1 ; int num2 ; for ( int i = sqrt ( n ) ; i <= n ; i ++ ) { if ( n % i == 0 ) { num1 = i ; num2 = n / i ; break ; } } return abs ( num1 - num2 ) ; } int dfs ( vector < int > g [ ] , int u , int par ) { sub [ u ] = minDivisorDifference ( u ) ; int mx = 0 ; for ( auto c : g [ u ] ) { if ( c != par ) { int ans = dfs ( g , c , u ) ; mx = max ( mx , ans ) ; } } sub [ u ] += mx ; return sub [ u ] ; } int main ( ) { vector < int > g [ 100005 ] ; int edges = 6 ; g [ 18 ] . push_back ( 7 ) ; g [ 7 ] . push_back ( 18 ) ; g [ 18 ] . push_back ( 15 ) ; g [ 15 ] . push_back ( 18 ) ; g [ 15 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 15 ) ; g [ 7 ] . push_back ( 4 ) ; g [ 4 ] . push_back ( 7 ) ; g [ 7 ] . push_back ( 12 ) ; g [ 12 ] . push_back ( 7 ) ; g [ 12 ] . push_back ( 9 ) ; g [ 9 ] . push_back ( 12 ) ; int root = 18 ; cout << dfs ( g , root , -1 ) ; }", "docstring": "Maximize sum of minimum difference of divisors of nodes in N | C ++ program to maximize the sum of minimum difference of divisors of nodes in an n - ary tree ; Array to store the result at each node ; Function to get minimum difference between the divisors of a number ; Iterate from square root of N to N ; return absolute difference ; DFS function to calculate the maximum sum ; Store the min difference ; Add the maximum of all children to sub [ u ] ; Return maximum sum of node ' u ' to its parent ; Driver code", "dfg": [["i", 36, "comesFrom", ["i"], [29]], ["i", 40, "comesFrom", ["i"], [29]], ["i", 48, "comesFrom", ["i"], [29]], ["i", 55, "comesFrom", ["i"], [29]], ["i", 61, "comesFrom", ["i"], [29]], ["n", 38, "comesFrom", ["n"], [17]], ["n", 33, "comesFrom", ["n"], [17]], ["n", 46, "comesFrom", ["n"], [17]], ["n", 59, "comesFrom", ["n"], [17]], ["mx", 155, "comesFrom", ["mx"], [139]], ["mx", 143, "comesFrom", ["mx"], [139]], ["u", 116, "comesFrom", ["u"], [88]], ["u", 160, "comesFrom", ["u"], [88]], ["u", 96, "comesFrom", ["u"], [88]], ["u", 101, "comesFrom", ["u"], [88]], ["u", 152, "comesFrom", ["u"], [88]], ["u", 136, "comesFrom", ["u"], [88]], ["num1", 70, "comesFrom", ["num1"], [53]], ["num2", 72, "comesFrom", ["num2"], [57]], ["root", 314, "comesFrom", ["root"], [304]], ["par", 124, "comesFrom", ["par"], [91]], ["ans", 145, "comesFrom", ["ans"], [128]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCenteredcube ( int N ) { int i = 1 ; while ( true ) { int ith_term = ( 2 * i + 1 ) * ( i * i + i + 1 ) ; if ( ith_term == N ) { return true ; } if ( ith_term > N ) { return false ; } i ++ ; } } int main ( ) { int N = 9 ; if ( isCenteredcube ( N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "docstring": "Program to check if N is a Centered Cubic Number | C ++ program to check if N is a centered cubic number ; Function to check if the number N is a centered cubic number ; Iterating from 1 ; Infinite loop ; Finding ith_term ; Checking if the number N is a Centered cube number ; If ith_term > N then N is not a Centered cube number ; Incrementing i ; Driver code ; Function call", "dfg": [["i", 67, "comesFrom", ["i"], [15]], ["i", 30, "comesFrom", ["i"], [15]], ["i", 40, "comesFrom", ["i"], [15]], ["i", 36, "comesFrom", ["i"], [15]], ["i", 38, "comesFrom", ["i"], [15]], ["N", 86, "comesFrom", ["N"], [78]], ["N", 49, "comesFrom", ["N"], [11]], ["N", 60, "comesFrom", ["N"], [11]], ["ith_term", 47, "comesFrom", ["ith_term"], [25]], ["ith_term", 58, "comesFrom", ["ith_term"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; } int main ( ) { float a = 1 , r = 2 ; int N = 4 ; cout << productOfGP ( a , r , N ) ; }", "docstring": "Product of N terms of a given Geometric series | C ++ program for the above approach ; Function to calculate product of geometric series ; Initialise final product with 1 ; Multiply product with each term stored in a ; Return the final product ; Driver Code ; Given first term and common ratio ; Number of terms ; Function Call", "dfg": [["product", 54, "comesFrom", ["product"], [40]], ["product", 42, "comesFrom", ["product"], [40]], ["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["n", 34, "comesFrom", ["n"], [17]], ["a", 80, "comesFrom", ["a"], [63]], ["a", 44, "comesFrom", ["a"], [11]], ["a", 48, "comesFrom", ["a"], [46]], ["r", 82, "comesFrom", ["r"], [67]], ["r", 50, "comesFrom", ["r"], [14]], ["N", 84, "comesFrom", ["N"], [72]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } int findlcm ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; } void addReduce ( int n , int num [ ] , int den [ ] ) { int final_numerator = 0 ; int final_denominator = findlcm ( den , n ) ; for ( int i = 0 ; i < n ; i ++ ) { final_numerator = final_numerator + ( num [ i ] ) * ( final_denominator / den [ i ] ) ; } int GCD = gcd ( final_numerator , final_denominator ) ; final_numerator /= GCD ; final_denominator /= GCD ; cout << final_numerator << \" / \" << final_denominator << endl ; } int main ( ) { int N = 3 ; int arr1 [ ] = { 1 , 2 , 5 } ; int arr2 [ ] = { 2 , 1 , 6 } ; addReduce ( N , arr1 , arr2 ) ; return 0 ; }", "docstring": "Sum of given N fractions in reduced form | C ++ program for the above approach ; Function to find GCD of a & b using Euclid Lemma ; Base Case ; Function to find the LCM of all elements in arr [ ] ; Initialize result ; Iterate arr [ ] to find LCM ; Return the final LCM ; Function to find the sum of N fraction in reduced form ; To store the sum of all final numerators ; Find the LCM of all denominator ; Find the sum of all N numerators & denominators ; Add each fraction one by one ; Find GCD of final numerator and denominator ; Convert into reduced form by dividing from GCD ; Print the final fraction ; Driven Code ; Given N ; Given Numerator ; Given Denominator ; Function Call", "dfg": [["ans", 103, "comesFrom", ["ans"], [74]], ["ans", 84, "comesFrom", ["ans"], [74]], ["ans", 96, "comesFrom", ["ans"], [74]], ["i", 66, "comesFrom", ["i"], [62]], ["i", 70, "comesFrom", ["i"], [62]], ["i", 145, "comesFrom", ["i"], [141]], ["i", 149, "comesFrom", ["i"], [141]], ["i", 160, "comesFrom", ["i"], [141]], ["i", 169, "comesFrom", ["i"], [141]], ["i", 81, "comesFrom", ["i"], [62]], ["i", 93, "comesFrom", ["i"], [62]], ["n", 68, "comesFrom", ["n"], [48]], ["n", 147, "comesFrom", ["n"], [110]], ["n", 135, "comesFrom", ["n"], [110]], ["GCD", 186, "comesFrom", ["GCD"], [175]], ["GCD", 190, "comesFrom", ["GCD"], [175]], ["b", 19, "comesFrom", ["b"], [14]], ["b", 31, "comesFrom", ["b"], [14]], ["b", 35, "comesFrom", ["b"], [14]], ["a", 25, "comesFrom", ["a"], [11]], ["a", 33, "comesFrom", ["a"], [11]], ["final_denominator", 200, "comesFrom", ["final_denominator"], [188]], ["final_denominator", 181, "comesFrom", ["final_denominator"], [129]], ["final_denominator", 165, "comesFrom", ["final_denominator"], [129]], ["N", 243, "comesFrom", ["N"], [211]], ["final_numerator", 179, "comesFrom", ["final_numerator"], [153]], ["final_numerator", 155, "comesFrom", ["final_numerator"], [153]], ["final_numerator", 194, "comesFrom", ["final_numerator"], [184]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int minLCM ( int arr [ ] , int n ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int g = gcd ( arr [ i ] , arr [ j ] ) ; int lcm = arr [ i ] / g * arr [ j ] ; ans = min ( ans , lcm ) ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 3 , 6 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minLCM ( arr , n ) << endl ; return 0 ; }", "docstring": "Minimum LCM of all pairs in a given array | C ++ program to find minimum possible lcm from any pair ; function to compute GCD of two numbers ; function that return minimum possible lcm from any pair ; fix the ith element and iterate over all the array to find minimum LCM ; Driver code", "dfg": [["ans", 129, "comesFrom", ["ans"], [117]], ["ans", 121, "comesFrom", ["ans"], [117]], ["a", 24, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]], ["i", 61, "comesFrom", ["i"], [57]], ["i", 65, "comesFrom", ["i"], [57]], ["i", 74, "comesFrom", ["i"], [57]], ["i", 93, "comesFrom", ["i"], [57]], ["i", 107, "comesFrom", ["i"], [57]], ["n", 63, "comesFrom", ["n"], [46]], ["n", 80, "comesFrom", ["n"], [46]], ["n", 176, "comesFrom", ["n"], [155]], ["b", 19, "comesFrom", ["b"], [14]], ["b", 29, "comesFrom", ["b"], [14]], ["b", 33, "comesFrom", ["b"], [14]], ["j", 78, "comesFrom", ["j"], [72]], ["j", 82, "comesFrom", ["j"], [72]], ["j", 114, "comesFrom", ["j"], [72]], ["j", 98, "comesFrom", ["j"], [72]], ["g", 110, "comesFrom", ["g"], [87]], ["lcm", 123, "comesFrom", ["lcm"], [103]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int n ) { int upper_limit = ceil ( pow ( n , 1.0 / 4 ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { cout << \" x ▁ = ▁ \" << x << \" , ▁ y ▁ = ▁ \" << y ; return ; } } } cout << -1 << endl ; } int main ( ) { int n = 15 ; solve ( n ) ; return 0 ; }", "docstring": "Find two numbers whose difference of fourth power is equal to N | C ++ implementation to find the values of x and y for the given equation with integer N ; Function which find required x & y ; Upper limit of x & y , if such x & y exists ; num1 stores x ^ 4 ; num2 stores y ^ 4 ; If condition is satisfied the print and return ; If no such pair exists ; Driver code", "dfg": [["x", 36, "comesFrom", ["x"], [32]], ["x", 40, "comesFrom", ["x"], [32]], ["x", 68, "comesFrom", ["x"], [32]], ["x", 66, "comesFrom", ["x"], [32]], ["x", 62, "comesFrom", ["x"], [32]], ["x", 64, "comesFrom", ["x"], [32]], ["x", 96, "comesFrom", ["x"], [32]], ["upper_limit", 38, "comesFrom", ["upper_limit"], [15]], ["upper_limit", 53, "comesFrom", ["upper_limit"], [15]], ["n", 128, "comesFrom", ["n"], [122]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 87, "comesFrom", ["n"], [11]], ["y", 51, "comesFrom", ["y"], [47]], ["y", 55, "comesFrom", ["y"], [47]], ["y", 79, "comesFrom", ["y"], [47]], ["y", 77, "comesFrom", ["y"], [47]], ["y", 102, "comesFrom", ["y"], [47]], ["y", 73, "comesFrom", ["y"], [47]], ["y", 75, "comesFrom", ["y"], [47]], ["num1", 83, "comesFrom", ["num1"], [60]], ["num2", 85, "comesFrom", ["num2"], [71]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool divisorsSame ( int n ) { int even_div = 0 , odd_div = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } else { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } if ( n / i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } } } return ( even_div == odd_div ) ; } int main ( ) { int N = 6 ; if ( divisorsSame ( N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "docstring": "Check if count of even divisors of N is equal to count of odd divisors | C ++ program for the above approach ; Function to check if count of even and odd divisors are equal ; To store the count of even factors and odd factors ; Loop till [ 1 , sqrt ( N ) ] ; If divisors are equal add only one ; Check for even divisor ; Odd divisor ; Check for both divisor i . e . , i and N / i ; Check if i is odd or even ; Check if N / i is odd or even ; Return true if count of even_div and odd_div are equals ; Driver Code ; Given Number ; Function Call", "dfg": [["i", 30, "comesFrom", ["i"], [26]], ["i", 37, "comesFrom", ["i"], [26]], ["i", 45, "comesFrom", ["i"], [26]], ["i", 56, "comesFrom", ["i"], [26]], ["i", 54, "comesFrom", ["i"], [26]], ["i", 61, "comesFrom", ["i"], [26]], ["i", 83, "comesFrom", ["i"], [26]], ["i", 104, "comesFrom", ["i"], [26]], ["even_div", 126, "comesFrom", ["even_div"], [15]], ["even_div", 68, "comesFrom", ["even_div"], [15]], ["even_div", 90, "comesFrom", ["even_div"], [15]], ["even_div", 111, "comesFrom", ["even_div"], [15]], ["odd_div", 128, "comesFrom", ["odd_div"], [19]], ["odd_div", 74, "comesFrom", ["odd_div"], [19]], ["odd_div", 96, "comesFrom", ["odd_div"], [19]], ["odd_div", 117, "comesFrom", ["odd_div"], [19]], ["n", 34, "comesFrom", ["n"], [11]], ["n", 43, "comesFrom", ["n"], [11]], ["n", 52, "comesFrom", ["n"], [11]], ["n", 102, "comesFrom", ["n"], [11]], ["N", 146, "comesFrom", ["N"], [138]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool isBalancedPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n == mean ) return true ; else return false ; } int main ( ) { int n = 53 ; if ( isBalancedPrime ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if N is a Balanced Prime number or not | C ++ program to check if a given number is Balanced prime ; Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a Balanced prime ; If n is not a prime number or n is the first prime then return false ; Initialize previous_prime to n - 1 and next_prime to n + 1 ; Find next prime number ; Find previous prime number ; Arithmetic mean ; If n is a weak prime ; Driver code", "dfg": [["n", 59, "comesFrom", ["n"], [11]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 25, "comesFrom", ["n"], [11]], ["n", 116, "comesFrom", ["n"], [96]], ["n", 123, "comesFrom", ["n"], [96]], ["n", 162, "comesFrom", ["n"], [96]], ["n", 106, "comesFrom", ["n"], [96]], ["n", 188, "comesFrom", ["n"], [180]], ["n", 34, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [11]], ["n", 69, "comesFrom", ["n"], [11]], ["n", 75, "comesFrom", ["n"], [11]], ["n", 104, "comesFrom", ["n"], [96]], ["i", 55, "comesFrom", ["i"], [51]], ["i", 57, "comesFrom", ["i"], [51]], ["i", 63, "comesFrom", ["i"], [61]], ["i", 71, "comesFrom", ["i"], [61]], ["i", 78, "comesFrom", ["i"], [61]], ["next_prime", 135, "comesFrom", ["next_prime"], [121]], ["next_prime", 132, "comesFrom", ["next_prime"], [121]], ["next_prime", 155, "comesFrom", ["next_prime"], [121]], ["previous_prime", 146, "comesFrom", ["previous_prime"], [114]], ["previous_prime", 143, "comesFrom", ["previous_prime"], [114]], ["previous_prime", 153, "comesFrom", ["previous_prime"], [114]], ["mean", 164, "comesFrom", ["mean"], [150]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100001 NEW_LINE vector < int > adj [ N ] ; int a [ N ] , ans [ N ] ; bool hasOddNumberOfDivisors ( int n ) { if ( ( double ) sqrt ( n ) == ( int ) sqrt ( n ) ) return true ; return false ; } int dfs ( int node , int parent ) { int count = 0 ; for ( auto i = adj [ node ] . begin ( ) ; i != adj [ node ] . end ( ) ; ++ i ) { if ( * i != parent ) { count += dfs ( * i , node ) ; } } if ( hasOddNumberOfDivisors ( a [ node ] ) ) ++ count ; ans [ node ] = count ; return count ; } int main ( ) { int n = 5 , i ; vector < int > q = { 4 , 1 , 5 , 3 } ; adj [ 1 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 1 ) ; adj [ 2 ] . push_back ( 3 ) ; adj [ 3 ] . push_back ( 2 ) ; adj [ 3 ] . push_back ( 4 ) ; adj [ 4 ] . push_back ( 3 ) ; adj [ 1 ] . push_back ( 5 ) ; adj [ 5 ] . push_back ( 1 ) ; a [ 1 ] = 4 ; a [ 2 ] = 9 ; a [ 3 ] = 14 ; a [ 4 ] = 100 ; a [ 5 ] = 5 ; dfs ( 1 , -1 ) ; for ( int i = 0 ; i < q . size ( ) ; i ++ ) { cout << ans [ q [ i ] ] << \" ▁ \" ; } return 0 ; }", "docstring": "Count of nodes having odd divisors in the given subtree for Q queries | C ++ implementation to count the number of nodes having odd number of divisors for each query ; Adjacency list for tree . ; Array for values and answer at ith node . ; Function to check whether N has odd divisors or not ; DFS function to pre - compute the answers ; Initialize the count ; Repeat for every child ; Increase the count if current node has odd number of divisors ; Driver Code ; Adjacency List ; Function call", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int costCalculation ( int current , int arr [ ] , int n , int pref [ ] , int a , int r , int minimum ) { int index = lower_bound ( arr , arr + n , current ) - arr ; int left = index * current - pref [ index ] ; int right = pref [ n ] - pref [ index ] - ( n - index ) * current ; int res = min ( left , right ) ; left -= res ; right -= res ; int total = res * minimum ; total += left * a ; total += right * r ; return total ; } void solve ( int arr [ ] , int n , int a , int r , int m ) { sort ( arr , arr + n ) ; int minimum = min ( a + r , m ) ; int pref [ n + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) pref [ i + 1 ] = pref [ i ] + arr [ i ] ; int ans = 10000 ; for ( int i = 0 ; i < n ; i ++ ) ans = min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) ; ans = min ( ans , costCalculation ( pref [ n ] / n , arr , n , pref , a , r , minimum ) ) ; ans = min ( ans , costCalculation ( pref [ n ] / n + 1 , arr , n , pref , a , r , minimum ) ) ; cout << ans << \" STRNEWLINE \" ; } int main ( ) { int arr [ ] = { 5 , 5 , 3 , 6 , 5 } ; int A = 1 , R = 2 , M = 4 ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; solve ( arr , size , A , R , M ) ; return 0 ; }", "docstring": "Minimum Cost to make all array elements equal using given operations | C ++ implementation to find the minimum cost to make all array elements equal ; Function that returns the cost of making all elements equal to current element ; Compute the lower bound of current element ; Calculate the requirement of add operation ; Calculate the requirement of subtract operation ; Compute minimum of left and right ; Computing the total cost of add and subtract operations ; Function that prints minimum cost of making all elements equal ; Sort the given array ; Calculate minimum from a + r and m ; Compute prefix sum and store in pref array ; Find the minimum cost from the given elements ; Finding the minimum cost from the other cases where minimum cost can occur ; Printing the minimum cost of making all elements equal ; Driver Code ; Function Call", "dfg": [["total", 123, "comesFrom", ["total"], [116]], ["res", 97, "comesFrom", ["res"], [86]], ["res", 101, "comesFrom", ["res"], [86]], ["res", 106, "comesFrom", ["res"], [86]], ["i", 187, "comesFrom", ["i"], [183]], ["i", 191, "comesFrom", ["i"], [183]], ["i", 223, "comesFrom", ["i"], [219]], ["i", 227, "comesFrom", ["i"], [219]], ["i", 196, "comesFrom", ["i"], [183]], ["i", 203, "comesFrom", ["i"], [183]], ["i", 208, "comesFrom", ["i"], [183]], ["i", 240, "comesFrom", ["i"], [219]], ["n", 189, "comesFrom", ["n"], [135]], ["n", 225, "comesFrom", ["n"], [135]], ["n", 153, "comesFrom", ["n"], [135]], ["n", 171, "comesFrom", ["n"], [135]], ["n", 45, "comesFrom", ["n"], [19]], ["n", 69, "comesFrom", ["n"], [19]], ["n", 78, "comesFrom", ["n"], [19]], ["n", 274, "comesFrom", ["n"], [135]], ["n", 305, "comesFrom", ["n"], [135]], ["n", 245, "comesFrom", ["n"], [135]], ["n", 270, "comesFrom", ["n"], [135]], ["n", 299, "comesFrom", ["n"], [135]], ["n", 267, "comesFrom", ["n"], [135]], ["n", 296, "comesFrom", ["n"], [135]], ["minimum", 108, "comesFrom", ["minimum"], [33]], ["minimum", 282, "comesFrom", ["minimum"], [157]], ["minimum", 313, "comesFrom", ["minimum"], [157]], ["minimum", 253, "comesFrom", ["minimum"], [157]], ["left", 112, "comesFrom", ["left"], [95]], ["left", 90, "comesFrom", ["left"], [53]], ["a", 114, "comesFrom", ["a"], [27]], ["a", 161, "comesFrom", ["a"], [138]], ["a", 278, "comesFrom", ["a"], [138]], ["a", 309, "comesFrom", ["a"], [138]], ["a", 249, "comesFrom", ["a"], [138]], ["right", 118, "comesFrom", ["right"], [99]], ["right", 92, "comesFrom", ["right"], [65]], ["r", 120, "comesFrom", ["r"], [30]], ["r", 163, "comesFrom", ["r"], [141]], ["r", 280, "comesFrom", ["r"], [141]], ["r", 311, "comesFrom", ["r"], [141]], ["r", 251, "comesFrom", ["r"], [141]], ["ans", 319, "comesFrom", ["ans"], [286]], ["ans", 261, "comesFrom", ["ans"], [257]], ["ans", 290, "comesFrom", ["ans"], [286]], ["ans", 234, "comesFrom", ["ans"], [230]], ["size", 381, "comesFrom", ["size"], [362]], ["A", 383, "comesFrom", ["A"], [349]], ["R", 385, "comesFrom", ["R"], [353]], ["M", 387, "comesFrom", ["M"], [357]], ["index", 55, "comesFrom", ["index"], [37]], ["index", 61, "comesFrom", ["index"], [37]], ["index", 74, "comesFrom", ["index"], [37]], ["index", 80, "comesFrom", ["index"], [37]], ["current", 57, "comesFrom", ["current"], [11]], ["current", 83, "comesFrom", ["current"], [11]], ["current", 47, "comesFrom", ["current"], [11]], ["m", 165, "comesFrom", ["m"], [144]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countBinaries ( int N ) { int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += pow ( 2 , ctr - 1 ) ; } else if ( N % 10 > 1 ) { ans = pow ( 2 , ctr ) - 1 ; } ctr ++ ; N /= 10 ; } return ans ; } int main ( ) { int N = 20 ; cout << countBinaries ( N ) ; return 0 ; }", "docstring": "Count of integers up to N which represent a Binary number | C ++ Program to count the number of integers upto N which are of the form of binary representations ; Function to return the count ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code", "dfg": [["ans", 83, "comesFrom", ["ans"], [62]], ["N", 26, "comesFrom", ["N"], [11]], ["N", 100, "comesFrom", ["N"], [92]], ["N", 33, "comesFrom", ["N"], [11]], ["N", 55, "comesFrom", ["N"], [11]], ["ctr", 74, "comesFrom", ["ctr"], [15]], ["ctr", 46, "comesFrom", ["ctr"], [15]], ["ctr", 68, "comesFrom", ["ctr"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countBinaries ( int N ) { vector < int > powersOfTwo ( 11 ) ; powersOfTwo [ 0 ] = 1 ; for ( int i = 1 ; i < 11 ; i ++ ) { powersOfTwo [ i ] = powersOfTwo [ i - 1 ] * 2 ; } int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += powersOfTwo [ ctr - 1 ] ; } else if ( N % 10 > 1 ) { ans = powersOfTwo [ ctr ] - 1 ; } ctr ++ ; N /= 10 ; } return ans ; } int main ( ) { int N = 20 ; cout << countBinaries ( N ) ; return 0 ; }", "docstring": "Count of integers up to N which represent a Binary number | C ++ Program to count the number of integers upto N which are of the form of binary representations ; Function to return the count ; PreCompute and store the powers of 2 ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code", "dfg": [["ans", 125, "comesFrom", ["ans"], [106]], ["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 47, "comesFrom", ["i"], [33]], ["i", 52, "comesFrom", ["i"], [33]], ["powersOfTwo", 23, "comesFrom", ["powersOfTwo"], [18]], ["powersOfTwo", 45, "comesFrom", ["powersOfTwo"], [18]], ["powersOfTwo", 50, "comesFrom", ["powersOfTwo"], [18]], ["powersOfTwo", 88, "comesFrom", ["powersOfTwo"], [18]], ["powersOfTwo", 108, "comesFrom", ["powersOfTwo"], [18]], ["N", 72, "comesFrom", ["N"], [11]], ["N", 142, "comesFrom", ["N"], [134]], ["N", 79, "comesFrom", ["N"], [11]], ["N", 99, "comesFrom", ["N"], [11]], ["ctr", 116, "comesFrom", ["ctr"], [61]], ["ctr", 90, "comesFrom", ["ctr"], [61]], ["ctr", 110, "comesFrom", ["ctr"], [61]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Centered_Hexadecagonal_num ( int n ) { return ( 8 * n * n - 8 * n + 1 ) ; } int sum_Centered_Hexadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Hexadecagonal_num ( i ) ; } return summ ; } int main ( ) { int n = 5 ; cout << sum_Centered_Hexadecagonal_num ( n ) ; }", "docstring": "Find the sum of the first Nth Centered Hexadecagonal Number | C ++ program to find the sum of the first N centred hexadecagonal numbers ; Centered_Hexadecagonal number function ; Formula to calculate nth Centered_Hexadecagonal number & return it into main function . ; Function to find the sum of the first N centered hexadecagonal number ; Variable to store the sum ; Loop to iterate through the first N numbers ; Finding the sum ; Driver code ; Display first Nth Centered_Hexadecagonal number", "dfg": [["summ", 68, "comesFrom", ["summ"], [59]], ["i", 49, "comesFrom", ["i"], [45]], ["i", 55, "comesFrom", ["i"], [45]], ["i", 63, "comesFrom", ["i"], [45]], ["n", 51, "comesFrom", ["n"], [34]], ["n", 85, "comesFrom", ["n"], [77]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int center_heptagonal_num ( int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; } int sum_center_heptagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_heptagonal_num ( i ) ; } return summ ; } int main ( ) { int n = 5 ; cout << ( sum_center_heptagonal_num ( n ) ) ; return 0 ; }", "docstring": "Find the sum of the first N Centered heptagonal number | C ++ program to find the sum of the first N centered heptagonal numbers ; Function to find the N - th centered heptagonal number ; Formula to calculate nth centered heptagonal number ; Function to find the sum of the first N centered heptagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver Code", "dfg": [["summ", 70, "comesFrom", ["summ"], [61]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 57, "comesFrom", ["i"], [47]], ["i", 65, "comesFrom", ["i"], [47]], ["n", 53, "comesFrom", ["n"], [36]], ["n", 88, "comesFrom", ["n"], [79]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Centered_Dodecagonal_num ( int n ) { return 6 * n * ( n - 1 ) + 1 ; } int sum_Centered_Dodecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Dodecagonal_num ( i ) ; } return summ ; } int main ( ) { int n = 5 ; cout << sum_Centered_Dodecagonal_num ( n ) ; }", "docstring": "Find the sum of the first N Centered Dodecagonal Number | C ++ program to find the sum of the first N Centred Dodecagonal number ; Function to find the N - th Centered Dodecagonal number ; Formula to calculate nth Centered_Dodecagonal number ; Function to find the sum of the first N Centered_Dodecagonal number ; Variable to store the sum ; Iterating from 1 to N ; Finding the sum ; Driver code", "dfg": [["summ", 66, "comesFrom", ["summ"], [57]], ["i", 47, "comesFrom", ["i"], [43]], ["i", 53, "comesFrom", ["i"], [43]], ["i", 61, "comesFrom", ["i"], [43]], ["n", 49, "comesFrom", ["n"], [32]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 83, "comesFrom", ["n"], [75]], ["n", 20, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int center_Octagonal_num ( int n ) { return ( 4 * n * n - 4 * n + 1 ) ; } int sum_center_Octagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_Octagonal_num ( i ) ; } return summ ; } int main ( ) { int n = 5 ; cout << ( sum_center_Octagonal_num ( n ) ) ; return 0 ; }", "docstring": "Find the sum of the first N Centered Octagonal Number | C ++ program to find the sum of the first N centered octagonal number ; Function to find the N - th centered octagonal number ; Formula to calculate nth centered octagonal number ; Function to find the sum of the first N centered octagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver Code", "dfg": [["summ", 68, "comesFrom", ["summ"], [59]], ["i", 49, "comesFrom", ["i"], [45]], ["i", 55, "comesFrom", ["i"], [45]], ["i", 63, "comesFrom", ["i"], [45]], ["n", 51, "comesFrom", ["n"], [34]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 86, "comesFrom", ["n"], [77]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Centered_decagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 1 ) ; } int sum_Centered_decagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_decagonal_num ( i ) ; } return summ ; } int main ( ) { int n = 5 ; cout << ( sum_Centered_decagonal_num ( n ) ) ; return 0 ; }", "docstring": "Find the sum of the first N Centered Decagonal Numbers | C ++ program to find the sum of the first N centred decagonal number ; Function to find the N - th centred decagonal number ; Formula to calculate nth centered_decagonal number & return it into main function . ; Function to find the sum of the first N centered decagonal numbers ; Variable to store the sum ; Iterating through the range ; Driver code ; Display first Nth centered_decagonal number", "dfg": [["summ", 68, "comesFrom", ["summ"], [59]], ["i", 49, "comesFrom", ["i"], [45]], ["i", 55, "comesFrom", ["i"], [45]], ["i", 63, "comesFrom", ["i"], [45]], ["n", 51, "comesFrom", ["n"], [34]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 86, "comesFrom", ["n"], [77]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int center_octadecagon_num ( int n ) { return ( 9 * n * n - 9 * n + 1 ) ; } int sum_center_octadecagon_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_octadecagon_num ( i ) ; } return summ ; } int main ( ) { int n = 3 ; cout << ( sum_center_octadecagon_num ( n ) ) ; return 0 ; }", "docstring": "Find the sum of the first N Centered Octadecagonal Numbers | C ++ program to find the sum of the first N centered octadecagonal numbers ; Function to find the N - th centered octadecagonal number ; Formula to calculate nth centered octadecagonal number ; Function to find the sum of the first N centered octadecagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver Code", "dfg": [["summ", 68, "comesFrom", ["summ"], [59]], ["i", 49, "comesFrom", ["i"], [45]], ["i", 55, "comesFrom", ["i"], [45]], ["i", 63, "comesFrom", ["i"], [45]], ["n", 51, "comesFrom", ["n"], [34]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 86, "comesFrom", ["n"], [77]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Centered_Pentadecagonal_num ( int n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } int sum_Centered_Pentadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentadecagonal_num ( i ) ; } return summ ; } int main ( ) { int n = 5 ; cout << sum_Centered_Pentadecagonal_num ( n ) ; return 0 ; }", "docstring": "Find the sum of the first Nth Centered Pentadecagonal Number | C ++ program to find the sum of the first N centered pentadecagonal number ; Function to find the centered pentadecagonal number ; Formula to calculate N - th centered pentadecagonal number ; Function to find the sum of the first N centered pentadecagonal numbers ; Variable to store the sum ; Driver Code", "dfg": [["summ", 70, "comesFrom", ["summ"], [61]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 57, "comesFrom", ["i"], [47]], ["i", 65, "comesFrom", ["i"], [47]], ["n", 53, "comesFrom", ["n"], [36]], ["n", 87, "comesFrom", ["n"], [79]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isoctagonal ( int N ) { float n = ( 2 + sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 8 ; if ( isoctagonal ( N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "docstring": "Program to check if N is a Octagonal Number | C ++ program for the above approach ; Function to check if N is a Octagonal Number ; Condition to check if the number is a octagonal number ; Driver Code ; Given Number ; Function call", "dfg": [["n", 34, "comesFrom", ["n"], [15]], ["n", 39, "comesFrom", ["n"], [15]], ["N", 59, "comesFrom", ["N"], [51]], ["N", 24, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPentadecagon ( int N ) { float n = ( 11 + sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 15 ; if ( isPentadecagon ( N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "docstring": "Program to check if N is a Pentadecagonal Number | C ++ program for the above approach ; Function to check if N is a Pentadecagon number ; Condition to check if the number is a Pentadecagon number ; Driver Code ; Given Number ; Function call", "dfg": [["n", 34, "comesFrom", ["n"], [15]], ["n", 39, "comesFrom", ["n"], [15]], ["N", 59, "comesFrom", ["N"], [51]], ["N", 24, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool istetradecagonal ( int N ) { float n = ( 10 + sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 11 ; if ( istetradecagonal ( N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "docstring": "Program to check if N is a Tetradecagonal Number | C ++ program for the above approach ; Function to check if N is a Tetradecagonal Number ; Condition to check if the number is a tetradecagonal number ; Driver Code ; Given Number ; Function call", "dfg": [["n", 34, "comesFrom", ["n"], [15]], ["n", 39, "comesFrom", ["n"], [15]], ["N", 59, "comesFrom", ["N"], [51]], ["N", 24, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Icosagonal_num ( int n ) { return ( 18 * n * n - 16 * n ) / 2 ; } int sum_Icosagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Icosagonal_num ( i ) ; } return summ ; } int main ( ) { int n = 5 ; cout << sum_Icosagonal_num ( n ) << endl ; }", "docstring": "Find the sum of the first Nth Icosagonal Numbers | C ++ program to find the sum of the first N icosagonal number ; Function to calculate the N - th icosagonal number ; Formula to calculate nth icosagonal number & return it ; Function to find the sum of the first N icosagonal numbers ; Variable to store the sum ; Loop to iterate through the first N values and find the sum of first N icosagonal numbers ; Function to get the Icosagonal_num ; Driver code ; Display the sum of first N icosagonal number", "dfg": [["summ", 66, "comesFrom", ["summ"], [57]], ["i", 49, "comesFrom", ["i"], [45]], ["i", 53, "comesFrom", ["i"], [45]], ["i", 61, "comesFrom", ["i"], [45]], ["n", 51, "comesFrom", ["n"], [34]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 83, "comesFrom", ["n"], [75]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Centered_Pentagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; } int sum_Centered_Pentagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentagonal_num ( i ) ; } return summ ; } int main ( ) { int n = 5 ; cout << ( sum_Centered_Pentagonal_num ( n ) ) ; return 0 ; }", "docstring": "Find the sum of the first N Centered Pentagonal Number | C ++ program to find the sum of the first N centered pentagonal numbers ; Function to find the Centered_Pentagonal number ; Formula to calculate nth Centered_Pentagonal number & return it into main function . ; Function to find the sum of the first N Centered_Pentagonal numbers ; To get the sum ; Iterating through the range 1 to N ; Driver Code ; Display first Nth Centered_Pentagonal number", "dfg": [["summ", 70, "comesFrom", ["summ"], [61]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 57, "comesFrom", ["i"], [47]], ["i", 65, "comesFrom", ["i"], [47]], ["n", 53, "comesFrom", ["n"], [36]], ["n", 88, "comesFrom", ["n"], [79]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Centered_tridecagonal_num ( int n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; } int sum_Centered_tridecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Centered_tridecagonal_num ( i ) ; } return summ ; } int main ( ) { int n = 5 ; cout << sum_Centered_tridecagonal_num ( n ) << endl ; return 0 ; }", "docstring": "Find the sum of the first Nth Centered Tridecagonal Numbers | C ++ program to find the sum of the first Nth centered tridecagonal number ; Function to calculate the N - th centered tridecagonal number ; Formula to calculate Nth centered tridecagonal number & return it ; Function to find the sum of the first N centered tridecagonal numbers ; Variable to store the sum ; Loop to iterate and find the sum of first N centered tridecagonal numbers ; Driver code", "dfg": [["summ", 68, "comesFrom", ["summ"], [59]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 55, "comesFrom", ["i"], [47]], ["i", 63, "comesFrom", ["i"], [47]], ["n", 53, "comesFrom", ["n"], [36]], ["n", 85, "comesFrom", ["n"], [77]], ["n", 18, "comesFrom", ["n"], [11]], ["n", 21, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isConcentrichexagonal ( int N ) { float n = sqrt ( ( 2 * N ) / 3 ) ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 6 ; if ( isConcentrichexagonal ( N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "docstring": "Program to check if N is a Concentric Hexagonal Number | C ++ program to check if N is a Concentric Hexagonal Number ; Function to check if the number is a Concentric hexagonal number ; Condition to check if the number is a Concentric hexagonal number ; Driver Code ; Function call", "dfg": [["n", 30, "comesFrom", ["n"], [15]], ["n", 35, "comesFrom", ["n"], [15]], ["N", 55, "comesFrom", ["N"], [47]], ["N", 22, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < bool > Prime ; void computePrime ( int N ) { Prime . resize ( N + 1 , true ) ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( Prime [ i ] ) { for ( int j = i * i ; j < N ; j += i ) { Prime [ j ] = false ; } } } } int countSexyPairs ( int arr [ ] , int n ) { int maxE = * max_element ( arr , arr + n ) ; computePrime ( maxE ) ; int count = 0 ; int freq [ maxE + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Prime [ arr [ i ] ] ) { if ( freq [ arr [ i ] + 6 ] > 0 && Prime [ arr [ i ] + 6 ] ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 6 , 7 , 5 , 11 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSexyPairs ( arr , n ) ; return 0 ; }", "docstring": "Count Sexy Prime Pairs in the given array | C ++ program to count Sexy Prime pairs in array ; To store check the prime number ; A utility function that find the Prime Numbers till N ; Resize the Prime Number ; Loop till sqrt ( N ) to find prime numbers and make their multiple false in the bool array Prime ; Function that returns the count of SPP ( Sexy Prime Pair ) Pairs ; Find the maximum element in the given array arr [ ] ; Function to calculate the prime numbers till N ; To store the count of pairs ; To store the frequency of element in the array arr [ ] ; Sort before traversing the array ; Traverse the array and find the pairs with SPP ( Sexy Prime Pair ) ; If current element is Prime , then check for ( current element + 6 ) ; Return the count of pairs ; Driver code ; Function call to find SPP ( Sexy Prime Pair ) pair", "dfg": [["count", 236, "comesFrom", ["count"], [128]], ["count", 229, "comesFrom", ["count"], [128]], ["N", 54, "comesFrom", ["N"], [17]], ["N", 24, "comesFrom", ["N"], [17]], ["N", 79, "comesFrom", ["N"], [17]], ["i", 56, "comesFrom", ["i"], [46]], ["i", 151, "comesFrom", ["i"], [147]], ["i", 155, "comesFrom", ["i"], [147]], ["i", 185, "comesFrom", ["i"], [181]], ["i", 189, "comesFrom", ["i"], [181]], ["i", 50, "comesFrom", ["i"], [46]], ["i", 52, "comesFrom", ["i"], [46]], ["i", 64, "comesFrom", ["i"], [46]], ["i", 83, "comesFrom", ["i"], [46]], ["i", 73, "comesFrom", ["i"], [46]], ["i", 75, "comesFrom", ["i"], [46]], ["i", 163, "comesFrom", ["i"], [147]], ["i", 199, "comesFrom", ["i"], [181]], ["i", 222, "comesFrom", ["i"], [181]], ["i", 210, "comesFrom", ["i"], [181]], ["n", 153, "comesFrom", ["n"], [106]], ["n", 187, "comesFrom", ["n"], [106]], ["n", 175, "comesFrom", ["n"], [106]], ["n", 283, "comesFrom", ["n"], [262]], ["n", 119, "comesFrom", ["n"], [106]], ["Prime", 20, "comesFrom", ["Prime"], [11]], ["Prime", 31, "comesFrom", ["Prime"], [11]], ["Prime", 36, "comesFrom", ["Prime"], [11]], ["Prime", 62, "comesFrom", ["Prime"], [11]], ["Prime", 195, "comesFrom", ["Prime"], [11]], ["Prime", 218, "comesFrom", ["Prime"], [11]], ["Prime", 86, "comesFrom", ["Prime"], [11]], ["maxE", 124, "comesFrom", ["maxE"], [110]], ["maxE", 135, "comesFrom", ["maxE"], [110]], ["j", 77, "comesFrom", ["j"], [71]], ["j", 88, "comesFrom", ["j"], [81]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countWays ( int n ) { if ( n <= 2 ) cout << \" - 1\" ; else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; cout << ans ; } } int main ( ) { int N = 5 ; countWays ( N ) ; return 0 ; }", "docstring": "Count of ways to write N as a sum of three numbers | C ++ program to count the total number of ways to write N as a sum of three numbers ; Function to find the number of ways ; Check if number is less than 2 ; Calculate the sum ; Driver code", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 32, "comesFrom", ["n"], [11]], ["n", 38, "comesFrom", ["n"], [11]], ["N", 63, "comesFrom", ["N"], [57]], ["ans", 47, "comesFrom", ["ans"], [29]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { int N = 8 ; if ( isPowerOfTwo ( N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } }", "docstring": "Logarithm tricks for Competitive Programming | C ++ implementation to check that a integer is a power of Two ; Function to check if the number is a power of two ; Driver Code", "dfg": [["N", 48, "comesFrom", ["N"], [40]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 28, "comesFrom", ["n"], [11]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int count_pairs ( int x ) { int ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = x / 2 ; } return ans ; } int main ( ) { int X = 6 ; cout << count_pairs ( X ) << endl ; return 0 ; }", "docstring": "Count of pairs having bit size at most X and Bitwise OR equal to X | C ++ implementation to Count number of possible pairs of ( a , b ) such that their Bitwise OR gives the value X ; Function to count the pairs ; Initializing answer with 1 ; Iterating through bits of x ; check if bit is 1 ; multiplying ans by 3 if bit is 1 ; Driver code", "dfg": [["ans", 48, "comesFrom", ["ans"], [34]], ["ans", 36, "comesFrom", ["ans"], [34]], ["x", 21, "comesFrom", ["x"], [11]], ["x", 42, "comesFrom", ["x"], [40]], ["x", 28, "comesFrom", ["x"], [11]], ["X", 65, "comesFrom", ["X"], [57]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void kthNonDivisible ( int N , int K ) { int L = 1 ; int H = INT_MAX ; int ans = 0 ; while ( L <= H ) { int mid = ( L + H ) / 2 ; int sol = mid - mid / N ; if ( sol > K ) { H = mid - 1 ; } else if ( sol < K ) { L = mid + 1 ; } else { ans = mid ; H = mid - 1 ; } } cout << ans ; } int main ( ) { int N = 3 ; int K = 7 ; kthNonDivisible ( N , K ) ; return 0 ; }", "docstring": "Find the Kth number which is not divisible by N | C ++ implementation for above approach ; Function to find the Kth not divisible by N ; Lowest possible value ; Highest possible value ; To store the Kth non divisible number of N ; Using binary search ; Calculating mid value ; Sol would have the value by subtracting all multiples of n till mid ; Check if sol is greater than k ; H should be reduced to find minimum possible value ; Check if sol is less than k then L will be mid + 1 ; Check if sol is equal to k ; ans will be mid ; H would be reduced to find any more possible value ; Print the answer ; Driver Code ; Function Call", "dfg": [["ans", 104, "comesFrom", ["ans"], [90]], ["L", 34, "comesFrom", ["L"], [18]], ["L", 43, "comesFrom", ["L"], [18]], ["H", 36, "comesFrom", ["H"], [23]], ["H", 45, "comesFrom", ["H"], [23]], ["N", 124, "comesFrom", ["N"], [113]], ["N", 57, "comesFrom", ["N"], [11]], ["K", 126, "comesFrom", ["K"], [118]], ["K", 63, "comesFrom", ["K"], [14]], ["K", 78, "comesFrom", ["K"], [14]], ["mid", 53, "comesFrom", ["mid"], [40]], ["mid", 55, "comesFrom", ["mid"], [40]], ["mid", 68, "comesFrom", ["mid"], [40]], ["mid", 83, "comesFrom", ["mid"], [40]], ["mid", 92, "comesFrom", ["mid"], [40]], ["mid", 96, "comesFrom", ["mid"], [40]], ["sol", 61, "comesFrom", ["sol"], [51]], ["sol", 76, "comesFrom", ["sol"], [51]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPair ( int n ) { cout << 1 << \" ▁ \" << n - 1 ; } int main ( ) { int n = 14 ; printPair ( n ) ; return 0 ; }", "docstring": "Print any pair of integers with sum of GCD and LCM equals to N | C ++ implementation to Print any pair of integers whose summation of GCD and LCM is equal to integer N ; Function to print the required pair ; print the pair ; Driver code", "dfg": [["n", 22, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [33]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isAutoBiographyNum ( int number ) { int count = 0 , position , size , digit ; string NUM ; NUM = to_string ( number ) ; size = NUM . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { position = NUM [ i ] - '0' ; count = 0 ; for ( int j = 0 ; j < size ; j ++ ) { digit = NUM [ j ] - '0' ; if ( digit == i ) count ++ ; } if ( position != count ) return false ; } return true ; } int checkArray ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isAutoBiographyNum ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; } int main ( ) { int arr [ ] = { 21200 , 1 , 1303 , 1210 , 2020 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << checkArray ( arr , n ) << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Find the length of largest subarray in which all elements are Autobiographical Numbers | C ++ program to find the length of the largest subarray whose every element is an Autobiographical Number ; function to check number is autobiographical ; Convert integer to string ; Iterate for every digit to check for their total count ; Check occurrence of every number and count them ; Check if any position mismatches with total count them return with false else continue with loop ; Function to return the length of the largest subarray whose every element is a Autobiographical number ; Utility function which checks every element of array for Autobiographical number ; Check if element arr [ i ] is an Autobiographical number ; Increment the current length ; Update max_length value ; Return the final result ; Driver code", "dfg": [["max_length", 189, "comesFrom", ["max_length"], [178]], ["max_length", 182, "comesFrom", ["max_length"], [178]], ["i", 50, "comesFrom", ["i"], [46]], ["i", 54, "comesFrom", ["i"], [46]], ["i", 152, "comesFrom", ["i"], [148]], ["i", 156, "comesFrom", ["i"], [148]], ["i", 62, "comesFrom", ["i"], [46]], ["i", 103, "comesFrom", ["i"], [46]], ["i", 166, "comesFrom", ["i"], [148]], ["size", 52, "comesFrom", ["size"], [35]], ["size", 82, "comesFrom", ["size"], [35]], ["n", 154, "comesFrom", ["n"], [132]], ["n", 236, "comesFrom", ["n"], [215]], ["number", 32, "comesFrom", ["number"], [11]], ["NUM", 37, "comesFrom", ["NUM"], [28]], ["NUM", 60, "comesFrom", ["NUM"], [28]], ["NUM", 90, "comesFrom", ["NUM"], [28]], ["j", 80, "comesFrom", ["j"], [76]], ["j", 84, "comesFrom", ["j"], [76]], ["j", 92, "comesFrom", ["j"], [76]], ["position", 111, "comesFrom", ["position"], [58]], ["count", 113, "comesFrom", ["count"], [69]], ["count", 105, "comesFrom", ["count"], [69]], ["current_length", 170, "comesFrom", ["current_length"], [136]], ["current_length", 184, "comesFrom", ["current_length"], [174]], ["digit", 101, "comesFrom", ["digit"], [88]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumOfSquares ( int n , vector < pair < int , int > > & vp ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { int h = n - i * i , h1 = sqrt ( h ) ; if ( h1 * h1 == h ) { int a = max ( h1 , i ) , b = min ( h1 , i ) ; if ( vp . size ( ) == 1 && a != vp [ 0 ] . first ) vp . push_back ( make_pair ( a , b ) ) ; if ( vp . size ( ) == 0 ) vp . push_back ( make_pair ( a , b ) ) ; if ( vp . size ( ) == 2 ) return ; } } } void findFactors ( int n ) { vector < pair < int , int > > vp ; sumOfSquares ( n , vp ) ; if ( vp . size ( ) != 2 ) cout << \" Factors ▁ Not ▁ Possible \" ; int a , b , c , d ; a = vp [ 0 ] . first ; b = vp [ 0 ] . second ; c = vp [ 1 ] . first ; d = vp [ 1 ] . second ; if ( a < c ) { int t = a ; a = c ; c = t ; t = b ; b = d ; d = t ; } int k , h , l , m ; k = __gcd ( a - c , d - b ) ; h = __gcd ( a + c , d + b ) ; l = ( a - c ) / k ; m = ( d - b ) / k ; cout << \" a ▁ = ▁ \" << a << \" TABSYMBOL TABSYMBOL ( A ) ▁ a ▁ - ▁ c ▁ = ▁ \" << ( a - c ) << \" TABSYMBOL TABSYMBOL k ▁ = ▁ gcd [ A , ▁ C ] ▁ = ▁ \" << k << endl ; cout << \" b ▁ = ▁ \" << b << \" TABSYMBOL TABSYMBOL ( B ) ▁ a ▁ + ▁ c ▁ = ▁ \" << ( a + c ) << \" TABSYMBOL TABSYMBOL h ▁ = ▁ gcd [ B , ▁ D ] ▁ = ▁ \" << h << endl ; cout << \" c ▁ = ▁ \" << c << \" TABSYMBOL TABSYMBOL ( C ) ▁ d ▁ - ▁ b ▁ = ▁ \" << ( d - b ) << \" TABSYMBOL TABSYMBOL l ▁ = ▁ A / k ▁ = ▁ \" << l << endl ; cout << \" d ▁ = ▁ \" << d << \" TABSYMBOL TABSYMBOL ( D ) ▁ d ▁ + ▁ b ▁ = ▁ \" << ( d + b ) << \" TABSYMBOL TABSYMBOL m ▁ = ▁ c / k ▁ = ▁ \" << m << endl ; if ( k % 2 == 0 && h % 2 == 0 ) { k = k / 2 ; h = h / 2 ; cout << \" Factors ▁ are : ▁ \" << ( ( k ) * ( k ) + ( h ) * ( h ) ) << \" ▁ \" << ( l * l + m * m ) << endl ; } else { l = l / 2 ; m = m / 2 ; cout << \" Factors ▁ are : ▁ \" << ( ( l ) * ( l ) + ( m ) * ( m ) ) << \" ▁ \" << ( k * k + h * h ) << endl ; } } int main ( ) { int n = 100000 ; findFactors ( n ) ; return 0 ; }", "docstring": "Euler 's Factorization method | C ++ program to implement Eulers Factorization algorithm ; Function to return N as the sum of two squares in two possible ways ; Iterate a loop from 1 to sqrt ( n ) ; If i * i is square check if there exists another integer such that h is a perfect square and i * i + h = n ; If h is perfect square ; Store in the sorted way ; If there is already a pair check if pairs are equal or not ; Insert the first pair ; If two pairs are found ; Function to find the factors ; Get pairs where a ^ 2 + b ^ 2 = n ; Number cannot be represented as sum of squares in two ways ; Assign a , b , c , d ; Swap if a < c because if a - c < 0 , GCD cant be computed . ; Compute the values of k , h , l , m using the formula mentioned in the approach ; Print the values of a , b , c , d and k , l , m , h ; Printing the factors ; Driver code", "dfg": [["i", 33, "comesFrom", ["i"], [29]], ["i", 40, "comesFrom", ["i"], [29]], ["i", 49, "comesFrom", ["i"], [29]], ["i", 51, "comesFrom", ["i"], [29]], ["i", 76, "comesFrom", ["i"], [29]], ["i", 85, "comesFrom", ["i"], [29]], ["vp", 178, "comesFrom", ["vp"], [172]], ["vp", 208, "comesFrom", ["vp"], [172]], ["vp", 217, "comesFrom", ["vp"], [172]], ["vp", 226, "comesFrom", ["vp"], [172]], ["vp", 235, "comesFrom", ["vp"], [172]], ["vp", 183, "comesFrom", ["vp"], [172]], ["n", 176, "comesFrom", ["n"], [160]], ["n", 570, "comesFrom", ["n"], [564]], ["n", 37, "comesFrom", ["n"], [11]], ["n", 47, "comesFrom", ["n"], [11]], ["a", 244, "comesFrom", ["a"], [206]], ["a", 288, "comesFrom", ["a"], [254]], ["a", 301, "comesFrom", ["a"], [254]], ["a", 313, "comesFrom", ["a"], [254]], ["a", 336, "comesFrom", ["a"], [254]], ["a", 343, "comesFrom", ["a"], [254]], ["a", 369, "comesFrom", ["a"], [254]], ["a", 98, "comesFrom", ["a"], [70]], ["a", 113, "comesFrom", ["a"], [70]], ["a", 135, "comesFrom", ["a"], [70]], ["c", 246, "comesFrom", ["c"], [224]], ["c", 256, "comesFrom", ["c"], [224]], ["c", 290, "comesFrom", ["c"], [258]], ["c", 303, "comesFrom", ["c"], [258]], ["c", 315, "comesFrom", ["c"], [258]], ["c", 345, "comesFrom", ["c"], [258]], ["c", 371, "comesFrom", ["c"], [258]], ["c", 388, "comesFrom", ["c"], [258]], ["k", 318, "comesFrom", ["k"], [284]], ["k", 328, "comesFrom", ["k"], [284]], ["k", 352, "comesFrom", ["k"], [284]], ["k", 436, "comesFrom", ["k"], [284]], ["k", 451, "comesFrom", ["k"], [449]], ["k", 545, "comesFrom", ["k"], [449]], ["k", 547, "comesFrom", ["k"], [449]], ["k", 469, "comesFrom", ["k"], [449]], ["h", 378, "comesFrom", ["h"], [297]], ["h", 66, "comesFrom", ["h"], [45]], ["h", 442, "comesFrom", ["h"], [297]], ["h", 457, "comesFrom", ["h"], [455]], ["h", 57, "comesFrom", ["h"], [45]], ["h", 549, "comesFrom", ["h"], [455]], ["h", 551, "comesFrom", ["h"], [455]], ["h", 481, "comesFrom", ["h"], [455]], ["h", 477, "comesFrom", ["h"], [455]], ["l", 404, "comesFrom", ["l"], [310]], ["l", 506, "comesFrom", ["l"], [504]], ["l", 490, "comesFrom", ["l"], [310]], ["l", 492, "comesFrom", ["l"], [310]], ["l", 524, "comesFrom", ["l"], [504]], ["m", 430, "comesFrom", ["m"], [320]], ["m", 512, "comesFrom", ["m"], [510]], ["m", 494, "comesFrom", ["m"], [320]], ["m", 496, "comesFrom", ["m"], [320]], ["m", 536, "comesFrom", ["m"], [510]], ["m", 532, "comesFrom", ["m"], [510]], ["t", 260, "comesFrom", ["t"], [250]], ["t", 272, "comesFrom", ["t"], [262]], ["b", 264, "comesFrom", ["b"], [215]], ["b", 294, "comesFrom", ["b"], [266]], ["b", 307, "comesFrom", ["b"], [266]], ["b", 325, "comesFrom", ["b"], [266]], ["b", 362, "comesFrom", ["b"], [266]], ["b", 397, "comesFrom", ["b"], [266]], ["b", 423, "comesFrom", ["b"], [266]], ["b", 115, "comesFrom", ["b"], [79]], ["b", 137, "comesFrom", ["b"], [79]], ["d", 268, "comesFrom", ["d"], [233]], ["d", 292, "comesFrom", ["d"], [270]], ["d", 305, "comesFrom", ["d"], [270]], ["d", 323, "comesFrom", ["d"], [270]], ["d", 395, "comesFrom", ["d"], [270]], ["d", 414, "comesFrom", ["d"], [270]], ["d", 421, "comesFrom", ["d"], [270]], ["h1", 62, "comesFrom", ["h1"], [53]], ["h1", 64, "comesFrom", ["h1"], [53]], ["h1", 74, "comesFrom", ["h1"], [53]], ["h1", 83, "comesFrom", ["h1"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE vector < int > graph [ MAX + 1 ] ; vector < bool > Prime ( MAX + 1 , true ) ; int height [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= MAX ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < MAX ; j += i ) { Prime [ j ] = false ; } } } } void dfs ( int node , int parent , int h ) { height [ node ] = h ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node , h + 1 ) ; } } void primeHeightNode ( int N ) { SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( Prime [ height [ i ] ] ) { cout << i << \" ▁ \" ; } } } int main ( ) { int N = 5 ; graph [ 1 ] . push_back ( 2 ) ; graph [ 1 ] . push_back ( 3 ) ; graph [ 2 ] . push_back ( 4 ) ; graph [ 2 ] . push_back ( 5 ) ; dfs ( 1 , 1 , 0 ) ; primeHeightNode ( N ) ; return 0 ; }", "docstring": "Print the nodes of the Binary Tree whose height is a Prime number | C ++ implementation of nodes at prime height in the given tree ; To store Prime Numbers ; To store height of each node ; Function to find the prime numbers till 10 ^ 5 ; Traverse all multiple of i and make it false ; Function to perform dfs ; Store the height of node ; Function to find the nodes at prime height ; To precompute prime number till 10 ^ 5 ; Check if height [ node ] is prime ; Driver code ; Number of nodes ; Edges of the tree", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int a ) { int rev = 0 ; while ( a != 0 ) { int r = a % 10 ; rev = rev * 10 + r ; a = a / 10 ; } return ( rev ) ; } int prime ( int a ) { int k = 0 ; for ( int i = 2 ; i < a ; i ++ ) { if ( a % i == 0 ) { k = 1 ; break ; } } if ( k == 1 ) { return ( 0 ) ; } else { return ( 1 ) ; } } int adam ( int a ) { int r1 = reverse ( a ) ; int s1 = a * a ; int s2 = r1 * r1 ; int r2 = reverse ( s2 ) ; if ( s1 == r2 ) { return ( 1 ) ; } else { return ( 0 ) ; } } void find ( int m , int n ) { if ( m > n ) { cout << \" ▁ INVALID ▁ INPUT ▁ \" << endl ; } else { int c = 0 ; for ( int i = m ; i <= n ; i ++ ) { int l = prime ( i ) ; int k = adam ( i ) ; if ( ( l == 1 ) && ( k == 1 ) ) { cout << i << \" TABSYMBOL \" ; } } } } int main ( ) { int L = 5 , R = 100 ; find ( L , R ) ; return 0 ; }", "docstring": "Find Prime Adam integers in the given range [ L , R ] | C ++ program to find all prime adam numbers in the given range ; Reversing a number by taking remainder at a time ; Function to check if a number is a prime or not ; Iterating till the number ; Checking for factors ; Returning 1 if the there are no factors of the number other than 1 or itself ; Function to check whether a number is an adam number or not ; Reversing given number ; Squaring given number ; Squaring reversed number ; Reversing the square of the reversed number ; Checking if the square of the number and the square of its reverse are equal or not ; Function to find all the prime adam numbers in the given range ; If the first number is greater than the second number , print invalid ; Iterating through all the numbers in the given range ; Checking for prime number ; Checking for Adam number ; Driver code", "dfg": [["rev", 50, "comesFrom", ["rev"], [33]], ["rev", 35, "comesFrom", ["rev"], [33]], ["i", 73, "comesFrom", ["i"], [69]], ["i", 77, "comesFrom", ["i"], [69]], ["i", 219, "comesFrom", ["i"], [215]], ["i", 223, "comesFrom", ["i"], [215]], ["i", 85, "comesFrom", ["i"], [69]], ["i", 232, "comesFrom", ["i"], [215]], ["i", 240, "comesFrom", ["i"], [215]], ["i", 260, "comesFrom", ["i"], [215]], ["a", 75, "comesFrom", ["a"], [58]], ["a", 21, "comesFrom", ["a"], [11]], ["a", 138, "comesFrom", ["a"], [124]], ["a", 140, "comesFrom", ["a"], [124]], ["a", 132, "comesFrom", ["a"], [124]], ["a", 29, "comesFrom", ["a"], [11]], ["a", 43, "comesFrom", ["a"], [41]], ["a", 83, "comesFrom", ["a"], [58]], ["k", 100, "comesFrom", ["k"], [90]], ["k", 252, "comesFrom", ["k"], [236]], ["r1", 145, "comesFrom", ["r1"], [128]], ["r1", 147, "comesFrom", ["r1"], [128]], ["s1", 159, "comesFrom", ["s1"], [136]], ["r2", 161, "comesFrom", ["r2"], [150]], ["m", 191, "comesFrom", ["m"], [183]], ["n", 193, "comesFrom", ["n"], [186]], ["n", 221, "comesFrom", ["n"], [186]], ["L", 286, "comesFrom", ["L"], [276]], ["R", 288, "comesFrom", ["R"], [280]], ["s2", 154, "comesFrom", ["s2"], [143]], ["r", 39, "comesFrom", ["r"], [27]], ["l", 246, "comesFrom", ["l"], [228]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumDig ( int n ) { int s = 0 ; while ( n != 0 ) { s = s + ( n % 10 ) ; n = n / 10 ; } return s ; } bool Pec ( int n ) { int dup = n ; int dig = sumDig ( n ) ; if ( dig * 3 == dup ) return true ; else return false ; } int main ( ) { int n = 36 ; if ( Pec ( n ) == true ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }", "docstring": "Determine whether the given integer N is a Peculiar Number or not | C ++ implementation to check if the number is peculiar ; Function to find sum of digits of a number ; Function to check if the number is peculiar ; Store a duplicate of n ; Driver code", "dfg": [["s", 44, "comesFrom", ["s"], [26]], ["s", 28, "comesFrom", ["s"], [26]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 64, "comesFrom", ["n"], [57]], ["n", 38, "comesFrom", ["n"], [36]], ["n", 97, "comesFrom", ["n"], [89]], ["n", 31, "comesFrom", ["n"], [11]], ["dup", 73, "comesFrom", ["dup"], [55]], ["dig", 69, "comesFrom", ["dig"], [60]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int digit_sum ( int n ) { int sum = 0 , m ; while ( n > 0 ) { m = n % 10 ; sum = sum + m ; n = n / 10 ; } return ( sum ) ; } int reverse ( int n ) { int r = 0 ; while ( n != 0 ) { r = r * 10 ; r = r + n % 10 ; n = n / 10 ; } return ( r ) ; } void operation ( int n ) { int i = 1 , a , count = 0 , r ; while ( count < n ) { a = digit_sum ( i ) ; r = reverse ( i ) ; if ( i % a == 0 && r % a == 0 ) { cout << i << \" ▁ \" ; count ++ ; i ++ ; } else i ++ ; } } int main ( ) { int n = 10 ; operation ( n ) ; }", "docstring": "Find N numbers such that a number and its reverse are divisible by sum of its digits | C ++ program to print the first N numbers such that every number and the reverse of the number is divisible by its sum of digits ; Function to calculate the sum of digits ; Loop to iterate through every digit of the number ; Returning the sum of digits ; Function to calculate the reverse of a number ; Loop to calculate the reverse of the number ; Return the reverse of the number ; Function to print the first N numbers such that every number and the reverse of the number is divisible by its sum of digits ; Loop to continuously check and generate number until there are n outputs ; Variable to hold the sum of the digit of the number ; Computing the reverse of the number ; Checking if the condition satisfies . Increment the count and print the number if it satisfies . ; Driver code", "dfg": [["sum", 49, "comesFrom", ["sum"], [34]], ["sum", 36, "comesFrom", ["sum"], [34]], ["r", 95, "comesFrom", ["r"], [78]], ["r", 74, "comesFrom", ["r"], [72]], ["r", 80, "comesFrom", ["r"], [78]], ["r", 148, "comesFrom", ["r"], [133]], ["n", 23, "comesFrom", ["n"], [11]], ["n", 67, "comesFrom", ["n"], [57]], ["n", 123, "comesFrom", ["n"], [103]], ["n", 188, "comesFrom", ["n"], [182]], ["n", 30, "comesFrom", ["n"], [11]], ["n", 42, "comesFrom", ["n"], [40]], ["n", 88, "comesFrom", ["n"], [86]], ["n", 82, "comesFrom", ["n"], [57]], ["count", 121, "comesFrom", ["count"], [113]], ["count", 163, "comesFrom", ["count"], [113]], ["m", 38, "comesFrom", ["m"], [28]], ["i", 130, "comesFrom", ["i"], [107]], ["i", 137, "comesFrom", ["i"], [107]], ["i", 166, "comesFrom", ["i"], [107]], ["i", 171, "comesFrom", ["i"], [107]], ["i", 142, "comesFrom", ["i"], [107]], ["i", 157, "comesFrom", ["i"], [107]], ["a", 144, "comesFrom", ["a"], [126]], ["a", 150, "comesFrom", ["a"], [126]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void createSets ( int N ) { if ( N <= 2 ) { cout << \" - 1\" << endl ; return ; } for ( int i = 2 ; i <= N ; i += 2 ) cout << i << \" ▁ \" ; cout << \" STRNEWLINE \" ; for ( int i = 1 ; i <= N ; i += 2 ) { cout << i << \" ▁ \" ; } } int main ( ) { int N = 6 ; createSets ( N ) ; return 0 ; }", "docstring": "Split N natural numbers into two sets having GCD of their sums greater than 1 | C ++ program to split N natural numbers into two sets having GCD of their sums greater than 1 ; Function to create and print the two sets ; No such split possible for N <= 2 ; Print the first set consisting of even elements ; Print the second set consisting of odd ones ; Driver Code", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 68, "comesFrom", ["i"], [64]], ["i", 49, "comesFrom", ["i"], [43]], ["i", 79, "comesFrom", ["i"], [72]], ["N", 41, "comesFrom", ["N"], [11]], ["N", 70, "comesFrom", ["N"], [11]], ["N", 16, "comesFrom", ["N"], [11]], ["N", 99, "comesFrom", ["N"], [93]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int ans = 0 ; vector < int > graph [ 100 ] ; vector < int > weight ( 100 ) ; bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } void dfs ( int node , int parent ) { if ( isPowerful ( weight [ node ] ) ) ans += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } } int main ( ) { weight [ 1 ] = 5 ; weight [ 2 ] = 10 ; weight [ 3 ] = 11 ; weight [ 4 ] = 8 ; weight [ 5 ] = 6 ; graph [ 1 ] . push_back ( 2 ) ; graph [ 2 ] . push_back ( 3 ) ; graph [ 2 ] . push_back ( 4 ) ; graph [ 1 ] . push_back ( 5 ) ; dfs ( 1 , 1 ) ; cout << ans ; return 0 ; }", "docstring": "Count the nodes in the given tree whose weight is a powerful number | C ++ implementation to Count the nodes in the given tree whose weight is a powerful number ; Function to check if the number is powerful ; First divide the number repeatedly by 2 ; Check if only 2 ^ 1 divides n , then return false ; Check if n is not a power of 2 then this loop will execute ; Find highest power of \" factor \" that divides n ; Check if only factor ^ 1 divides n , then return false ; n must be 1 now if it is not a prime number . Since prime numbers are not powerful , we return false if n is not 1. ; Function to perform dfs ; Check if weight of the current node is a powerful number ; Driver code ; Weights of the node ; Edges of the tree", "dfg": [["factor", 85, "comesFrom", ["factor"], [81]], ["factor", 106, "comesFrom", ["factor"], [92]], ["factor", 115, "comesFrom", ["factor"], [92]], ["ans", 280, "comesFrom", ["ans"], [159]], ["n", 133, "comesFrom", ["n"], [111]], ["n", 39, "comesFrom", ["n"], [34]], ["n", 89, "comesFrom", ["n"], [60]], ["n", 53, "comesFrom", ["n"], [34]], ["n", 104, "comesFrom", ["n"], [60]], ["n", 113, "comesFrom", ["n"], [111]], ["node", 170, "comesFrom", ["node"], [143]], ["node", 186, "comesFrom", ["node"], [143]], ["node", 155, "comesFrom", ["node"], [143]], ["weight", 196, "comesFrom", ["weight"], [25]], ["weight", 203, "comesFrom", ["weight"], [25]], ["weight", 210, "comesFrom", ["weight"], [25]], ["weight", 217, "comesFrom", ["weight"], [25]], ["weight", 224, "comesFrom", ["weight"], [25]], ["weight", 153, "comesFrom", ["weight"], [25]], ["power", 70, "comesFrom", ["power"], [47]], ["power", 123, "comesFrom", ["power"], [98]], ["power", 64, "comesFrom", ["power"], [47]], ["power", 117, "comesFrom", ["power"], [98]], ["parent", 178, "comesFrom", ["parent"], [146]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountWays ( int N , int M ) { int count = 1 ; count = pow ( 3 , M + N ) ; count *= pow ( 2 , M * N ) ; return count ; } int main ( ) { int N = 3 ; int M = 2 ; cout << CountWays ( N , M ) ; return 0 ; }", "docstring": "Number of ways to color boundary of each block of M * N table | C ++ program to count the number of ways to color boundary of each block of M * N table . ; Function to compute all way to fill the boundary of all sides of the unit square ; Count possible ways to fill all upper and left side of the rectangle M * N ; Count possible ways to fill all side of the all squares unit size ; Driver code ; Number of rows ; Number of columns", "dfg": [["count", 45, "comesFrom", ["count"], [33]], ["N", 67, "comesFrom", ["N"], [54]], ["N", 30, "comesFrom", ["N"], [11]], ["N", 41, "comesFrom", ["N"], [11]], ["M", 69, "comesFrom", ["M"], [59]], ["M", 28, "comesFrom", ["M"], [14]], ["M", 39, "comesFrom", ["M"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNthNumber ( int N ) { long long arr [ N + 1 ] ; queue < long long > q ; for ( int i = 1 ; i <= 9 ; i ++ ) q . push ( i ) ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i ] = q . front ( ) ; q . pop ( ) ; if ( arr [ i ] % 10 != 0 ) q . push ( arr [ i ] * 10 + arr [ i ] % 10 - 1 ) ; q . push ( arr [ i ] * 10 + arr [ i ] % 10 ) ; if ( arr [ i ] % 10 != 9 ) q . push ( arr [ i ] * 10 + arr [ i ] % 10 + 1 ) ; } cout << arr [ N ] << endl ; } int main ( ) { int N = 21 ; findNthNumber ( N ) ; return 0 ; }", "docstring": "Nth positive number whose absolute difference of adjacent digits is at most 1 | C ++ Program to find Nth number with absolute difference between all adjacent digits at most 1. ; Return Nth number with absolute difference between all adjacent digits at most 1. ; To store all such numbers ; Enqueue all integers from 1 to 9 in increasing order . ; Perform the operation N times so that we can get all such N numbers . ; Store the front element of queue , in array and pop it from queue . ; If the last digit of dequeued integer is not 0 , then enqueue the next such number . ; Enqueue the next such number ; If the last digit of dequeued integer is not 9 , then enqueue the next such number . ; Driver Code", "dfg": [["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 58, "comesFrom", ["i"], [54]], ["i", 62, "comesFrom", ["i"], [54]], ["i", 48, "comesFrom", ["i"], [33]], ["i", 68, "comesFrom", ["i"], [54]], ["i", 87, "comesFrom", ["i"], [54]], ["i", 138, "comesFrom", ["i"], [54]], ["i", 121, "comesFrom", ["i"], [54]], ["i", 128, "comesFrom", ["i"], [54]], ["i", 100, "comesFrom", ["i"], [54]], ["i", 107, "comesFrom", ["i"], [54]], ["i", 151, "comesFrom", ["i"], [54]], ["i", 158, "comesFrom", ["i"], [54]], ["N", 60, "comesFrom", ["N"], [11]], ["N", 18, "comesFrom", ["N"], [11]], ["N", 189, "comesFrom", ["N"], [183]], ["N", 171, "comesFrom", ["N"], [11]], ["q", 44, "comesFrom", ["q"], [28]], ["q", 77, "comesFrom", ["q"], [28]], ["q", 115, "comesFrom", ["q"], [28]], ["q", 71, "comesFrom", ["q"], [28]], ["q", 94, "comesFrom", ["q"], [28]], ["q", 145, "comesFrom", ["q"], [28]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findUniqueElements ( int arr [ ] , int N , int K ) { unordered_set < int > s ( arr , arr + N ) ; int arr_sum = accumulate ( arr , arr + N , 0 ) ; int set_sum = accumulate ( s . begin ( ) , s . end ( ) , 0 ) ; cout << ( K * set_sum - arr_sum ) / ( K - 1 ) ; } int main ( ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; findUniqueElements ( arr , N , K ) ; return 0 ; }", "docstring": "Unique element in an array where all elements occur K times except one | Set 2 | C ++ program for the above approach ; Function that find the unique element in the array arr [ ] ; Store all unique element in set ; Sum of all element of the array ; Sum of element in the set ; Print the unique element using formula ; Driver Code ; Function call", "dfg": [["N", 149, "comesFrom", ["N"], [125]], ["N", 32, "comesFrom", ["N"], [16]], ["N", 44, "comesFrom", ["N"], [16]], ["K", 151, "comesFrom", ["K"], [141]], ["K", 80, "comesFrom", ["K"], [19]], ["K", 72, "comesFrom", ["K"], [19]], ["arr_sum", 76, "comesFrom", ["arr_sum"], [36]], ["s", 54, "comesFrom", ["s"], [26]], ["s", 60, "comesFrom", ["s"], [26]], ["set_sum", 74, "comesFrom", ["set_sum"], [50]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findEquation ( int a , int b , int c ) { int X = ( a + b + c ) ; int Y = ( a * b ) + ( b * c ) + ( c * a ) ; int Z = a * b * c ; cout << \" x ^ 3 ▁ - ▁ \" << X << \" x ^ 2 ▁ + ▁ \" << Y << \" x ▁ - ▁ \" << Z << \" ▁ = ▁ 0\" ; } int main ( ) { int a = 5 , b = 2 , c = 3 ; findEquation ( a , b , c ) ; return 0 ; }", "docstring": "Form the Cubic equation from the given roots | C ++ program for the approach ; Function to find the cubic equation whose roots are a , b and c ; Find the value of coefficient ; Print the equation as per the above coefficients ; Driver Code ; Function Call", "dfg": [["c", 59, "comesFrom", ["c"], [17]], ["c", 110, "comesFrom", ["c"], [100]], ["c", 28, "comesFrom", ["c"], [17]], ["c", 47, "comesFrom", ["c"], [17]], ["c", 43, "comesFrom", ["c"], [17]], ["Z", 79, "comesFrom", ["Z"], [53]], ["a", 106, "comesFrom", ["a"], [92]], ["a", 55, "comesFrom", ["a"], [11]], ["a", 24, "comesFrom", ["a"], [11]], ["a", 49, "comesFrom", ["a"], [11]], ["a", 35, "comesFrom", ["a"], [11]], ["b", 108, "comesFrom", ["b"], [96]], ["b", 57, "comesFrom", ["b"], [14]], ["b", 26, "comesFrom", ["b"], [14]], ["b", 37, "comesFrom", ["b"], [14]], ["b", 41, "comesFrom", ["b"], [14]], ["Y", 73, "comesFrom", ["Y"], [32]], ["X", 67, "comesFrom", ["X"], [21]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float dydx ( float x , float y ) { return ( x - y ) / 2 ; } float Gill ( float x0 , float y0 , float x , float h ) { int n = ( int ) ( ( x - x0 ) / h ) ; float k1 , k2 , k3 , k4 ; float y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; k3 = h * dydx ( x0 + 0.5 * h , y + 0.5 * ( -1 + sqrt ( 2 ) ) * k1 + k2 * ( 1 - 0.5 * sqrt ( 2 ) ) ) ; k4 = h * dydx ( x0 + h , y - ( 0.5 * sqrt ( 2 ) ) * k2 + k3 * ( 1 + 0.5 * sqrt ( 2 ) ) ) ; y = y + ( 1.0 / 6 ) * ( k1 + ( 2 - sqrt ( 2 ) ) * k2 + ( 2 + sqrt ( 2 ) ) * k3 + k4 ) ; x0 = x0 + h ; } return y ; } int main ( ) { float x0 = 0 , y = 3.0 , x = 5.0 , h = 0.2 ; printf ( \" y ( x ) ▁ = ▁ % .6f \" , Gill ( x0 , y , x , h ) ) ; return 0 ; }", "docstring": "Gill 's 4th Order Method to solve Differential Equations | C ++ program to implement Gill 's method ; A sample differential equation \" dy / dx ▁ = ▁ ( x ▁ - ▁ y ) /2\" ; Finds value of y for a given x using step size h and initial value y0 at x0 ; Count number of iterations using step size or height h ; Value of K_i ; Initial value of y ( 0 ) ; Iterate for number of iteration ; Value of K1 ; Value of K2 ; Value of K3 ; Value of K4 ; Find the next value of y ( n + 1 ) using y ( n ) and values of K in the above steps ; Update next value of x ; Return the final value of dy / dx ; Driver Code", "dfg": [["y", 242, "comesFrom", ["y"], [196]], ["y", 21, "comesFrom", ["y"], [14]], ["y", 198, "comesFrom", ["y"], [196]], ["y", 277, "comesFrom", ["y"], [255]], ["y", 96, "comesFrom", ["y"], [69]], ["y", 111, "comesFrom", ["y"], [69]], ["y", 130, "comesFrom", ["y"], [69]], ["y", 169, "comesFrom", ["y"], [69]], ["i", 80, "comesFrom", ["i"], [76]], ["i", 84, "comesFrom", ["i"], [76]], ["n", 82, "comesFrom", ["n"], [44]], ["x", 19, "comesFrom", ["x"], [11]], ["x", 279, "comesFrom", ["x"], [259]], ["x", 51, "comesFrom", ["x"], [37]], ["h", 56, "comesFrom", ["h"], [40]], ["h", 90, "comesFrom", ["h"], [40]], ["h", 101, "comesFrom", ["h"], [40]], ["h", 120, "comesFrom", ["h"], [40]], ["h", 161, "comesFrom", ["h"], [40]], ["h", 238, "comesFrom", ["h"], [40]], ["h", 281, "comesFrom", ["h"], [263]], ["h", 167, "comesFrom", ["h"], [40]], ["h", 109, "comesFrom", ["h"], [40]], ["h", 128, "comesFrom", ["h"], [40]], ["x0", 236, "comesFrom", ["x0"], [234]], ["x0", 275, "comesFrom", ["x0"], [251]], ["x0", 53, "comesFrom", ["x0"], [31]], ["x0", 94, "comesFrom", ["x0"], [31]], ["x0", 105, "comesFrom", ["x0"], [31]], ["x0", 124, "comesFrom", ["x0"], [31]], ["x0", 165, "comesFrom", ["x0"], [31]], ["k4", 231, "comesFrom", ["k4"], [159]], ["k1", 115, "comesFrom", ["k1"], [88]], ["k1", 143, "comesFrom", ["k1"], [88]], ["k1", 207, "comesFrom", ["k1"], [88]], ["k2", 145, "comesFrom", ["k2"], [99]], ["k2", 180, "comesFrom", ["k2"], [99]], ["k2", 218, "comesFrom", ["k2"], [99]], ["k3", 182, "comesFrom", ["k3"], [118]], ["k3", 229, "comesFrom", ["k3"], [118]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) cout << i << \" ▁ \" ; } int main ( ) { int N = 5 ; PrintReverseOrder ( N ) ; return 0 ; }", "docstring": "Program to print numbers from N to 1 in reverse order | C ++ program to print all numbers between 1 to N in reverse order ; Recursive function to print from N to 1 ; Driven Code", "dfg": [["i", 21, "comesFrom", ["i"], [17]], ["i", 25, "comesFrom", ["i"], [17]], ["i", 30, "comesFrom", ["i"], [17]], ["N", 49, "comesFrom", ["N"], [43]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findAns ( int a , int b , int n ) { int lcm = ( a * b ) / __gcd ( a , b ) ; int multiples = ( n / lcm ) + 1 ; int answer = max ( a , b ) * multiples ; int lastvalue = lcm * ( n / lcm ) + max ( a , b ) ; if ( lastvalue > n ) answer = answer - ( lastvalue - n - 1 ) ; return answer ; } int main ( ) { int a = 1 , b = 13 , n = 500 ; cout << findAns ( a , b , n ) << endl ; }", "docstring": "Find count of numbers from 0 to n which satisfies the given equation for a value K | C ++ implementation to Find the total count of all the numbers from 0 to n which satisfies the given equation for a value K ; Function to find the values ; Calculate the LCM ; Calculate the multiples of lcm ; Find the values which satisfies the given condition ; Subtract the extra values ; Return the final result ; Driver code", "dfg": [["answer", 96, "comesFrom", ["answer"], [83]], ["answer", 85, "comesFrom", ["answer"], [83]], ["multiples", 57, "comesFrom", ["multiples"], [37]], ["lastvalue", 79, "comesFrom", ["lastvalue"], [60]], ["lastvalue", 88, "comesFrom", ["lastvalue"], [60]], ["n", 81, "comesFrom", ["n"], [17]], ["n", 40, "comesFrom", ["n"], [17]], ["n", 125, "comesFrom", ["n"], [113]], ["n", 65, "comesFrom", ["n"], [17]], ["n", 90, "comesFrom", ["n"], [17]], ["lcm", 62, "comesFrom", ["lcm"], [21]], ["lcm", 42, "comesFrom", ["lcm"], [21]], ["lcm", 67, "comesFrom", ["lcm"], [21]], ["a", 24, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]], ["a", 52, "comesFrom", ["a"], [11]], ["a", 72, "comesFrom", ["a"], [11]], ["a", 121, "comesFrom", ["a"], [105]], ["b", 26, "comesFrom", ["b"], [14]], ["b", 33, "comesFrom", ["b"], [14]], ["b", 54, "comesFrom", ["b"], [14]], ["b", 74, "comesFrom", ["b"], [14]], ["b", 123, "comesFrom", ["b"], [109]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float ArithmeticMean ( float A , float B ) { return ( A + B ) / 2 ; } float HarmonicMean ( float A , float B ) { return ( 2 * A * B ) / ( A + B ) ; } void CheckArithmeticHarmonic ( float arr [ ] , float A , float B , int N ) { float AM = ArithmeticMean ( A , B ) ; float HM = HarmonicMean ( A , B ) ; unordered_set < float > Hash ; for ( int i = 0 ; i < N ; i ++ ) { Hash . insert ( arr [ i ] ) ; } if ( Hash . find ( A ) != Hash . end ( ) && Hash . find ( B ) != Hash . end ( ) ) { if ( Hash . find ( AM ) != Hash . end ( ) && Hash . find ( HM ) != Hash . end ( ) ) { cout << \" GM ▁ = ▁ \" ; printf ( \" % 0.2f \" , sqrt ( AM * HM ) ) ; } else { cout << \" AM ▁ and ▁ HM ▁ not ▁ found \" ; } } else { cout << \" Numbers ▁ not ▁ found \" ; } } int main ( ) { float arr [ ] = { 1.0 , 2.0 , 2.5 , 3.0 , 4.0 , 4.5 , 5.0 , 6.0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; float A = 3.0 ; float B = 6.0 ; CheckArithmeticHarmonic ( arr , A , B , N ) ; return 0 ; }", "docstring": "Program to find if two numbers and their AM and HM are present in an array using STL | C ++ program to check if two numbers are present in an array then their AM and HM are also present . Finally , find the GM of the numbers ; Function to find the Arithmetic Mean of 2 numbers ; Function to find the Harmonic Mean of 2 numbers ; Following function checks and computes the desired results based on the means ; Calculate means ; Hash container ( Set ) to store elements ; Insertion of array elements in the Set ; Conditionals to check if numbers are present in array by Hashing ; Conditionals to check if the AM and HM of the numbers are present in array ; If all conditions are satisfied , the Geometric Mean is calculated ; If numbers are found but the respective AM and HM are not found in the array ; If none of the conditions are satisfied ; Driver code", "dfg": [["i", 104, "comesFrom", ["i"], [100]], ["i", 108, "comesFrom", ["i"], [100]], ["i", 118, "comesFrom", ["i"], [100]], ["N", 106, "comesFrom", ["N"], [68]], ["N", 284, "comesFrom", ["N"], [251]], ["A", 280, "comesFrom", ["A"], [267]], ["A", 19, "comesFrom", ["A"], [11]], ["A", 47, "comesFrom", ["A"], [31]], ["A", 76, "comesFrom", ["A"], [62]], ["A", 86, "comesFrom", ["A"], [62]], ["A", 41, "comesFrom", ["A"], [31]], ["A", 129, "comesFrom", ["A"], [62]], ["B", 282, "comesFrom", ["B"], [272]], ["B", 21, "comesFrom", ["B"], [14]], ["B", 43, "comesFrom", ["B"], [34]], ["B", 49, "comesFrom", ["B"], [34]], ["B", 78, "comesFrom", ["B"], [65]], ["B", 88, "comesFrom", ["B"], [65]], ["B", 142, "comesFrom", ["B"], [65]], ["Hash", 112, "comesFrom", ["Hash"], [95]], ["Hash", 125, "comesFrom", ["Hash"], [95]], ["Hash", 132, "comesFrom", ["Hash"], [95]], ["Hash", 138, "comesFrom", ["Hash"], [95]], ["Hash", 145, "comesFrom", ["Hash"], [95]], ["Hash", 154, "comesFrom", ["Hash"], [95]], ["Hash", 161, "comesFrom", ["Hash"], [95]], ["Hash", 167, "comesFrom", ["Hash"], [95]], ["Hash", 174, "comesFrom", ["Hash"], [95]], ["AM", 158, "comesFrom", ["AM"], [72]], ["AM", 195, "comesFrom", ["AM"], [72]], ["HM", 171, "comesFrom", ["HM"], [82]], ["HM", 197, "comesFrom", ["HM"], [82]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void movesRequired ( int a , int b ) { int total_moves = a % b ; cout << total_moves << \" STRNEWLINE \" ; } int main ( ) { int A = 10 , B = 3 ; movesRequired ( A , B ) ; return 0 ; }", "docstring": "Minimum decrements to make integer A divisible by integer B | C ++ implementation to count Total numbers moves to make integer A divisible by integer B ; Function that print number of moves required ; calculate modulo ; print the required answer ; Driver Code ; initialise A and B", "dfg": [["a", 20, "comesFrom", ["a"], [11]], ["b", 22, "comesFrom", ["b"], [14]], ["total_moves", 26, "comesFrom", ["total_moves"], [18]], ["A", 49, "comesFrom", ["A"], [39]], ["B", 51, "comesFrom", ["B"], [43]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void PythagoreanTriplet ( int n ) { int flag = 0 ; for ( int a = 1 ; a < n ; a ++ ) { int b = ( n * n - 2 * n * a ) / ( 2 * n - 2 * a ) ; int c = n - a - b ; if ( a * a + b * b == c * c && b > 0 && c > 0 ) { cout << a << \" ▁ \" << b << \" ▁ \" << c ; flag = 1 ; break ; } } if ( flag == 0 ) { cout << \" - 1\" ; } return ; } int main ( ) { int N = 12 ; PythagoreanTriplet ( N ) ; return 0 ; }", "docstring": "Pythagorean Triplet with given sum using single loop | C ++ program to find the Pythagorean Triplet with given sum ; Function to calculate the Pythagorean triplet in O ( n ) ; Iterate a from 1 to N - 1. ; Calculate value of b ; The value of c = n - a - b ; Driver Code ; Function call", "dfg": [["a", 26, "comesFrom", ["a"], [22]], ["a", 30, "comesFrom", ["a"], [22]], ["a", 64, "comesFrom", ["a"], [22]], ["a", 46, "comesFrom", ["a"], [22]], ["a", 56, "comesFrom", ["a"], [22]], ["a", 70, "comesFrom", ["a"], [22]], ["a", 72, "comesFrom", ["a"], [22]], ["a", 93, "comesFrom", ["a"], [22]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 62, "comesFrom", ["n"], [11]], ["n", 38, "comesFrom", ["n"], [11]], ["n", 40, "comesFrom", ["n"], [11]], ["n", 52, "comesFrom", ["n"], [11]], ["n", 44, "comesFrom", ["n"], [11]], ["flag", 117, "comesFrom", ["flag"], [107]], ["N", 144, "comesFrom", ["N"], [138]], ["b", 66, "comesFrom", ["b"], [35]], ["b", 82, "comesFrom", ["b"], [35]], ["b", 99, "comesFrom", ["b"], [35]], ["b", 74, "comesFrom", ["b"], [35]], ["b", 76, "comesFrom", ["b"], [35]], ["c", 86, "comesFrom", ["c"], [60]], ["c", 105, "comesFrom", ["c"], [60]], ["c", 78, "comesFrom", ["c"], [60]], ["c", 80, "comesFrom", ["c"], [60]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int X , int K ) { int prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = sqrt ( X ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = temp / i ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; } int main ( ) { int X , K ; X = 4 ; K = 2 ; if ( check ( X , K ) ) cout << \" Yes \" ; else cout << \" No \" ; }", "docstring": "Check if there exists a number with X factors out of which exactly K are prime | C ++ program to check if there exists a number with X factors out of which exactly K are prime ; Function to check if such number exists ; To store the sum of powers of prime factors of X which determines the maximum count of numbers whose product can form X ; Determining the prime factors of X ; To check if the number is prime ; If X is 1 , then we cannot form a number with 1 factor and K prime factor ( as K is atleast 1 ) ; If X itself is prime then it can be represented as a power of only 1 prime factor which is X itself so we return true ; If sum of the powers of prime factors of X is greater than or equal to K , which means X can be represented as a product of K numbers , we return true ; In any other case , we return false as we cannot form a number with X factors and K prime factors ; Driver code", "dfg": [["X", 32, "comesFrom", ["X"], [11]], ["X", 86, "comesFrom", ["X"], [11]], ["X", 38, "comesFrom", ["X"], [11]], ["X", 143, "comesFrom", ["X"], [131]], ["i", 47, "comesFrom", ["i"], [43]], ["i", 51, "comesFrom", ["i"], [43]], ["i", 59, "comesFrom", ["i"], [43]], ["i", 68, "comesFrom", ["i"], [43]], ["sqr", 49, "comesFrom", ["sqr"], [34]], ["temp", 77, "comesFrom", ["temp"], [64]], ["temp", 57, "comesFrom", ["temp"], [30]], ["temp", 66, "comesFrom", ["temp"], [64]], ["prime", 81, "comesFrom", ["prime"], [26]], ["prime", 95, "comesFrom", ["prime"], [26]], ["prime", 109, "comesFrom", ["prime"], [26]], ["prime", 70, "comesFrom", ["prime"], [26]], ["K", 99, "comesFrom", ["K"], [14]], ["K", 145, "comesFrom", ["K"], [135]], ["K", 111, "comesFrom", ["K"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int N = 1000000 ; vector < int > prime ; void SieveOfEratosthenes ( ) { bool check [ N + 1 ] ; memset ( check , true , sizeof ( check ) ) ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . push_back ( p ) ; for ( int i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } } bool isPathCo_Prime ( vector < int > & path ) { int max = 0 ; for ( auto x : path ) { if ( max < x ) max = x ; } for ( int i = 0 ; i * prime [ i ] <= max / 2 ; i ++ ) { int ct = 0 ; for ( auto x : path ) { if ( x % prime [ i ] == 0 ) ct ++ ; } if ( ct > 1 ) { return false ; } } return true ; } void printCo_PrimePaths ( vector < int > & path ) { for ( auto x : path ) { cout << x << \" ▁ \" ; } cout << endl ; } void findCo_PrimePaths ( struct Node * root , vector < int > & path ) { if ( root == NULL ) return ; path . push_back ( root -> key ) ; findCo_PrimePaths ( root -> left , path ) ; findCo_PrimePaths ( root -> right , path ) ; if ( root -> left == NULL && root -> right == NULL ) { if ( isPathCo_Prime ( path ) ) { printCo_PrimePaths ( path ) ; } } path . pop_back ( ) ; } void printCo_PrimePaths ( struct Node * node ) { SieveOfEratosthenes ( ) ; vector < int > path ; findCo_PrimePaths ( node , path ) ; } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 48 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 11 ) ; root -> right -> right = newNode ( 37 ) ; root -> right -> left -> left = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 29 ) ; root -> right -> right -> left = newNode ( 42 ) ; root -> right -> right -> right = newNode ( 19 ) ; root -> right -> right -> right -> left = newNode ( 7 ) ; printCo_PrimePaths ( root ) ; return 0 ; }", "docstring": "Print all Coprime path of a Binary Tree | C ++ program for printing Co - prime paths of binary Tree ; A Tree node ; Utility function to create a new node ; Vector to store all the prime numbers ; Function to store all the prime numbers in an array ; Create a boolean array \" prime [ 0 . . N ] \" and initialize all the entries in it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiples of p and are less than p ^ 2 are already marked . ; Function to check whether Path is Co - prime or not ; Iterating through the array to find the maximum element in the array ; Incrementing the variable if any of the value has a factor ; If not co - prime ; Function to print a Co - Prime path ; Function to find co - prime paths of binary tree ; Base case ; Store the value in path vector ; Recursively call for left sub tree ; Recursively call for right sub tree ; Condition to check , if leaf node ; Condition to check , if path co - prime or not ; Print co - prime path ; Remove the last element from the path vector ; Function to find Co - Prime paths In a given binary tree ; To save all prime numbers ; Function call ; Driver Code ; Create Binary Tree as shown ; Print Co - Prime Paths", "dfg": [["key", 42, "comesFrom", ["key"], [28]], ["key", 40, "comesFrom", ["key"], [28]], ["key", 321, "comesFrom", ["key"], [28]], ["path", 402, "comesFrom", ["path"], [396]], ["N", 107, "comesFrom", ["N"], [61]], ["N", 79, "comesFrom", ["N"], [61]], ["N", 141, "comesFrom", ["N"], [61]], ["p", 109, "comesFrom", ["p"], [99]], ["p", 103, "comesFrom", ["p"], [99]], ["p", 105, "comesFrom", ["p"], [99]], ["p", 145, "comesFrom", ["p"], [99]], ["p", 117, "comesFrom", ["p"], [99]], ["p", 127, "comesFrom", ["p"], [99]], ["p", 135, "comesFrom", ["p"], [99]], ["p", 137, "comesFrom", ["p"], [99]], ["i", 210, "comesFrom", ["i"], [195]], ["i", 199, "comesFrom", ["i"], [195]], ["i", 203, "comesFrom", ["i"], [195]], ["i", 139, "comesFrom", ["i"], [133]], ["i", 149, "comesFrom", ["i"], [143]], ["i", 233, "comesFrom", ["i"], [195]], ["max", 206, "comesFrom", ["max"], [187]], ["max", 183, "comesFrom", ["max"], [169]], ["prime", 201, "comesFrom", ["prime"], [69]], ["prime", 123, "comesFrom", ["prime"], [69]], ["prime", 231, "comesFrom", ["prime"], [69]], ["ct", 244, "comesFrom", ["ct"], [215]], ["ct", 238, "comesFrom", ["ct"], [215]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int countSubsets ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = -1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) { if ( bitwiseAND == -1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; } int main ( ) { int N = 6 ; int A [ N ] = { 1 , 3 , 2 , 1 , 2 , 1 } ; cout << countSubsets ( A , N ) ; return 0 ; }", "docstring": "Number of subsets with same AND , OR and XOR values in an Array | C ++ implementation to find the number of subsets with equal bitwise AND , OR and XOR values ; Function to find the number of subsets with equal bitwise AND , OR and XOR values ; Traverse through all the subsets ; Finding the subsets with the bits of ' i ' which are set ; Computing the bitwise AND ; Computing the bitwise OR ; Computing the bitwise XOR ; Comparing all the three values ; Driver code", "dfg": [["answer", 149, "comesFrom", ["answer"], [137]], ["answer", 140, "comesFrom", ["answer"], [137]], ["i", 37, "comesFrom", ["i"], [33]], ["i", 45, "comesFrom", ["i"], [33]], ["i", 81, "comesFrom", ["i"], [33]], ["N", 165, "comesFrom", ["N"], [158]], ["N", 188, "comesFrom", ["N"], [158]], ["n", 42, "comesFrom", ["n"], [22]], ["n", 73, "comesFrom", ["n"], [22]], ["j", 71, "comesFrom", ["j"], [67]], ["j", 75, "comesFrom", ["j"], [67]], ["j", 86, "comesFrom", ["j"], [67]], ["j", 115, "comesFrom", ["j"], [67]], ["j", 122, "comesFrom", ["j"], [67]], ["j", 100, "comesFrom", ["j"], [67]], ["j", 108, "comesFrom", ["j"], [67]], ["bitwiseAND", 129, "comesFrom", ["bitwiseAND"], [104]], ["bitwiseAND", 92, "comesFrom", ["bitwiseAND"], [50]], ["bitwiseOR", 131, "comesFrom", ["bitwiseOR"], [111]], ["bitwiseOR", 133, "comesFrom", ["bitwiseOR"], [111]], ["bitwiseXOR", 135, "comesFrom", ["bitwiseXOR"], [118]], ["mod", 145, "comesFrom", ["mod"], [9]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int count ( int arr [ ] , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 1 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 0 ; cout << count ( arr , N , K ) ; }", "docstring": "Count of Subsets containing only the given value K | C ++ implementation to find the number of subsets formed by the given value K ; Function to find the number of subsets formed by the given value K ; Count is used to maintain the number of continuous K 's ; Iterating through the array ; If the element in the array is equal to K ; count * ( count + 1 ) / 2 is the total number of subsets with only K as their element ; Change count to 0 because other element apart from K has been found ; To handle the last set of K 's ; Driver code", "dfg": [["count", 151, "comesFrom", ["count"], [79]], ["count", 90, "comesFrom", ["count"], [79]], ["count", 58, "comesFrom", ["count"], [56]], ["count", 93, "comesFrom", ["count"], [79]], ["count", 68, "comesFrom", ["count"], [56]], ["count", 71, "comesFrom", ["count"], [56]], ["ans", 102, "comesFrom", ["ans"], [85]], ["ans", 87, "comesFrom", ["ans"], [85]], ["i", 38, "comesFrom", ["i"], [34]], ["i", 42, "comesFrom", ["i"], [34]], ["i", 50, "comesFrom", ["i"], [34]], ["N", 40, "comesFrom", ["N"], [16]], ["N", 155, "comesFrom", ["N"], [132]], ["K", 157, "comesFrom", ["K"], [145]], ["K", 53, "comesFrom", ["K"], [19]]]}
{"code": "#include <cstdio> NEW_LINE #include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void convertToTernary ( int N ) { if ( N == 0 ) return ; int x = N % 3 ; N /= 3 ; if ( x < 0 ) N += 1 ; convertToTernary ( N ) ; if ( x < 0 ) cout << x + ( 3 * -1 ) ; else cout << x ; } void convert ( int Decimal ) { cout << \" Ternary ▁ number ▁ of ▁ \" << Decimal << \" ▁ is : ▁ \" ; if ( Decimal != 0 ) { convertToTernary ( Decimal ) ; } else cout << \"0\" << endl ; } int main ( ) { int Decimal = 2747 ; convert ( Decimal ) ; return 0 ; }", "docstring": "Ternary number system or Base 3 numbers | C ++ program to convert decimal number to ternary number ; Function to convert a decimal number to a ternary number ; Base case ; Finding the remainder when N is divided by 3 ; Recursive function to call the function for the integer division of the value N / 3 ; Handling the negative cases ; Function to convert the decimal to ternary ; If the number is greater than 0 , compute the ternary representation of the number ; Driver code", "dfg": [["N", 22, "comesFrom", ["N"], [17]], ["N", 31, "comesFrom", ["N"], [17]], ["N", 51, "comesFrom", ["N"], [45]], ["x", 41, "comesFrom", ["x"], [29]], ["x", 56, "comesFrom", ["x"], [29]], ["x", 62, "comesFrom", ["x"], [29]], ["x", 73, "comesFrom", ["x"], [29]], ["Decimal", 89, "comesFrom", ["Decimal"], [80]], ["Decimal", 97, "comesFrom", ["Decimal"], [80]], ["Decimal", 130, "comesFrom", ["Decimal"], [124]], ["Decimal", 104, "comesFrom", ["Decimal"], [80]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int get ( int x , int y , int z ) { if ( x > z ) return -1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; } int main ( ) { int x = 1 , y = 5 , z = 8 ; cout << get ( x , y , z ) << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Largest number less than or equal to Z that leaves a remainder X when divided by Y | C ++ implementation to Find the largest non - negative number that is less than or equal to integer Z and leaves a remainder X when divided by Y ; Function to get the number ; remainder can ' t ▁ be ▁ larger ▁ ▁ than ▁ the ▁ largest ▁ number , ▁ ▁ if ▁ so ▁ then ▁ answer ▁ doesn ' t exist . ; reduce number by x ; finding the possible number that is divisible by y ; this number is always <= x as we calculated over z - x ; Driver Code ; initialise the three integers", "dfg": [["ans", 57, "comesFrom", ["ans"], [48]], ["x", 22, "comesFrom", ["x"], [11]], ["x", 34, "comesFrom", ["x"], [11]], ["x", 54, "comesFrom", ["x"], [11]], ["x", 42, "comesFrom", ["x"], [11]], ["x", 82, "comesFrom", ["x"], [66]], ["z", 24, "comesFrom", ["z"], [17]], ["z", 32, "comesFrom", ["z"], [17]], ["z", 40, "comesFrom", ["z"], [17]], ["z", 86, "comesFrom", ["z"], [74]], ["y", 45, "comesFrom", ["y"], [14]], ["y", 52, "comesFrom", ["y"], [14]], ["y", 84, "comesFrom", ["y"], [70]], ["div", 50, "comesFrom", ["div"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string s ) { string z = s ; int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; replace ( s . begin ( ) , s . end ( ) , ' + ' , ' - ' ) ; } else { i = s . find ( ' - ' ) ; replace ( s . begin ( ) , s . end ( ) , ' - ' , ' + ' ) ; } cout << \" Conjugate ▁ of ▁ \" << z << \" ▁ = ▁ \" << s << endl ; } int main ( ) { string s = \"3-4i \" ; solve ( s ) ; return 0 ; }", "docstring": "Find the conjugate of a Complex number | C ++ implementation to Find the conjugate of a complex number ; Function to find conjugate of a complex number ; store index of ' + ' ; store index of ' - ' ; print the result ; Driver code ; initialise the complex number", "dfg": [["l", 44, "comesFrom", ["l"], [20]], ["s", 143, "comesFrom", ["s"], [17]], ["s", 162, "comesFrom", ["s"], [154]], ["s", 22, "comesFrom", ["s"], [17]], ["s", 33, "comesFrom", ["s"], [17]], ["s", 49, "comesFrom", ["s"], [17]], ["s", 62, "comesFrom", ["s"], [17]], ["s", 68, "comesFrom", ["s"], [17]], ["s", 92, "comesFrom", ["s"], [17]], ["s", 105, "comesFrom", ["s"], [17]], ["s", 111, "comesFrom", ["s"], [17]], ["z", 137, "comesFrom", ["z"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countOfGreaterElements ( int arr [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; } int x = 0 ; for ( auto it = mp . rbegin ( ) ; it != mp . rend ( ) ; it ++ ) { int temp = it -> second ; mp [ it -> first ] = x ; x += temp ; } for ( int i = 0 ; i < n ; i ++ ) cout << mp [ arr [ i ] ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 7 , 9 , 5 , 2 , 1 , 3 , 4 , 8 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countOfGreaterElements ( arr , n ) ; return 0 ; }", "docstring": "Count of greater elements for each element in the Array | C ++ implementation of the above approach ; Store the frequency of the array elements ; Store the sum of frequency of elements greater than the current element ; Driver code", "dfg": [["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 108, "comesFrom", ["i"], [104]], ["i", 112, "comesFrom", ["i"], [104]], ["i", 46, "comesFrom", ["i"], [30]], ["i", 121, "comesFrom", ["i"], [104]], ["n", 36, "comesFrom", ["n"], [16]], ["n", 110, "comesFrom", ["n"], [16]], ["n", 180, "comesFrom", ["n"], [161]], ["it", 68, "comesFrom", ["it"], [60]], ["it", 76, "comesFrom", ["it"], [60]], ["it", 83, "comesFrom", ["it"], [60]], ["it", 89, "comesFrom", ["it"], [60]], ["mp", 70, "comesFrom", ["mp"], [25]], ["mp", 42, "comesFrom", ["mp"], [25]], ["mp", 62, "comesFrom", ["mp"], [25]], ["mp", 87, "comesFrom", ["mp"], [25]], ["mp", 117, "comesFrom", ["mp"], [25]], ["x", 94, "comesFrom", ["x"], [53]], ["temp", 98, "comesFrom", ["temp"], [81]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int minOperations ( long long int A , long long int B ) { if ( A > B ) swap ( A , B ) ; B = B / __gcd ( A , B ) ; return B - 1 ; } int main ( ) { long long int A = 7 , B = 15 ; cout << minOperations ( A , B ) << endl ; return 0 ; }", "docstring": "Minimum operations required to make two numbers equal | C ++ program to find minimum operations required to make two numbers equal ; Function to return the minimum operations required ; Keeping B always greater ; Reduce B such that gcd ( A , B ) becomes 1. ; Driver code", "dfg": [["B", 48, "comesFrom", ["B"], [36]], ["B", 27, "comesFrom", ["B"], [20]], ["B", 38, "comesFrom", ["B"], [36]], ["B", 33, "comesFrom", ["B"], [20]], ["B", 44, "comesFrom", ["B"], [36]], ["B", 75, "comesFrom", ["B"], [65]], ["A", 25, "comesFrom", ["A"], [15]], ["A", 31, "comesFrom", ["A"], [15]], ["A", 42, "comesFrom", ["A"], [15]], ["A", 73, "comesFrom", ["A"], [61]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void quadrant ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - 1 ) ; int x = stoi ( real ) ; int y = stoi ( imaginary ) ; if ( x > 0 and y > 0 ) cout << \" Quadrant ▁ 1\" ; else if ( x < 0 and y > 0 ) cout << \" Quadrant ▁ 2\" ; else if ( x < 0 and y < 0 ) cout << \" Quadrant ▁ 3\" ; else if ( x > 0 and y < 0 ) cout << \" Quadrant ▁ 4\" ; else if ( x == 0 and y > 0 ) cout << \" Lies ▁ on ▁ positive \" << \" ▁ Imaginary ▁ axis \" ; else if ( x == 0 and y < 0 ) cout << \" Lies ▁ on ▁ negative \" << \" ▁ Imaginary ▁ axis \" ; else if ( y == 0 and x < 0 ) cout << \" Lies ▁ on ▁ negative \" << \" ▁ X - axis \" ; else if ( y == 0 and x > 0 ) cout << \" Lies ▁ on ▁ positive \" << \" ▁ X - axis \" ; else cout << \" Lies ▁ on ▁ the ▁ Origin \" ; } int main ( ) { string s = \"5 + 3i \" ; quadrant ( s ) ; return 0 ; }", "docstring": "Program to determine the Quadrant of a Complex number | C ++ program to determine the quadrant of a complex number ; Function to determine the quadrant of a complex number ; Storing the index of ' + ' ; Storing the index of ' - ' ; Finding the real part of the complex number ; Finding the imaginary part of the complex number ; Driver code", "dfg": [["l", 39, "comesFrom", ["l"], [15]], ["l", 95, "comesFrom", ["l"], [15]], ["s", 289, "comesFrom", ["s"], [281]], ["s", 17, "comesFrom", ["s"], [11]], ["s", 75, "comesFrom", ["s"], [11]], ["s", 87, "comesFrom", ["s"], [11]], ["s", 28, "comesFrom", ["s"], [11]], ["s", 44, "comesFrom", ["s"], [11]], ["s", 60, "comesFrom", ["s"], [11]], ["i", 81, "comesFrom", ["i"], [58]], ["i", 91, "comesFrom", ["i"], [58]], ["real", 105, "comesFrom", ["real"], [73]], ["imaginary", 113, "comesFrom", ["imaginary"], [85]], ["x", 118, "comesFrom", ["x"], [101]], ["x", 135, "comesFrom", ["x"], [101]], ["x", 152, "comesFrom", ["x"], [101]], ["x", 169, "comesFrom", ["x"], [101]], ["x", 186, "comesFrom", ["x"], [101]], ["x", 207, "comesFrom", ["x"], [101]], ["x", 232, "comesFrom", ["x"], [101]], ["x", 253, "comesFrom", ["x"], [101]], ["y", 122, "comesFrom", ["y"], [109]], ["y", 139, "comesFrom", ["y"], [109]], ["y", 156, "comesFrom", ["y"], [109]], ["y", 173, "comesFrom", ["y"], [109]], ["y", 190, "comesFrom", ["y"], [109]], ["y", 211, "comesFrom", ["y"], [109]], ["y", 228, "comesFrom", ["y"], [109]], ["y", 249, "comesFrom", ["y"], [109]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; void push ( Node * * head_ref , int new_data ) { Node * new_node = ( Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int largestElement ( struct Node * head_ref ) { int max = INT_MIN ; Node * head = head_ref ; while ( head != NULL ) { if ( max < head -> data ) max = head -> data ; head = head -> next ; } return max ; } void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } void sumAndProduct ( Node * head_ref ) { int maxEle = largestElement ( head_ref ) ; set < int > hash ; createHash ( hash , maxEle ) ; int prod = 1 ; int sum = 0 ; Node * ptr = head_ref ; while ( ptr != NULL ) { if ( hash . find ( ptr -> data ) != hash . end ( ) ) { prod *= ptr -> data ; sum += ptr -> data ; } ptr = ptr -> next ; } cout << \" Sum ▁ = ▁ \" << sum << endl ; cout << \" Product ▁ = ▁ \" << prod ; } int main ( ) { Node * head = NULL ; push ( & head , 13 ) ; push ( & head , 6 ) ; push ( & head , 8 ) ; push ( & head , 16 ) ; push ( & head , 15 ) ; sumAndProduct ( head ) ; return 0 ; }", "docstring": "Sum and Product of all Fibonacci Nodes of a Singly Linked List | C ++ implementation to find the sum and product of all of the Fibonacci nodes in a singly linked list ; Node of the singly linked list ; Function to insert a node at the beginning of the singly Linked List ; Allocate new node ; Insert the data ; Link the old list to the new node ; Move the head to point the new node ; Function that returns the largest element from the linked list . ; Declare a max variable and initialize with INT_MIN ; Check loop while head not equal to NULL ; If max is less then head -> data then assign value of head -> data to max otherwise node points to next node . ; Function to create a hash table to check Fibonacci numbers ; Inserting the first two numbers in the hash ; Loop to add Fibonacci numbers upto the maximum element present in the linked list ; Function to find the required sum and product ; Find the largest node value in Singly Linked List ; Creating a set containing all the fibonacci numbers upto the maximum data value in the Singly Linked List ; Traverse the linked list ; If current node is fibonacci ; Find the sum and the product ; Driver code ; Create the linked list 15 -> 16 -> 8 -> 6 -> 13", "dfg": [["max", 120, "comesFrom", ["max"], [106]], ["max", 100, "comesFrom", ["max"], [81]], ["new_data", 52, "comesFrom", ["new_data"], [28]], ["prod", 297, "comesFrom", ["prod"], [261]], ["head_ref", 196, "comesFrom", ["head_ref"], [89]], ["head_ref", 204, "comesFrom", ["head_ref"], [89]], ["head", 307, "comesFrom", ["head"], [112]], ["head", 353, "comesFrom", ["head"], [112]], ["head", 314, "comesFrom", ["head"], [112]], ["head", 322, "comesFrom", ["head"], [112]], ["head", 330, "comesFrom", ["head"], [112]], ["head", 338, "comesFrom", ["head"], [112]], ["head", 346, "comesFrom", ["head"], [112]], ["head", 114, "comesFrom", ["head"], [112]], ["hash", 215, "comesFrom", ["hash"], [211]], ["hash", 245, "comesFrom", ["hash"], [211]], ["hash", 254, "comesFrom", ["hash"], [211]], ["prev", 150, "comesFrom", ["prev"], [138]], ["prev", 172, "comesFrom", ["prev"], [138]], ["curr", 157, "comesFrom", ["curr"], [142]], ["curr", 162, "comesFrom", ["curr"], [142]], ["curr", 183, "comesFrom", ["curr"], [142]], ["curr", 170, "comesFrom", ["curr"], [142]], ["maxElement", 164, "comesFrom", ["maxElement"], [134]], ["maxEle", 217, "comesFrom", ["maxEle"], [200]], ["ptr", 276, "comesFrom", ["ptr"], [274]], ["sum", 287, "comesFrom", ["sum"], [267]], ["temp", 187, "comesFrom", ["temp"], [168]], ["temp", 178, "comesFrom", ["temp"], [168]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void product_subarrays ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } cout << product << \" STRNEWLINE \" ; } int main ( ) { int arr [ ] = { 10 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; product_subarrays ( arr , n ) ; return 0 ; }", "docstring": "Product of all Subarrays of an Array | C ++ program to find product of all subarray of an array ; Function to find product of all subarrays ; Variable to store the product ; Compute the product while traversing for subarrays ; Printing product of all subarray ; Driver code ; Function call", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 124, "comesFrom", ["n"], [105]], ["n", 48, "comesFrom", ["n"], [16]], ["product", 79, "comesFrom", ["product"], [68]], ["j", 46, "comesFrom", ["j"], [42]], ["j", 50, "comesFrom", ["j"], [42]], ["j", 63, "comesFrom", ["j"], [42]], ["k", 61, "comesFrom", ["k"], [57]], ["k", 65, "comesFrom", ["k"], [57]], ["k", 72, "comesFrom", ["k"], [57]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } int toDeci ( string str , int base ) { int len = str . length ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { cout << \" Invalid ▁ Number \" ; return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; } bool isEven ( string num , int N ) { int deci = toDeci ( num , N ) ; return ( deci % 2 == 0 ) ; } int main ( ) { string num = \"11A \" ; int N = 16 ; if ( isEven ( num , N ) ) { cout << \" Even \" ; } else { cout << \" Odd \" ; } }", "docstring": "Check if a N base number is Even or Odd | C ++ code to check if a Octal number is Even or Odd ; To return value of a char . ; Function to convert a number from N base to decimal ; power of base ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 1 ] * base + str [ len - 1 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Returns true if n is even , else odd ; Driver code", "dfg": [["num", 145, "comesFrom", ["num"], [125]], ["num", 163, "comesFrom", ["num"], [152]], ["num", 199, "comesFrom", ["num"], [184]], ["i", 94, "comesFrom", ["i"], [88]], ["i", 98, "comesFrom", ["i"], [88]], ["i", 108, "comesFrom", ["i"], [88]], ["i", 131, "comesFrom", ["i"], [88]], ["len", 90, "comesFrom", ["len"], [65]], ["c", 16, "comesFrom", ["c"], [11]], ["c", 22, "comesFrom", ["c"], [11]], ["c", 32, "comesFrom", ["c"], [11]], ["c", 43, "comesFrom", ["c"], [11]], ["str", 67, "comesFrom", ["str"], [58]], ["str", 106, "comesFrom", ["str"], [58]], ["str", 129, "comesFrom", ["str"], [58]], ["N", 165, "comesFrom", ["N"], [155]], ["N", 201, "comesFrom", ["N"], [191]], ["deci", 170, "comesFrom", ["deci"], [159]], ["base", 112, "comesFrom", ["base"], [61]], ["base", 141, "comesFrom", ["base"], [61]], ["power", 135, "comesFrom", ["power"], [74]], ["power", 139, "comesFrom", ["power"], [137]]]}
{"code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; long long fact [ 21 ] ; void preCompute ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < 18 ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) ; } void nextFactorial ( int N ) { for ( int i = 0 ; i < 21 ; i ++ ) { if ( N < fact [ i ] ) { cout << fact [ i ] ; break ; } } } int main ( ) { preCompute ( ) ; int N = 120 ; nextFactorial ( N ) ; return 0 ; }", "docstring": "Find the next Factorial greater than N | C ++ implementation of the above approach ; Array that stores the factorial till 20 ; Function to pre - compute the factorial till 20 ; Precomputing factorials ; Function to return the next factorial number greater than N ; Traverse the factorial array ; Find the next just greater factorial than N ; Driver Code ; Function to precalculate the factorial till 20 ; Function call", "dfg": [["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 73, "comesFrom", ["i"], [69]], ["i", 77, "comesFrom", ["i"], [69]], ["i", 44, "comesFrom", ["i"], [31]], ["i", 55, "comesFrom", ["i"], [31]], ["i", 87, "comesFrom", ["i"], [69]], ["i", 50, "comesFrom", ["i"], [31]], ["i", 95, "comesFrom", ["i"], [69]], ["N", 119, "comesFrom", ["N"], [113]], ["N", 83, "comesFrom", ["N"], [63]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void findDistinctOddSum ( ll n , ll k ) { if ( ( k * k ) <= n && ( n + k ) % 2 == 0 ) { int val = 1 ; int sum = 0 ; for ( int i = 1 ; i < k ; i ++ ) { cout << val << \" ▁ \" ; sum += val ; val += 2 ; } cout << n - sum << endl ; } else cout << \" NO ▁ STRNEWLINE \" ; } int main ( ) { ll n = 100 ; ll k = 4 ; findDistinctOddSum ( n , k ) ; return 0 ; }", "docstring": "Find K distinct positive odd integers with sum N | C ++ implementation to find K odd positive integers such that their sum is equal to given number ; Function to find K odd positive integers such that their sum is N ; Condition to check if there are enough values to check ; Driver Code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkArray ( int a [ ] , int b [ ] , int n ) { int operations = 0 ; int i = 0 ; while ( i < n ) { if ( a [ i ] - b [ i ] == 0 ) { i ++ ; continue ; } int diff = a [ i ] - b [ i ] ; i ++ ; while ( i < n && a [ i ] - b [ i ] == diff ) { i ++ ; } operations ++ ; } cout << operations << \" STRNEWLINE \" ; } int main ( ) { int a [ ] = { 3 , 7 , 1 , 4 , 1 , 2 } ; int b [ ] = { 3 , 7 , 3 , 6 , 3 , 2 } ; int size = sizeof ( a ) / sizeof ( a [ 0 ] ) ; checkArray ( a , b , size ) ; return 0 ; }", "docstring": "Minimum number of operations to convert array A to array B by adding an integer into a subarray | C ++ implementation to find the minimum number of operations in which the array A can be converted to another array B ; Function to find the minimum number of operations in which array A can be converted to array B ; Loop to iterate over the array ; if both elements are equal then move to next element ; Calculate the difference between two elements ; loop while the next pair of elements have same difference ; Increase the number of operations by 1 ; Print the number of operations required ; Driver Code", "dfg": [["i", 36, "comesFrom", ["i"], [30]], ["i", 75, "comesFrom", ["i"], [30]], ["i", 56, "comesFrom", ["i"], [30]], ["i", 80, "comesFrom", ["i"], [30]], ["i", 97, "comesFrom", ["i"], [30]], ["i", 67, "comesFrom", ["i"], [30]], ["i", 72, "comesFrom", ["i"], [30]], ["i", 45, "comesFrom", ["i"], [30]], ["i", 50, "comesFrom", ["i"], [30]], ["i", 86, "comesFrom", ["i"], [30]], ["i", 91, "comesFrom", ["i"], [30]], ["n", 38, "comesFrom", ["n"], [21]], ["n", 82, "comesFrom", ["n"], [21]], ["operations", 107, "comesFrom", ["operations"], [25]], ["operations", 101, "comesFrom", ["operations"], [25]], ["size", 179, "comesFrom", ["size"], [158]], ["diff", 94, "comesFrom", ["diff"], [63]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > insertPF ( map < int , int > primeFact , int fact ) { if ( primeFact . find ( fact ) != primeFact . end ( ) ) { primeFact [ fact ] ++ ; } else { primeFact [ fact ] = 1 ; } return primeFact ; } map < int , int > primeFactors ( int n ) { map < int , int > primeFact ; while ( n % 2 == 0 ) { primeFact = insertPF ( primeFact , 2 ) ; n /= 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { primeFact = insertPF ( primeFact , i ) ; n /= i ; } } if ( n > 2 ) primeFact = insertPF ( primeFact , n ) ; return primeFact ; } string perfectCube ( int n ) { map < int , int > primeFact ; primeFact = primeFactors ( n ) ; for ( auto x : primeFact ) { if ( x . second % 3 != 0 ) return \" No \" ; } return \" Yes \" ; } int main ( ) { int N = 216 ; cout << perfectCube ( N ) ; return 0 ; }", "docstring": "Perfect Cube | C ++ program to check if a number is a perfect cube using prime factors ; Inserts the prime factor in HashMap if not present if present updates it 's frequency ; A utility function to find all prime factors of a given number N ; Insert the number of 2 s that divide n ; n must be odd at this point So we can skip one element ; while i divides n , insert i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to check if a number is perfect cube ; Iteration in Map ; Driver Code ; Function to check if N is perfect cube or not", "dfg": [["primeFact", 61, "comesFrom", ["primeFact"], [21]], ["primeFact", 166, "comesFrom", ["primeFact"], [156]], ["primeFact", 196, "comesFrom", ["primeFact"], [184]], ["primeFact", 29, "comesFrom", ["primeFact"], [21]], ["primeFact", 36, "comesFrom", ["primeFact"], [21]], ["primeFact", 43, "comesFrom", ["primeFact"], [21]], ["primeFact", 160, "comesFrom", ["primeFact"], [156]], ["primeFact", 52, "comesFrom", ["primeFact"], [21]], ["primeFact", 97, "comesFrom", ["primeFact"], [93]], ["primeFact", 139, "comesFrom", ["primeFact"], [135]], ["i", 114, "comesFrom", ["i"], [110]], ["i", 130, "comesFrom", ["i"], [121]], ["i", 146, "comesFrom", ["i"], [121]], ["i", 141, "comesFrom", ["i"], [121]], ["n", 152, "comesFrom", ["n"], [144]], ["n", 86, "comesFrom", ["n"], [73]], ["n", 118, "comesFrom", ["n"], [102]], ["n", 188, "comesFrom", ["n"], [173]], ["n", 162, "comesFrom", ["n"], [144]], ["n", 128, "comesFrom", ["n"], [102]], ["N", 235, "comesFrom", ["N"], [227]], ["fact", 33, "comesFrom", ["fact"], [24]], ["fact", 45, "comesFrom", ["fact"], [24]], ["fact", 54, "comesFrom", ["fact"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int ways ( int n ) { if ( n < 3 ) { return 0 ; } int c2 = 0 ; int c1 = n - 3 ; int l = c1 + 1 ; int s = 0 ; int exp_c2 = c1 / 2 ; while ( exp_c2 >= c2 ) { int f1 = factorial ( l ) ; int f2 = factorial ( c1 ) ; int f3 = factorial ( c2 ) ; int f4 = ( f2 * f3 ) ; s += f1 / f4 ; c2 += 1 ; c1 -= 2 ; l -= 1 ; } return s ; } int main ( ) { int n = 7 ; int ans = ways ( n ) ; cout << ans << endl ; return 0 ; }", "docstring": "Count ways to reach the Nth stair using multiple 1 or 2 steps and a single step 3 | C ++ implementation to find the number the number of ways to reach Nth stair by taking 1 or 2 steps at a time and 3 rd step exactly once ; Single line to find factorial ; Function to find the number of ways ; Base Case ; Count of 2 - steps ; Count of 1 - steps ; Initial length of sequence ; Expected count of 2 - steps ; Loop to find the ways for every possible sequence ; Driver code", "dfg": [["s", 145, "comesFrom", ["s"], [125]], ["n", 26, "comesFrom", ["n"], [11]], ["n", 45, "comesFrom", ["n"], [40]], ["n", 62, "comesFrom", ["n"], [40]], ["n", 163, "comesFrom", ["n"], [154]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 30, "comesFrom", ["n"], [11]], ["c1", 69, "comesFrom", ["c1"], [60]], ["c1", 81, "comesFrom", ["c1"], [60]], ["c1", 105, "comesFrom", ["c1"], [60]], ["exp_c2", 87, "comesFrom", ["exp_c2"], [79]], ["c2", 89, "comesFrom", ["c2"], [55]], ["c2", 113, "comesFrom", ["c2"], [55]], ["ans", 168, "comesFrom", ["ans"], [159]], ["f1", 127, "comesFrom", ["f1"], [93]], ["f4", 129, "comesFrom", ["f4"], [117]], ["l", 97, "comesFrom", ["l"], [67]], ["f2", 120, "comesFrom", ["f2"], [101]], ["f3", 122, "comesFrom", ["f3"], [109]]]}
{"code": "#include \" bits / stdc + + . h \" NEW_LINE #define ll  long long int NEW_LINE using namespace std ; map < ll , ll > m ; int precompute ( ) { ll fact = 1 ; for ( ll i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } } int main ( ) { precompute ( ) ; int K = 120 ; cout << m [ K ] << endl ; K = 6 ; cout << m [ K ] << endl ; return 0 ; }", "docstring": "Find N from the value of N ! | C ++ program to find a number such that the factorial of that number is given ; Map to precompute and store the factorials of the numbers ; Function to precompute factorial ; Calculating the factorial for each i and storing in a map ; Driver code ; Precomputing the factorials", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calNum ( int year ) { return ( year / 4 ) - ( year / 100 ) + ( year / 400 ) ; } void leapNum ( int l , int r ) { l -- ; int num1 = calNum ( r ) ; int num2 = calNum ( l ) ; cout << num1 - num2 << endl ; } int main ( ) { int l1 = 1 , r1 = 400 ; leapNum ( l1 , r1 ) ; int l2 = 400 , r2 = 2000 ; leapNum ( l2 , r2 ) ; return 0 ; }", "docstring": "Count of Leap Years in a given year range | C ++ implementation to find the count of leap years in given range of the year ; Function to calculate the number of leap years in range of ( 1 , year ) ; Function to calculate the number of leap years in given range ; Driver Code", "dfg": [["l", 44, "comesFrom", ["l"], [38]], ["l", 60, "comesFrom", ["l"], [38]], ["l1", 88, "comesFrom", ["l1"], [78]], ["r1", 90, "comesFrom", ["r1"], [82]], ["l2", 104, "comesFrom", ["l2"], [94]], ["r2", 106, "comesFrom", ["r2"], [98]], ["year", 28, "comesFrom", ["year"], [11]], ["year", 16, "comesFrom", ["year"], [11]], ["year", 22, "comesFrom", ["year"], [11]], ["r", 52, "comesFrom", ["r"], [41]], ["num1", 65, "comesFrom", ["num1"], [48]], ["num2", 67, "comesFrom", ["num2"], [56]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef struct cantor { double start , end ; struct cantor * next ; } Cantor ; Cantor * startList ( Cantor * head , double start_num , double end_num ) { if ( head == NULL ) { head = new Cantor ; head -> start = start_num ; head -> end = end_num ; head -> next = NULL ; } return head ; } Cantor * propagate ( Cantor * head ) { Cantor * temp = head ; if ( temp != NULL ) { Cantor * newNode = new Cantor ; double diff = ( ( ( temp -> end ) - ( temp -> start ) ) / 3 ) ; newNode -> end = temp -> end ; temp -> end = ( ( temp -> start ) + diff ) ; newNode -> start = ( newNode -> end ) - diff ; newNode -> next = temp -> next ; temp -> next = newNode ; propagate ( temp -> next -> next ) ; } return head ; } void print ( Cantor * temp ) { while ( temp != NULL ) { printf ( \" [ % lf ] ▁ - - ▁ [ % lf ] TABSYMBOL \" , temp -> start , temp -> end ) ; temp = temp -> next ; } cout << endl ; } void buildCantorSet ( int A , int B , int L ) { Cantor * head = NULL ; head = startList ( head , A , B ) ; for ( int i = 0 ; i < L ; i ++ ) { cout << \" Level _ \" << i << \" ▁ : ▁ \" ; print ( head ) ; propagate ( head ) ; } cout << \" Level _ \" << L << \" ▁ : ▁ \" ; print ( head ) ; } int main ( ) { int A = 0 ; int B = 9 ; int L = 2 ; buildCantorSet ( A , B , L ) ; return 0 ; }", "docstring": "Ternary representation of Cantor set | C ++ implementation to find the cantor set for n levels and for a given start_num and end_num ; The Linked List Structure for the Cantor Set ; Function to initialize the Cantor Set List ; Function to propogate the list by adding new nodes for the next levels ; Modifying the start and end values for the next level ; Changing the pointers to the next node ; Recursively call the function to generate the Cantor Set for the entire level ; Function to print a level of the Set ; Function to build and display the Cantor Set for each level ; Driver code", "dfg": [["head", 71, "comesFrom", ["head"], [46]], ["head", 183, "comesFrom", ["head"], [87]], ["head", 243, "comesFrom", ["head"], [87]], ["head", 310, "comesFrom", ["head"], [247]], ["head", 80, "comesFrom", ["head"], [46]], ["head", 251, "comesFrom", ["head"], [247]], ["head", 51, "comesFrom", ["head"], [46]], ["head", 57, "comesFrom", ["head"], [46]], ["head", 63, "comesFrom", ["head"], [46]], ["head", 287, "comesFrom", ["head"], [247]], ["head", 292, "comesFrom", ["head"], [247]], ["i", 265, "comesFrom", ["i"], [261]], ["i", 269, "comesFrom", ["i"], [261]], ["i", 279, "comesFrom", ["i"], [261]], ["L", 267, "comesFrom", ["L"], [238]], ["L", 302, "comesFrom", ["L"], [238]], ["L", 340, "comesFrom", ["L"], [330]], ["temp", 218, "comesFrom", ["temp"], [216]], ["A", 336, "comesFrom", ["A"], [320]], ["A", 253, "comesFrom", ["A"], [232]], ["B", 338, "comesFrom", ["B"], [325]], ["B", 255, "comesFrom", ["B"], [235]], ["start_num", 55, "comesFrom", ["start_num"], [33]], ["end_num", 61, "comesFrom", ["end_num"], [36]], ["diff", 156, "comesFrom", ["diff"], [104]], ["diff", 143, "comesFrom", ["diff"], [104]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE #define mod  (int)(1e9 + 7) NEW_LINE int factorial [ N ] , modinverse [ N ] ; int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( 1LL * a * a ) % mod ; else if ( m1 & 1 ) return ( 1LL * a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; } void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( 1LL * factorial [ i - 1 ] * i ) % mod ; } void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( 1LL * modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; } int binomial ( int n , int r ) { if ( r > n ) return 0 ; int a = ( 1LL * factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( 1LL * a * modinverse [ r ] ) % mod ; return a ; } int max_min ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; factorialfun ( ) ; modinversefun ( ) ; long long ans = 0 ; k -- ; for ( int i = 0 ; i < n ; i ++ ) { int x = n - i - 1 ; if ( x >= k ) ans -= binomial ( x , k ) * a [ i ] % mod ; int y = i ; if ( y >= k ) ans += binomial ( y , k ) * a [ i ] % mod ; ans = ( ans + mod ) % mod ; } return ( int ) ( ans ) ; } int main ( ) { int a [ ] = { 1 , 1 , 3 , 4 } , k = 2 ; int n = sizeof ( a ) / sizeof ( int ) ; cout << max_min ( a , n , k ) ; return 0 ; }", "docstring": "Find sum of f ( s ) for all the chosen sets from the given array | C ++ implementation of the approach ; To store the factorial and the factorial mod inverse of a number ; Function to find ( a ^ m1 ) % mod ; Function to find factorial of all the numbers ; Function to find the factorial mod inverse of all the numbers ; Function to return nCr ; Function to find sum of f ( s ) for all the chosen sets from the given array ; Sort the given array ; Calculate the factorial and modinverse of all elements ; For all the possible sets Calculate max ( S ) and min ( S ) ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; } int main ( ) { int N , S ; N = 5 ; S = 11 ; int count = countNumber ( N , S ) ; cout << count << endl ; return 0 ; }", "docstring": "Length of Smallest subarray in range 1 to N with sum greater than a given value | C ++ implementation of the above implementation ; Function to return the count of minimum elements such that the sum of those elements is > S . ; Initialize currentSum = 0 ; Loop from N to 1 to add the numbers and check the condition . ; Driver code", "dfg": [["countElements", 46, "comesFrom", ["countElements"], [18]], ["countElements", 41, "comesFrom", ["countElements"], [18]], ["currSum", 29, "comesFrom", ["currSum"], [23]], ["S", 31, "comesFrom", ["S"], [14]], ["S", 74, "comesFrom", ["S"], [63]], ["count", 79, "comesFrom", ["count"], [68]], ["N", 36, "comesFrom", ["N"], [11]], ["N", 38, "comesFrom", ["N"], [11]], ["N", 72, "comesFrom", ["N"], [59]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDistinct ( int n ) { int arr [ 10 ] = { 0 } ; int count = 0 ; while ( n ) { int r = n % 10 ; arr [ r ] = 1 ; n /= 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] ) count ++ ; } return count ; } int countDigit ( int n ) { int c = 0 ; while ( n ) { int r = n % 10 ; c ++ ; n /= 10 ; } return c ; } int nextNumberDistinctDigit ( int n ) { while ( n < INT_MAX ) { int distinct_digits = countDistinct ( n + 1 ) ; int total_digits = countDigit ( n + 1 ) ; if ( distinct_digits == total_digits ) { return n + 1 ; } else n ++ ; } return -1 ; } int main ( ) { int n = 2019 ; cout << nextNumberDistinctDigit ( n ) ; return 0 ; }", "docstring": "Next Number with distinct digits | C ++ program to find next consecutive Number with all distinct digits ; Function to count distinct digits in a number ; To count the occurrence of digits in number from 0 to 9 ; Iterate over the digits of the number Flag those digits as found in the array ; Traverse the array arr and count the distinct digits in the array ; Function to return the total number of digits in the number ; Iterate over the digits of the number ; Function to return the next number with distinct digits ; Count the distinct digits in N + 1 ; Count the total number of digits in N + 1 ; Return the next consecutive number ; Increment Number by 1 ; Driver code", "dfg": [["count", 80, "comesFrom", ["count"], [25]], ["count", 75, "comesFrom", ["count"], [25]], ["c", 116, "comesFrom", ["c"], [91]], ["c", 107, "comesFrom", ["c"], [91]], ["n", 31, "comesFrom", ["n"], [11]], ["n", 97, "comesFrom", ["n"], [87]], ["n", 128, "comesFrom", ["n"], [123]], ["n", 189, "comesFrom", ["n"], [181]], ["n", 37, "comesFrom", ["n"], [11]], ["n", 103, "comesFrom", ["n"], [87]], ["n", 161, "comesFrom", ["n"], [123]], ["n", 167, "comesFrom", ["n"], [123]], ["n", 138, "comesFrom", ["n"], [123]], ["n", 148, "comesFrom", ["n"], [123]], ["i", 60, "comesFrom", ["i"], [56]], ["i", 64, "comesFrom", ["i"], [56]], ["i", 72, "comesFrom", ["i"], [56]], ["distinct_digits", 155, "comesFrom", ["distinct_digits"], [134]], ["total_digits", 157, "comesFrom", ["total_digits"], [144]], ["r", 43, "comesFrom", ["r"], [35]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  (int)(1e9 + 7) NEW_LINE #define N  1000005 NEW_LINE int lpf [ N ] ; void least_prime_factor ( ) { for ( int i = 1 ; i < N ; i ++ ) lpf [ i ] = i ; for ( int i = 2 ; i < N ; i ++ ) if ( lpf [ i ] == i ) for ( int j = i * 2 ; j < N ; j += i ) if ( lpf [ j ] == j ) lpf [ j ] = i ; } int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( 1LL * a * a ) % mod ; else if ( m1 & 1 ) return ( 1LL * a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; } long long sum_of_elements ( int a [ ] , int n ) { least_prime_factor ( ) ; map < int , int > prime_factor ; for ( int i = 0 ; i < n ; i ++ ) { int temp = a [ i ] ; map < int , int > single_number ; while ( temp > 1 ) { int x = lpf [ temp ] ; single_number [ x ] ++ ; temp /= x ; } if ( i == 0 ) prime_factor = single_number ; else { for ( auto x : single_number ) prime_factor [ x . first ] = max ( x . second , prime_factor [ x . first ] ) ; } } long long ans = 0 , lcm = 1 ; for ( auto x : prime_factor ) lcm = ( lcm * power ( x . first , x . second ) ) % mod ; for ( int i = 0 ; i < n ; i ++ ) ans = ( ans + ( lcm * power ( a [ i ] , mod - 2 ) ) % mod ) % mod ; return ans ; } int main ( ) { int a [ ] = { 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << sum_of_elements ( a , n ) ; return 0 ; }", "docstring": "Minimum possible sum of array B such that AiBi = AjBj for all 1 â ‰¤ i < j â ‰¤ N | C ++ implementation of the approach ; To store least prime factors of all the numbers ; Function to find the least prime factor of all the numbers ; Function to return the ( ( a ^ m1 ) % mod ) ; Function to return the sum of elements of array B ; Find the prime factors of all the numbers ; To store each prime count in lcm ; Current number ; Map to store the prime count of a single number ; Basic way to calculate all prime factors ; If it is the first number in the array ; Take the maximum count of prime in a number ; Calculate lcm of given array ; Calculate sum of elements of array B ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumberOfEvenCells ( int n , int q [ ] [ 2 ] , int size ) { int row [ n ] = { 0 } ; int col [ n ] = { 0 } ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i ] [ 0 ] ; int y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 , r2 = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) { r1 ++ ; } if ( row [ i ] % 2 == 1 ) { r2 ++ ; } if ( col [ i ] % 2 == 0 ) { c1 ++ ; } if ( col [ i ] % 2 == 1 ) { c2 ++ ; } } int count = r1 * c1 + r2 * c2 ; return count ; } int main ( ) { int n = 2 ; int q [ ] [ 2 ] = { { 1 , 1 } , { 1 , 2 } , { 2 , 1 } } ; int size = sizeof ( q ) / sizeof ( q [ 0 ] ) ; cout << findNumberOfEvenCells ( n , q , size ) ; return 0 ; }", "docstring": "Find Number of Even cells in a Zero Matrix after Q queries | C ++ program find Number of Even cells in a Zero Matrix after Q queries ; Function to find the number of even cell in a 2D matrix ; Maintain two arrays , one for rows operation and one for column operation ; Increment operation on row [ i ] ; Increment operation on col [ i ] ; Count odd and even values in both arrays and multiply them ; Count of rows having even numbers ; Count of rows having odd numbers ; Count of columns having even numbers ; Count of columns having odd numbers ; Driver code", "dfg": [["count", 209, "comesFrom", ["count"], [198]], ["i", 52, "comesFrom", ["i"], [48]], ["i", 56, "comesFrom", ["i"], [48]], ["i", 124, "comesFrom", ["i"], [120]], ["i", 128, "comesFrom", ["i"], [120]], ["i", 65, "comesFrom", ["i"], [48]], ["i", 76, "comesFrom", ["i"], [48]], ["i", 136, "comesFrom", ["i"], [120]], ["i", 152, "comesFrom", ["i"], [120]], ["i", 168, "comesFrom", ["i"], [120]], ["i", 184, "comesFrom", ["i"], [120]], ["size", 54, "comesFrom", ["size"], [22]], ["size", 274, "comesFrom", ["size"], [251]], ["n", 126, "comesFrom", ["n"], [11]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 38, "comesFrom", ["n"], [11]], ["n", 270, "comesFrom", ["n"], [218]], ["r1", 200, "comesFrom", ["r1"], [100]], ["r1", 144, "comesFrom", ["r1"], [100]], ["c1", 202, "comesFrom", ["c1"], [109]], ["c1", 176, "comesFrom", ["c1"], [109]], ["r2", 204, "comesFrom", ["r2"], [104]], ["r2", 160, "comesFrom", ["r2"], [104]], ["c2", 206, "comesFrom", ["c2"], [113]], ["c2", 192, "comesFrom", ["c2"], [113]], ["x", 84, "comesFrom", ["x"], [61]], ["y", 92, "comesFrom", ["y"], [72]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; } int main ( ) { int h1 = 7 , h2 = 5 ; cout << max ( 0 , maxHeight ( h1 , h2 ) ) ; return 0 ; }", "docstring": "Find maximum unreachable height using two ladders | C ++ implementation of the approach ; Function to return the maximum height which can 't be reached ; Driver code", "dfg": [["h2", 27, "comesFrom", ["h2"], [14]], ["h2", 22, "comesFrom", ["h2"], [14]], ["h2", 55, "comesFrom", ["h2"], [41]], ["h1", 25, "comesFrom", ["h1"], [11]], ["h1", 20, "comesFrom", ["h1"], [11]], ["h1", 53, "comesFrom", ["h1"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void FermatFactors ( int n ) { if ( n <= 0 ) { cout << \" [ \" << n << \" ] \" ; return ; } if ( ( n & 1 ) == 0 ) { cout << \" [ \" << n / 2.0 << \" , \" << 2 << \" ] \" ; return ; } int a = ceil ( sqrt ( n ) ) ; if ( a * a == n ) { cout << \" [ \" << a << \" , \" << a << \" ] \" ; return ; } int b ; while ( true ) { int b1 = a * a - n ; b = ( int ) sqrt ( b1 ) ; if ( b * b == b1 ) break ; else a += 1 ; } cout << \" [ \" << ( a - b ) << \" , \" << ( a + b ) << \" ] \" ; return ; } int main ( ) { FermatFactors ( 6557 ) ; return 0 ; }", "docstring": "Fermat 's Factorization Method | C ++ implementation of fermat 's factorization ; This function finds the value of a and b and returns a + b and a - b ; since fermat 's factorization applicable  for odd positive integers only ; check if n is a even number ; if n is a perfect root , then both its square roots are its factors ; Driver Code", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 87, "comesFrom", ["n"], [11]], ["n", 27, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [11]], ["n", 126, "comesFrom", ["n"], [11]], ["n", 77, "comesFrom", ["n"], [11]], ["n", 53, "comesFrom", ["n"], [11]], ["a", 83, "comesFrom", ["a"], [71]], ["a", 85, "comesFrom", ["a"], [71]], ["a", 102, "comesFrom", ["a"], [71]], ["a", 171, "comesFrom", ["a"], [149]], ["a", 122, "comesFrom", ["a"], [71]], ["a", 124, "comesFrom", ["a"], [71]], ["a", 96, "comesFrom", ["a"], [71]], ["a", 161, "comesFrom", ["a"], [149]], ["b1", 144, "comesFrom", ["b1"], [120]], ["b1", 135, "comesFrom", ["b1"], [120]], ["b", 173, "comesFrom", ["b"], [128]], ["b", 140, "comesFrom", ["b"], [128]], ["b", 142, "comesFrom", ["b"], [128]], ["b", 163, "comesFrom", ["b"], [128]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNums ( int arr [ ] , int n ) { int S = 0 , X = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } cout << X << \" ▁ \" << ( X + S ) ; } int main ( ) { int arr [ ] = { 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; findNums ( arr , n ) ; return 0 ; }", "docstring": "Append two elements to make the array satisfy the given condition | C ++ implementation of the approach ; Function to find the required numbers ; Find the sum and xor ; Print the required elements ; Driver code", "dfg": [["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 47, "comesFrom", ["i"], [31]], ["i", 54, "comesFrom", ["i"], [31]], ["n", 37, "comesFrom", ["n"], [16]], ["n", 106, "comesFrom", ["n"], [90]], ["X", 60, "comesFrom", ["X"], [50]], ["X", 67, "comesFrom", ["X"], [50]], ["S", 69, "comesFrom", ["S"], [43]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int A , int B ) { double p = B / 2.0 ; int M = ceil ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; int Q = ceil ( A * A + 4 * p * p ) ; cout << M << \" ▁ \" << N << \" ▁ \" << O << \" ▁ \" << Q ; } int main ( ) { int a = 1 ; int b = 1 ; solve ( a , b ) ; }", "docstring": "Satisfy the parabola when point ( A , B ) and the equation is given | C ++ implementation of the approach ; Function to find the required values ; Driver code", "dfg": [["Q", 83, "comesFrom", ["Q"], [48]], ["B", 20, "comesFrom", ["B"], [14]], ["A", 45, "comesFrom", ["A"], [11]], ["A", 52, "comesFrom", ["A"], [11]], ["A", 54, "comesFrom", ["A"], [11]], ["a", 103, "comesFrom", ["a"], [92]], ["b", 105, "comesFrom", ["b"], [97]], ["O", 77, "comesFrom", ["O"], [40]], ["p", 31, "comesFrom", ["p"], [18]], ["p", 60, "comesFrom", ["p"], [18]], ["p", 58, "comesFrom", ["p"], [18]], ["N", 71, "comesFrom", ["N"], [35]], ["M", 65, "comesFrom", ["M"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLargest ( int * arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; } int main ( ) { int arr [ ] = { 3 , 6 , 9 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findLargest ( arr , n ) ; return 0 ; }", "docstring": "Largest number dividing maximum number of elements in the array | C ++ implementation of the approach ; Function to return the largest number that divides the maximum elements from the given array ; Finding gcd of all the numbers in the array ; Driver code", "dfg": [["gcd", 50, "comesFrom", ["gcd"], [37]], ["gcd", 46, "comesFrom", ["gcd"], [37]], ["i", 30, "comesFrom", ["i"], [26]], ["i", 34, "comesFrom", ["i"], [26]], ["i", 43, "comesFrom", ["i"], [26]], ["n", 32, "comesFrom", ["n"], [15]], ["n", 90, "comesFrom", ["n"], [72]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } return sum ; } bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } bool isDigitSumPalindrome ( int n ) { int sum = digitSum ( n ) ; if ( isPalindrome ( sum ) ) return true ; return false ; } int main ( ) { int n = 56 ; if ( isDigitSumPalindrome ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if the sum of digits of N is palindrome | C ++ implementation of the approach ; Function to return the sum of digits of n ; Function that returns true if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digit not same return false ; Removing the leading and trailing digit from number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function that returns true if the digit sum of n is palindrome ; Sum of the digits of n ; If the digit sum is palindrome ; Driver code", "dfg": [["sum", 40, "comesFrom", ["sum"], [26]], ["sum", 137, "comesFrom", ["sum"], [126]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 69, "comesFrom", ["n"], [47]], ["n", 57, "comesFrom", ["n"], [47]], ["n", 130, "comesFrom", ["n"], [122]], ["n", 161, "comesFrom", ["n"], [153]], ["n", 77, "comesFrom", ["n"], [47]], ["n", 84, "comesFrom", ["n"], [47]], ["n", 29, "comesFrom", ["n"], [11]], ["n", 100, "comesFrom", ["n"], [97]], ["divisor", 59, "comesFrom", ["divisor"], [51]], ["divisor", 79, "comesFrom", ["divisor"], [63]], ["divisor", 109, "comesFrom", ["divisor"], [107]], ["divisor", 102, "comesFrom", ["divisor"], [63]], ["leading", 90, "comesFrom", ["leading"], [75]], ["trailing", 92, "comesFrom", ["trailing"], [82]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorK ( int n , int k ) { if ( k % 2 == 1 ) return n ; return 0 ; } int main ( ) { int n = 123 , k = 3 ; cout << xorK ( n , k ) ; return 0 ; }", "docstring": "Find the value of N XOR 'ed to itself K times | C ++ implementation of the approach ; Function to return n ^ n ^ ... k times ; If k is odd the answer is the number itself ; Else the answer is 0 ; Driver code", "dfg": [["n", 26, "comesFrom", ["n"], [11]], ["n", 50, "comesFrom", ["n"], [38]], ["k", 19, "comesFrom", ["k"], [14]], ["k", 52, "comesFrom", ["k"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE #define mod  (int)(1e9 + 7) NEW_LINE int factorial [ N ] , modinverse [ N ] ; int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( 1LL * a * a ) % mod ; else if ( m1 & 1 ) return ( 1LL * a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; } void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( 1LL * factorial [ i - 1 ] * i ) % mod ; } void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( 1LL * modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; } int binomial ( int n , int r ) { if ( r > n ) return 0 ; int a = ( 1LL * factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( 1LL * a * modinverse [ r ] ) % mod ; return a ; } int arrange ( int n , int m , int k ) { factorialfun ( ) ; modinversefun ( ) ; long long ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += ( 1LL * i * ( n - i ) * m * m ) % mod ; for ( int i = 1 ; i < m ; i ++ ) ans += ( 1LL * i * ( m - i ) * n * n ) % mod ; ans = ( ans * binomial ( n * m - 2 , k - 2 ) ) % mod ; return ( int ) ans ; } int main ( ) { int n = 2 , m = 2 , k = 2 ; cout << arrange ( n , m , k ) ; return 0 ; }", "docstring": "Find the sum of the costs of all possible arrangements of the cells | C ++ implementation of the approach ; To store the factorials and factorial mod inverse of the numbers ; Function to return ( a ^ m1 ) % mod ; Function to find the factorials of all the numbers ; Function to find factorial mod inverse of all the numbers ; Function to return nCr ; Function to return the sum of the costs of all the possible arrangements of the cells ; For all possible X 's ; For all possible Y 's ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNthDigit ( int p , int q , int N ) { int res ; while ( N > 0 ) { N -- ; p *= 10 ; res = p / q ; p %= q ; } return res ; } int main ( ) { int p = 1 , q = 2 , N = 1 ; cout << findNthDigit ( p , q , N ) ; return 0 ; }", "docstring": "Find the Nth digit in the proper fraction of two numbers | C ++ implementation of the approach ; Function to print the Nth digit in the fraction ( p / q ) ; To store the resultant digit ; While N > 0 compute the Nth digit by dividing p and q and store the result into variable res and go to next digit ; Driver code", "dfg": [["res", 49, "comesFrom", ["res"], [37]], ["N", 25, "comesFrom", ["N"], [17]], ["N", 30, "comesFrom", ["N"], [17]], ["N", 78, "comesFrom", ["N"], [66]], ["q", 45, "comesFrom", ["q"], [14]], ["q", 76, "comesFrom", ["q"], [62]], ["q", 41, "comesFrom", ["q"], [14]], ["p", 74, "comesFrom", ["p"], [58]], ["p", 39, "comesFrom", ["p"], [33]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } int sumModArr ( int arr [ ] , int n ) { int subSum = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int curr = arr [ i ] ; arr [ i ] -= subSum ; subSum += curr ; } return sumArr ( arr , n ) ; } int main ( ) { int arr [ ] = { 40 , 25 , 12 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumModArr ( arr , n ) ; return 0 ; }", "docstring": "Sum of the updated array after performing the given operation | C ++ implementation of the approach ; Utility function to return the sum of the array ; Function to return the sum of the modified array ; Subtract the subarray sum ; Sum of subarray arr [ i ... n - 1 ] ; Return the sum of the modified array ; Driver code", "dfg": [["sum", 46, "comesFrom", ["sum"], [38]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 80, "comesFrom", ["i"], [74]], ["i", 84, "comesFrom", ["i"], [74]], ["i", 42, "comesFrom", ["i"], [27]], ["i", 93, "comesFrom", ["i"], [74]], ["i", 98, "comesFrom", ["i"], [74]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 113, "comesFrom", ["n"], [58]], ["n", 76, "comesFrom", ["n"], [58]], ["n", 159, "comesFrom", ["n"], [138]], ["n", 66, "comesFrom", ["n"], [58]], ["subSum", 101, "comesFrom", ["subSum"], [62]], ["curr", 105, "comesFrom", ["curr"], [89]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int NumUnsignBits = 64 ; unsigned long findNum ( unsigned long x ) { for ( int i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } } int main ( ) { int n = 92 ; cout << findNum ( n ) ; return 0 ; }", "docstring": "Find closest integer with the same weight | C ++ implementation of the approach ; Function to return the number closest to x which has equal number of set bits as x ; Loop for each bit in x and compare with the next bit ; Driver code", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 35, "comesFrom", ["i"], [25]], ["i", 45, "comesFrom", ["i"], [25]], ["i", 71, "comesFrom", ["i"], [25]], ["i", 56, "comesFrom", ["i"], [25]], ["i", 78, "comesFrom", ["i"], [25]], ["NumUnsignBits", 31, "comesFrom", ["NumUnsignBits"], [9]], ["n", 104, "comesFrom", ["n"], [96]], ["x", 85, "comesFrom", ["x"], [66]], ["x", 43, "comesFrom", ["x"], [19]], ["x", 53, "comesFrom", ["x"], [19]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntCakes ( int n , int m ) { int sum = ( n * ( n + 1 ) ) / 2 ; int quo = m / sum ; int rem = m % sum ; double ans = m - quo * sum ; double x = ( -1 + pow ( ( 8 * rem ) + 1 , 0.5 ) ) / 2 ; ans = ans - x * ( x + 1 ) / 2 ; return int ( ans ) ; } int main ( ) { int n = 3 ; int m = 8 ; int ans = cntCakes ( n , m ) ; cout << ( ans ) ; }", "docstring": "Cake Distribution Problem | C ++ implementation of the approach ; Function to return the remaining count of cakes ; Sum for 1 cycle ; no . of full cycle and remainder ; Driver Code", "dfg": [["m", 35, "comesFrom", ["m"], [14]], ["m", 42, "comesFrom", ["m"], [14]], ["m", 49, "comesFrom", ["m"], [14]], ["m", 120, "comesFrom", ["m"], [109]], ["sum", 37, "comesFrom", ["sum"], [18]], ["sum", 44, "comesFrom", ["sum"], [18]], ["sum", 53, "comesFrom", ["sum"], [18]], ["ans", 79, "comesFrom", ["ans"], [77]], ["ans", 94, "comesFrom", ["ans"], [77]], ["ans", 126, "comesFrom", ["ans"], [114]], ["quo", 51, "comesFrom", ["quo"], [33]], ["n", 118, "comesFrom", ["n"], [104]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["x", 81, "comesFrom", ["x"], [56]], ["x", 84, "comesFrom", ["x"], [56]], ["rem", 66, "comesFrom", ["rem"], [40]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int cnt_squares ( int n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; } int main ( ) { cout << cnt_squares ( 4 ) << endl ; return 0 ; }", "docstring": "Find the number of squares inside the given square grid | C ++ implementation of the approach ; Function to return the number of squares inside an n * n grid ; Driver code", "dfg": [["n", 15, "comesFrom", ["n"], [11]], ["n", 18, "comesFrom", ["n"], [11]], ["n", 26, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num = num / 10 ; } return rev ; } bool isPalindrome ( int num ) { if ( num == reverse ( num ) ) return true ; return false ; } void printPalindromes ( int d ) { if ( d <= 0 ) return ; int smallest = pow ( 10 , d - 1 ) ; int largest = pow ( 10 , d ) - 1 ; for ( int i = smallest ; i <= largest ; i ++ ) { if ( isPalindrome ( i ) ) cout << i << \" ▁ \" ; } } int main ( ) { int d = 2 ; printPalindromes ( d ) ; return 0 ; }", "docstring": "Find all palindrome numbers of given digits | C ++ implementation of the approach ; Function to return the reverse of num ; Function that returns true if num is palindrome ; If the number is equal to the reverse of it then it is a palindrome ; Function to print all the d - digit palindrome numbers ; Smallest and the largest d - digit numbers ; Starting from the smallest d - digit number till the largest ; If the current number is palindrome ; Driver code", "dfg": [["rev", 44, "comesFrom", ["rev"], [26]], ["rev", 28, "comesFrom", ["rev"], [26]], ["i", 116, "comesFrom", ["i"], [112]], ["i", 120, "comesFrom", ["i"], [112]], ["i", 128, "comesFrom", ["i"], [112]], ["i", 133, "comesFrom", ["i"], [112]], ["largest", 118, "comesFrom", ["largest"], [98]], ["num", 21, "comesFrom", ["num"], [11]], ["num", 56, "comesFrom", ["num"], [51]], ["num", 38, "comesFrom", ["num"], [36]], ["num", 60, "comesFrom", ["num"], [51]], ["num", 32, "comesFrom", ["num"], [11]], ["d", 79, "comesFrom", ["d"], [74]], ["d", 153, "comesFrom", ["d"], [147]], ["d", 92, "comesFrom", ["d"], [74]], ["d", 104, "comesFrom", ["d"], [74]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void getXandYintercept ( int P [ ] , int Q [ ] ) { int a = P [ 1 ] - Q [ 1 ] ; int b = P [ 0 ] - Q [ 0 ] ; if ( b == 0 ) { cout << P [ 0 ] << endl ; cout << \" infinity \" ; return ; } if ( a == 0 ) { cout << \" infinity \" ; cout << P [ 1 ] << endl ; return ; } double m = a / ( b * 1.0 ) ; int x = P [ 0 ] ; int y = P [ 1 ] ; double c = y - m * x ; y = 0 ; double r = ( y - c ) / ( m * 1.0 ) ; cout << r << endl ; x = 0 ; y = m * x + c ; printf ( \" % .8f \" , c ) ; } int main ( ) { int p1 [ ] = { 5 , 2 } ; int p2 [ ] = { 2 , 7 } ; getXandYintercept ( p1 , p2 ) ; return 0 ; }", "docstring": "Find X and Y intercepts of a line passing through the given points | C ++ implementation of the approach ; Function to find the X and Y intercepts of the line passing through the given points ; if line is parallel to y axis ; x - intercept will be p [ 0 ] ; y - intercept will be infinity ; if line is parallel to x axis ; x - intercept will be infinity ; y - intercept will be p [ 1 ] ; Slope of the line ; y = mx + c in where c is unknown Use any of the given point to find c ; For finding the x - intercept put y = 0 ; For finding the y - intercept put x = 0 ; Driver code", "dfg": [["b", 49, "comesFrom", ["b"], [35]], ["b", 103, "comesFrom", ["b"], [35]], ["a", 74, "comesFrom", ["a"], [22]], ["a", 100, "comesFrom", ["a"], [22]], ["y", 127, "comesFrom", ["y"], [117]], ["y", 141, "comesFrom", ["y"], [133]], ["r", 154, "comesFrom", ["r"], [138]], ["c", 168, "comesFrom", ["c"], [125]], ["c", 176, "comesFrom", ["c"], [125]], ["c", 143, "comesFrom", ["c"], [125]], ["m", 129, "comesFrom", ["m"], [98]], ["m", 164, "comesFrom", ["m"], [98]], ["m", 147, "comesFrom", ["m"], [98]], ["x", 131, "comesFrom", ["x"], [109]], ["x", 166, "comesFrom", ["x"], [158]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_moves ( int n ) { int ans = INT_MAX ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = min ( ans , i + n / i - 2 ) ; } } return ans ; } int main ( ) { int n = 10 ; cout << min_moves ( n ) ; return 0 ; }", "docstring": "Minimum number of moves to reach N starting from ( 1 , 1 ) | C ++ implementation of the approach ; Function to return the minimum number of moves required to reach the cell containing N starting from ( 1 , 1 ) ; To store the required answer ; For all possible values of divisors ; If i is a divisor of n ; Get the moves to reach n ; Return the required answer ; Driver code", "dfg": [["ans", 63, "comesFrom", ["ans"], [45]], ["ans", 49, "comesFrom", ["ans"], [45]], ["n", 30, "comesFrom", ["n"], [11]], ["n", 80, "comesFrom", ["n"], [72]], ["n", 38, "comesFrom", ["n"], [11]], ["n", 53, "comesFrom", ["n"], [11]], ["i", 32, "comesFrom", ["i"], [22]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 28, "comesFrom", ["i"], [22]], ["i", 40, "comesFrom", ["i"], [22]], ["i", 51, "comesFrom", ["i"], [22]], ["i", 55, "comesFrom", ["i"], [22]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 2019 ; int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = min ( ans , ( i * j ) % MOD ) ; } } return ans ; } } int main ( ) { int l = 2020 , r = 2040 ; cout << min_modulo ( l , r ) ; return 0 ; }", "docstring": "Minimum possible value of ( i * j ) % 2019 | C ++ implementation of the approach ; Function to return the minimum possible value of ( i * j ) % 2019 ; If we can get a number divisible by 2019 ; Find the minimum value by running nested loops ; Driver code", "dfg": [["MOD", 29, "comesFrom", ["MOD"], [9]], ["MOD", 39, "comesFrom", ["MOD"], [9]], ["MOD", 87, "comesFrom", ["MOD"], [9]], ["r", 25, "comesFrom", ["r"], [20]], ["r", 117, "comesFrom", ["r"], [107]], ["r", 52, "comesFrom", ["r"], [20]], ["r", 69, "comesFrom", ["r"], [20]], ["l", 27, "comesFrom", ["l"], [17]], ["l", 115, "comesFrom", ["l"], [103]], ["ans", 93, "comesFrom", ["ans"], [75]], ["ans", 79, "comesFrom", ["ans"], [75]], ["i", 50, "comesFrom", ["i"], [46]], ["i", 54, "comesFrom", ["i"], [46]], ["i", 63, "comesFrom", ["i"], [46]], ["i", 82, "comesFrom", ["i"], [46]], ["j", 67, "comesFrom", ["j"], [61]], ["j", 71, "comesFrom", ["j"], [61]], ["j", 84, "comesFrom", ["j"], [61]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_numbers ( int N ) { if ( N == 1 ) { cout << -1 ; } else { cout << N << \" ▁ \" << N + 1 << \" ▁ \" << N * ( N + 1 ) ; } } int main ( ) { int N = 5 ; find_numbers ( N ) ; return 0 ; }", "docstring": "Represent ( 2 / N ) as the sum of three distinct positive integers of the form ( 1 / m ) | C ++ implementation of the approach ; Function to find the required fractions ; Base condition ; For N > 1 ; Driver code", "dfg": [["N", 16, "comesFrom", ["N"], [11]], ["N", 66, "comesFrom", ["N"], [60]], ["N", 44, "comesFrom", ["N"], [11]], ["N", 36, "comesFrom", ["N"], [11]], ["N", 47, "comesFrom", ["N"], [11]], ["N", 30, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; int res = 0 ; for ( auto x : map ) { int cnt = x . second ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; } int main ( ) { int arr [ ] = { 1 , 5 , 6 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }", "docstring": "Count the pairs in an array such that the difference between them and their indices is equal | C ++ implementation of the approach ; Function to return the count of all valid pairs ; To store the frequencies of ( arr [ i ] - i ) ; To store the required count ; If cnt is the number of elements whose difference with their index is same then ( ( cnt * ( cnt - 1 ) ) / 2 ) such pairs are possible ; Driver code", "dfg": [["map", 62, "comesFrom", ["map"], [25]], ["map", 41, "comesFrom", ["map"], [25]], ["res", 90, "comesFrom", ["res"], [72]], ["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 48, "comesFrom", ["i"], [30]], ["i", 45, "comesFrom", ["i"], [30]], ["n", 36, "comesFrom", ["n"], [16]], ["n", 137, "comesFrom", ["n"], [116]], ["cnt", 76, "comesFrom", ["cnt"], [66]], ["cnt", 79, "comesFrom", ["cnt"], [66]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string minInt ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= '5' ) { str [ i ] = ( '9' - str [ i ] ) + '0' ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; return str ; } int main ( ) { string str = \"589\" ; cout << minInt ( str ) ; return 0 ; }", "docstring": "Minimum possible number with the given operation | C ++ implementation of the approach ; Function to return the minimum possible integer that can be obtained from the given integer after performing the given operations ; For every digit ; Digits less than 5 need not to be changed as changing them will lead to a larger number ; The resulting integer cannot have leading zero ; Driver code", "dfg": [["str", 88, "comesFrom", ["str"], [11]], ["str", 23, "comesFrom", ["str"], [11]], ["str", 69, "comesFrom", ["str"], [11]], ["str", 78, "comesFrom", ["str"], [11]], ["str", 107, "comesFrom", ["str"], [97]], ["str", 35, "comesFrom", ["str"], [11]], ["str", 45, "comesFrom", ["str"], [11]], ["str", 55, "comesFrom", ["str"], [11]], ["i", 21, "comesFrom", ["i"], [17]], ["i", 29, "comesFrom", ["i"], [17]], ["i", 37, "comesFrom", ["i"], [17]], ["i", 47, "comesFrom", ["i"], [17]], ["i", 57, "comesFrom", ["i"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int minOperations ( long long int n ) { long long int count = 0 ; long long int d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = max ( d , n - 1 ) ; count += abs ( d ) ; return count - 1 ; } int main ( ) { long long int n = 240 ; cout << minOperations ( n ) ; return 0 ; }", "docstring": "Reduce N to 1 with minimum number of given operations | C ++ implementation of the approach ; Function to return the minimum number of given operations required to reduce n to 1 ; To store the count of operations ; To store the digit ; If n is already then no operation is required ; Extract all the digits except the first digit ; Store the maximum of that digits ; for each digit ; First digit ; Add the value to count ; Driver code", "dfg": [["count", 87, "comesFrom", ["count"], [79]], ["n", 34, "comesFrom", ["n"], [15]], ["n", 43, "comesFrom", ["n"], [15]], ["n", 108, "comesFrom", ["n"], [100]], ["n", 74, "comesFrom", ["n"], [59]], ["n", 52, "comesFrom", ["n"], [15]], ["d", 72, "comesFrom", ["d"], [68]], ["d", 83, "comesFrom", ["d"], [68]], ["d", 56, "comesFrom", ["d"], [48]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; string findMaximumNum ( string str , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str [ i ] != '9' ) { str [ i ] = '9' ; k -- ; } } return str ; } int main ( ) { string str = \"569431\" ; int n = str . length ( ) ; int k = 3 ; cout << findMaximumNum ( str , n , k ) ; return 0 ; }", "docstring": "Find the largest number that can be formed by changing at most K digits | C ++ implementation of the approach ; Function to return the maximum number that can be formed by changing at most k digits in str ; For every digit of the number ; If no more digits can be replaced ; If current digit is not already 9 ; Replace it with 9 ; One digit has been used ; Driver code", "dfg": [["str", 70, "comesFrom", ["str"], [11]], ["str", 88, "comesFrom", ["str"], [79]], ["str", 103, "comesFrom", ["str"], [79]], ["str", 45, "comesFrom", ["str"], [11]], ["str", 55, "comesFrom", ["str"], [11]], ["i", 27, "comesFrom", ["i"], [23]], ["i", 31, "comesFrom", ["i"], [23]], ["i", 47, "comesFrom", ["i"], [23]], ["i", 57, "comesFrom", ["i"], [23]], ["n", 29, "comesFrom", ["n"], [14]], ["n", 105, "comesFrom", ["n"], [86]], ["k", 107, "comesFrom", ["k"], [95]], ["k", 37, "comesFrom", ["k"], [17]], ["k", 64, "comesFrom", ["k"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areAnagrams ( int a , int b ) { string c = to_string ( a ) ; string d = to_string ( b ) ; sort ( c . begin ( ) , c . end ( ) ) ; sort ( d . begin ( ) , d . end ( ) ) ; if ( c == d ) return true ; else return false ; } int main ( ) { int a = 240 ; int b = 204 ; if ( areAnagrams ( a , b ) ) cout << \" Yes \" ; else cout << \" No \" ; }", "docstring": "Check if two Integer are anagrams of each other | C ++ implementation of the approach ; Function that returns true if a and b are anagarams of each other ; Converting numbers to strings ; Checking if the sorting values of two strings are equal ; Driver code", "dfg": [["c", 65, "comesFrom", ["c"], [18]], ["c", 35, "comesFrom", ["c"], [18]], ["c", 41, "comesFrom", ["c"], [18]], ["d", 67, "comesFrom", ["d"], [26]], ["d", 50, "comesFrom", ["d"], [26]], ["d", 56, "comesFrom", ["d"], [26]], ["a", 22, "comesFrom", ["a"], [11]], ["a", 96, "comesFrom", ["a"], [83]], ["b", 30, "comesFrom", ["b"], [14]], ["b", 98, "comesFrom", ["b"], [88]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int ang , int n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; } int main ( ) { int ang = 90 , n = 4 ; cout << solve ( ang , n ) ; return 0 ; }", "docstring": "Number of occurrences of a given angle formed using 3 vertices of a n | C ++ implementation of the approach ; Function that calculates occurrences of given angle that can be created using any 3 sides ; Maximum angle in a regular n - gon is equal to the interior angle If the given angle is greater than the interior angle then the given angle cannot be created ; The given angle times n should be divisible by 180 else it cannot be created ; Initialise answer ; Calculate the frequency of given angle for each vertex ; Multiply answer by frequency . ; Multiply answer by the number of vertices . ; Driver code", "dfg": [["ans", 93, "comesFrom", ["ans"], [86]], ["ans", 76, "comesFrom", ["ans"], [74]], ["ans", 88, "comesFrom", ["ans"], [86]], ["n", 90, "comesFrom", ["n"], [14]], ["n", 116, "comesFrom", ["n"], [106]], ["n", 22, "comesFrom", ["n"], [14]], ["n", 69, "comesFrom", ["n"], [14]], ["n", 79, "comesFrom", ["n"], [14]], ["n", 29, "comesFrom", ["n"], [14]], ["n", 46, "comesFrom", ["n"], [14]], ["ang", 114, "comesFrom", ["ang"], [102]], ["ang", 20, "comesFrom", ["ang"], [11]], ["ang", 67, "comesFrom", ["ang"], [11]], ["ang", 44, "comesFrom", ["ang"], [11]], ["freq", 83, "comesFrom", ["freq"], [64]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } void thirdNumber ( int a , int b ) { int sum = 0 , temp = 0 ; sum = a + b ; temp = 1 ; if ( sum & 1 ) { temp = 2 ; } while ( ! prime ( sum + temp ) ) { temp += 2 ; } cout << temp ; } int main ( ) { int a = 3 , b = 5 ; thirdNumber ( a , b ) ; return 0 ; }", "docstring": "Find third number such that sum of all three number becomes prime | C ++ implementation of the above approach ; Function that will check whether number is prime or not ; Function to print the 3 rd number ; If the sum is odd ; If sum is not prime ; Driver code", "dfg": [["n", 25, "comesFrom", ["n"], [11]], ["n", 33, "comesFrom", ["n"], [11]], ["i", 27, "comesFrom", ["i"], [17]], ["i", 21, "comesFrom", ["i"], [17]], ["i", 23, "comesFrom", ["i"], [17]], ["i", 35, "comesFrom", ["i"], [17]], ["temp", 106, "comesFrom", ["temp"], [99]], ["temp", 95, "comesFrom", ["temp"], [83]], ["a", 68, "comesFrom", ["a"], [51]], ["a", 125, "comesFrom", ["a"], [115]], ["b", 70, "comesFrom", ["b"], [54]], ["b", 127, "comesFrom", ["b"], [119]], ["sum", 78, "comesFrom", ["sum"], [66]], ["sum", 93, "comesFrom", ["sum"], [66]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } int total_ways ( int N , int X ) { return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; } int main ( ) { int N = 5 , X = 3 ; cout << total_ways ( N , X ) ; return 0 ; }", "docstring": "Total ways of selecting a group of X men from N men with or without including a particular man | C ++ implementation of the approach ; Function to return the value of nCr ; Initialize the answer ; Divide simultaneously by i to avoid overflow ; Function to return the count of ways ; Driver code", "dfg": [["ans", 54, "comesFrom", ["ans"], [48]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 50, "comesFrom", ["i"], [33]], ["i", 45, "comesFrom", ["i"], [33]], ["r", 31, "comesFrom", ["r"], [14]], ["r", 43, "comesFrom", ["r"], [14]], ["N", 109, "comesFrom", ["N"], [97]], ["N", 71, "comesFrom", ["N"], [61]], ["N", 82, "comesFrom", ["N"], [61]], ["X", 111, "comesFrom", ["X"], [101]], ["X", 86, "comesFrom", ["X"], [64]], ["X", 75, "comesFrom", ["X"], [64]], ["n", 41, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE int calculate ( ll int n , ll int k , ll int m , ll int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; } int main ( ) { ll N = 1 , K = 2 , M = 5 ; cout << calculate ( N , K , M , 0 ) ; return 0 ; }", "docstring": "Compute the maximum power with a given condition | Compute maximum power to which K can be raised so that given condition remains true ; Function to return the largest power ; If n is greater than given M ; If n == m ; Checking for the next power ; Driver Code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNumber ( int holes ) { if ( holes == 0 ) cout << \"1\" ; else if ( holes == 1 ) cout << \"0\" ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) cout << \"4\" ; for ( int i = 0 ; i < quo ; i ++ ) cout << \"8\" ; } } int main ( ) { int holes = 3 ; printNumber ( holes ) ; return 0 ; }", "docstring": "Program to find the number from given holes | C ++ implementation of the above approach ; Function that will find out the number ; If number of holes equal 0 then return 1 ; If number of holes equal 0 then return 0 ; If number of holes is more than 0 or 1. ; If number of holes is odd ; Driver code ; Calling Function", "dfg": [["holes", 16, "comesFrom", ["holes"], [11]], ["holes", 108, "comesFrom", ["holes"], [102]], ["holes", 29, "comesFrom", ["holes"], [11]], ["holes", 52, "comesFrom", ["holes"], [11]], ["holes", 58, "comesFrom", ["holes"], [11]], ["i", 81, "comesFrom", ["i"], [77]], ["i", 85, "comesFrom", ["i"], [77]], ["quo", 83, "comesFrom", ["quo"], [56]], ["rem", 64, "comesFrom", ["rem"], [50]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int arr [ ] , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return min ( count_even , count_odd ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 3 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minCost ( arr , n ) ; return 0 ; }", "docstring": "Minimum cost to make all array elements equal | C ++ implementation of the approach ; Function to return the minimum cost to make each array element equal ; To store the count of even numbers present in the array ; To store the count of odd numbers present in the array ; Iterate through the array and find the count of even numbers and odd numbers ; Driver code", "dfg": [["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 48, "comesFrom", ["i"], [32]], ["n", 38, "comesFrom", ["n"], [16]], ["n", 116, "comesFrom", ["n"], [95]], ["count_even", 66, "comesFrom", ["count_even"], [20]], ["count_even", 55, "comesFrom", ["count_even"], [20]], ["count_odd", 68, "comesFrom", ["count_odd"], [25]], ["count_odd", 59, "comesFrom", ["count_odd"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = -1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; } int posProdSubArr ( int arr [ ] , int n ) { int total = ( n * ( n + 1 ) ) / 2 ; int cntNeg = negProdSubArr ( arr , n ) ; return ( total - cntNeg ) ; } int main ( ) { int arr [ ] = { 5 , -4 , -3 , 2 , -5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << posProdSubArr ( arr , n ) ; return 0 ; }", "docstring": "Number of Subarrays with positive product | C ++ implementation of the approach ; Function to return the count of subarrays with negative product ; Replace current element with 1 if it is positive else replace it with - 1 instead ; Take product with previous element to form the prefix product ; Count positive and negative elements in the prefix product array ; Return the required count of subarrays ; Function to return the count of subarrays with positive product ; Total subarrays possible ; Count to subarrays with negative product ; Return the count of subarrays with positive product ; Driver code", "dfg": [["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 69, "comesFrom", ["i"], [31]], ["i", 47, "comesFrom", ["i"], [31]], ["i", 54, "comesFrom", ["i"], [31]], ["i", 75, "comesFrom", ["i"], [31]], ["i", 89, "comesFrom", ["i"], [31]], ["i", 62, "comesFrom", ["i"], [31]], ["i", 80, "comesFrom", ["i"], [31]], ["n", 37, "comesFrom", ["n"], [16]], ["n", 144, "comesFrom", ["n"], [119]], ["n", 199, "comesFrom", ["n"], [178]], ["n", 126, "comesFrom", ["n"], [119]], ["n", 129, "comesFrom", ["n"], [119]], ["positive", 104, "comesFrom", ["positive"], [20]], ["positive", 94, "comesFrom", ["positive"], [20]], ["negative", 106, "comesFrom", ["negative"], [24]], ["negative", 98, "comesFrom", ["negative"], [24]], ["total", 149, "comesFrom", ["total"], [123]], ["cntNeg", 151, "comesFrom", ["cntNeg"], [138]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE bool prime [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } int xorFirstNPrime ( int n ) { int count = 0 , num = 1 ; int xorVal = 0 ; while ( count < n ) { if ( prime [ num ] ) { xorVal ^= num ; count ++ ; } num ++ ; } return xorVal ; } int main ( ) { SieveOfEratosthenes ( ) ; int n = 4 ; cout << xorFirstNPrime ( n ) ; return 0 ; }", "docstring": "Find the XOR of first N Prime Numbers | C ++ implementation of the approach ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to return the xor of 1 st N prime numbers ; Count of prime numbers ; XOR of prime numbers ; If the number is prime xor it ; Increment the count ; Get to the next number ; Driver code ; Create the sieve ; Find the xor of 1 st n prime numbers", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE const long long inv2 = 500000004 ; long long int modulo ( string num ) { long long int res = 0 ; for ( long long int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( long long int ) num [ i ] - '0' ) % mod ; return res ; } long long int findSum ( string L , string R ) { long long int a , b , l , r , ret ; a = modulo ( L ) ; b = modulo ( R ) ; l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; ret = ( r % mod - l % mod ) ; if ( ret < 0 ) ret = ret + mod ; else ret = ret % mod ; return ret ; } int main ( ) { string L = \"88949273204\" ; string R = \"98429729474298592\" ; cout << findSum ( L , R ) << endl ; return 0 ; }", "docstring": "Sum of all natural numbers from L to R ( for large values of L and R ) | C ++ implementation of the approach ; Value of inverse modulo 2 with 10 ^ 9 + 7 ; Function to return num % 1000000007 where num is a large number ; Initialize result ; One by one process all the digits of string ' num ' ; Function to return the sum of the integers from the given range modulo 1000000007 ; a stores the value of L modulo 10 ^ 9 + 7 ; b stores the value of R modulo 10 ^ 9 + 7 ; l stores the sum of natural numbers from 1 to ( a - 1 ) ; r stores the sum of natural numbers from 1 to b ; If the result is negative ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int n , int k , int i ) { int max_so_far = INT_MIN , max_ending_here = 0 ; while ( i < n ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; i += k ; } return max_so_far ; } int find ( int arr [ ] , int n , int k ) { int maxSum = 0 ; for ( int i = 0 ; i <= min ( n , k ) ; i ++ ) { int sum = 0 ; maxSum = max ( maxSum , maxSubArraySum ( arr , n , k , i ) ) ; } return maxSum ; } int main ( ) { int arr [ ] = { 2 , -3 , -1 , -1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << find ( arr , n , k ) ; return 0 ; }", "docstring": "Maximum subsequence sum such that all elements are K distance apart | C ++ implementation of the approach ; Function to return the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Function to return the sum of the maximum required subsequence ; To store the result ; Run a loop from 0 to k ; Find the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Return the maximum value ; Driver code", "dfg": [["max_so_far", 76, "comesFrom", ["max_so_far"], [56]], ["max_so_far", 52, "comesFrom", ["max_so_far"], [26]], ["maxSum", 144, "comesFrom", ["maxSum"], [124]], ["maxSum", 128, "comesFrom", ["maxSum"], [124]], ["i", 106, "comesFrom", ["i"], [102]], ["i", 115, "comesFrom", ["i"], [102]], ["i", 36, "comesFrom", ["i"], [22]], ["i", 47, "comesFrom", ["i"], [22]], ["i", 138, "comesFrom", ["i"], [102]], ["n", 38, "comesFrom", ["n"], [16]], ["n", 110, "comesFrom", ["n"], [88]], ["n", 196, "comesFrom", ["n"], [170]], ["n", 134, "comesFrom", ["n"], [88]], ["k", 72, "comesFrom", ["k"], [19]], ["k", 112, "comesFrom", ["k"], [91]], ["k", 198, "comesFrom", ["k"], [186]], ["k", 136, "comesFrom", ["k"], [91]], ["max_ending_here", 43, "comesFrom", ["max_ending_here"], [41]], ["max_ending_here", 54, "comesFrom", ["max_ending_here"], [41]], ["max_ending_here", 58, "comesFrom", ["max_ending_here"], [41]], ["max_ending_here", 62, "comesFrom", ["max_ending_here"], [41]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE bool prime [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } void solve ( int n ) { int count = 0 ; for ( int i = 3 ; count < n ; i ++ ) { if ( prime [ i ] ) { cout << i << \" ▁ \" ; count ++ ; } } } int main ( ) { SieveOfEratosthenes ( ) ; int n = 6 ; solve ( n ) ; return 0 ; }", "docstring": "Generate N integers satisfying the given conditions | C ++ implementation of the approach ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to find the first n odd prime numbers ; To store the current count of prime numbers ; Starting with 3 as 2 is an even prime number ; If i is prime ; Print i and increment count ; Driver code ; Create the sieve", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int n ) { int n_2 = n / 2 ; string den ; den = \"1\" ; while ( n_2 -- ) den += '0' ; cout << 1 << \" / \" << den << \" STRNEWLINE \" ; } int main ( ) { int N = 5 ; solve ( N ) ; return 0 ; }", "docstring": "Probability that a N digit number is palindrome | C ++ code of above approach ; Find the probability that a n digit number is palindrome ; Denominator ; Assign 10 ^ ( floor ( n / 2 ) ) to denominator ; Display the answer ; Driver code", "dfg": [["n", 17, "comesFrom", ["n"], [11]], ["n_2", 32, "comesFrom", ["n_2"], [15]], ["den", 49, "comesFrom", ["den"], [35]], ["N", 68, "comesFrom", ["N"], [62]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1000000007 ; int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; } int main ( ) { int n = 3 ; cout << countWays ( n ) ; return 0 ; }", "docstring": "Ways to choose balls such that at least one ball is chosen | C ++ implementation of the approach ; Function to return the count of ways to choose the balls ; Calculate ( 2 ^ n ) % MOD ; Subtract the only where no ball was chosen ; Driver code", "dfg": [["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["n", 34, "comesFrom", ["n"], [17]], ["n", 77, "comesFrom", ["n"], [69]], ["MOD", 59, "comesFrom", ["MOD"], [9]], ["MOD", 46, "comesFrom", ["MOD"], [9]], ["MOD", 56, "comesFrom", ["MOD"], [9]], ["ans", 52, "comesFrom", ["ans"], [44]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sort ( arr , arr + n ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } cout << ( sum - max ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMin ( arr , n ) ; }", "docstring": "Minimize the sum of the array according the given condition | C ++ implementation ; Function to return the minimum sum ; sort the array to find the minimum element ; finding the number to divide ; Checking to what instance the sum has decreased ; getting the max difference ; Driver Code", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 76, "comesFrom", ["i"], [70]], ["i", 80, "comesFrom", ["i"], [70]], ["i", 42, "comesFrom", ["i"], [27]], ["i", 89, "comesFrom", ["i"], [70]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 216, "comesFrom", ["n"], [197]], ["n", 51, "comesFrom", ["n"], [16]], ["n", 72, "comesFrom", ["n"], [16]], ["j", 108, "comesFrom", ["j"], [104]], ["j", 112, "comesFrom", ["j"], [104]], ["j", 120, "comesFrom", ["j"], [104]], ["num", 110, "comesFrom", ["num"], [85]], ["num", 95, "comesFrom", ["num"], [85]], ["num", 118, "comesFrom", ["num"], [85]], ["num", 134, "comesFrom", ["num"], [85]], ["sum", 168, "comesFrom", ["sum"], [38]], ["max", 170, "comesFrom", ["max"], [158]], ["max", 156, "comesFrom", ["max"], [63]], ["min", 97, "comesFrom", ["min"], [55]], ["min", 140, "comesFrom", ["min"], [55]], ["total", 148, "comesFrom", ["total"], [93]], ["now", 150, "comesFrom", ["now"], [131]], ["reduce", 154, "comesFrom", ["reduce"], [146]], ["reduce", 160, "comesFrom", ["reduce"], [146]], ["d", 136, "comesFrom", ["d"], [126]], ["d", 142, "comesFrom", ["d"], [126]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void convert_To_Len_th_base ( int n , int arr [ ] , int len , int L ) { for ( int i = 0 ; i < L ; i ++ ) { cout << arr [ n % len ] ; n /= len ; } cout << endl ; } void print ( int arr [ ] , int len , int L ) { for ( int i = 0 ; i < ( int ) pow ( len , L ) ; i ++ ) { convert_To_Len_th_base ( i , arr , len , L ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 2 ; print ( arr , len , L ) ; return 0 ; }", "docstring": "Print all the permutation of length L using the elements of an array | Iterative | C ++ implementation ; Convert the number to Lth base and print the sequence ; Sequence is of length L ; Print the ith element of sequence ; Print all the permuataions ; There can be ( len ) ^ l permutations ; Convert i to len th base ; Driver code ; function call", "dfg": [["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 81, "comesFrom", ["i"], [77]], ["i", 93, "comesFrom", ["i"], [77]], ["i", 99, "comesFrom", ["i"], [77]], ["L", 34, "comesFrom", ["L"], [22]], ["L", 155, "comesFrom", ["L"], [145]], ["L", 90, "comesFrom", ["L"], [71]], ["L", 105, "comesFrom", ["L"], [71]], ["len", 153, "comesFrom", ["len"], [129]], ["len", 51, "comesFrom", ["len"], [19]], ["len", 88, "comesFrom", ["len"], [68]], ["len", 103, "comesFrom", ["len"], [68]], ["len", 46, "comesFrom", ["len"], [19]], ["n", 44, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalways ( int * arr , int n ) { unordered_map < int , int > cnt ; for ( int i = 0 ; i < n ; ++ i ) { cnt [ arr [ i ] ] ++ ; } if ( n % 2 == 1 ) { int start = 0 , endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { if ( i == 0 ) { if ( cnt [ i ] != 1 ) { return 0 ; } } else { if ( cnt [ i ] != 2 ) { return 0 ; } } } int ways = 1 ; start = 2 , endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } else if ( n % 2 == 0 ) { int start = 1 , endd = n - 1 ; for ( int i = 1 ; i <= endd ; i = i + 2 ) { if ( cnt [ i ] != 2 ) return 0 ; } int ways = 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } } int main ( ) { int N = 5 ; int arr [ N ] = { 2 , 4 , 4 , 0 , 2 } ; cout << totalways ( arr , N ) ; return 0 ; }", "docstring": "Number of possible permutations when absolute difference between number of elements to the right and left are given | C ++ implementation of the above approach ; Function to find the number of permutations possible of the original array to satisfy the given absolute differences ; To store the count of each a [ i ] in a map ; if n is odd ; check the count of each whether it satisfy the given criteria or not ; there is only 1 way for middle element . ; for others there are 2 ways . ; now find total ways ; When n is even . ; there will be no middle element so for each a [ i ] there will be 2 ways ; Driver Code", "dfg": [["i", 33, "comesFrom", ["i"], [29]], ["i", 38, "comesFrom", ["i"], [29]], ["i", 78, "comesFrom", ["i"], [74]], ["i", 151, "comesFrom", ["i"], [147]], ["i", 84, "comesFrom", ["i"], [82]], ["i", 157, "comesFrom", ["i"], [155]], ["i", 201, "comesFrom", ["i"], [197]], ["i", 237, "comesFrom", ["i"], [233]], ["i", 91, "comesFrom", ["i"], [82]], ["i", 207, "comesFrom", ["i"], [205]], ["i", 243, "comesFrom", ["i"], [241]], ["i", 45, "comesFrom", ["i"], [29]], ["i", 100, "comesFrom", ["i"], [82]], ["i", 216, "comesFrom", ["i"], [205]], ["i", 117, "comesFrom", ["i"], [82]], ["n", 35, "comesFrom", ["n"], [15]], ["n", 53, "comesFrom", ["n"], [15]], ["n", 67, "comesFrom", ["n"], [15]], ["n", 140, "comesFrom", ["n"], [15]], ["n", 176, "comesFrom", ["n"], [15]], ["n", 190, "comesFrom", ["n"], [15]], ["ways", 170, "comesFrom", ["ways"], [162]], ["ways", 256, "comesFrom", ["ways"], [248]], ["ways", 164, "comesFrom", ["ways"], [162]], ["ways", 250, "comesFrom", ["ways"], [248]], ["N", 273, "comesFrom", ["N"], [266]], ["N", 294, "comesFrom", ["N"], [266]], ["endd", 80, "comesFrom", ["endd"], [65]], ["endd", 153, "comesFrom", ["endd"], [138]], ["endd", 203, "comesFrom", ["endd"], [188]], ["endd", 239, "comesFrom", ["endd"], [188]], ["cnt", 41, "comesFrom", ["cnt"], [24]], ["cnt", 98, "comesFrom", ["cnt"], [24]], ["cnt", 214, "comesFrom", ["cnt"], [24]], ["cnt", 115, "comesFrom", ["cnt"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int proizvolov ( int a [ ] , int b [ ] , int n ) { return n * n ; } int main ( ) { int a [ ] = { 1 , 5 , 6 , 8 , 10 } , b [ ] = { 9 , 7 , 4 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << proizvolov ( a , b , n ) ; return 0 ; }", "docstring": "Proizvolov 's Identity | CPP program to implement proizvolov 's identity ; Function to implement proizvolov 's identity ; According to proizvolov 's identity ; Driver code ; Function call", "dfg": [["n", 25, "comesFrom", ["n"], [21]], ["n", 27, "comesFrom", ["n"], [21]], ["n", 92, "comesFrom", ["n"], [69]]]}
{"code": "#include <cmath> NEW_LINE #include <iomanip> NEW_LINE #include <iostream> NEW_LINE using namespace std ; double calculateLnx ( double n ) { double num , mul , cal , sum = 0 ; num = ( n - 1 ) / ( n + 1 ) ; for ( int i = 1 ; i <= 1000 ; i ++ ) { mul = ( 2 * i ) - 1 ; cal = pow ( num , mul ) ; cal = cal / mul ; sum = sum + cal ; } sum = 2 * sum ; return sum ; } double calculateLogx ( double lnx ) { return ( lnx / 2.303 ) ; } int main ( ) { double lnx , logx , n = 5 ; lnx = calculateLnx ( n ) ; logx = calculateLogx ( lnx ) ; cout << fixed << setprecision ( 3 ) << \" ln ▁ \" << n << \" ▁ = ▁ \" << lnx << endl ; cout << fixed << setprecision ( 3 ) << \" log10 ▁ \" << n << \" ▁ = ▁ \" << logx << endl ; }", "docstring": "Find the ln ( X ) and log10X with the help of expansion | CPP code to Find the ln x and log < sub > 10 < / sub > x with the help of expansion ; Function to calculate ln x using expansion ; terminating value of the loop can be increased to improve the precision ; Function to calculate log10 x ; Driver Code ; setprecision ( 3 ) is used to display the output up to 3 decimal places", "dfg": [["sum", 99, "comesFrom", ["sum"], [92]], ["sum", 96, "comesFrom", ["sum"], [92]], ["sum", 87, "comesFrom", ["sum"], [85]], ["i", 52, "comesFrom", ["i"], [48]], ["i", 56, "comesFrom", ["i"], [48]], ["i", 65, "comesFrom", ["i"], [48]], ["lnx", 111, "comesFrom", ["lnx"], [106]], ["lnx", 164, "comesFrom", ["lnx"], [131]], ["lnx", 142, "comesFrom", ["lnx"], [131]], ["logx", 187, "comesFrom", ["logx"], [138]], ["n", 135, "comesFrom", ["n"], [127]], ["n", 34, "comesFrom", ["n"], [17]], ["n", 40, "comesFrom", ["n"], [17]], ["n", 158, "comesFrom", ["n"], [127]], ["n", 181, "comesFrom", ["n"], [127]], ["cal", 81, "comesFrom", ["cal"], [79]], ["cal", 89, "comesFrom", ["cal"], [79]], ["mul", 83, "comesFrom", ["mul"], [60]], ["mul", 76, "comesFrom", ["mul"], [60]], ["num", 74, "comesFrom", ["num"], [31]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int sum ( int A , int B , int R ) { int sum = 0 ; for ( int i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; } int main ( ) { int A = 5 , B = 3 , R = 3 ; cout << sum ( A , B , R ) ; return 0 ; }", "docstring": "Find the sum of elements of the Matrix generated by the given rules | C ++ implementation of the approach ; Function to return the required sum ; To store the sum ; For every row ; Update the sum as A appears i number of times in the current row ; Update A for the next row ; Return the sum ; Driver code", "dfg": [["sum", 58, "comesFrom", ["sum"], [40]], ["sum", 81, "comesFrom", ["sum"], [40]], ["sum", 42, "comesFrom", ["sum"], [40]], ["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 45, "comesFrom", ["i"], [28]], ["R", 34, "comesFrom", ["R"], [17]], ["R", 87, "comesFrom", ["R"], [75]], ["A", 83, "comesFrom", ["A"], [67]], ["A", 52, "comesFrom", ["A"], [50]], ["A", 47, "comesFrom", ["A"], [11]], ["B", 85, "comesFrom", ["B"], [71]], ["B", 54, "comesFrom", ["B"], [14]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs & 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; } int main ( ) { int n = 14 ; cout << countSetBits ( n ) ; return 0 ; }", "docstring": "Count total set bits in all numbers from 1 to n | Set 2 | C ++ implementation of the approach ; Function to return the sum of the count of set bits in the integers from 1 to n ; Ignore 0 as all the bits are unset ; To store the powers of 2 ; To store the result , it is initialized with n / 2 because the count of set least significant bits in the integers from 1 to n is n / 2 ; Loop for every bit required to represent n ; Total count of pairs of 0 s and 1 s ; totalPairs / 2 gives the complete count of the pairs of 1 s Multiplying it with the current power of 2 will give the count of 1 s in the current bit ; If the count of pairs was odd then add the remaining 1 s which could not be groupped together ; Next power of 2 ; Return the result ; Driver code", "dfg": [["cnt", 75, "comesFrom", ["cnt"], [53]], ["n", 14, "comesFrom", ["n"], [11]], ["n", 25, "comesFrom", ["n"], [11]], ["n", 33, "comesFrom", ["n"], [11]], ["n", 92, "comesFrom", ["n"], [84]], ["n", 39, "comesFrom", ["n"], [11]], ["n", 62, "comesFrom", ["n"], [11]], ["powerOf2", 31, "comesFrom", ["powerOf2"], [18]], ["powerOf2", 41, "comesFrom", ["powerOf2"], [18]], ["powerOf2", 51, "comesFrom", ["powerOf2"], [18]], ["powerOf2", 64, "comesFrom", ["powerOf2"], [18]], ["totalPairs", 46, "comesFrom", ["totalPairs"], [37]], ["totalPairs", 56, "comesFrom", ["totalPairs"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getHeight ( int X ) { return ( 2 * X ) ; } int main ( ) { int X = 35 ; cout << getHeight ( X ) ; return 0 ; }", "docstring": "Find the height of a right | C ++ implementation of the approach ; Function to return the height of the right - angled triangle whose area is X times its base ; Driver code", "dfg": [["X", 18, "comesFrom", ["X"], [11]], ["X", 36, "comesFrom", ["X"], [28]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double SumofInverseDivisors ( int N , int Sum ) { double ans = ( double ) ( Sum ) * 1.0 / ( double ) ( N ) ; return ans ; } int main ( ) { int N = 9 ; int Sum = 13 ; cout << setprecision ( 2 ) << fixed << SumofInverseDivisors ( N , Sum ) ; return 0 ; }", "docstring": "Find sum of inverse of the divisors when sum of divisors and the number is given | C ++ implementation of above approach ; Function to return the sum of inverse of divisors ; Calculating the answer ; Return the answer ; Driver code ; Function call", "dfg": [["ans", 37, "comesFrom", ["ans"], [18]], ["N", 66, "comesFrom", ["N"], [46]], ["N", 33, "comesFrom", ["N"], [11]], ["Sum", 68, "comesFrom", ["Sum"], [51]], ["Sum", 24, "comesFrom", ["Sum"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int NoofTriplets ( int N , int K ) { int cnt [ K ] ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( K & 1 ) return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } } int main ( ) { int N = 3 , K = 2 ; cout << NoofTriplets ( N , K ) ; return 0 ; }", "docstring": "Number of triplets such that each value is less than N and each pair sum is a multiple of K | C ++ implementation of the above approach ; Function to return the number of triplets ; Initializing the count array ; Storing the frequency of each modulo class ; If K is odd ; If K is even ; Driver Code ; Function Call", "dfg": [["K", 20, "comesFrom", ["K"], [14]], ["K", 63, "comesFrom", ["K"], [14]], ["K", 146, "comesFrom", ["K"], [136]], ["K", 55, "comesFrom", ["K"], [14]], ["K", 118, "comesFrom", ["K"], [14]], ["K", 104, "comesFrom", ["K"], [14]], ["K", 111, "comesFrom", ["K"], [14]], ["i", 42, "comesFrom", ["i"], [38]], ["i", 53, "comesFrom", ["i"], [46]], ["N", 44, "comesFrom", ["N"], [11]], ["N", 144, "comesFrom", ["N"], [132]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll findNumber ( int n ) { ll num = n - 1 ; num = 2 * ( ll ) pow ( 4 , num ) ; num = floor ( num / 3.0 ) ; return num ; } int main ( ) { int n = 5 ; cout << findNumber ( n ) ; return 0 ; }", "docstring": "Find a number containing N | C ++ implementation of the approach ; Function to compute number using our deduced formula ; Initialize num to n - 1 ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findXOR ( int n ) { int mod = n % 4 ; if ( mod == 0 ) return n ; else if ( mod == 1 ) return 1 ; else if ( mod == 2 ) return n + 1 ; else if ( mod == 3 ) return 0 ; } int findXOR ( int l , int r ) { return ( findXOR ( l - 1 ) ^ findXOR ( r ) ) ; } int main ( ) { int l = 4 , r = 8 ; cout << findXOR ( l , r ) ; return 0 ; }", "docstring": "Find XOR of numbers from the range [ L , R ] | C ++ implementation of the approach ; Function to return the XOR of elements from the range [ 1 , n ] ; If n is a multiple of 4 ; If n % 4 gives remainder 1 ; If n % 4 gives remainder 2 ; If n % 4 gives remainder 3 ; Function to return the XOR of elements from the range [ l , r ] ; Driver code", "dfg": [["n", 28, "comesFrom", ["n"], [11]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 48, "comesFrom", ["n"], [11]], ["mod", 23, "comesFrom", ["mod"], [15]], ["mod", 33, "comesFrom", ["mod"], [15]], ["mod", 43, "comesFrom", ["mod"], [15]], ["mod", 55, "comesFrom", ["mod"], [15]], ["l", 107, "comesFrom", ["l"], [95]], ["l", 77, "comesFrom", ["l"], [67]], ["r", 109, "comesFrom", ["r"], [99]], ["r", 84, "comesFrom", ["r"], [70]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } int findReachable ( int arr [ ] , int D , int A , int B , int n ) { int gcd_AB = GCD ( A , B ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - D ) % gcd_AB == 0 ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int D = 4 , A = 4 , B = 6 ; cout << findReachable ( arr , D , A , B , n ) ; return 0 ; }", "docstring": "Number of elements from the array which are reachable after performing given operations on D | C ++ implementation of the approach ; Function to return the GCD of a and b ; Function to return the count of reachable integers from the given array ; GCD of A and B ; To store the count of reachable integers ; If current element can be reached ; Return the count ; Driver code", "dfg": [["count", 108, "comesFrom", ["count"], [69]], ["count", 103, "comesFrom", ["count"], [69]], ["a", 24, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]], ["i", 80, "comesFrom", ["i"], [76]], ["i", 84, "comesFrom", ["i"], [76]], ["i", 93, "comesFrom", ["i"], [76]], ["n", 82, "comesFrom", ["n"], [55]], ["n", 173, "comesFrom", ["n"], [136]], ["b", 19, "comesFrom", ["b"], [14]], ["b", 29, "comesFrom", ["b"], [14]], ["b", 33, "comesFrom", ["b"], [14]], ["A", 63, "comesFrom", ["A"], [49]], ["A", 169, "comesFrom", ["A"], [153]], ["B", 65, "comesFrom", ["B"], [52]], ["B", 171, "comesFrom", ["B"], [157]], ["D", 167, "comesFrom", ["D"], [149]], ["D", 96, "comesFrom", ["D"], [46]], ["gcd_AB", 99, "comesFrom", ["gcd_AB"], [59]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll power ( int x , ll y ) { ll res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) ; y = y >> 1 ; x = ( x * x ) ; } return res ; } ll solve ( int L ) { int n = L / 2 + 1 ; ll ans = power ( n , n - 2 ) ; return ans ; } int main ( ) { int L = 6 ; cout << solve ( L ) ; return 0 ; }", "docstring": "Number of trees whose sum of degrees of all the vertices is L | C ++ implementation of the approach ; Iterative Function to calculate ( x ^ y ) in O ( log y ) ; Initialize result ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; Function to return the count of required trees ; number of nodes ; Return the result ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void makeAP ( int arr [ ] , int n ) { int initial_term , common_difference ; if ( n == 3 ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else if ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) { initial_term = arr [ 0 ] ; common_difference = arr [ 1 ] - arr [ 0 ] ; } else if ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else { common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 ; initial_term = arr [ 0 ] ; } for ( int i = 0 ; i < n ; i ++ ) cout << initial_term + ( i * common_difference ) << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; makeAP ( arr , n ) ; return 0 ; }", "docstring": "Change one element in the given array to make it an Arithmetic Progression | C ++ program to change one element of an array such that the resulting array is in arithmetic progression . ; Finds the initial term and common difference and prints the resulting sequence . ; Check if the first three elements are in arithmetic progression ; Check if the first element is not in arithmetic progression ; The first and fourth element are in arithmetic progression ; Print the arithmetic progression ; Driver Program", "dfg": [["i", 182, "comesFrom", ["i"], [178]], ["i", 186, "comesFrom", ["i"], [178]], ["i", 194, "comesFrom", ["i"], [178]], ["n", 184, "comesFrom", ["n"], [16]], ["n", 26, "comesFrom", ["n"], [16]], ["n", 246, "comesFrom", ["n"], [227]], ["common_difference", 50, "comesFrom", ["common_difference"], [31]], ["common_difference", 196, "comesFrom", ["common_difference"], [151]], ["common_difference", 146, "comesFrom", ["common_difference"], [127]], ["initial_term", 191, "comesFrom", ["initial_term"], [167]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int getfactor ( int n , int p ) { int pw = 0 ; while ( n ) { n /= p ; pw += n ; } return pw ; } bool isDivisible ( int n , int r , int p ) { int x1 = getfactor ( n , p ) ; int x2 = getfactor ( r , p ) ; int x3 = getfactor ( n - r , p ) ; if ( x1 > x2 + x3 ) return true ; return false ; } int main ( ) { int n = 7 , r = 2 , p = 7 ; if ( isDivisible ( n , r , p ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Find if nCr is divisible by the given prime | C ++ implementation of the approach ; Function to return the highest power of p that divides n ! implementing Legendre Formula ; Return the highest power of p which divides n ! ; Function that returns true if nCr is divisible by p ; Find the highest powers of p that divide n ! , r ! and ( n - r ) ! ; If nCr is divisible by p ; Driver code", "dfg": []}
{"code": "#include <iostream> NEW_LINE using namespace std ; bool isEven ( int arr [ ] , int n , int r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { int oddCount = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; } int main ( ) { int arr [ ] = { 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int r = 2 ; if ( isEven ( arr , n , r ) ) cout << \" Even \" ; else cout << \" Odd \" ; return 0 ; }", "docstring": "Check if the number is even or odd whose digits and base ( radix ) is given | C ++ implementation of the approach ; Function that returns true if the number represented by arr [ ] is even in base r ; If the base is even , then the last digit is checked ; If base is odd , then the number of odd digits are checked ; To store the count of odd digits ; Number is odd ; Driver code", "dfg": [["r", 24, "comesFrom", ["r"], [19]], ["r", 146, "comesFrom", ["r"], [134]], ["n", 144, "comesFrom", ["n"], [118]], ["n", 64, "comesFrom", ["n"], [16]], ["n", 35, "comesFrom", ["n"], [16]], ["i", 62, "comesFrom", ["i"], [58]], ["i", 67, "comesFrom", ["i"], [58]], ["i", 74, "comesFrom", ["i"], [58]], ["oddCount", 87, "comesFrom", ["oddCount"], [51]], ["oddCount", 81, "comesFrom", ["oddCount"], [51]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int closetAND ( int arr [ ] , int n , int k ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = min ( ans , abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; } int main ( ) { int arr [ ] = { 4 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << closetAND ( arr , n , k ) ; return 0 ; }", "docstring": "Bitwise AND of sub | C ++ implementation of the approach ; Function to return the minimum possible value of | K - X | where X is the bitwise AND of the elements of some sub - array ; Check all possible sub - arrays ; Find the overall minimum ; No need to perform more AND operations as | k - X | will increase ; Driver code", "dfg": [["ans", 97, "comesFrom", ["ans"], [72]], ["ans", 76, "comesFrom", ["ans"], [72]], ["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 47, "comesFrom", ["i"], [30]], ["n", 36, "comesFrom", ["n"], [16]], ["n", 59, "comesFrom", ["n"], [16]], ["n", 145, "comesFrom", ["n"], [119]], ["j", 57, "comesFrom", ["j"], [53]], ["j", 61, "comesFrom", ["j"], [53]], ["j", 69, "comesFrom", ["j"], [53]], ["k", 147, "comesFrom", ["k"], [135]], ["k", 90, "comesFrom", ["k"], [19]], ["k", 80, "comesFrom", ["k"], [19]], ["X", 88, "comesFrom", ["X"], [65]], ["X", 82, "comesFrom", ["X"], [65]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int countQuadruplets ( int l , int r , int k ) { int frequency [ r + 1 ] = { 0 } ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = l ; j <= r ; j ++ ) { frequency [ gcd ( i , j ) ] ++ ; } } long long answer = 0 ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= r ; j ++ ) { if ( gcd ( i , j ) == k ) { answer += ( frequency [ i ] * frequency [ j ] ) ; } } } return answer ; } int main ( ) { int l = 1 , r = 10 , k = 2 ; cout << countQuadruplets ( l , r , k ) ; return 0 ; }", "docstring": "Count of quadruplets from range [ L , R ] having GCD equal to K | C ++ implementation of the approach ; Function to return the gcd of a and b ; Function to return the count of quadruplets having gcd = k ; Count the frequency of every possible gcd value in the range ; To store the required count ; Calculate the answer using frequency values ; Return the required count ; Driver code", "dfg": [["answer", 171, "comesFrom", ["answer"], [153]], ["a", 24, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]], ["i", 69, "comesFrom", ["i"], [65]], ["i", 73, "comesFrom", ["i"], [65]], ["i", 118, "comesFrom", ["i"], [114]], ["i", 122, "comesFrom", ["i"], [114]], ["i", 145, "comesFrom", ["i"], [114]], ["i", 96, "comesFrom", ["i"], [65]], ["i", 158, "comesFrom", ["i"], [114]], ["r", 71, "comesFrom", ["r"], [44]], ["r", 120, "comesFrom", ["r"], [44]], ["r", 53, "comesFrom", ["r"], [44]], ["r", 86, "comesFrom", ["r"], [44]], ["r", 135, "comesFrom", ["r"], [44]], ["r", 198, "comesFrom", ["r"], [184]], ["b", 19, "comesFrom", ["b"], [14]], ["b", 29, "comesFrom", ["b"], [14]], ["b", 33, "comesFrom", ["b"], [14]], ["j", 84, "comesFrom", ["j"], [80]], ["j", 88, "comesFrom", ["j"], [80]], ["j", 133, "comesFrom", ["j"], [129]], ["j", 137, "comesFrom", ["j"], [129]], ["j", 147, "comesFrom", ["j"], [129]], ["j", 98, "comesFrom", ["j"], [80]], ["j", 163, "comesFrom", ["j"], [129]], ["l", 196, "comesFrom", ["l"], [180]], ["k", 200, "comesFrom", ["k"], [188]], ["k", 150, "comesFrom", ["k"], [47]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int a [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos ) a [ ind ++ ] = 2 ; bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << \" ▁ \" ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; solve ( a , n ) ; return 0 ; }", "docstring": "Rearrange the array to maximize the number of primes in prefix sum of the array | C ++ implementation of the approach ; Function to print the re - arranged array ; Count the number of ones and twos in a [ ] ; If the array element is 1 ; Array element is 2 ; If it has at least one 2 Fill up first 2 ; Decrease the cnt of ones if even ; Fill up with odd count of ones ; Fill up with remaining twos ; If even ones , then fill last position ; Print the rearranged array ; Driver code", "dfg": [["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 107, "comesFrom", ["i"], [103]], ["i", 111, "comesFrom", ["i"], [103]], ["i", 129, "comesFrom", ["i"], [125]], ["i", 135, "comesFrom", ["i"], [125]], ["i", 165, "comesFrom", ["i"], [161]], ["i", 169, "comesFrom", ["i"], [161]], ["i", 176, "comesFrom", ["i"], [161]], ["i", 47, "comesFrom", ["i"], [31]], ["n", 37, "comesFrom", ["n"], [16]], ["n", 167, "comesFrom", ["n"], [16]], ["n", 226, "comesFrom", ["n"], [207]], ["twos", 67, "comesFrom", ["twos"], [24]], ["twos", 131, "comesFrom", ["twos"], [24]], ["twos", 56, "comesFrom", ["twos"], [24]], ["evenOnes", 94, "comesFrom", ["evenOnes"], [78]], ["evenOnes", 148, "comesFrom", ["evenOnes"], [78]], ["ones", 109, "comesFrom", ["ones"], [96]], ["ones", 52, "comesFrom", ["ones"], [20]], ["ones", 81, "comesFrom", ["ones"], [20]], ["ind", 71, "comesFrom", ["ind"], [61]], ["ind", 116, "comesFrom", ["ind"], [61]], ["ind", 140, "comesFrom", ["ind"], [61]], ["ind", 152, "comesFrom", ["ind"], [61]]]}
{"code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void CreateArray ( int N , int even , int odd ) { int temp = -1 ; int OddPreSums ; for ( int i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == -1 ) { cout << temp << endl ; } else { int EvenPreSums = ( N + 1 ) - OddPreSums ; int e = 1 ; int o = 0 ; int CurrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; cout << \"0 ▁ \" ; } else { o ++ ; cout << \"1 ▁ \" ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; cout << \"1 ▁ \" ; CurrSum ++ ; } else { o ++ ; cout << \"0 ▁ \" ; } } } cout << endl ; } } int main ( ) { int N = 15 ; int even = 60 , odd = 60 ; CreateArray ( N , even , odd ) ; return 0 ; }", "docstring": "Generate an Array in which count of even and odd sum sub | C ++ implementation of the approach ; Function to generate and print the required array ; Find the number of odd prefix sums ; If no odd prefix sum found ; Calculating the number of even prefix sums ; Stores the current prefix sum ; If current prefix sum is even ; Print 0 until e = EvenPreSums - 1 ; Print 1 when e = EvenPreSums ; Print 0 for rest of the values ; Driver code", "dfg": [["i", 38, "comesFrom", ["i"], [34]], ["i", 44, "comesFrom", ["i"], [34]], ["i", 126, "comesFrom", ["i"], [122]], ["i", 130, "comesFrom", ["i"], [122]], ["i", 50, "comesFrom", ["i"], [34]], ["i", 71, "comesFrom", ["i"], [34]], ["i", 59, "comesFrom", ["i"], [34]], ["N", 40, "comesFrom", ["N"], [14]], ["N", 239, "comesFrom", ["N"], [224]], ["N", 128, "comesFrom", ["N"], [14]], ["N", 97, "comesFrom", ["N"], [14]], ["N", 54, "comesFrom", ["N"], [14]], ["temp", 79, "comesFrom", ["temp"], [65]], ["temp", 86, "comesFrom", ["temp"], [65]], ["even", 241, "comesFrom", ["even"], [229]], ["odd", 243, "comesFrom", ["odd"], [233]], ["odd", 62, "comesFrom", ["odd"], [20]], ["OddPreSums", 102, "comesFrom", ["OddPreSums"], [69]], ["CurrSum", 136, "comesFrom", ["CurrSum"], [115]], ["CurrSum", 171, "comesFrom", ["CurrSum"], [115]], ["CurrSum", 194, "comesFrom", ["CurrSum"], [115]], ["e", 145, "comesFrom", ["e"], [105]], ["e", 150, "comesFrom", ["e"], [105]], ["e", 180, "comesFrom", ["e"], [105]], ["e", 185, "comesFrom", ["e"], [105]], ["EvenPreSums", 147, "comesFrom", ["EvenPreSums"], [94]], ["EvenPreSums", 182, "comesFrom", ["EvenPreSums"], [94]], ["o", 162, "comesFrom", ["o"], [110]], ["o", 200, "comesFrom", ["o"], [110]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int changeTheArray ( int arr [ ] , int n ) { int minEle = * ( std :: min_element ( arr , arr + n ) ) ; int maxEle = * ( std :: max_element ( arr , arr + n ) ) ; int minOperations = INT_MAX ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = min ( minOperations , operations ) ; } return minOperations ; } int main ( ) { int arr [ ] = { 10 , 1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << changeTheArray ( arr , n ) ; return 0 ; }", "docstring": "Minimum operations required to change the array such that | arr [ i ] | C ++ implementation of the approach ; Function to return the minimum number of operations required ; Minimum and maximum elements from the array ; To store the minimum number of operations required ; To store the number of operations required to change every element to either ( num - 1 ) , num or ( num + 1 ) ; If current element is not already num ; Add the count of operations required to change arr [ i ] ; Update the minimum operations so far ; Driver code", "dfg": [["minOperations", 132, "comesFrom", ["minOperations"], [121]], ["minOperations", 125, "comesFrom", ["minOperations"], [121]], ["num", 65, "comesFrom", ["num"], [61]], ["num", 69, "comesFrom", ["num"], [61]], ["num", 100, "comesFrom", ["num"], [61]], ["num", 108, "comesFrom", ["num"], [61]], ["maxEle", 67, "comesFrom", ["maxEle"], [37]], ["i", 85, "comesFrom", ["i"], [81]], ["i", 89, "comesFrom", ["i"], [81]], ["i", 97, "comesFrom", ["i"], [81]], ["i", 112, "comesFrom", ["i"], [81]], ["n", 87, "comesFrom", ["n"], [16]], ["n", 175, "comesFrom", ["n"], [154]], ["n", 32, "comesFrom", ["n"], [16]], ["n", 49, "comesFrom", ["n"], [16]], ["operations", 127, "comesFrom", ["operations"], [103]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A B ) { if ( ( A & 1 ) && ( B & 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; } int main ( ) { int A = 2 , B = 3 ; int X = findX ( A , B ) ; cout << \" X ▁ = ▁ \" << X << \" , ▁ Sum ▁ = ▁ \" << ( A ^ X ) + ( B ^ X ) ; return 0 ; }", "docstring": "Choose X such that ( A xor X ) + ( B xor X ) is minimized | C ++ implementation of the approach ; Function to return the integer X such that ( A xor X ) + ( B ^ X ) is minimized ; While either A or B is non - zero ; Position at which both A and B have a set bit ; Inserting a set bit in x ; Right shifting both numbers to traverse all the bits ; Driver code", "dfg": [["x", 71, "comesFrom", ["x"], [47]], ["A", 93, "comesFrom", ["A"], [80]], ["A", 111, "comesFrom", ["A"], [80]], ["A", 35, "comesFrom", ["A"], [11]], ["B", 95, "comesFrom", ["B"], [84]], ["B", 117, "comesFrom", ["B"], [84]], ["B", 41, "comesFrom", ["B"], [29]], ["X", 104, "comesFrom", ["X"], [89]], ["X", 113, "comesFrom", ["X"], [89]], ["X", 119, "comesFrom", ["X"], [89]], ["j", 52, "comesFrom", ["j"], [18]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int findX ( int A , int B ) { return A & B ; } int findSum ( int A , int B ) { return A ^ B ; } int main ( ) { int A = 2 , B = 3 ; cout << \" X ▁ = ▁ \" << findX ( A , B ) << \" , ▁ Sum ▁ = ▁ \" << findSum ( A , B ) ; return 0 ; }", "docstring": "Choose X such that ( A xor X ) + ( B xor X ) is minimized | c ++ implementation of above approach ; finding X ; finding Sum ; Driver code", "dfg": [["A", 18, "comesFrom", ["A"], [11]], ["A", 34, "comesFrom", ["A"], [27]], ["A", 72, "comesFrom", ["A"], [45]], ["A", 61, "comesFrom", ["A"], [45]], ["B", 20, "comesFrom", ["B"], [14]], ["B", 36, "comesFrom", ["B"], [30]], ["B", 74, "comesFrom", ["B"], [49]], ["B", 63, "comesFrom", ["B"], [49]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; bool isSumEqual ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSumEqual ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Compare sum of first N | C ++ implementation of the approach ; Function that returns true if sum of first n - 1 elements of the array is equal to the last element ; Find the sum of first n - 1 elements of the array ; If sum equals to the last element ; Driver code", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 37, "comesFrom", ["i"], [27]], ["i", 44, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 109, "comesFrom", ["n"], [88]], ["n", 53, "comesFrom", ["n"], [16]], ["sum", 49, "comesFrom", ["sum"], [40]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int perfectSquares ( int a , int b ) { return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; } int countOnes ( int arr [ ] , int n ) { return perfectSquares ( 1 , n ) ; } int main ( ) { int N = 10 ; int arr [ 10 ] = { 0 } ; cout << countOnes ( arr , N ) ; return 0 ; }", "docstring": "Count number of 1 s in the array after N moves | C ++ implementation of the above approach ; Function to count number of perfect squares ; Counting number of perfect squares between a and b ; Function to count number of 1 s in array after N moves ; Driver Code ; Initialize array size ; Initialize all elements to 0", "dfg": [["n", 56, "comesFrom", ["n"], [48]], ["N", 86, "comesFrom", ["N"], [66]], ["b", 23, "comesFrom", ["b"], [14]], ["a", 31, "comesFrom", ["a"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPosition ( int A [ ] , int B [ ] , int sizeOfA , int sizeOfB ) { for ( int i = 1 ; i < sizeOfA ; i ++ ) A [ i ] += A [ i - 1 ] ; for ( int i = 0 ; i < sizeOfB ; i ++ ) { int row = lower_bound ( A , A + sizeOfA , B [ i ] ) - A ; int boxNumber = ( row >= 1 ) ? B [ i ] - A [ row - 1 ] : B [ i ] ; cout << row + 1 << \" , ▁ \" << boxNumber << \" STRNEWLINE \" ; } } int main ( ) { int A [ ] = { 2 , 2 , 2 , 2 } ; int B [ ] = { 1 , 2 , 3 , 4 } ; int sizeOfA = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int sizeOfB = sizeof ( B ) / sizeof ( B [ 0 ] ) ; printPosition ( A , B , sizeOfA , sizeOfB ) ; return 0 ; }", "docstring": "Find the position of box which occupies the given ball | C ++ implementation of the approach ; Function to print the position of each boxes where a ball has to be placed ; Find the cumulative sum of array A [ ] ; Find the position of box for each ball ; Row number ; Column ( position of box in particular row ) ; Row + 1 denotes row if indexing of array start from 1 ; Driver code", "dfg": [["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 60, "comesFrom", ["i"], [56]], ["i", 64, "comesFrom", ["i"], [56]], ["i", 43, "comesFrom", ["i"], [30]], ["i", 48, "comesFrom", ["i"], [30]], ["i", 110, "comesFrom", ["i"], [56]], ["i", 98, "comesFrom", ["i"], [56]], ["i", 81, "comesFrom", ["i"], [56]], ["sizeOfA", 36, "comesFrom", ["sizeOfA"], [21]], ["sizeOfA", 204, "comesFrom", ["sizeOfA"], [167]], ["sizeOfA", 77, "comesFrom", ["sizeOfA"], [21]], ["sizeOfB", 62, "comesFrom", ["sizeOfB"], [24]], ["sizeOfB", 206, "comesFrom", ["sizeOfB"], [183]], ["boxNumber", 123, "comesFrom", ["boxNumber"], [88]], ["row", 91, "comesFrom", ["row"], [69]], ["row", 115, "comesFrom", ["row"], [69]], ["row", 103, "comesFrom", ["row"], [69]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void primeFactors ( int n , int freq [ ] ) { int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; } int getMaximumPower ( int n , int m ) { int freq1 [ n + 1 ] , freq2 [ m + 1 ] ; memset ( freq1 , 0 , sizeof freq1 ) ; memset ( freq2 , 0 , sizeof freq2 ) ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; int maxi = 0 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] ) { maxi = max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; } int main ( ) { int n = 48 , m = 4 ; cout << getMaximumPower ( n , m ) ; return 0 ; }", "docstring": "Highest power of a number that divides other number | C ++ program to implement the above approach ; Function to get the prime factors and its count of times it divides ; Count the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , count i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to return the highest power ; Initialize two arrays ; Get the prime factors of n and m ; Iterate and find the maximum power ; If i not a prime factor of n and m ; If i is a prime factor of n and m If count of i dividing m is more than i dividing n , then power will be 0 ; If i is a prime factor of M ; get the maximum power ; Drivers code", "dfg": [["maxi", 256, "comesFrom", ["maxi"], [236]], ["maxi", 240, "comesFrom", ["maxi"], [236]], ["cnt", 48, "comesFrom", ["cnt"], [20]], ["cnt", 33, "comesFrom", ["cnt"], [20]], ["cnt", 99, "comesFrom", ["cnt"], [71]], ["cnt", 84, "comesFrom", ["cnt"], [71]], ["i", 57, "comesFrom", ["i"], [53]], ["i", 187, "comesFrom", ["i"], [183]], ["i", 191, "comesFrom", ["i"], [183]], ["i", 66, "comesFrom", ["i"], [64]], ["i", 79, "comesFrom", ["i"], [64]], ["i", 96, "comesFrom", ["i"], [64]], ["i", 232, "comesFrom", ["i"], [183]], ["i", 91, "comesFrom", ["i"], [64]], ["i", 217, "comesFrom", ["i"], [183]], ["i", 222, "comesFrom", ["i"], [183]], ["i", 199, "comesFrom", ["i"], [183]], ["i", 206, "comesFrom", ["i"], [183]], ["i", 244, "comesFrom", ["i"], [183]], ["i", 249, "comesFrom", ["i"], [183]], ["m", 189, "comesFrom", ["m"], [123]], ["m", 136, "comesFrom", ["m"], [123]], ["m", 170, "comesFrom", ["m"], [123]], ["m", 279, "comesFrom", ["m"], [269]], ["n", 104, "comesFrom", ["n"], [87]], ["n", 129, "comesFrom", ["n"], [120]], ["n", 163, "comesFrom", ["n"], [120]], ["n", 26, "comesFrom", ["n"], [11]], ["n", 61, "comesFrom", ["n"], [36]], ["n", 277, "comesFrom", ["n"], [265]], ["n", 38, "comesFrom", ["n"], [36]], ["n", 110, "comesFrom", ["n"], [87]], ["n", 77, "comesFrom", ["n"], [36]], ["n", 89, "comesFrom", ["n"], [87]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findDivisors ( int n ) { int div [ n + 1 ] ; memset ( div , 0 , sizeof div ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) cout << div [ i ] << \" ▁ \" ; } int main ( ) { int n = 10 ; findDivisors ( n ) ; return 0 ; }", "docstring": "Find the number of divisors of all numbers in the range [ 1 , n ] | C ++ implementation of the approach ; Function to find the number of divisors of all numbers in the range [ 1 , n ] ; Array to store the count of divisors ; For every number from 1 to n ; Increase divisors count for every number divisible by i ; Print the divisors ; Driver code", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 79, "comesFrom", ["i"], [75]], ["i", 83, "comesFrom", ["i"], [75]], ["i", 56, "comesFrom", ["i"], [35]], ["i", 90, "comesFrom", ["i"], [75]], ["i", 65, "comesFrom", ["i"], [35]], ["n", 41, "comesFrom", ["n"], [11]], ["n", 81, "comesFrom", ["n"], [11]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 110, "comesFrom", ["n"], [104]], ["n", 58, "comesFrom", ["n"], [11]], ["j", 60, "comesFrom", ["j"], [50]], ["j", 54, "comesFrom", ["j"], [50]], ["j", 67, "comesFrom", ["j"], [50]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int decideWinner ( int a [ ] , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; } int main ( ) { int a [ ] = { 4 , 8 , 5 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( decideWinner ( a , n ) == 1 ) cout << \" X ▁ wins \" ; else cout << \" Y ▁ wins \" ; return 0 ; }", "docstring": "Predict the winner of the game on the basis of absolute difference of sum by selecting numbers | C ++ implementation of the approach ; Function to decide the winner ; Iterate for all numbers in the array ; If mod gives 0 ; If mod gives 1 ; If mod gives 2 ; If mod gives 3 ; Check the winning condition for X ; Driver code", "dfg": [["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 58, "comesFrom", ["i"], [42]], ["i", 73, "comesFrom", ["i"], [42]], ["i", 88, "comesFrom", ["i"], [42]], ["i", 103, "comesFrom", ["i"], [42]], ["n", 48, "comesFrom", ["n"], [16]], ["n", 188, "comesFrom", ["n"], [167]], ["count3", 134, "comesFrom", ["count3"], [35]], ["count3", 110, "comesFrom", ["count3"], [35]], ["count0", 65, "comesFrom", ["count0"], [20]], ["count0", 116, "comesFrom", ["count0"], [20]], ["count2", 128, "comesFrom", ["count2"], [30]], ["count2", 95, "comesFrom", ["count2"], [30]], ["count1", 80, "comesFrom", ["count1"], [25]], ["count1", 122, "comesFrom", ["count1"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 2 ; cout << CntDivbyX ( arr , n , x ) ; return 0 ; }", "docstring": "Count all prefixes of the given binary array which are divisible by x | C ++ implementation of the approach ; Function to return the count of total binary prefix which are divisible by x ; Initialize with zero ; Instead of converting all prefixes to decimal , take reminder with x ; If number is divisible by x then reminder = 0 ; Driver code", "dfg": [["count", 74, "comesFrom", ["count"], [68]], ["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 56, "comesFrom", ["i"], [35]], ["n", 41, "comesFrom", ["n"], [16]], ["n", 130, "comesFrom", ["n"], [104]], ["x", 132, "comesFrom", ["x"], [120]], ["x", 60, "comesFrom", ["x"], [19]], ["number", 64, "comesFrom", ["number"], [47]], ["number", 50, "comesFrom", ["number"], [47]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return -1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return -1 ; } int main ( ) { int K = 7 ; cout << numLen ( K ) ; return 0 ; }", "docstring": "Length of the smallest number which is divisible by K and formed by using 1 's only | C ++ implementation of the approach ; Function to return length of the resultant number ; If K is a multiple of 2 or 5 ; Instead of generating all possible numbers 1 , 11 , 111 , 111 , ... , K 1 's  Take remainder with K ; If number is divisible by k then remainder will be 0 ; Driver code", "dfg": [["len", 46, "comesFrom", ["len"], [42]], ["len", 50, "comesFrom", ["len"], [42]], ["len", 73, "comesFrom", ["len"], [42]], ["K", 48, "comesFrom", ["K"], [11]], ["K", 94, "comesFrom", ["K"], [86]], ["K", 16, "comesFrom", ["K"], [11]], ["K", 21, "comesFrom", ["K"], [11]], ["K", 64, "comesFrom", ["K"], [11]], ["number", 68, "comesFrom", ["number"], [54]], ["number", 57, "comesFrom", ["number"], [54]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE const ll max_Element = 1e6 + 5 ; int sum1 [ max_Element ] , sum2 [ max_Element ] , sum3 [ max_Element ] ; void precomputation ( int arr [ ] , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) cout << sum3 [ arr [ i ] ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 9 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; precomputation ( arr , n ) ; return 0 ; }", "docstring": "Sum of multiplication of triplet of divisors of a number | C ++ implementation of the approach ; Global array declaration ; Function to find the sum of multiplication of every triplet in the divisors of a number ; sum1 [ x ] represents the sum of all the divisors of x ; Adding i to sum1 [ j ] because i is a divisor of j ; sum2 [ x ] represents the sum of all the divisors of x ; Here i is divisor of j and sum1 [ j ] - i represents sum of all divisors of j which do not include i so we add i * ( sum1 [ j ] - i ) to sum2 [ j ] ; In the above implementation we have considered every pair two times so we have to divide every sum2 array element by 2 ; Here i is the divisor of j and we are trying to add the sum of multiplication of all triplets of divisors of j such that one of the divisors is i ; In the above implementation we have considered every triplet three times so we have to divide every sum3 array element by 3 ; Print the results ; Driver code ; Precomputing", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fib ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; } int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } int main ( ) { int l = 4 , r = 8 ; cout << calculateSum ( l , r ) ; return 0 ; }", "docstring": "Sum of Fibonacci Numbers in a range | C ++ implementation of the approach ; Function to return the nth Fibonacci number ; Function to return the required sum ; Using our deduced result ; Driver code", "dfg": [["sum", 73, "comesFrom", ["sum"], [56]], ["l", 94, "comesFrom", ["l"], [82]], ["l", 67, "comesFrom", ["l"], [49]], ["r", 96, "comesFrom", ["r"], [86]], ["r", 60, "comesFrom", ["r"], [52]], ["phi", 33, "comesFrom", ["phi"], [15]], ["n", 35, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( a == d && a ) || ( a == 0 && c == 0 && d == 0 ) ) { for ( int i = 1 ; i <= a ; i ++ ) cout << \" ( ( \" ; for ( int i = 1 ; i <= c ; i ++ ) cout << \" ) ( \" ; for ( int i = 1 ; i <= d ; i ++ ) cout << \" ) ) \" ; for ( int i = 1 ; i <= b ; i ++ ) cout << \" ( ) \" ; } else cout << -1 ; } int main ( ) { int a = 3 , b = 1 , c = 4 , d = 3 ; printBalancedExpression ( a , b , c , d ) ; return 0 ; }", "docstring": "Print the balanced bracket expression using given brackets | C ++ implementation of the approach ; Function to print balanced bracket expression if it is possible ; If the condition is met ; Print brackets of type - 1 ; Print brackets of type - 3 ; Print brackets of type - 4 ; Print brackets of type - 2 ; If the condition is not met ; Driver code", "dfg": [["a", 159, "comesFrom", ["a"], [141]], ["a", 57, "comesFrom", ["a"], [11]], ["a", 30, "comesFrom", ["a"], [11]], ["a", 26, "comesFrom", ["a"], [11]], ["a", 34, "comesFrom", ["a"], [11]], ["b", 161, "comesFrom", ["b"], [145]], ["b", 117, "comesFrom", ["b"], [14]], ["c", 163, "comesFrom", ["c"], [149]], ["c", 77, "comesFrom", ["c"], [17]], ["c", 38, "comesFrom", ["c"], [17]], ["d", 165, "comesFrom", ["d"], [153]], ["d", 97, "comesFrom", ["d"], [20]], ["d", 28, "comesFrom", ["d"], [20]], ["d", 42, "comesFrom", ["d"], [20]], ["i", 55, "comesFrom", ["i"], [51]], ["i", 59, "comesFrom", ["i"], [51]], ["i", 75, "comesFrom", ["i"], [71]], ["i", 79, "comesFrom", ["i"], [71]], ["i", 95, "comesFrom", ["i"], [91]], ["i", 99, "comesFrom", ["i"], [91]], ["i", 115, "comesFrom", ["i"], [111]], ["i", 119, "comesFrom", ["i"], [111]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll factorial ( int f ) { ll fact = 1 ; for ( int i = 2 ; i <= f ; i ++ ) fact *= ( ll ) i ; return fact ; } ll findPermutation ( int N , int M ) { ll permutation = factorial ( N + M - 1 ) / ( factorial ( N ) * factorial ( M - 1 ) ) ; return permutation ; } int main ( ) { int N = 3 , M = 3 ; cout << findPermutation ( N , M ) ; return 0 ; }", "docstring": "Count numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros | C ++ implementation of the approach ; Function to return the factorial of a number ; Function to return the count of distinct ( N + M ) digit numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; } int main ( ) { int n = 4 ; cout << maxValue ( n ) ; return 0 ; }", "docstring": "Maximum value of | arr [ 0 ] | C ++ implementation of the approach ; Function to return the maximum required value ; Driver code", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 51, "comesFrom", ["n"], [43]], ["n", 26, "comesFrom", ["n"], [11]], ["n", 28, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ull  unsigned long long NEW_LINE void findCount ( int n ) { ull a = 1 , b = 0 , c = 0 ; int x = n / 60 ; a = ( ull ) pow ( 32 , x ) ; x = 60 * x ; for ( int i = x + 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { b += a ; a = 0 ; } if ( i % 5 == 0 ) { c += b ; b = 0 ; } if ( i % 12 == 0 ) { a += ( 2 * c ) ; c = 0 ; } } cout << \" a ▁ = ▁ \" << a << \" , ▁ \" ; cout << \" b ▁ = ▁ \" << b << \" , ▁ \" ; cout << \" c ▁ = ▁ \" << c ; } int main ( ) { int n = 72 ; findCount ( n ) ; return 0 ; }", "docstring": "Count of a , b & c after n seconds for given reproduction rate | C ++ implementation of the approach ; Function to print the count of a , b and c after n seconds ; Number of multiples of 60 below n ; Multiple of 60 nearest to n ; Change all a to b ; Change all b to c ; Change each c to two a ; Print the updated values of a , b and c ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; } int gcdOfFactorial ( int arr [ ] , int n ) { int minm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ; return factorial ( minm ) ; } int main ( ) { int arr [ ] = { 9 , 12 , 122 , 34 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << gcdOfFactorial ( arr , n ) ; return 0 ; }", "docstring": "Find GCD of factorial of elements of given array | C ++ implementation of the above approach ; Implementation of factorial function ; Function to find GCD of factorial of elements from array ; find the minimum element of array ; return the factorial of minimum element ; Driver Code", "dfg": [["i", 63, "comesFrom", ["i"], [59]], ["i", 67, "comesFrom", ["i"], [59]], ["i", 81, "comesFrom", ["i"], [59]], ["i", 76, "comesFrom", ["i"], [59]], ["n", 65, "comesFrom", ["n"], [45]], ["n", 33, "comesFrom", ["n"], [11]], ["n", 137, "comesFrom", ["n"], [116]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 28, "comesFrom", ["n"], [11]], ["minm", 89, "comesFrom", ["minm"], [70]], ["minm", 84, "comesFrom", ["minm"], [70]], ["minm", 72, "comesFrom", ["minm"], [70]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( ll ) pow ( n , n ) + sum ( n - 1 ) ) ; } int main ( ) { int n = 2 ; cout << sum ( n ) ; return 0 ; }", "docstring": "Sum of the series 1 ^ 1 + 2 ^ 2 + 3 ^ 3 + ... . . + n ^ n using recursion | C ++ implementation of the approach ; Recursive function to return the sum of the given series ; 1 ^ 1 = 1 ; Recursive call ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; const int mod = 1000000007 ; ll power ( ll a , ll n ) { if ( n == 0 ) return 1 ; ll p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n & 1 ) p = ( p * a ) % mod ; return p ; } int countPermutations ( int n ) { if ( n == 1 ) { return 0 ; } return ( power ( 2 , n - 1 ) - 2 ) % mod ; } int main ( ) { int n = 5 ; cout << countPermutations ( n ) ; return 0 ; }", "docstring": "Count permutations that are first decreasing then increasing . | C ++ implementation of the above approach ; Function to compute a ^ n % mod ; Function to count permutations that are first decreasing and then increasing ; For n = 1 return 0 ; Calculate and return result ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long numbers ( int n ) { return ( long long ) ( pow ( 2 , n + 1 ) ) - 2 ; } int main ( ) { int n = 2 ; cout << numbers ( n ) ; return 0 ; }", "docstring": "Find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . | Cpp program to find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . ; Function to find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . ; Driver code", "dfg": [["n", 48, "comesFrom", ["n"], [40]], ["n", 25, "comesFrom", ["n"], [12]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long NumberofWays ( int n ) { long long x = ( 1LL * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; long long y = ( 1LL * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ; return ( 1LL * x * y ) ; } int main ( ) { int n = 4 ; cout << NumberofWays ( n ) ; return 0 ; }", "docstring": "Ways to place 4 items in n ^ 2 positions such that no row / column contains more than one | C ++ implementation of the approach ; Function to return the number of ways to place 4 items in n ^ 2 positions ; Driver code", "dfg": [["y", 91, "comesFrom", ["y"], [57]], ["x", 89, "comesFrom", ["x"], [17]], ["n", 109, "comesFrom", ["n"], [101]], ["n", 79, "comesFrom", ["n"], [12]], ["n", 39, "comesFrom", ["n"], [12]], ["n", 73, "comesFrom", ["n"], [12]], ["n", 33, "comesFrom", ["n"], [12]], ["n", 63, "comesFrom", ["n"], [12]], ["n", 67, "comesFrom", ["n"], [12]], ["n", 23, "comesFrom", ["n"], [12]], ["n", 27, "comesFrom", ["n"], [12]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; } int main ( ) { int N = 5 ; cout << nthTerm ( N ) << endl ; return 0 ; }", "docstring": "Find Nth term of the series 1 , 6 , 18 , 40 , 75 , ... . | CPP code to generate ' Nth ' term of this sequence ; Function to generate a fixed number ; ( N ^ 2 * ( N + 1 ) ) / 2 ; Driver Method", "dfg": [["nth", 36, "comesFrom", ["nth"], [19]], ["N", 53, "comesFrom", ["N"], [45]], ["N", 22, "comesFrom", ["N"], [11]], ["N", 24, "comesFrom", ["N"], [11]], ["N", 27, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { cout << ( ( 2 * i ) - 1 ) << \" ▁ \" ; i ++ ; } } int main ( ) { int n = 3 ; findNumbers ( n ) ; }", "docstring": "Print n numbers such that their sum is a perfect square | C ++ implementation of the approach ; Function to print n numbers such that their sum is a perfect square ; Print ith odd number ; Driver code", "dfg": [["i", 21, "comesFrom", ["i"], [15]], ["i", 42, "comesFrom", ["i"], [15]], ["i", 32, "comesFrom", ["i"], [15]], ["n", 23, "comesFrom", ["n"], [11]], ["n", 59, "comesFrom", ["n"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMissingNums ( int even [ ] , int sizeEven , int odd [ ] , int sizeOdd ) { int minEven = INT_MAX ; int maxEven = INT_MIN ; int minOdd = INT_MAX ; int maxOdd = INT_MIN ; int sumEvenArr = 0 , sumOddArr = 0 ; for ( int i = 0 ; i < sizeEven ; i ++ ) { minEven = min ( minEven , even [ i ] ) ; maxEven = max ( maxEven , even [ i ] ) ; sumEvenArr += even [ i ] ; } for ( int i = 0 ; i < sizeOdd ; i ++ ) { minOdd = min ( minOdd , odd [ i ] ) ; maxOdd = max ( maxOdd , odd [ i ] ) ; sumOddArr += odd [ i ] ; } int totalTerms = 0 , reqSum = 0 ; totalTerms = minEven / 2 ; int evenSumMin = totalTerms * ( totalTerms + 1 ) ; totalTerms = maxEven / 2 ; int evenSumMax = totalTerms * ( totalTerms + 1 ) ; reqSum = evenSumMax - evenSumMin + minEven ; cout << \" Even ▁ = ▁ \" << reqSum - sumEvenArr << \" STRNEWLINE \" ; totalTerms = ( minOdd / 2 ) + 1 ; int oddSumMin = totalTerms * totalTerms ; totalTerms = ( maxOdd / 2 ) + 1 ; int oddSumMax = totalTerms * totalTerms ; reqSum = oddSumMax - oddSumMin + minOdd ; cout << \" Odd ▁ = ▁ \" << reqSum - sumOddArr ; } int main ( ) { int even [ ] = { 6 , 4 , 8 , 14 , 10 } ; int sizeEven = sizeof ( even ) / sizeof ( even [ 0 ] ) ; int odd [ ] = { 7 , 5 , 3 , 11 , 13 } ; int sizeOdd = sizeof ( odd ) / sizeof ( odd [ 0 ] ) ; findMissingNums ( even , sizeEven , odd , sizeOdd ) ; return 0 ; }", "docstring": "Missing even and odd elements from the given arrays | C ++ implementation of the approach ; Function to find the missing numbers ; To store the minimum and the maximum odd and even elements from the arrays ; To store the sum of the array elements ; Get the minimum and the maximum even elements from the array ; Get the minimum and the maximum odd elements from the array ; To store the total terms in the series and the required sum of the array ; Total terms from 2 to minEven ; Sum of all even numbers from 2 to minEven ; Total terms from 2 to maxEven ; Sum of all even numbers from 2 to maxEven ; Required sum for the even array ; Missing even number ; Total terms from 1 to minOdd ; Sum of all odd numbers from 1 to minOdd ; Total terms from 1 to maxOdd ; Sum of all odd numbers from 1 to maxOdd ; Required sum for the odd array ; Missing odd number ; Driver code", "dfg": [["i", 63, "comesFrom", ["i"], [59]], ["i", 67, "comesFrom", ["i"], [59]], ["i", 110, "comesFrom", ["i"], [106]], ["i", 114, "comesFrom", ["i"], [106]], ["i", 99, "comesFrom", ["i"], [59]], ["i", 146, "comesFrom", ["i"], [106]], ["i", 79, "comesFrom", ["i"], [59]], ["i", 91, "comesFrom", ["i"], [59]], ["i", 126, "comesFrom", ["i"], [106]], ["i", 138, "comesFrom", ["i"], [106]], ["sizeEven", 65, "comesFrom", ["sizeEven"], [16]], ["sizeEven", 343, "comesFrom", ["sizeEven"], [291]], ["sizeOdd", 112, "comesFrom", ["sizeOdd"], [24]], ["sizeOdd", 347, "comesFrom", ["sizeOdd"], [324]], ["minEven", 161, "comesFrom", ["minEven"], [71]], ["minEven", 199, "comesFrom", ["minEven"], [71]], ["minEven", 75, "comesFrom", ["minEven"], [71]], ["totalTerms", 168, "comesFrom", ["totalTerms"], [159]], ["totalTerms", 185, "comesFrom", ["totalTerms"], [176]], ["totalTerms", 228, "comesFrom", ["totalTerms"], [215]], ["totalTerms", 230, "comesFrom", ["totalTerms"], [215]], ["totalTerms", 245, "comesFrom", ["totalTerms"], [232]], ["totalTerms", 247, "comesFrom", ["totalTerms"], [232]], ["totalTerms", 171, "comesFrom", ["totalTerms"], [159]], ["totalTerms", 188, "comesFrom", ["totalTerms"], [176]], ["maxEven", 178, "comesFrom", ["maxEven"], [83]], ["maxEven", 87, "comesFrom", ["maxEven"], [83]], ["minOdd", 255, "comesFrom", ["minOdd"], [118]], ["minOdd", 218, "comesFrom", ["minOdd"], [118]], ["minOdd", 122, "comesFrom", ["minOdd"], [118]], ["reqSum", 263, "comesFrom", ["reqSum"], [249]], ["reqSum", 207, "comesFrom", ["reqSum"], [193]], ["sumOddArr", 265, "comesFrom", ["sumOddArr"], [142]], ["evenSumMax", 195, "comesFrom", ["evenSumMax"], [183]], ["evenSumMin", 197, "comesFrom", ["evenSumMin"], [166]], ["sumEvenArr", 209, "comesFrom", ["sumEvenArr"], [95]], ["oddSumMax", 251, "comesFrom", ["oddSumMax"], [243]], ["oddSumMin", 253, "comesFrom", ["oddSumMin"], [226]], ["maxOdd", 235, "comesFrom", ["maxOdd"], [130]], ["maxOdd", 134, "comesFrom", ["maxOdd"], [130]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; } int main ( ) { int x = 6 , y = 5 ; cout << findMinimum ( x , y ) ; return 0 ; }", "docstring": "Minimum matches the team needs to win to qualify | C ++ implementation of the approach ; Function to return the minimum number of matches to win to qualify for next round ; Do a binary search to find ; Find mid element ; Check for condition to qualify for next round ; Driver Code", "dfg": [["low", 75, "comesFrom", ["low"], [67]], ["low", 28, "comesFrom", ["low"], [18]], ["low", 37, "comesFrom", ["low"], [18]], ["high", 30, "comesFrom", ["high"], [22]], ["high", 39, "comesFrom", ["high"], [22]], ["x", 96, "comesFrom", ["x"], [84]], ["x", 58, "comesFrom", ["x"], [11]], ["y", 98, "comesFrom", ["y"], [88]], ["y", 52, "comesFrom", ["y"], [24]], ["mid", 62, "comesFrom", ["mid"], [34]], ["mid", 69, "comesFrom", ["mid"], [34]], ["mid", 47, "comesFrom", ["mid"], [34]], ["mid", 54, "comesFrom", ["mid"], [34]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void getResult ( int n ) { int proOdd = 1 ; int proEven = 1 ; string num = to_string ( n ) ; for ( int i = 0 ; i < num . size ( ) ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num [ i ] - '0' ) ; else proEven = proEven * ( num [ i ] - '0' ) ; if ( proOdd == proEven ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int n = 4324 ; getResult ( n ) ; return 0 ; }", "docstring": "Check if product of digits of a number at even and odd places is equal | C ++ implementation of the approach ; To store the respective product ; Converting integer to string ; Traversing the string ; Driver code", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 47, "comesFrom", ["i"], [35]], ["i", 52, "comesFrom", ["i"], [35]], ["i", 65, "comesFrom", ["i"], [35]], ["i", 81, "comesFrom", ["i"], [35]], ["proOdd", 91, "comesFrom", ["proOdd"], [58]], ["proOdd", 60, "comesFrom", ["proOdd"], [58]], ["proEven", 93, "comesFrom", ["proEven"], [74]], ["proEven", 76, "comesFrom", ["proEven"], [74]], ["n", 121, "comesFrom", ["n"], [115]], ["n", 29, "comesFrom", ["n"], [11]], ["num", 41, "comesFrom", ["num"], [25]], ["num", 63, "comesFrom", ["num"], [25]], ["num", 79, "comesFrom", ["num"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; } int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; } return count ; } int main ( ) { int l = 1000 , r = 6000 ; cout << countNumbers ( l , r ) ; return 0 ; }", "docstring": "Count of all even numbers in the range [ L , R ] whose sum of digits is divisible by 3 | C ++ implementation of the approach ; Function to return the sum of digits of x ; Function to return the count of required numbers ; If i is divisible by 2 and sum of digits of i is divisible by 3 ; Return the required count ; Driver code", "dfg": [["sum", 40, "comesFrom", ["sum"], [26]], ["count", 95, "comesFrom", ["count"], [54]], ["count", 90, "comesFrom", ["count"], [54]], ["i", 65, "comesFrom", ["i"], [61]], ["i", 69, "comesFrom", ["i"], [61]], ["i", 75, "comesFrom", ["i"], [61]], ["i", 83, "comesFrom", ["i"], [61]], ["r", 67, "comesFrom", ["r"], [50]], ["r", 118, "comesFrom", ["r"], [108]], ["x", 21, "comesFrom", ["x"], [11]], ["x", 28, "comesFrom", ["x"], [11]], ["x", 34, "comesFrom", ["x"], [32]], ["l", 116, "comesFrom", ["l"], [104]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; } int main ( ) { int arr [ ] = { 3 , 5 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSum ( arr , n ) ; return 0 ; }", "docstring": "Sum of minimum element of all subarrays of a sorted array | C ++ implementation of the above approach ; Function to find the sum of minimum of all subarrays ; Driver code", "dfg": [["sum", 52, "comesFrom", ["sum"], [38]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 42, "comesFrom", ["i"], [27]], ["i", 48, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 97, "comesFrom", ["n"], [76]], ["n", 46, "comesFrom", ["n"], [16]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLenSubArr ( int a [ ] , int n ) { int count , j ; int cm = 1 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( int i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; } int main ( ) { int arr [ ] = { 6 , 1 , 6 , 6 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxLenSubArr ( arr , n ) ; return 0 ; }", "docstring": "Longest Sub | C ++ implementation of the approach ; Function to return the max length of the sub - array that have the maximum average ( average value of the elements ) ; Finding the maximum value ; If consecutive maximum found ; Find the max length of consecutive max ; Driver code", "dfg": [["cm", 160, "comesFrom", ["cm"], [149]], ["cm", 147, "comesFrom", ["cm"], [25]], ["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 72, "comesFrom", ["i"], [68]], ["i", 155, "comesFrom", ["i"], [68]], ["i", 52, "comesFrom", ["i"], [36]], ["i", 61, "comesFrom", ["i"], [36]], ["i", 110, "comesFrom", ["i"], [68]], ["i", 88, "comesFrom", ["i"], [68]], ["i", 100, "comesFrom", ["i"], [68]], ["i", 93, "comesFrom", ["i"], [68]], ["i", 135, "comesFrom", ["i"], [68]], ["n", 42, "comesFrom", ["n"], [16]], ["n", 74, "comesFrom", ["n"], [16]], ["n", 207, "comesFrom", ["n"], [186]], ["n", 116, "comesFrom", ["n"], [16]], ["max", 55, "comesFrom", ["max"], [29]], ["max", 103, "comesFrom", ["max"], [57]], ["max", 129, "comesFrom", ["max"], [57]], ["j", 114, "comesFrom", ["j"], [108]], ["j", 118, "comesFrom", ["j"], [108]], ["j", 126, "comesFrom", ["j"], [108]], ["count", 145, "comesFrom", ["count"], [80]], ["count", 151, "comesFrom", ["count"], [80]], ["count", 132, "comesFrom", ["count"], [80]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll minSum ( int arr [ ] , int n , int x ) { ll sum = 0 ; int largestDivisible = -1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == -1 ) return sum ; ll sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return min ( sum , sumAfterOperation ) ; } int main ( ) { int arr [ ] = { 5 , 5 , 5 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; cout << minSum ( arr , n , x ) ; return 0 ; }", "docstring": "Minimum possible sum of array elements after performing the given operation | C ++ implementation of the approach ; Function to return the minimized sum ; To store the largest element from the array which is divisible by x ; Sum of array elements before performing any operation ; If current element is divisible by x and it is maximum so far ; Update the minimum element ; If no element can be reduced then there 's no point  in performing the operation as we will end up  increasing the sum when an element is multiplied by x ; Subtract the chosen elements from the sum and then add their updated values ; Return the minimized sum ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } } int main ( ) { int L = 1 , R = 632 ; cout << maxAND ( L , R ) ; return 0 ; }", "docstring": "Maximum Bitwise AND pair from given range | C ++ implementation of the approach ; Function to return the maximum bitwise AND possible among all the possible pairs ; If there is only a single value in the range [ L , R ] ; If there are only two values in the range [ L , R ] ; Driver code", "dfg": [["L", 24, "comesFrom", ["L"], [11]], ["L", 19, "comesFrom", ["L"], [11]], ["L", 119, "comesFrom", ["L"], [107]], ["L", 41, "comesFrom", ["L"], [11]], ["L", 32, "comesFrom", ["L"], [11]], ["R", 21, "comesFrom", ["R"], [14]], ["R", 121, "comesFrom", ["R"], [111]], ["R", 39, "comesFrom", ["R"], [14]], ["R", 30, "comesFrom", ["R"], [14]], ["R", 80, "comesFrom", ["R"], [14]], ["R", 55, "comesFrom", ["R"], [14]], ["R", 75, "comesFrom", ["R"], [14]], ["R", 50, "comesFrom", ["R"], [14]], ["R", 60, "comesFrom", ["R"], [14]], ["R", 66, "comesFrom", ["R"], [14]], ["R", 87, "comesFrom", ["R"], [14]], ["R", 93, "comesFrom", ["R"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkSpecialPrime ( bool * sieve , int num ) { while ( num ) { if ( ! sieve [ num ] ) { return false ; } num /= 10 ; } return true ; } void findSpecialPrime ( int N ) { bool sieve [ N * 10 ] ; memset ( sieve , true , sizeof ( sieve ) ) ; sieve [ 0 ] = sieve [ 1 ] = false ; for ( long long i = 2 ; i <= N * 10 ; i ++ ) { if ( sieve [ i ] ) { for ( long long j = i * i ; j <= N * 10 ; j += i ) { sieve [ j ] = false ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { cout << N << ' ' ; break ; } else N ++ ; } } int main ( ) { int N = 379 ; findSpecialPrime ( N ) ; N = 100 ; findSpecialPrime ( N ) ; return 0 ; }", "docstring": "Smallest Special Prime which is greater than or equal to a given number | CPP program to find the Smallest Special Prime which is greater than or equal to a given number ; Function to check whether the number is a special prime or not ; While number is not equal to zero ; If the number is not prime return false . ; Else remove the last digit by dividing the number by 10. ; If the number has become zero then the number is special prime , hence return true ; Function to find the Smallest Special Prime which is greater than or equal to a given number ; Initially all numbers are considered Primes . ; There is always an answer possible ; Checking if the number is a special prime or not ; If yes print the number and break the loop . ; Else increment the number . ; Driver code", "dfg": [["num", 20, "comesFrom", ["num"], [15]], ["num", 28, "comesFrom", ["num"], [15]], ["i", 92, "comesFrom", ["i"], [88]], ["i", 98, "comesFrom", ["i"], [88]], ["i", 106, "comesFrom", ["i"], [88]], ["i", 128, "comesFrom", ["i"], [88]], ["i", 116, "comesFrom", ["i"], [88]], ["i", 118, "comesFrom", ["i"], [88]], ["N", 55, "comesFrom", ["N"], [49]], ["N", 94, "comesFrom", ["N"], [49]], ["N", 185, "comesFrom", ["N"], [179]], ["N", 194, "comesFrom", ["N"], [188]], ["N", 152, "comesFrom", ["N"], [49]], ["N", 168, "comesFrom", ["N"], [49]], ["N", 122, "comesFrom", ["N"], [49]], ["N", 158, "comesFrom", ["N"], [49]], ["j", 120, "comesFrom", ["j"], [114]], ["j", 133, "comesFrom", ["j"], [126]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMoves ( long long n ) { string s = to_string ( n ) ; int ans = INT_MAX ; int len = s . size ( ) ; for ( int i = 0 ; i < len ; ++ i ) { for ( int j = 0 ; j < len ; ++ j ) { if ( i == j ) continue ; string t = s ; int cur = 0 ; for ( int k = i ; k < len - 1 ; ++ k ) { swap ( t [ k ] , t [ k + 1 ] ) ; ++ cur ; } for ( int k = j - ( j > i ) ; k < len - 2 ; ++ k ) { swap ( t [ k ] , t [ k + 1 ] ) ; ++ cur ; } int pos = -1 ; for ( int k = 0 ; k < len ; ++ k ) { if ( t [ k ] != '0' ) { pos = k ; break ; } } for ( int k = pos ; k > 0 ; -- k ) { swap ( t [ k ] , t [ k - 1 ] ) ; ++ cur ; } long long nn = atoll ( t . c_str ( ) ) ; if ( nn % 25 == 0 ) ans = min ( ans , cur ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; } int main ( ) { long long n = 509201 ; cout << minMoves ( n ) ; return 0 ; }", "docstring": "Minimum number of given moves required to make N divisible by 25 | C ++ implementation of the approach ; Function to return the minimum number of moves required to make n divisible by 25 ; Convert number into string ; To store required answer ; Length of the string ; To check all possible pairs ; Make a duplicate string ; Number of swaps required to place ith digit in last position ; Number of swaps required to place jth digit in 2 nd last position ; Find first non zero digit ; Place first non zero digit in the first position ; Convert string to number ; If this number is divisible by 25 then cur is one of the possible answer ; If not possible ; Driver code", "dfg": [["ans", 279, "comesFrom", ["ans"], [258]], ["ans", 271, "comesFrom", ["ans"], [258]], ["ans", 262, "comesFrom", ["ans"], [258]], ["i", 44, "comesFrom", ["i"], [40]], ["i", 49, "comesFrom", ["i"], [40]], ["i", 69, "comesFrom", ["i"], [40]], ["i", 131, "comesFrom", ["i"], [90]], ["len", 46, "comesFrom", ["len"], [29]], ["len", 61, "comesFrom", ["len"], [29]], ["len", 177, "comesFrom", ["len"], [29]], ["len", 94, "comesFrom", ["len"], [29]], ["len", 136, "comesFrom", ["len"], [29]], ["INT_MAX", 273, "comesFrom", ["INT_MAX"], [26]], ["n", 20, "comesFrom", ["n"], [12]], ["n", 297, "comesFrom", ["n"], [289]], ["s", 31, "comesFrom", ["s"], [16]], ["j", 59, "comesFrom", ["j"], [55]], ["j", 64, "comesFrom", ["j"], [55]], ["j", 71, "comesFrom", ["j"], [55]], ["j", 126, "comesFrom", ["j"], [55]], ["j", 129, "comesFrom", ["j"], [55]], ["k", 92, "comesFrom", ["k"], [88]], ["k", 99, "comesFrom", ["k"], [88]], ["k", 134, "comesFrom", ["k"], [124]], ["k", 141, "comesFrom", ["k"], [124]], ["k", 175, "comesFrom", ["k"], [171]], ["k", 180, "comesFrom", ["k"], [171]], ["k", 210, "comesFrom", ["k"], [206]], ["k", 215, "comesFrom", ["k"], [206]], ["k", 197, "comesFrom", ["k"], [171]], ["k", 106, "comesFrom", ["k"], [88]], ["k", 148, "comesFrom", ["k"], [124]], ["k", 187, "comesFrom", ["k"], [171]], ["k", 222, "comesFrom", ["k"], [206]], ["k", 111, "comesFrom", ["k"], [88]], ["k", 153, "comesFrom", ["k"], [124]], ["k", 227, "comesFrom", ["k"], [206]], ["cur", 118, "comesFrom", ["cur"], [81]], ["cur", 160, "comesFrom", ["cur"], [81]], ["cur", 234, "comesFrom", ["cur"], [81]], ["cur", 264, "comesFrom", ["cur"], [81]], ["nn", 252, "comesFrom", ["nn"], [239]], ["t", 104, "comesFrom", ["t"], [76]], ["t", 109, "comesFrom", ["t"], [76]], ["t", 146, "comesFrom", ["t"], [76]], ["t", 151, "comesFrom", ["t"], [76]], ["t", 185, "comesFrom", ["t"], [76]], ["t", 220, "comesFrom", ["t"], [76]], ["t", 225, "comesFrom", ["t"], [76]], ["t", 243, "comesFrom", ["t"], [76]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return -1 ; } int main ( ) { int a = 2 , b = 10 , c = 3 ; cout << getMaxNum ( a , b , c ) ; return 0 ; }", "docstring": "Maximum positive integer divisible by C and is in the range [ A , B ] | C ++ implementation of the above approach ; Function to return the required number ; If b % c = 0 then b is the required number ; Else get the maximum multiple of c smaller than b ; Driver code", "dfg": [["b", 29, "comesFrom", ["b"], [14]], ["b", 22, "comesFrom", ["b"], [14]], ["b", 52, "comesFrom", ["b"], [14]], ["b", 86, "comesFrom", ["b"], [72]], ["b", 36, "comesFrom", ["b"], [14]], ["x", 55, "comesFrom", ["x"], [32]], ["x", 46, "comesFrom", ["x"], [32]], ["x", 50, "comesFrom", ["x"], [32]], ["c", 24, "comesFrom", ["c"], [17]], ["c", 41, "comesFrom", ["c"], [17]], ["c", 88, "comesFrom", ["c"], [76]], ["c", 38, "comesFrom", ["c"], [17]], ["a", 48, "comesFrom", ["a"], [11]], ["a", 84, "comesFrom", ["a"], [68]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairs ( int a [ ] ) { int n = sizeof ( a [ 0 ] ) ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; } int main ( ) { int a [ ] = { 2 , 4 , 3 , 1 } ; cout << getPairs ( a ) ; return 0 ; }", "docstring": "Count of pairs ( x , y ) in an array such that x < y | C ++ implementation of the approach ; Function to return the number of pairs ( x , y ) such that x < y ; Length of the array ; Calculate the number valid pairs ; Return the count of valid pairs ; Driver code", "dfg": [["count", 43, "comesFrom", ["count"], [28]], ["n", 31, "comesFrom", ["n"], [17]], ["n", 34, "comesFrom", ["n"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSquares ( int row , int column ) { int topLeft = min ( row , column ) - 1 ; int bottomRight = 8 - max ( row , column ) ; int topRight = min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; } int main ( ) { int row = 4 , column = 4 ; cout << countSquares ( row , column ) ; return 0 ; }", "docstring": "Count the total number of squares that can be visited by Bishop in one move | C ++ implementation of above approach ; Function to return the count of total positions the Bishop can visit in a single move ; Count top left squares ; Count bottom right squares ; Count top right squares ; Count bottom left squares ; Return total count ; Driver code ; Bishop 's Position", "dfg": [["bottomLeft", 77, "comesFrom", ["bottomLeft"], [56]], ["bottomRight", 75, "comesFrom", ["bottomRight"], [30]], ["row", 99, "comesFrom", ["row"], [87]], ["row", 22, "comesFrom", ["row"], [11]], ["row", 36, "comesFrom", ["row"], [11]], ["row", 46, "comesFrom", ["row"], [11]], ["row", 62, "comesFrom", ["row"], [11]], ["column", 101, "comesFrom", ["column"], [91]], ["column", 24, "comesFrom", ["column"], [14]], ["column", 38, "comesFrom", ["column"], [14]], ["column", 50, "comesFrom", ["column"], [14]], ["column", 66, "comesFrom", ["column"], [14]], ["topLeft", 71, "comesFrom", ["topLeft"], [18]], ["topRight", 73, "comesFrom", ["topRight"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; } int main ( ) { int bishopX = 5 , bishopY = 5 ; int pawnX = 1 , pawnY = 1 ; if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) cout << \" Yes \" ; else cout << \" No \" ; }", "docstring": "Check whether Bishop can take down Pawn or not | C ++ implementation of above approach ; Function that return true if the Bishop can take down the pawn ; If pawn is at angle 45 or 225 degree from bishop 's Position ; If pawn is at angle 135 or 315 degree from bishop 's Position ; Driver code ; Bishop 's Position ; Pawn 's Position", "dfg": [["pawnX", 25, "comesFrom", ["pawnX"], [17]], ["pawnX", 87, "comesFrom", ["pawnX"], [71]], ["pawnX", 40, "comesFrom", ["pawnX"], [17]], ["bishopX", 27, "comesFrom", ["bishopX"], [11]], ["bishopX", 83, "comesFrom", ["bishopX"], [62]], ["bishopX", 42, "comesFrom", ["bishopX"], [11]], ["pawnY", 29, "comesFrom", ["pawnY"], [20]], ["pawnY", 89, "comesFrom", ["pawnY"], [75]], ["pawnY", 44, "comesFrom", ["pawnY"], [20]], ["bishopY", 31, "comesFrom", ["bishopY"], [14]], ["bishopY", 85, "comesFrom", ["bishopY"], [66]], ["bishopY", 46, "comesFrom", ["bishopY"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005 NEW_LINE int primeFactors [ N ] ; void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; } int main ( ) { findPrimeFactors ( ) ; int a = 6 , b = 3 ; cout << primeFactors [ a ] - primeFactors [ b ] ; return 0 ; }", "docstring": "Find maximum operations to reduce N to 1 | CPP program to find maximum number moves possible ; To store number of prime factors of each number ; Function to find number of prime factors of each number ; if i is a prime number ; increase value by one from it 's preveious multiple ; make prefix sum this will be helpful for multiple test cases ; Driver Code ; Generate primeFactors array ; required answer", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int digitSum ( int n ) { int ans = 0 ; while ( n ) { ans += n % 10 ; n /= 10 ; } return ans ; } int findInt ( int n , int m ) { int minDigit = floor ( m / 9 ) ; int start = pow ( 10 , minDigit ) - ( int ) pow ( 10 , minDigit ) % n ; while ( start < INT_MAX ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return -1 ; } int main ( ) { int n = 13 , m = 32 ; cout << findInt ( n , m ) ; return 0 ; }", "docstring": "Smallest integer with digit sum M and multiple of N | C ++ implementation of the above approach ; Function to return digit sum ; Function to find out the smallest integer ; Start of the iterator ( Smallest multiple of n ) ; Driver code", "dfg": [["ans", 36, "comesFrom", ["ans"], [24]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 79, "comesFrom", ["n"], [43]], ["n", 128, "comesFrom", ["n"], [116]], ["n", 26, "comesFrom", ["n"], [11]], ["n", 103, "comesFrom", ["n"], [43]], ["start", 83, "comesFrom", ["start"], [60]], ["start", 98, "comesFrom", ["start"], [60]], ["start", 92, "comesFrom", ["start"], [60]], ["m", 130, "comesFrom", ["m"], [120]], ["m", 54, "comesFrom", ["m"], [46]], ["m", 95, "comesFrom", ["m"], [46]], ["minDigit", 66, "comesFrom", ["minDigit"], [50]], ["minDigit", 76, "comesFrom", ["minDigit"], [50]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestDivisor ( int n ) { int mx = sqrt ( n ) ; for ( int i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; } int maxSum ( int n ) { long long res = n ; while ( n > 1 ) { int divi = smallestDivisor ( n ) ; n /= divi ; res += n ; } return res ; } int main ( ) { int n = 34 ; cout << maxSum ( n ) ; return 0 ; }", "docstring": "Maximum sum after repeatedly dividing N by a divisor | C ++ implementation of the above approach ; Function to find the smallest divisor ; Function to find the maximum sum ; Driver Code", "dfg": [["n", 48, "comesFrom", ["n"], [11]], ["n", 66, "comesFrom", ["n"], [62]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 85, "comesFrom", ["n"], [79]], ["n", 106, "comesFrom", ["n"], [98]], ["n", 38, "comesFrom", ["n"], [11]], ["n", 76, "comesFrom", ["n"], [62]], ["res", 89, "comesFrom", ["res"], [83]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 45, "comesFrom", ["i"], [25]], ["i", 40, "comesFrom", ["i"], [25]], ["mx", 31, "comesFrom", ["mx"], [15]], ["divi", 81, "comesFrom", ["divi"], [72]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int n , int k , int arr [ ] ) { int sum = arr [ 0 ] , maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; } int main ( ) { int k = 8 ; int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isPossible ( n , k , arr ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Make all elements of an array equal with the given operation | C ++ implementation of the approach ; Function that returns true if all the elements of the array can be made equal with the given operation ; To store the sum of the array elements and the maximum element from the array ; Driver code", "dfg": [["i", 44, "comesFrom", ["i"], [40]], ["i", 48, "comesFrom", ["i"], [40]], ["i", 56, "comesFrom", ["i"], [40]], ["i", 67, "comesFrom", ["i"], [40]], ["n", 46, "comesFrom", ["n"], [11]], ["n", 88, "comesFrom", ["n"], [11]], ["n", 142, "comesFrom", ["n"], [123]], ["maxVal", 77, "comesFrom", ["maxVal"], [59]], ["maxVal", 63, "comesFrom", ["maxVal"], [59]], ["k", 144, "comesFrom", ["k"], [103]], ["k", 85, "comesFrom", ["k"], [14]], ["sum", 83, "comesFrom", ["sum"], [52]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) { for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) ( c ) ; if ( floor ( z ) == ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = max ( maxVal , x + y + ( int ) z ) ; } } } return maxVal ; } int main ( ) { int n = 10 , a = 5 , b = 3 , c = 4 ; cout << maxResult ( n , a , b , c ) ; return 0 ; }", "docstring": "Maximize the value of x + y + z such that ax + by + cz = n | C ++ implementation of the approach ; Function to return the maximum value of ( x + y + z ) such that ( ax + by + cz = n ) ; i represents possible values of a * x ; j represents possible values of b * y ; If z is an integer ; Driver code ; Function Call", "dfg": [["maxVal", 132, "comesFrom", ["maxVal"], [112]], ["maxVal", 116, "comesFrom", ["maxVal"], [112]], ["i", 35, "comesFrom", ["i"], [31]], ["i", 55, "comesFrom", ["i"], [39]], ["i", 101, "comesFrom", ["i"], [39]], ["i", 72, "comesFrom", ["i"], [39]], ["n", 37, "comesFrom", ["n"], [11]], ["n", 161, "comesFrom", ["n"], [141]], ["n", 53, "comesFrom", ["n"], [11]], ["n", 69, "comesFrom", ["n"], [11]], ["a", 41, "comesFrom", ["a"], [14]], ["a", 163, "comesFrom", ["a"], [145]], ["a", 103, "comesFrom", ["a"], [14]], ["j", 51, "comesFrom", ["j"], [47]], ["j", 108, "comesFrom", ["j"], [57]], ["j", 74, "comesFrom", ["j"], [57]], ["b", 59, "comesFrom", ["b"], [17]], ["b", 165, "comesFrom", ["b"], [149]], ["b", 110, "comesFrom", ["b"], [17]], ["c", 167, "comesFrom", ["c"], [153]], ["c", 82, "comesFrom", ["c"], [20]], ["z", 89, "comesFrom", ["z"], [63]], ["z", 94, "comesFrom", ["z"], [63]], ["z", 125, "comesFrom", ["z"], [63]], ["x", 118, "comesFrom", ["x"], [99]], ["y", 120, "comesFrom", ["y"], [106]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool EqualNumbers ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) a [ i ] /= 2 ; while ( a [ i ] % 3 == 0 ) a [ i ] /= 3 ; if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; } int main ( ) { int a [ ] = { 50 , 75 , 150 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( EqualNumbers ( a , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Make all numbers of an array equal | C ++ implementation of the approach ; Function that returns true if all the array elements can be made equal with the given operation ; Divide number by 2 ; Divide number by 3 ; Driver code", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 47, "comesFrom", ["i"], [22]], ["i", 65, "comesFrom", ["i"], [22]], ["i", 74, "comesFrom", ["i"], [22]], ["i", 38, "comesFrom", ["i"], [22]], ["i", 56, "comesFrom", ["i"], [22]], ["n", 28, "comesFrom", ["n"], [16]], ["n", 132, "comesFrom", ["n"], [111]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long max_gcd ( long n , long p ) { int count = 0 ; long gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= ( long ) pow ( 2 , count / n ) ; for ( long i = 3 ; i <= sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= ( long ) pow ( i , count / n ) ; } } if ( p > 2 ) gcd *= ( long ) pow ( p , 1 / n ) ; return gcd ; } int main ( ) { long n = 3 ; long p = 80 ; cout << max_gcd ( n , p ) ; }", "docstring": "Maximum GCD from Given Product of Unknowns | C ++ implementation of the approach ; Function to return the required gcd ; Count the number of times 2 divides p ; Equivalent to p = p / 2 ; ; If 2 divides p ; Check all the possible numbers that can divide p ; If n in the end is a prime number ; Return the required gcd ; Driver code", "dfg": [["gcd", 150, "comesFrom", ["gcd"], [135]], ["i", 71, "comesFrom", ["i"], [67]], ["i", 91, "comesFrom", ["i"], [78]], ["i", 103, "comesFrom", ["i"], [78]], ["i", 120, "comesFrom", ["i"], [78]], ["count", 46, "comesFrom", ["count"], [18]], ["count", 40, "comesFrom", ["count"], [18]], ["count", 108, "comesFrom", ["count"], [83]], ["count", 96, "comesFrom", ["count"], [83]], ["count", 59, "comesFrom", ["count"], [18]], ["count", 122, "comesFrom", ["count"], [83]], ["p", 131, "comesFrom", ["p"], [99]], ["p", 29, "comesFrom", ["p"], [14]], ["p", 75, "comesFrom", ["p"], [36]], ["p", 174, "comesFrom", ["p"], [164]], ["p", 89, "comesFrom", ["p"], [36]], ["p", 142, "comesFrom", ["p"], [99]], ["p", 101, "comesFrom", ["p"], [99]], ["n", 172, "comesFrom", ["n"], [159]], ["n", 61, "comesFrom", ["n"], [11]], ["n", 146, "comesFrom", ["n"], [11]], ["n", 124, "comesFrom", ["n"], [11]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) return c ; int x = ( ( b / c ) * c ) + c ; return x ; } int main ( ) { int a = 2 , b = 4 , c = 4 ; cout << getMinNum ( a , b , c ) ; return 0 ; }", "docstring": "Minimum positive integer divisible by C and is not in range [ A , B ] | C ++ implementation of the approach ; Function to return the required number ; If doesn 't belong to the range  then c is the required number ; Else get the next multiple of c starting from b + 1 ; Driver code", "dfg": [["x", 49, "comesFrom", ["x"], [33]], ["c", 45, "comesFrom", ["c"], [17]], ["c", 78, "comesFrom", ["c"], [66]], ["c", 30, "comesFrom", ["c"], [17]], ["c", 42, "comesFrom", ["c"], [17]], ["c", 25, "comesFrom", ["c"], [17]], ["c", 39, "comesFrom", ["c"], [17]], ["a", 74, "comesFrom", ["a"], [58]], ["b", 76, "comesFrom", ["b"], [62]], ["b", 37, "comesFrom", ["b"], [27]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; } int main ( ) { int n = 5 ; cout << countPairs ( n ) ; }", "docstring": "Count of pairs of ( i , j ) such that ( ( n % i ) % j ) % n is maximized | C ++ implementation of the approach ; Function to return the count of required pairs ; Special case ; Number which will give the max value for ( ( n % i ) % j ) % n ; To store the maximum possible value of ( ( n % i ) % j ) % n ; Count of possible pairs ; Driver code", "dfg": [["count", 51, "comesFrom", ["count"], [44]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [11]], ["n", 46, "comesFrom", ["n"], [11]], ["n", 68, "comesFrom", ["n"], [60]], ["n", 28, "comesFrom", ["n"], [11]], ["num", 41, "comesFrom", ["num"], [24]], ["max", 48, "comesFrom", ["max"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkSub ( string sub , string s ) { int j = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) if ( sub [ j ] == s [ i ] ) j ++ ; return j == ( int ) sub . size ( ) ; } int getMultiple ( string s ) { for ( int i = 0 ; i < 1e3 ; i += 8 ) { if ( checkSub ( to_string ( i ) , s ) ) return i ; } return -1 ; } int main ( ) { string s = \"3454\" ; cout << getMultiple ( s ) ; return 0 ; }", "docstring": "Remove characters from a numeric string such that string becomes divisible by 8 | C ++ program to remove digits from a numeric string such that the number becomes divisible by 8 ; Function that return true if sub is a sub - sequence in s ; Function to return a multiple of 8 formed after removing 0 or more characters from the given string ; Iterate over all multiples of 8 ; If current multiple exists as a subsequence in the given string ; Driver Code", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 37, "comesFrom", ["i"], [25]], ["i", 82, "comesFrom", ["i"], [78]], ["i", 104, "comesFrom", ["i"], [86]], ["i", 49, "comesFrom", ["i"], [25]], ["i", 97, "comesFrom", ["i"], [86]], ["j", 56, "comesFrom", ["j"], [18]], ["j", 52, "comesFrom", ["j"], [18]], ["j", 44, "comesFrom", ["j"], [18]], ["s", 31, "comesFrom", ["s"], [14]], ["s", 127, "comesFrom", ["s"], [117]], ["s", 47, "comesFrom", ["s"], [14]], ["s", 100, "comesFrom", ["s"], [72]], ["sub", 42, "comesFrom", ["sub"], [11]], ["sub", 61, "comesFrom", ["sub"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string getResult ( int n ) { string st = to_string ( n ) ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { int d = st [ i ] - 48 ; if ( n % d == 0 ) { return \" Yes \" ; } } return \" No \" ; } int main ( ) { int n = 9876543 ; cout << getResult ( n ) ; }", "docstring": "Program to check if a number is divisible by any of its digits | C ++ implementation of above approach ; Converting integer to string ; Traversing the string ; find the actual digit ; If the number is divisible by digits then return yes ; If no digits are dividing the number then return no ; Driver Code ; passing this number to get result function", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 37, "comesFrom", ["i"], [25]], ["i", 46, "comesFrom", ["i"], [25]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 87, "comesFrom", ["n"], [79]], ["n", 53, "comesFrom", ["n"], [11]], ["st", 31, "comesFrom", ["st"], [15]], ["st", 44, "comesFrom", ["st"], [15]], ["d", 55, "comesFrom", ["d"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; } int main ( ) { cout << ( sum ( 8 ) ) << endl ; cout << ( sum ( 10 ) ) << endl ; return 0 ; }", "docstring": "Program to find sum of harmonic series | CPP program to find sum of harmonic series using recursion ; Base condition ; Driven Code", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 27, "comesFrom", ["n"], [11]], ["n", 32, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < double , double > findingValues ( double m , double n , double mth , double nth ) { double d = ( abs ( mth - nth ) ) / abs ( ( m - 1 ) - ( n - 1 ) ) ; double a = mth - ( ( m - 1 ) * d ) ; return make_pair ( a , d ) ; } double findSum ( int m , int n , int mth , int nth , int p ) { pair < double , double > ad ; ad = findingValues ( m , n , mth , nth ) ; double a = ad . first , d = ad . second ; double sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 ; return sum ; } int main ( ) { double m = 6 , n = 10 , mTerm = 12 , nTerm = 20 , p = 5 ; cout << findSum ( m , n , mTerm , nTerm , p ) << endl ; return 0 ; }", "docstring": "Sum of P terms of an AP if Mth and Nth terms are given | C ++ implementation of the above approach ; Function to calculate the value of the ; Calculate value of d using formula ; Calculate value of a using formula ; Return pair ; Function to calculate value sum of first p numbers of the series ; First calculate value of a and d ; Calculate the sum by using formula ; Return the sum ; Driven Code", "dfg": [["sum", 156, "comesFrom", ["sum"], [133]], ["mth", 58, "comesFrom", ["mth"], [22]], ["mth", 114, "comesFrom", ["mth"], [89]], ["mth", 34, "comesFrom", ["mth"], [22]], ["a", 73, "comesFrom", ["a"], [56]], ["a", 141, "comesFrom", ["a"], [120]], ["d", 75, "comesFrom", ["d"], [29]], ["d", 67, "comesFrom", ["d"], [29]], ["d", 149, "comesFrom", ["d"], [126]], ["ad", 122, "comesFrom", ["ad"], [106]], ["ad", 128, "comesFrom", ["ad"], [106]], ["m", 110, "comesFrom", ["m"], [83]], ["m", 189, "comesFrom", ["m"], [165]], ["m", 62, "comesFrom", ["m"], [16]], ["m", 43, "comesFrom", ["m"], [16]], ["n", 112, "comesFrom", ["n"], [86]], ["n", 191, "comesFrom", ["n"], [169]], ["n", 49, "comesFrom", ["n"], [19]], ["nth", 116, "comesFrom", ["nth"], [92]], ["nth", 36, "comesFrom", ["nth"], [25]], ["p", 136, "comesFrom", ["p"], [95]], ["p", 197, "comesFrom", ["p"], [181]], ["p", 144, "comesFrom", ["p"], [95]], ["mTerm", 193, "comesFrom", ["mTerm"], [173]], ["nTerm", 195, "comesFrom", ["nTerm"], [177]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void powerfulIntegers ( int x , int y , int bound ) { set < int > s ; vector < int > powersOfY ; int i ; powersOfY . push_back ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . push_back ( i ) ; i = 0 ; while ( true ) { int xPowI = pow ( x , i ) ; for ( auto j = powersOfY . begin ( ) ; j != powersOfY . end ( ) ; ++ j ) { int num = xPowI + * j ; if ( num <= bound ) s . insert ( num ) ; else break ; } if ( xPowI >= bound x == 1 ) break ; i ++ ; } set < int > :: iterator itr ; for ( itr = s . begin ( ) ; itr != s . end ( ) ; itr ++ ) { cout << * itr << \" ▁ \" ; } } int main ( ) { int x = 2 , y = 3 , bound = 10 ; powerfulIntegers ( x , y , bound ) ; return 0 ; }", "docstring": "Print all integers that are sum of powers of two given numbers | C ++ implementation of the approach ; Function to print powerful integers ; Set is used to store distinct numbers in sorted order ; Store all the powers of y < bound in a vector to avoid calculating them again and again ; x ^ i ; If num is within limits insert it into the set ; Break out of the inner loop ; Adding any number to it will be out of bounds ; Increment i ; Print the contents of the set ; Driver code ; Print powerful integers", "dfg": [["y", 46, "comesFrom", ["y"], [14]], ["y", 52, "comesFrom", ["y"], [14]], ["y", 60, "comesFrom", ["y"], [14]], ["y", 214, "comesFrom", ["y"], [202]], ["itr", 169, "comesFrom", ["itr"], [161]], ["itr", 177, "comesFrom", ["itr"], [161]], ["itr", 184, "comesFrom", ["itr"], [161]], ["powersOfY", 35, "comesFrom", ["powersOfY"], [30]], ["powersOfY", 62, "comesFrom", ["powersOfY"], [30]], ["powersOfY", 101, "comesFrom", ["powersOfY"], [30]], ["powersOfY", 93, "comesFrom", ["powersOfY"], [30]], ["i", 48, "comesFrom", ["i"], [44]], ["i", 58, "comesFrom", ["i"], [56]], ["i", 66, "comesFrom", ["i"], [56]], ["i", 147, "comesFrom", ["i"], [69]], ["i", 85, "comesFrom", ["i"], [69]], ["bound", 50, "comesFrom", ["bound"], [17]], ["bound", 216, "comesFrom", ["bound"], [206]], ["bound", 140, "comesFrom", ["bound"], [17]], ["bound", 123, "comesFrom", ["bound"], [17]], ["x", 212, "comesFrom", ["x"], [198]], ["x", 83, "comesFrom", ["x"], [11]], ["x", 141, "comesFrom", ["x"], [11]], ["j", 99, "comesFrom", ["j"], [91]], ["j", 108, "comesFrom", ["j"], [91]], ["j", 117, "comesFrom", ["j"], [91]], ["s", 163, "comesFrom", ["s"], [24]], ["s", 171, "comesFrom", ["s"], [24]], ["s", 125, "comesFrom", ["s"], [24]], ["xPowI", 138, "comesFrom", ["xPowI"], [79]], ["xPowI", 114, "comesFrom", ["xPowI"], [79]], ["num", 121, "comesFrom", ["num"], [112]], ["num", 129, "comesFrom", ["num"], [112]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int arr [ k ] ; memset ( arr , 0 , sizeof ( arr ) ) ; while ( n ) { int f1 = ( ind - 1 ) * k ; int f2 = ind * k ; int sum1 = ( f1 * ( f1 + 1 ) ) / 2 ; int sum2 = ( f2 * ( f2 + 1 ) ) / 2 ; int res = sum2 - sum1 ; if ( res <= n ) { count ++ ; n -= res ; ind ++ ; } { int i = 0 ; int term = ( ( ind - 1 ) * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; } else { arr [ i ++ ] = n ; n = 0 ; } } } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int n = 10 , k = 3 ; candies ( n , k ) ; return 0 ; }", "docstring": "Distribute N candies among K people | C ++ code for better approach to distribute candies ; Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Last term of last and current series ; Sum of current and last series ; Sum of current series only ; If sum of current is less than N ; else Individually distribute ; First term ; Distribute candies till there ; Candies available ; Not available ; Count the total candies ; Print the total candies ; Driver Code", "dfg": [["k", 30, "comesFrom", ["k"], [14]], ["k", 201, "comesFrom", ["k"], [14]], ["k", 246, "comesFrom", ["k"], [14]], ["k", 281, "comesFrom", ["k"], [273]], ["k", 59, "comesFrom", ["k"], [14]], ["k", 66, "comesFrom", ["k"], [14]], ["k", 222, "comesFrom", ["k"], [14]], ["k", 139, "comesFrom", ["k"], [14]], ["n", 47, "comesFrom", ["n"], [11]], ["n", 279, "comesFrom", ["n"], [269]], ["n", 109, "comesFrom", ["n"], [11]], ["n", 146, "comesFrom", ["n"], [115]], ["n", 155, "comesFrom", ["n"], [115]], ["n", 182, "comesFrom", ["n"], [166]], ["i", 199, "comesFrom", ["i"], [195]], ["i", 203, "comesFrom", ["i"], [195]], ["i", 244, "comesFrom", ["i"], [240]], ["i", 248, "comesFrom", ["i"], [240]], ["i", 208, "comesFrom", ["i"], [195]], ["i", 255, "comesFrom", ["i"], [240]], ["i", 215, "comesFrom", ["i"], [195]], ["i", 160, "comesFrom", ["i"], [125]], ["i", 178, "comesFrom", ["i"], [125]], ["ind", 64, "comesFrom", ["ind"], [23]], ["ind", 119, "comesFrom", ["ind"], [23]], ["ind", 54, "comesFrom", ["ind"], [23]], ["ind", 134, "comesFrom", ["ind"], [23]], ["sum2", 101, "comesFrom", ["sum2"], [84]], ["sum1", 103, "comesFrom", ["sum1"], [69]], ["res", 107, "comesFrom", ["res"], [99]], ["res", 117, "comesFrom", ["res"], [99]], ["count", 112, "comesFrom", ["count"], [18]], ["count", 212, "comesFrom", ["count"], [18]], ["count", 225, "comesFrom", ["count"], [18]], ["count", 228, "comesFrom", ["count"], [18]], ["f1", 72, "comesFrom", ["f1"], [51]], ["f1", 75, "comesFrom", ["f1"], [51]], ["f2", 87, "comesFrom", ["f2"], [62]], ["f2", 90, "comesFrom", ["f2"], [62]], ["term", 153, "comesFrom", ["term"], [130]], ["term", 164, "comesFrom", ["term"], [130]], ["term", 168, "comesFrom", ["term"], [130]], ["term", 170, "comesFrom", ["term"], [130]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int arr [ k ] ; memset ( arr , 0 , sizeof ( arr ) ) ; int low = 0 , high = n ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; int sum = ( mid * ( mid + 1 ) ) >> 1 ; if ( sum <= n ) { count = mid / k ; low = mid + 1 ; } else { high = mid - 1 ; } } int last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; int i = 0 ; int term = ( count * k ) + 1 ; while ( n ) { if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; } else { arr [ i ] += n ; n = 0 ; } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int n = 7 , k = 4 ; candies ( n , k ) ; return 0 ; }", "docstring": "Distribute N candies among K people | C ++ implementation of the above approach ; Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Do a binary search to find the number whose sum is less than N . ; Get mide ; If sum is below N ; Find number of complete turns ; Right halve ; Left halve ; Last term of last complete series ; Subtract the sum till ; First term of incomplete series ; Count the total candies ; Print the total candies ; Driver Code", "dfg": [["k", 30, "comesFrom", ["k"], [14]], ["k", 208, "comesFrom", ["k"], [14]], ["k", 253, "comesFrom", ["k"], [14]], ["k", 288, "comesFrom", ["k"], [280]], ["k", 123, "comesFrom", ["k"], [14]], ["k", 151, "comesFrom", ["k"], [14]], ["k", 98, "comesFrom", ["k"], [14]], ["k", 229, "comesFrom", ["k"], [14]], ["n", 158, "comesFrom", ["n"], [126]], ["n", 286, "comesFrom", ["n"], [276]], ["n", 91, "comesFrom", ["n"], [52]], ["n", 165, "comesFrom", ["n"], [126]], ["n", 191, "comesFrom", ["n"], [176]], ["i", 206, "comesFrom", ["i"], [202]], ["i", 210, "comesFrom", ["i"], [202]], ["i", 251, "comesFrom", ["i"], [247]], ["i", 255, "comesFrom", ["i"], [247]], ["i", 215, "comesFrom", ["i"], [202]], ["i", 262, "comesFrom", ["i"], [247]], ["i", 222, "comesFrom", ["i"], [202]], ["i", 170, "comesFrom", ["i"], [141]], ["i", 188, "comesFrom", ["i"], [141]], ["low", 56, "comesFrom", ["low"], [46]], ["low", 65, "comesFrom", ["low"], [46]], ["high", 58, "comesFrom", ["high"], [50]], ["high", 67, "comesFrom", ["high"], [50]], ["count", 121, "comesFrom", ["count"], [94]], ["count", 149, "comesFrom", ["count"], [94]], ["count", 219, "comesFrom", ["count"], [94]], ["count", 232, "comesFrom", ["count"], [94]], ["count", 235, "comesFrom", ["count"], [94]], ["sum", 89, "comesFrom", ["sum"], [73]], ["last", 129, "comesFrom", ["last"], [118]], ["last", 132, "comesFrom", ["last"], [118]], ["term", 163, "comesFrom", ["term"], [146]], ["term", 174, "comesFrom", ["term"], [146]], ["term", 178, "comesFrom", ["term"], [146]], ["term", 180, "comesFrom", ["term"], [146]], ["mid", 76, "comesFrom", ["mid"], [62]], ["mid", 96, "comesFrom", ["mid"], [62]], ["mid", 102, "comesFrom", ["mid"], [62]], ["mid", 111, "comesFrom", ["mid"], [62]], ["mid", 79, "comesFrom", ["mid"], [62]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int printSmallest ( int a [ 3 ] ) { int sum , sum1 ; sort ( a , a + 3 ) ; int i , j , k , num ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] % 3 == 0 ) return a [ i ] ; } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { num = ( a [ i ] * 10 ) + a [ j ] ; if ( num % 3 == 0 ) return num ; } } return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] ; } int main ( ) { int arr [ ] = { 7 , 7 , 1 } ; cout << printSmallest ( arr ) ; return 0 ; }", "docstring": "Smallest multiple of 3 which consists of three given non | C ++ implementation of the approach ; Function to return the minimum number divisible by 3 formed by the given digits ; Sort the given array in ascending ; Check if any single digit is divisible by 3 ; Check if any two digit number formed by the given digits is divisible by 3 starting from the minimum ; Generate the two digit number ; If none of the above is true , we can form three digit number by taking a [ 0 ] three times . ; Driver code", "dfg": [["i", 47, "comesFrom", ["i"], [43]], ["i", 51, "comesFrom", ["i"], [43]], ["i", 79, "comesFrom", ["i"], [75]], ["i", 83, "comesFrom", ["i"], [75]], ["i", 69, "comesFrom", ["i"], [43]], ["i", 59, "comesFrom", ["i"], [43]], ["i", 106, "comesFrom", ["i"], [75]], ["j", 93, "comesFrom", ["j"], [89]], ["j", 97, "comesFrom", ["j"], [89]], ["j", 114, "comesFrom", ["j"], [89]], ["num", 126, "comesFrom", ["num"], [101]], ["num", 119, "comesFrom", ["num"], [101]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void updateMatrix ( int n , int q [ 3 ] [ 4 ] ) { int i , j ; int mat [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = 0 ; for ( i = 0 ; i < 3 ; i ++ ) { int X1 = q [ i ] [ 0 ] ; int Y1 = q [ i ] [ 1 ] ; int X2 = q [ i ] [ 2 ] ; int Y2 = q [ i ] [ 3 ] ; mat [ X1 ] [ Y1 ] ++ ; if ( Y2 + 1 < n ) mat [ X2 ] [ Y2 + 1 ] -- ; else if ( X2 + 1 < n ) mat [ X2 + 1 ] [ 0 ] -- ; } int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { sum += mat [ i ] [ j ] ; cout << sum << \" ▁ \" ; } cout << endl ; } } int main ( ) { int n = 5 ; int q [ 3 ] [ 4 ] = { { 0 , 0 , 1 , 2 } , { 1 , 2 , 3 , 4 } , { 1 , 4 , 3 , 4 } } ; updateMatrix ( n , q ) ; return 0 ; }", "docstring": "Print matrix after applying increment operations in M ranges | C ++ implementation of the approach ; Function to update and print the matrix after performing queries ; Add 1 to the first element of the sub - matrix ; If there is an element after the last element of the sub - matrix then decrement it by 1 ; Calculate the running sum ; Print the updated element ; Next line ; Driver code ; Size of the matrix ; Queries", "dfg": [["n", 34, "comesFrom", ["n"], [11]], ["n", 46, "comesFrom", ["n"], [11]], ["n", 195, "comesFrom", ["n"], [11]], ["n", 31, "comesFrom", ["n"], [11]], ["n", 60, "comesFrom", ["n"], [11]], ["n", 293, "comesFrom", ["n"], [246]], ["n", 209, "comesFrom", ["n"], [11]], ["n", 148, "comesFrom", ["n"], [11]], ["n", 168, "comesFrom", ["n"], [11]], ["i", 44, "comesFrom", ["i"], [40]], ["i", 48, "comesFrom", ["i"], [40]], ["i", 81, "comesFrom", ["i"], [77]], ["i", 85, "comesFrom", ["i"], [77]], ["i", 193, "comesFrom", ["i"], [189]], ["i", 197, "comesFrom", ["i"], [189]], ["i", 67, "comesFrom", ["i"], [40]], ["i", 94, "comesFrom", ["i"], [77]], ["i", 105, "comesFrom", ["i"], [77]], ["i", 116, "comesFrom", ["i"], [77]], ["i", 127, "comesFrom", ["i"], [77]], ["i", 219, "comesFrom", ["i"], [189]], ["j", 58, "comesFrom", ["j"], [54]], ["j", 62, "comesFrom", ["j"], [54]], ["j", 207, "comesFrom", ["j"], [203]], ["j", 211, "comesFrom", ["j"], [203]], ["j", 70, "comesFrom", ["j"], [54]], ["j", 222, "comesFrom", ["j"], [203]], ["Y1", 138, "comesFrom", ["Y1"], [101]], ["Y2", 144, "comesFrom", ["Y2"], [123]], ["Y2", 155, "comesFrom", ["Y2"], [123]], ["X1", 135, "comesFrom", ["X1"], [90]], ["sum", 227, "comesFrom", ["sum"], [215]], ["X2", 152, "comesFrom", ["X2"], [112]], ["X2", 164, "comesFrom", ["X2"], [112]], ["X2", 172, "comesFrom", ["X2"], [112]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( float arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } void replaceMax ( float arr [ ] , int n ) { float max = * std :: max_element ( arr , arr + n ) ; float min = * std :: min_element ( arr , arr + n ) ; float range = max - min ; float coeffOfRange = range / ( max + min ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; } int main ( ) { float arr [ ] = { 15 , 16 , 10 , 9 , 6 , 7 , 17 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; replaceMax ( arr , n ) ; return 0 ; }", "docstring": "Replace the maximum element in the array by coefficient of range | C ++ implementation to replace maximum element by coefficient of range ; Utility function to print the contents of the array ; Function to replace the maximum element from the array with the coefficient of range of the array ; Maximum element from the array ; Minimum element from the array ; Calculate the coefficient of range for the array ; Assuming all the array elements are distinc Replace the maximum element with the coefficient of range of the array ; Print the updated array ; Driver code", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 112, "comesFrom", ["i"], [108]], ["i", 116, "comesFrom", ["i"], [108]], ["i", 37, "comesFrom", ["i"], [22]], ["i", 124, "comesFrom", ["i"], [108]], ["i", 132, "comesFrom", ["i"], [108]], ["n", 28, "comesFrom", ["n"], [16]], ["n", 114, "comesFrom", ["n"], [54]], ["n", 145, "comesFrom", ["n"], [54]], ["n", 195, "comesFrom", ["n"], [176]], ["n", 69, "comesFrom", ["n"], [54]], ["n", 84, "comesFrom", ["n"], [54]], ["max", 90, "comesFrom", ["max"], [58]], ["max", 100, "comesFrom", ["max"], [58]], ["max", 127, "comesFrom", ["max"], [58]], ["min", 92, "comesFrom", ["min"], [73]], ["min", 102, "comesFrom", ["min"], [73]], ["range", 97, "comesFrom", ["range"], [88]], ["coeffOfRange", 135, "comesFrom", ["coeffOfRange"], [95]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void divide ( int a , int b ) { for ( int i = 2 ; i <= min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } cout << \" A ▁ = ▁ \" << a << \" , ▁ B ▁ = ▁ \" << b << endl ; } int main ( ) { int A = 10 , B = 15 ; divide ( A , B ) ; return 0 ; }", "docstring": "Divide the two given numbers by their common divisors | C ++ implementation of above approach ; print the numbers after dividing them by their common factors ; iterate from 1 to minimum of a and b ; if i is the common factor of both the numbers ; Driver code ; divide A and B by their common factors", "dfg": [["i", 24, "comesFrom", ["i"], [20]], ["i", 33, "comesFrom", ["i"], [20]], ["i", 41, "comesFrom", ["i"], [20]], ["i", 47, "comesFrom", ["i"], [20]], ["i", 56, "comesFrom", ["i"], [20]], ["i", 62, "comesFrom", ["i"], [20]], ["b", 78, "comesFrom", ["b"], [58]], ["b", 30, "comesFrom", ["b"], [14]], ["b", 45, "comesFrom", ["b"], [14]], ["b", 60, "comesFrom", ["b"], [58]], ["A", 99, "comesFrom", ["A"], [89]], ["B", 101, "comesFrom", ["B"], [93]], ["a", 28, "comesFrom", ["a"], [11]], ["a", 72, "comesFrom", ["a"], [52]], ["a", 39, "comesFrom", ["a"], [11]], ["a", 54, "comesFrom", ["a"], [52]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } void commDiv ( int a , int b ) { int n = gcd ( a , b ) ; a = a / n ; b = b / n ; cout << \" A ▁ = ▁ \" << a << \" , ▁ B ▁ = ▁ \" << b << endl ; } int main ( ) { int a = 10 , b = 15 ; commDiv ( a , b ) ; return 0 ; }", "docstring": "Divide the two given numbers by their common divisors | C ++ implementation of above approach ; Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Driver code", "dfg": [["b", 24, "comesFrom", ["b"], [14]], ["b", 65, "comesFrom", ["b"], [63]], ["b", 81, "comesFrom", ["b"], [63]], ["b", 104, "comesFrom", ["b"], [96]], ["b", 29, "comesFrom", ["b"], [14]], ["b", 54, "comesFrom", ["b"], [44]], ["a", 19, "comesFrom", ["a"], [11]], ["a", 33, "comesFrom", ["a"], [11]], ["a", 59, "comesFrom", ["a"], [57]], ["a", 102, "comesFrom", ["a"], [92]], ["a", 31, "comesFrom", ["a"], [11]], ["a", 52, "comesFrom", ["a"], [41]], ["a", 75, "comesFrom", ["a"], [57]], ["n", 61, "comesFrom", ["n"], [48]], ["n", 67, "comesFrom", ["n"], [48]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int n ) { int left = 1 << ( ( int ) floor ( log2 ( n ) ) ) ; int right = left * 2 ; return min ( ( n - left ) , ( right - n ) ) ; } int main ( ) { int n = 15 ; cout << minAbsDiff ( n ) ; return 0 ; }", "docstring": "Minimum absolute difference between N and a power of 2 | C ++ implementation of the above approach ; Function to return the minimum difference between N and a power of 2 ; Power of 2 closest to n on its left ; Power of 2 closest to n on its right ; Return the minimum abs difference ; Driver code", "dfg": [["left", 35, "comesFrom", ["left"], [15]], ["left", 45, "comesFrom", ["left"], [15]], ["n", 70, "comesFrom", ["n"], [62]], ["n", 43, "comesFrom", ["n"], [11]], ["n", 51, "comesFrom", ["n"], [11]], ["n", 27, "comesFrom", ["n"], [11]], ["right", 49, "comesFrom", ["right"], [33]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; } int main ( ) { double p = 1 , q = 2 , r = 1 , s = 2 ; cout << fixed << setprecision ( 9 ) << find_probability ( p , q , r , s ) ; return 0 ; }", "docstring": "Find probability that a player wins when probabilities of hitting the target are given | C ++ implementation of the approach ; Function to return the probability of the winner ; Driver Code ; Will print 9 digits after the decimal point", "dfg": [["ans", 58, "comesFrom", ["ans"], [43]], ["p", 94, "comesFrom", ["p"], [67]], ["p", 46, "comesFrom", ["p"], [11]], ["p", 29, "comesFrom", ["p"], [11]], ["q", 96, "comesFrom", ["q"], [71]], ["q", 48, "comesFrom", ["q"], [14]], ["q", 31, "comesFrom", ["q"], [14]], ["r", 98, "comesFrom", ["r"], [75]], ["r", 37, "comesFrom", ["r"], [17]], ["s", 100, "comesFrom", ["s"], [79]], ["s", 39, "comesFrom", ["s"], [20]], ["t", 54, "comesFrom", ["t"], [24]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void FindAllElements ( int n , int k ) { int sum = k ; int A [ k ] ; fill ( A , A + k , 1 ) ; for ( int i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { cout << \" Impossible \" ; } else { for ( int i = 0 ; i < k ; ++ i ) cout << A [ i ] << ' ▁ ' ; } } int main ( ) { int n = 12 ; int k = 6 ; FindAllElements ( n , k ) ; return 0 ; }", "docstring": "Represent n as the sum of exactly k powers of two | Set 2 | C ++ implementation of the above approach ; Function to print k numbers which are powers of two and whose sum is equal to n ; Initialising the sum with k ; Initialising an array A with k elements and filling all elements with 1 ; Iterating A [ ] from k - 1 to 0 ; Update sum and A [ i ] till sum + A [ i ] is less than equal to n ; Impossible to find the combination ; Possible solution is stored in A [ ] ; Driver code", "dfg": [["k", 25, "comesFrom", ["k"], [20]], ["k", 148, "comesFrom", ["k"], [140]], ["k", 34, "comesFrom", ["k"], [20]], ["k", 44, "comesFrom", ["k"], [20]], ["k", 109, "comesFrom", ["k"], [20]], ["i", 48, "comesFrom", ["i"], [42]], ["i", 53, "comesFrom", ["i"], [42]], ["i", 107, "comesFrom", ["i"], [103]], ["i", 112, "comesFrom", ["i"], [103]], ["i", 62, "comesFrom", ["i"], [42]], ["i", 72, "comesFrom", ["i"], [42]], ["i", 77, "comesFrom", ["i"], [42]], ["i", 118, "comesFrom", ["i"], [103]], ["sum", 86, "comesFrom", ["sum"], [68]], ["sum", 58, "comesFrom", ["sum"], [18]], ["n", 88, "comesFrom", ["n"], [11]], ["n", 146, "comesFrom", ["n"], [135]], ["n", 65, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; } bool isEqual ( int a , int b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; } int main ( ) { int a = 105 , b = 106 ; isEqual ( a , b ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }", "docstring": "Check whether a + b = c or not after removing all zeroes from a , b and c | C ++ program to check the sum after Removing all zeroes is true or not ; Function to remove zeroes ; Initialize result to zero holds the Result after removing zeroes from no ; Initialize variable d to 1 that holds digits of no ; Loop while n is greater then zero ; Check if n mod 10 is not equal to zero ; store the result by removing zeroes And increment d by 10 ; Go to the next digit ; Return the result ; Function to check if sum is true after Removing all zeroes . ; Call removeZero ( ) for both sides and check whether they are equal After removing zeroes . ; Driver code", "dfg": [["res", 61, "comesFrom", ["res"], [40]], ["n", 26, "comesFrom", ["n"], [11]], ["n", 33, "comesFrom", ["n"], [11]], ["n", 43, "comesFrom", ["n"], [11]], ["a", 116, "comesFrom", ["a"], [106]], ["a", 78, "comesFrom", ["a"], [68]], ["a", 88, "comesFrom", ["a"], [68]], ["b", 118, "comesFrom", ["b"], [110]], ["b", 83, "comesFrom", ["b"], [71]], ["b", 90, "comesFrom", ["b"], [71]], ["d", 48, "comesFrom", ["d"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumArray ( int arr [ ] , int n ) { int leftSum [ n ] , rightSum [ n ] , Sum [ n ] , i , j ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) cout << Sum [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 3 , 6 , 4 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sumArray ( arr , n ) ; return 0 ; }", "docstring": "A Sum Array Puzzle | C ++ implementation of above approach ; Allocate memory for temporary arrays leftSum [ ] , rightSum [ ] and Sum [ ] ; Left most element of left array is always 0 ; Rightmost most element of right array is always 0 ; Construct the left array ; Construct the right array ; Construct the sum array using left [ ] and right [ ] ; print the constructed prod array ; Driver program to test above functions", "dfg": [["n", 22, "comesFrom", ["n"], [16]], ["n", 27, "comesFrom", ["n"], [16]], ["n", 32, "comesFrom", ["n"], [16]], ["n", 63, "comesFrom", ["n"], [16]], ["n", 129, "comesFrom", ["n"], [16]], ["n", 157, "comesFrom", ["n"], [16]], ["n", 91, "comesFrom", ["n"], [16]], ["n", 216, "comesFrom", ["n"], [197]], ["n", 48, "comesFrom", ["n"], [16]], ["i", 61, "comesFrom", ["i"], [57]], ["i", 65, "comesFrom", ["i"], [57]], ["i", 127, "comesFrom", ["i"], [123]], ["i", 131, "comesFrom", ["i"], [123]], ["i", 155, "comesFrom", ["i"], [151]], ["i", 159, "comesFrom", ["i"], [151]], ["i", 70, "comesFrom", ["i"], [57]], ["i", 136, "comesFrom", ["i"], [123]], ["i", 141, "comesFrom", ["i"], [123]], ["i", 146, "comesFrom", ["i"], [123]], ["i", 166, "comesFrom", ["i"], [151]], ["i", 75, "comesFrom", ["i"], [57]], ["i", 82, "comesFrom", ["i"], [57]], ["j", 95, "comesFrom", ["j"], [89]], ["j", 99, "comesFrom", ["j"], [89]], ["j", 104, "comesFrom", ["j"], [89]], ["j", 109, "comesFrom", ["j"], [89]], ["j", 116, "comesFrom", ["j"], [89]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumX ( int n , int k ) { int mini = INT_MAX ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = min ( num2 , mini ) ; } } return mini ; } int main ( ) { int n = 4 , k = 6 ; cout << minimumX ( n , k ) << endl ; n = 5 , k = 5 ; cout << minimumX ( n , k ) << endl ; return 0 ; }", "docstring": "Find minimum x such that ( x % k ) * ( x / k ) == n | Set | CPP Program to find the minimum positive X such that the given equation holds true ; This function gives the required answer ; Iterate for all the factors ; Check if i is a factor ; Consider i to be A and n / i to be B ; Consider i to be B and n / i to be A ; Driver Code to test above function", "dfg": [["mini", 140, "comesFrom", ["mini"], [128]], ["mini", 96, "comesFrom", ["mini"], [90]], ["mini", 134, "comesFrom", ["mini"], [128]], ["n", 33, "comesFrom", ["n"], [11]], ["n", 161, "comesFrom", ["n"], [149]], ["n", 180, "comesFrom", ["n"], [168]], ["n", 41, "comesFrom", ["n"], [11]], ["n", 56, "comesFrom", ["n"], [11]], ["n", 88, "comesFrom", ["n"], [11]], ["n", 126, "comesFrom", ["n"], [11]], ["i", 35, "comesFrom", ["i"], [25]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 31, "comesFrom", ["i"], [25]], ["i", 43, "comesFrom", ["i"], [25]], ["i", 58, "comesFrom", ["i"], [51]], ["k", 163, "comesFrom", ["k"], [153]], ["k", 182, "comesFrom", ["k"], [172]], ["k", 65, "comesFrom", ["k"], [14]], ["k", 104, "comesFrom", ["k"], [14]], ["k", 75, "comesFrom", ["k"], [14]], ["k", 81, "comesFrom", ["k"], [14]], ["k", 113, "comesFrom", ["k"], [14]], ["k", 119, "comesFrom", ["k"], [14]], ["sec", 67, "comesFrom", ["sec"], [54]], ["sec", 102, "comesFrom", ["sec"], [54]], ["res", 86, "comesFrom", ["res"], [70]], ["res", 124, "comesFrom", ["res"], [108]], ["fir", 106, "comesFrom", ["fir"], [49]], ["fir", 63, "comesFrom", ["fir"], [49]], ["num1", 73, "comesFrom", ["num1"], [61]], ["num1", 79, "comesFrom", ["num1"], [61]], ["num1", 94, "comesFrom", ["num1"], [61]], ["num2", 111, "comesFrom", ["num2"], [100]], ["num2", 117, "comesFrom", ["num2"], [100]], ["num2", 132, "comesFrom", ["num2"], [100]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumX ( int n , int k ) { int ans = INT_MAX ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = min ( ans , rem + ( n / rem ) * k ) ; } return ans ; } int main ( ) { int n = 4 , k = 6 ; cout << minimumX ( n , k ) << endl ; n = 5 , k = 5 ; cout << minimumX ( n , k ) << endl ; return 0 ; }", "docstring": "Find minimum x such that ( x % k ) * ( x / k ) == n | CPP Program to find the minimum positive X such that the given equation holds true ; This function gives the required answer ; Iterate over all possible remainders ; it must divide n ; Driver Code to test above function", "dfg": [["ans", 66, "comesFrom", ["ans"], [47]], ["ans", 51, "comesFrom", ["ans"], [47]], ["rem", 31, "comesFrom", ["rem"], [25]], ["rem", 35, "comesFrom", ["rem"], [25]], ["rem", 43, "comesFrom", ["rem"], [25]], ["rem", 53, "comesFrom", ["rem"], [25]], ["rem", 58, "comesFrom", ["rem"], [25]], ["k", 27, "comesFrom", ["k"], [14]], ["k", 89, "comesFrom", ["k"], [79]], ["k", 108, "comesFrom", ["k"], [98]], ["k", 61, "comesFrom", ["k"], [14]], ["n", 87, "comesFrom", ["n"], [75]], ["n", 106, "comesFrom", ["n"], [94]], ["n", 41, "comesFrom", ["n"], [11]], ["n", 56, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; else return -2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; } int main ( ) { int n = 6 ; cout << getHermiteNumber ( n ) ; return 0 ; }", "docstring": "Find nth Hermite number | C ++ program to find nth Hermite number ; Function to return nth Hermite number ; Base conditions ; Driver Code ; Print nth Hermite number", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 25, "comesFrom", ["n"], [11]], ["n", 64, "comesFrom", ["n"], [56]], ["n", 37, "comesFrom", ["n"], [11]], ["n", 44, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { cout << \" a ▁ = ▁ \" << a << \" , ▁ b ▁ = ▁ \" << b ; } else cout << -1 << endl ; } int main ( ) { int n = 10 ; find ( n ) ; return 0 ; }", "docstring": "Find numbers a and b that satisfy the given conditions | C ++ implementation of the above approach ; Function to print the required numbers ; Suppose b = n and we want a % b = 0 and also ( a / b ) < n so a = b * ( n - 1 ) ; Special case if n = 1 we get a = 0 so ( a * b ) < n ; If no pair satisfies the conditions ; Driver code", "dfg": [["b", 22, "comesFrom", ["b"], [15]], ["b", 57, "comesFrom", ["b"], [15]], ["b", 34, "comesFrom", ["b"], [15]], ["b", 40, "comesFrom", ["b"], [15]], ["n", 80, "comesFrom", ["n"], [74]], ["n", 36, "comesFrom", ["n"], [17]], ["n", 42, "comesFrom", ["n"], [17]], ["n", 25, "comesFrom", ["n"], [17]], ["a", 32, "comesFrom", ["a"], [20]], ["a", 38, "comesFrom", ["a"], [20]], ["a", 51, "comesFrom", ["a"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfect ( int N ) { if ( ( sqrt ( N ) - floor ( sqrt ( N ) ) ) != 0 ) return false ; return true ; } void getClosestPerfectSquare ( int N ) { if ( isPerfect ( N ) ) { cout << N << \" ▁ \" << \"0\" << endl ; return ; } int aboveN = -1 , belowN = -1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; if ( diff1 > diff2 ) cout << belowN << \" ▁ \" << diff2 ; else cout << aboveN << \" ▁ \" << diff1 ; } int main ( ) { int N = 1500 ; getClosestPerfectSquare ( N ) ; }", "docstring": "Closest perfect square and its distance | CPP program to find the closest perfect square taking minimum steps to reach from a number ; Function to check if a number is perfect square or not ; Function to find the closest perfect square taking minimum steps to reach from a number ; Variables to store first perfect square number above and below N ; Finding first perfect square number greater than N ; Finding first perfect square number less than N ; Variables to store the differences ; Driver code", "dfg": [["N", 86, "comesFrom", ["N"], [44]], ["N", 117, "comesFrom", ["N"], [44]], ["N", 151, "comesFrom", ["N"], [44]], ["N", 156, "comesFrom", ["N"], [44]], ["N", 200, "comesFrom", ["N"], [194]], ["N", 51, "comesFrom", ["N"], [44]], ["N", 19, "comesFrom", ["N"], [11]], ["N", 57, "comesFrom", ["N"], [44]], ["N", 26, "comesFrom", ["N"], [11]], ["aboveN", 149, "comesFrom", ["aboveN"], [103]], ["aboveN", 179, "comesFrom", ["aboveN"], [103]], ["belowN", 158, "comesFrom", ["belowN"], [134]], ["belowN", 168, "comesFrom", ["belowN"], [134]], ["diff1", 162, "comesFrom", ["diff1"], [147]], ["diff1", 185, "comesFrom", ["diff1"], [147]], ["diff2", 164, "comesFrom", ["diff2"], [154]], ["diff2", 174, "comesFrom", ["diff2"], [154]], ["n1", 99, "comesFrom", ["n1"], [84]], ["n1", 105, "comesFrom", ["n1"], [84]], ["n1", 111, "comesFrom", ["n1"], [84]], ["n1", 130, "comesFrom", ["n1"], [115]], ["n1", 136, "comesFrom", ["n1"], [115]], ["n1", 142, "comesFrom", ["n1"], [115]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } void lowest ( int & den3 , int & num3 ) { int common_factor = gcd ( num3 , den3 ) ; den3 = den3 / common_factor ; num3 = num3 / common_factor ; } void addFraction ( int num1 , int den1 , int num2 , int den2 , int & num3 , int & den3 ) { den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; num3 = ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ; lowest ( den3 , num3 ) ; } int main ( ) { int num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 , den3 , num3 ; addFraction ( num1 , den1 , num2 , den2 , num3 , den3 ) ; printf ( \" % d / % d ▁ + ▁ % d / % d ▁ is ▁ equal ▁ to ▁ % d / % d STRNEWLINE \" , num1 , den1 , num2 , den2 , num3 , den3 ) ; return 0 ; }", "docstring": "Fraction | C ++ program to add 2 fractions ; Function to return gcd of a and b ; Function to convert the obtained fraction into it 's simplest form ; Finding gcd of both terms ; Converting both terms into simpler terms by dividing them by common factor ; Function to add two fractions ; Finding gcd of den1 and den2 ; Denominator of final fraction obtained finding LCM of den1 and den2 LCM * GCD = a * b ; Changing the fractions to have same denominator Numerator of the final fraction obtained ; Calling function to convert final fraction into it 's simplest form ; Driver program", "dfg": [["b", 24, "comesFrom", ["b"], [14]], ["b", 29, "comesFrom", ["b"], [14]], ["a", 19, "comesFrom", ["a"], [11]], ["a", 33, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]], ["den3", 61, "comesFrom", ["den3"], [59]], ["den3", 93, "comesFrom", ["den3"], [59]], ["den3", 113, "comesFrom", ["den3"], [105]], ["den3", 139, "comesFrom", ["den3"], [105]], ["den3", 183, "comesFrom", ["den3"], [167]], ["den3", 202, "comesFrom", ["den3"], [167]], ["den3", 122, "comesFrom", ["den3"], [105]], ["den3", 132, "comesFrom", ["den3"], [105]], ["num3", 67, "comesFrom", ["num3"], [65]], ["num3", 89, "comesFrom", ["num3"], [65]], ["num3", 141, "comesFrom", ["num3"], [115]], ["num3", 181, "comesFrom", ["num3"], [169]], ["num3", 200, "comesFrom", ["num3"], [169]], ["common_factor", 63, "comesFrom", ["common_factor"], [50]], ["common_factor", 69, "comesFrom", ["common_factor"], [50]], ["num1", 173, "comesFrom", ["num1"], [151]], ["num1", 192, "comesFrom", ["num1"], [151]], ["num1", 118, "comesFrom", ["num1"], [76]], ["den1", 175, "comesFrom", ["den1"], [155]], ["den1", 194, "comesFrom", ["den1"], [155]], ["den1", 100, "comesFrom", ["den1"], [79]], ["den1", 108, "comesFrom", ["den1"], [79]], ["den1", 124, "comesFrom", ["den1"], [79]], ["num2", 177, "comesFrom", ["num2"], [159]], ["num2", 196, "comesFrom", ["num2"], [159]], ["num2", 128, "comesFrom", ["num2"], [82]], ["den2", 179, "comesFrom", ["den2"], [163]], ["den2", 198, "comesFrom", ["den2"], [163]], ["den2", 102, "comesFrom", ["den2"], [85]], ["den2", 110, "comesFrom", ["den2"], [85]], ["den2", 134, "comesFrom", ["den2"], [85]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLargestDivisor ( int n ) { for ( int i = 2 ; i < sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; } int main ( ) { int n = 12 ; cout << findLargestDivisor ( n ) << endl ; n = 97 ; cout << findLargestDivisor ( n ) << endl ; return 0 ; }", "docstring": "Largest Divisor of a Number not divisible by a perfect square | Efficient C ++ Program to find the largest divisor not divisible by any perfect square greater than 1 ; Function to find the largest divisor not divisible by any perfect square greater than 1 ; If the number is divisible by i * i , then remove one i ; Now all squares are removed from n ; Driver Code", "dfg": [["n", 56, "comesFrom", ["n"], [47]], ["n", 25, "comesFrom", ["n"], [11]], ["n", 73, "comesFrom", ["n"], [65]], ["n", 86, "comesFrom", ["n"], [78]], ["n", 36, "comesFrom", ["n"], [11]], ["n", 49, "comesFrom", ["n"], [47]], ["i", 21, "comesFrom", ["i"], [17]], ["i", 30, "comesFrom", ["i"], [17]], ["i", 51, "comesFrom", ["i"], [17]], ["i", 39, "comesFrom", ["i"], [17]], ["i", 41, "comesFrom", ["i"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << \" Yes \" << endl ) : ( cout << \" No \" << endl ) ; return 0 ; }", "docstring": "Arithmetic Progression | C ++ program to check if a given array can form arithmetic progression ; Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; Driven Program", "dfg": [["i", 57, "comesFrom", ["i"], [53]], ["i", 61, "comesFrom", ["i"], [53]], ["i", 68, "comesFrom", ["i"], [53]], ["i", 73, "comesFrom", ["i"], [53]], ["n", 59, "comesFrom", ["n"], [16]], ["n", 21, "comesFrom", ["n"], [16]], ["n", 34, "comesFrom", ["n"], [16]], ["n", 130, "comesFrom", ["n"], [110]], ["d", 78, "comesFrom", ["d"], [38]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n and n != 1 ) return true ; else false ; } int main ( ) { int n = 120 ; if ( isTriPerfect ( n ) ) cout << n << \" ▁ is ▁ a ▁ Triperfect ▁ number \" ; }", "docstring": "Check if a number is Triperfect Number | CPP code to check if a given number is Triperfect or not ; Returns true if n is Triperfect ; To store sum of divisors . Adding 1 and n since they are divisors of n . ; Find all divisors and add them ; If sum of divisors is equal to 3 * n , then n is a Triperfect number ; Driver program", "dfg": [["n", 19, "comesFrom", ["n"], [11]], ["n", 32, "comesFrom", ["n"], [11]], ["n", 83, "comesFrom", ["n"], [11]], ["n", 108, "comesFrom", ["n"], [100]], ["n", 113, "comesFrom", ["n"], [100]], ["n", 81, "comesFrom", ["n"], [11]], ["n", 37, "comesFrom", ["n"], [11]], ["n", 46, "comesFrom", ["n"], [11]], ["n", 65, "comesFrom", ["n"], [11]], ["i", 28, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 39, "comesFrom", ["i"], [22]], ["i", 50, "comesFrom", ["i"], [22]], ["i", 48, "comesFrom", ["i"], [22]], ["i", 56, "comesFrom", ["i"], [22]], ["i", 63, "comesFrom", ["i"], [22]], ["i", 67, "comesFrom", ["i"], [22]], ["sum", 77, "comesFrom", ["sum"], [59]], ["sum", 54, "comesFrom", ["sum"], [52]], ["sum", 61, "comesFrom", ["sum"], [59]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; } int main ( ) { int N = 14 ; int X = 3 , Y = 5 ; cout << sum ( N , X , Y ) ; return 0 ; }", "docstring": "Sum of first N natural numbers which are divisible by X or Y | C ++ program to find sum of numbers from 1 to N which are divisible by X or Y ; Function to calculate the sum of numbers divisible by X or Y ; Driver code", "dfg": [["S3", 132, "comesFrom", ["S3"], [83]], ["S1", 128, "comesFrom", ["S1"], [27]], ["S2", 130, "comesFrom", ["S2"], [55]], ["N", 158, "comesFrom", ["N"], [141]], ["N", 31, "comesFrom", ["N"], [11]], ["N", 59, "comesFrom", ["N"], [11]], ["N", 87, "comesFrom", ["N"], [11]], ["N", 43, "comesFrom", ["N"], [11]], ["N", 71, "comesFrom", ["N"], [11]], ["N", 107, "comesFrom", ["N"], [11]], ["X", 160, "comesFrom", ["X"], [146]], ["X", 33, "comesFrom", ["X"], [14]], ["X", 40, "comesFrom", ["X"], [14]], ["X", 50, "comesFrom", ["X"], [14]], ["X", 90, "comesFrom", ["X"], [14]], ["X", 101, "comesFrom", ["X"], [14]], ["X", 119, "comesFrom", ["X"], [14]], ["X", 45, "comesFrom", ["X"], [14]], ["X", 110, "comesFrom", ["X"], [14]], ["Y", 162, "comesFrom", ["Y"], [150]], ["Y", 61, "comesFrom", ["Y"], [17]], ["Y", 68, "comesFrom", ["Y"], [17]], ["Y", 78, "comesFrom", ["Y"], [17]], ["Y", 92, "comesFrom", ["Y"], [17]], ["Y", 103, "comesFrom", ["Y"], [17]], ["Y", 121, "comesFrom", ["Y"], [17]], ["Y", 73, "comesFrom", ["Y"], [17]], ["Y", 112, "comesFrom", ["Y"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; } int main ( ) { int l = 1 , r = 10 ; cout << findTwoThreePrime ( l , r ) ; return 0 ; }", "docstring": "Count numbers from range whose prime factors are only 2 and 3 | C ++ program to count the numbers within a range whose prime factors are only 2 and 3 ; Function to count the number within a range whose prime factors are only 2 and 3 ; Start with 2 so that 1 doesn 't get counted ; While num is divisible by 2 , divide it by 2 ; While num is divisible by 3 , divide it by 3 ; If num got reduced to 1 then it has only 2 and 3 as prime factors ; Driver code", "dfg": [["count", 86, "comesFrom", ["count"], [27]], ["count", 81, "comesFrom", ["count"], [27]], ["i", 38, "comesFrom", ["i"], [34]], ["i", 42, "comesFrom", ["i"], [34]], ["r", 40, "comesFrom", ["r"], [14]], ["r", 109, "comesFrom", ["r"], [99]], ["l", 19, "comesFrom", ["l"], [11]], ["l", 23, "comesFrom", ["l"], [11]], ["l", 107, "comesFrom", ["l"], [95]], ["num", 77, "comesFrom", ["num"], [71]], ["num", 53, "comesFrom", ["num"], [47]], ["num", 65, "comesFrom", ["num"], [59]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string getNumber ( string s ) { int number_of_digits = s . length ( ) ; int freq [ 10 ] = { 0 } ; for ( int i = 0 ; i < number_of_digits ; i ++ ) { if ( s [ i ] == '1' s [ i ] == '2' s [ i ] == '3' s [ i ] == '5' s [ i ] == '7' ) { freq [ s [ i ] - 48 ] += 1 ; } if ( s [ i ] == '4' ) { freq [ 2 ] += 2 ; freq [ 3 ] ++ ; } if ( s [ i ] == '6' ) { freq [ 5 ] ++ ; freq [ 3 ] ++ ; } if ( s [ i ] == '8' ) { freq [ 7 ] ++ ; freq [ 2 ] += 3 ; } if ( s [ i ] == '9' ) { freq [ 7 ] ++ ; freq [ 3 ] += 2 ; freq [ 2 ] ++ ; } } string t = \" \" ; if ( freq [ 1 ] == number_of_digits || freq [ 0 ] == number_of_digits || ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) { return s ; } else { for ( int i = 9 ; i >= 2 ; i -- ) { int ctr = freq [ i ] ; while ( ctr -- ) { t += ( char ) ( i + 48 ) ; } } return t ; } } int main ( ) { string s = \"1280\" ; cout << getNumber ( s ) ; return 0 ; }", "docstring": "Maximum number with same digit factorial product | C ++ implementation of the approach ; Function to return the required number ; Count the frequency of each digit ; 4 ! can be expressed as 2 ! * 2 ! * 3 ! ; 6 ! can be expressed as 5 ! * 3 ! ; 8 ! can be expressed as 7 ! * 2 ! * 2 ! * 2 ! ; 9 ! can be expressed as 7 ! * 3 ! * 3 ! * 2 ! ; To store the required number ; If number has only either 1 and 0 as its digits ; Generate the greatest number possible ; Driver code", "dfg": [["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 266, "comesFrom", ["i"], [262]], ["i", 270, "comesFrom", ["i"], [262]], ["i", 109, "comesFrom", ["i"], [36]], ["i", 135, "comesFrom", ["i"], [36]], ["i", 160, "comesFrom", ["i"], [36]], ["i", 186, "comesFrom", ["i"], [36]], ["i", 84, "comesFrom", ["i"], [36]], ["i", 76, "comesFrom", ["i"], [36]], ["i", 279, "comesFrom", ["i"], [262]], ["i", 68, "comesFrom", ["i"], [36]], ["i", 52, "comesFrom", ["i"], [36]], ["i", 60, "comesFrom", ["i"], [36]], ["i", 96, "comesFrom", ["i"], [36]], ["i", 294, "comesFrom", ["i"], [262]], ["number_of_digits", 42, "comesFrom", ["number_of_digits"], [15]], ["number_of_digits", 250, "comesFrom", ["number_of_digits"], [15]], ["number_of_digits", 229, "comesFrom", ["number_of_digits"], [15]], ["number_of_digits", 236, "comesFrom", ["number_of_digits"], [15]], ["s", 254, "comesFrom", ["s"], [11]], ["s", 17, "comesFrom", ["s"], [11]], ["s", 322, "comesFrom", ["s"], [312]], ["s", 107, "comesFrom", ["s"], [11]], ["s", 133, "comesFrom", ["s"], [11]], ["s", 158, "comesFrom", ["s"], [11]], ["s", 184, "comesFrom", ["s"], [11]], ["s", 82, "comesFrom", ["s"], [11]], ["s", 74, "comesFrom", ["s"], [11]], ["s", 50, "comesFrom", ["s"], [11]], ["s", 66, "comesFrom", ["s"], [11]], ["s", 94, "comesFrom", ["s"], [11]], ["s", 58, "comesFrom", ["s"], [11]], ["t", 302, "comesFrom", ["t"], [288]], ["ctr", 284, "comesFrom", ["ctr"], [275]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } void icanobifNumbers ( int N ) { int first = 0 , second = 1 ; if ( N == 1 ) cout << first ; else if ( N == 2 ) cout << first << \" ▁ \" << second ; else { cout << first << \" ▁ \" << second << \" ▁ \" ; for ( int i = 3 ; i <= N ; i ++ ) { int x = reversDigits ( first ) ; int y = reversDigits ( second ) ; cout << x + y << \" ▁ \" ; int temp = second ; second = x + y ; first = temp ; } } } int main ( ) { int N = 12 ; icanobifNumbers ( N ) ; return 0 ; }", "docstring": "Program to find first N Iccanobif Numbers | C ++ program to find first N Icanobif numbers ; Iterative function to reverse digits of num ; Function to print first N Icanobif Numbers ; Initialize first , second numbers ; Print first two numbers ; Reversing digit of previous two terms and adding them ; Driver Code", "dfg": [["rev_num", 44, "comesFrom", ["rev_num"], [26]], ["rev_num", 28, "comesFrom", ["rev_num"], [26]], ["num", 21, "comesFrom", ["num"], [11]], ["num", 38, "comesFrom", ["num"], [36]], ["num", 32, "comesFrom", ["num"], [11]], ["N", 65, "comesFrom", ["N"], [51]], ["N", 177, "comesFrom", ["N"], [171]], ["N", 76, "comesFrom", ["N"], [51]], ["N", 115, "comesFrom", ["N"], [51]], ["first", 71, "comesFrom", ["first"], [55]], ["first", 82, "comesFrom", ["first"], [55]], ["first", 94, "comesFrom", ["first"], [55]], ["first", 126, "comesFrom", ["first"], [55]], ["second", 88, "comesFrom", ["second"], [59]], ["second", 100, "comesFrom", ["second"], [59]], ["second", 134, "comesFrom", ["second"], [59]], ["i", 113, "comesFrom", ["i"], [109]], ["i", 117, "comesFrom", ["i"], [109]], ["temp", 160, "comesFrom", ["temp"], [148]], ["x", 154, "comesFrom", ["x"], [122]], ["x", 139, "comesFrom", ["x"], [122]], ["y", 156, "comesFrom", ["y"], [130]], ["y", 141, "comesFrom", ["y"], [130]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return -1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; } int main ( ) { int a = 5 , b = 3 , n = 3 ; cout << addNDigits ( a , b , n ) ; return 0 ; }", "docstring": "Add N digits to A such that it is divisible by B after each addition | C ++ implementation of the approach ; Try all digits from ( 0 to 9 ) ; Fails in the first move itself ; Add ( n - 1 ) 0 's ; Driver Program to test above function", "dfg": [["a", 96, "comesFrom", ["a"], [91]], ["a", 70, "comesFrom", ["a"], [58]], ["a", 121, "comesFrom", ["a"], [105]], ["a", 43, "comesFrom", ["a"], [23]], ["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 47, "comesFrom", ["i"], [28]], ["j", 82, "comesFrom", ["j"], [78]], ["j", 88, "comesFrom", ["j"], [78]], ["num", 68, "comesFrom", ["num"], [21]], ["n", 84, "comesFrom", ["n"], [17]], ["n", 125, "comesFrom", ["n"], [113]], ["b", 123, "comesFrom", ["b"], [109]], ["b", 53, "comesFrom", ["b"], [14]], ["tmp", 51, "comesFrom", ["tmp"], [41]], ["tmp", 60, "comesFrom", ["tmp"], [41]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; } int main ( ) { int n = 10 ; cout << Triplets ( n ) ; return 0 ; }", "docstring": "Count number of triplets ( a , b , c ) such that a ^ 2 + b ^ 2 = c ^ 2 and 1 <= a <= b <= c <= n | C ++ program to Find number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; function to ind number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; to store required answer ; run nested loops for first two numbers . ; third number ; check if third number is perfect square and less than n ; Driver code ; function call", "dfg": [["ans", 86, "comesFrom", ["ans"], [15]], ["ans", 81, "comesFrom", ["ans"], [15]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 31, "comesFrom", ["i"], [22]], ["i", 52, "comesFrom", ["i"], [39]], ["i", 54, "comesFrom", ["i"], [39]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 43, "comesFrom", ["n"], [11]], ["n", 103, "comesFrom", ["n"], [95]], ["n", 78, "comesFrom", ["n"], [11]], ["j", 41, "comesFrom", ["j"], [37]], ["j", 46, "comesFrom", ["j"], [37]], ["j", 56, "comesFrom", ["j"], [37]], ["j", 58, "comesFrom", ["j"], [37]], ["x", 65, "comesFrom", ["x"], [50]], ["x", 74, "comesFrom", ["x"], [50]], ["y", 76, "comesFrom", ["y"], [61]], ["y", 70, "comesFrom", ["y"], [61]], ["y", 72, "comesFrom", ["y"], [61]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int n , int base ) { int sum = 0 ; while ( n > 0 ) { int remainder = n % base ; sum += remainder ; n = n / base ; } return sum ; } void SumsOfDigits ( int n ) { int sum = 0 ; for ( int base = 2 ; base <= n / 2 ; ++ base ) sum += solve ( n , base ) ; cout << sum ; } int main ( ) { int n = 8 ; SumsOfDigits ( n ) ; return 0 ; }", "docstring": "Sum of the digits of a number N written in all bases from 2 to N / 2 | C ++ implementation of the approach ; Function to calculate the sum of the digits of n in the given base ; Sum of digits ; Digit of n in the given base ; Add the digit ; Function to calculate the sum of digits of n in bases from 2 to n / 2 ; to store digit sum in all bases ; function call for multiple bases ; Driver program", "dfg": [["sum", 48, "comesFrom", ["sum"], [36]], ["sum", 90, "comesFrom", ["sum"], [79]], ["base", 70, "comesFrom", ["base"], [66]], ["base", 77, "comesFrom", ["base"], [66]], ["base", 34, "comesFrom", ["base"], [14]], ["base", 44, "comesFrom", ["base"], [14]], ["base", 85, "comesFrom", ["base"], [66]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 72, "comesFrom", ["n"], [55]], ["n", 105, "comesFrom", ["n"], [99]], ["n", 32, "comesFrom", ["n"], [11]], ["n", 42, "comesFrom", ["n"], [40]], ["n", 83, "comesFrom", ["n"], [55]], ["remainder", 38, "comesFrom", ["remainder"], [30]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPerfectcube ( int n ) { int d = cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; } int largestNonPerfectcubeNumber ( int a [ ] , int n ) { int maxi = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! checkPerfectcube ( a [ i ] ) ) maxi = max ( a [ i ] , maxi ) ; } return maxi ; } int main ( ) { int a [ ] = { 16 , 64 , 25 , 2 , 3 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << largestNonPerfectcubeNumber ( a , n ) ; return 0 ; }", "docstring": "Largest number in an array that is not a perfect cube | CPP program to find the largest non - perfect cube number among n numbers ; Function to check if a number is perfect cube number or not ; takes the sqrt of the number ; checks if it is a perfect cube number ; Function to find the largest non perfect cube number in the array ; stores the maximum of all perfect cube numbers ; Traverse all elements in the array ; store the maximum if current element is a non perfect cube ; Driver Code", "dfg": [["maxi", 96, "comesFrom", ["maxi"], [82]], ["maxi", 91, "comesFrom", ["maxi"], [82]], ["i", 63, "comesFrom", ["i"], [59]], ["i", 67, "comesFrom", ["i"], [59]], ["i", 78, "comesFrom", ["i"], [59]], ["i", 88, "comesFrom", ["i"], [59]], ["n", 65, "comesFrom", ["n"], [48]], ["n", 30, "comesFrom", ["n"], [11]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 145, "comesFrom", ["n"], [124]], ["d", 28, "comesFrom", ["d"], [15]], ["d", 24, "comesFrom", ["d"], [15]], ["d", 26, "comesFrom", ["d"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkIfPossibleRec ( int x , int a , int b , bool isPossible [ ] , int n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; } bool checkPossible ( int n , int a , int b ) { bool isPossible [ n + 1 ] = { false } ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; } int main ( ) { int a = 3 , b = 7 , n = 8 ; if ( checkPossible ( a , b , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if N can be represented as sum of integers chosen from set { A , B } | CPP program to find if number N can be represented as sum of a ' s ▁ and ▁ b ' s ; Function to find if number N can be represented as sum of a ' s ▁ and ▁ b ' s ; base condition ; if x is already visited ; set x as possible ; recursive call ; Driver program", "dfg": [["x", 30, "comesFrom", ["x"], [11]], ["x", 40, "comesFrom", ["x"], [11]], ["x", 47, "comesFrom", ["x"], [11]], ["x", 54, "comesFrom", ["x"], [11]], ["x", 69, "comesFrom", ["x"], [11]], ["n", 32, "comesFrom", ["n"], [25]], ["n", 64, "comesFrom", ["n"], [25]], ["n", 79, "comesFrom", ["n"], [25]], ["n", 118, "comesFrom", ["n"], [87]], ["n", 124, "comesFrom", ["n"], [87]], ["n", 99, "comesFrom", ["n"], [87]], ["n", 154, "comesFrom", ["n"], [142]], ["a", 58, "comesFrom", ["a"], [14]], ["a", 73, "comesFrom", ["a"], [14]], ["a", 112, "comesFrom", ["a"], [90]], ["a", 56, "comesFrom", ["a"], [14]], ["a", 150, "comesFrom", ["a"], [134]], ["b", 60, "comesFrom", ["b"], [17]], ["b", 75, "comesFrom", ["b"], [17]], ["b", 114, "comesFrom", ["b"], [93]], ["b", 71, "comesFrom", ["b"], [17]], ["b", 152, "comesFrom", ["b"], [138]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOdd ( int n ) { int terms = ( n + 1 ) / 2 ; int sum = terms * terms ; return sum ; } int suminRange ( int l , int r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; } int main ( ) { int l = 2 , r = 5 ; cout << \" Sum ▁ of ▁ odd ▁ natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ \" << suminRange ( l , r ) ; return 0 ; }", "docstring": "Sum of all odd natural numbers in range L and R | C ++ program to print the sum of all numbers in range L and R ; Function to return the sum of all odd natural numbers ; Function to return the sum of all odd numbers in range L and R ; Driver Code", "dfg": [["sum", 33, "comesFrom", ["sum"], [26]], ["terms", 28, "comesFrom", ["terms"], [15]], ["terms", 30, "comesFrom", ["terms"], [15]], ["r", 49, "comesFrom", ["r"], [43]], ["r", 84, "comesFrom", ["r"], [70]], ["l", 82, "comesFrom", ["l"], [66]], ["l", 54, "comesFrom", ["l"], [40]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int sumcommDiv ( int a , int b ) { int n = gcd ( a , b ) ; int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; } int main ( ) { int a = 10 , b = 15 ; cout << \" Sum ▁ = ▁ \" << sumcommDiv ( a , b ) ; return 0 ; }", "docstring": "Sum of common divisors of two numbers A and B | C ++ implementation of above approach ; Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Find the sum of divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; Driver program to run the case", "dfg": [["sum", 115, "comesFrom", ["sum"], [102]], ["b", 24, "comesFrom", ["b"], [14]], ["b", 29, "comesFrom", ["b"], [14]], ["b", 54, "comesFrom", ["b"], [44]], ["b", 142, "comesFrom", ["b"], [128]], ["i", 69, "comesFrom", ["i"], [65]], ["i", 76, "comesFrom", ["i"], [65]], ["i", 84, "comesFrom", ["i"], [65]], ["i", 95, "comesFrom", ["i"], [65]], ["i", 99, "comesFrom", ["i"], [65]], ["i", 93, "comesFrom", ["i"], [65]], ["i", 110, "comesFrom", ["i"], [65]], ["i", 107, "comesFrom", ["i"], [65]], ["a", 19, "comesFrom", ["a"], [11]], ["a", 33, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]], ["a", 52, "comesFrom", ["a"], [41]], ["a", 140, "comesFrom", ["a"], [124]], ["n", 73, "comesFrom", ["n"], [48]], ["n", 82, "comesFrom", ["n"], [48]], ["n", 91, "comesFrom", ["n"], [48]], ["n", 105, "comesFrom", ["n"], [48]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; string checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp /= 1000 ; else if ( temp % 100 == 14 ) temp /= 100 ; else if ( temp % 10 == 1 ) temp /= 10 ; else { return \" NO \" ; } } return \" YES \" ; } int main ( ) { int N = 1414 ; cout << checkNumber ( N ) ; return 0 ; }", "docstring": "Check if a number is formed by Concatenation of 1 , 14 or 144 only | C ++ program to check if a number is formed by Concatenation of 1 , 14 or 144 only ; Function to check if a number is formed by Concatenation of 1 , 14 or 144 only ; check for each possible digit if given number consist other then 1 , 14 , 144 print NO else print YES ; Driver Code", "dfg": [["temp", 21, "comesFrom", ["temp"], [15]], ["temp", 28, "comesFrom", ["temp"], [15]], ["temp", 41, "comesFrom", ["temp"], [34]], ["temp", 54, "comesFrom", ["temp"], [47]], ["N", 93, "comesFrom", ["N"], [85]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int getResult ( int n ) { if ( n & 1 ) return 1 ; return -1 ; } int main ( ) { int n = 3 ; cout << getResult ( n ) ; }", "docstring": "Fibonacci problem ( Value of Fib ( N ) * Fib ( N ) | C ++ implementation of the approach ; Driver code", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 41, "comesFrom", ["n"], [33]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { cout << \" NO \" ; return ; } double a = ( N + sqrt ( val ) ) / 2.0 ; double b = ( N - sqrt ( val ) ) / 2.0 ; cout << \" a ▁ = ▁ \" << a << endl ; cout << \" b ▁ = ▁ \" << b << endl ; } int main ( ) { double N = 69.0 ; findAandB ( N ) ; return 0 ; }", "docstring": "Find two numbers with sum and product both same as N | C ++ program to find a and b such that a * b = N and a + b = N ; Function to return the smallest string ; Not possible ; find a and b ; Driver Code", "dfg": [["val", 27, "comesFrom", ["val"], [15]], ["val", 49, "comesFrom", ["val"], [15]], ["val", 63, "comesFrom", ["val"], [15]], ["a", 75, "comesFrom", ["a"], [42]], ["b", 85, "comesFrom", ["b"], [56]], ["N", 102, "comesFrom", ["N"], [96]], ["N", 17, "comesFrom", ["N"], [11]], ["N", 19, "comesFrom", ["N"], [11]], ["N", 23, "comesFrom", ["N"], [11]], ["N", 45, "comesFrom", ["N"], [11]], ["N", 59, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int A [ ] , int n ) { if ( n & 1 ) return -1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { A [ i ] == 0 ? zeros ++ : ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return -1 ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minOperations ( A , n ) ; return 0 ; }", "docstring": "Find minimum operations needed to make an Array beautiful | CPP implementation of above approach ; Function to find minimum operations required to make array beautiful ; counting consecutive zeros . ; check that start and end are same ; check is zero and one are equal ; Driver program", "dfg": [["i", 48, "comesFrom", ["i"], [44]], ["i", 53, "comesFrom", ["i"], [44]], ["i", 71, "comesFrom", ["i"], [44]], ["i", 58, "comesFrom", ["i"], [44]], ["i", 82, "comesFrom", ["i"], [44]], ["i", 89, "comesFrom", ["i"], [44]], ["n", 50, "comesFrom", ["n"], [16]], ["n", 21, "comesFrom", ["n"], [16]], ["n", 181, "comesFrom", ["n"], [160]], ["n", 75, "comesFrom", ["n"], [16]], ["n", 110, "comesFrom", ["n"], [16]], ["consZeros", 132, "comesFrom", ["consZeros"], [33]], ["consZeros", 122, "comesFrom", ["consZeros"], [33]], ["consZeros", 96, "comesFrom", ["consZeros"], [33]], ["zeros", 127, "comesFrom", ["zeros"], [29]], ["zeros", 63, "comesFrom", ["zeros"], [29]], ["ones", 129, "comesFrom", ["ones"], [37]], ["ones", 66, "comesFrom", ["ones"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countdig ( int m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( m / 10 ) ; } int countSteps ( int x ) { int c = 0 ; int last = x ; while ( last ) { int digits = countdig ( last ) ; digits -= 1 ; int divisor = pow ( 10 , digits ) ; int first = last / divisor ; int lastnumber = first * divisor ; int skipped = ( last - lastnumber ) / first ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; } int main ( ) { int n = 14 ; cout << countSteps ( n ) ; return 0 ; }", "docstring": "Steps to reduce N to zero by subtracting its most significant digit at every step | C ++ program to find the count of Steps to reduce N to zero by subtracting its most significant digit at every step ; Function to count the number of digits in a number m ; Function to count the number of steps to reach 0 ; count the total number of stesp ; iterate till we reach 0 ; count the digits in last ; decrease it by 1 ; find the number on whose division , we get the first digit ; first digit in last ; find the first number less than last where the first digit changes ; find the number of numbers with same first digit that are jumped ; count the steps ; the next number with a different first digit ; Driver code", "dfg": [["c", 124, "comesFrom", ["c"], [108]], ["last", 54, "comesFrom", ["last"], [48]], ["last", 82, "comesFrom", ["last"], [48]], ["last", 114, "comesFrom", ["last"], [112]], ["last", 62, "comesFrom", ["last"], [48]], ["last", 97, "comesFrom", ["last"], [48]], ["m", 16, "comesFrom", ["m"], [11]], ["m", 29, "comesFrom", ["m"], [11]], ["skipped", 110, "comesFrom", ["skipped"], [104]], ["skipped", 119, "comesFrom", ["skipped"], [104]], ["n", 141, "comesFrom", ["n"], [133]], ["divisor", 84, "comesFrom", ["divisor"], [70]], ["divisor", 91, "comesFrom", ["divisor"], [70]], ["first", 89, "comesFrom", ["first"], [80]], ["first", 102, "comesFrom", ["first"], [80]], ["first", 117, "comesFrom", ["first"], [80]], ["digits", 76, "comesFrom", ["digits"], [65]], ["lastnumber", 99, "comesFrom", ["lastnumber"], [87]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; ll power ( ll x , ll y , ll p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } ll gcd ( ll a , ll b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } ll powerGCD ( ll a , ll b , ll n ) { ll e = power ( a , n , b ) ; return gcd ( e , b ) ; } int main ( ) { ll a = 5 , b = 4 , n = 2 ; cout << powerGCD ( a , b , n ) ; return 0 ; }", "docstring": "GCD of a number raised to some power and another number | C ++ program of the above approach ; Calculates modular exponentiation , i . e . , ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Returns GCD of a ^ n and b ; Driver code", "dfg": [["res", 61, "comesFrom", ["res"], [39]], ["res", 42, "comesFrom", ["res"], [39]], ["b", 81, "comesFrom", ["b"], [71]], ["b", 124, "comesFrom", ["b"], [101]], ["b", 86, "comesFrom", ["b"], [71]], ["b", 116, "comesFrom", ["b"], [101]], ["b", 152, "comesFrom", ["b"], [138]], ["y", 28, "comesFrom", ["y"], [20]], ["y", 35, "comesFrom", ["y"], [20]], ["a", 76, "comesFrom", ["a"], [68]], ["a", 90, "comesFrom", ["a"], [68]], ["a", 88, "comesFrom", ["a"], [68]], ["a", 112, "comesFrom", ["a"], [98]], ["a", 150, "comesFrom", ["a"], [134]], ["e", 122, "comesFrom", ["e"], [108]], ["n", 114, "comesFrom", ["n"], [104]], ["n", 154, "comesFrom", ["n"], [142]], ["p", 57, "comesFrom", ["p"], [23]], ["p", 47, "comesFrom", ["p"], [23]], ["x", 52, "comesFrom", ["x"], [49]], ["x", 54, "comesFrom", ["x"], [49]], ["x", 44, "comesFrom", ["x"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool allOddDigits ( int n ) { while ( n ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n /= 10 ; } return true ; } int largestNumber ( int n ) { if ( n % 2 == 0 ) n -- ; for ( int i = n ; ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; } int main ( ) { int N = 23 ; cout << largestNumber ( N ) ; return 0 ; }", "docstring": "Largest number not greater than N all the digits of which are odd | CPP program to print the largest integer not greater than N with all odd digits ; Function to check if all digits of a number are odd ; iterate for all digits ; if digit is even ; all digits are odd ; function to return the largest number with all digits odd ; iterate till we find a number with all digits odd ; Driver Code", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 58, "comesFrom", ["n"], [47]], ["n", 52, "comesFrom", ["n"], [47]], ["n", 22, "comesFrom", ["n"], [11]], ["i", 81, "comesFrom", ["i"], [69]], ["i", 77, "comesFrom", ["i"], [69]], ["N", 98, "comesFrom", ["N"], [90]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestNumber ( int n ) { string s = \" \" ; int duplicate = n ; while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( ( s [ i ] - '0' ) % 2 & 1 ) == 0 ) { index = i ; break ; } } if ( index == -1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' - 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 9 ; return num ; } int main ( ) { int N = 24578 ; cout << largestNumber ( N ) ; return 0 ; }", "docstring": "Largest number not greater than N all the digits of which are odd | CPP program to print the largest integer not greater than N with all odd digits ; function to return the largest number with all digits odd ; convert the number to a string for easy operations ; find first even digit ; if no even digit , then N is the answer ; till first even digit , add all odd numbers ; decrease 1 from the even digit ; add 9 in the rest of the digits ; Driver Code", "dfg": [["num", 196, "comesFrom", ["num"], [187]], ["num", 150, "comesFrom", ["num"], [148]], ["num", 133, "comesFrom", ["num"], [131]], ["num", 189, "comesFrom", ["num"], [187]], ["n", 28, "comesFrom", ["n"], [24]], ["n", 35, "comesFrom", ["n"], [24]], ["i", 61, "comesFrom", ["i"], [57]], ["i", 69, "comesFrom", ["i"], [57]], ["i", 124, "comesFrom", ["i"], [120]], ["i", 128, "comesFrom", ["i"], [120]], ["i", 176, "comesFrom", ["i"], [170]], ["i", 184, "comesFrom", ["i"], [170]], ["i", 97, "comesFrom", ["i"], [57]], ["i", 140, "comesFrom", ["i"], [120]], ["i", 79, "comesFrom", ["i"], [57]], ["duplicate", 110, "comesFrom", ["duplicate"], [22]], ["index", 126, "comesFrom", ["index"], [95]], ["index", 105, "comesFrom", ["index"], [95]], ["index", 172, "comesFrom", ["index"], [95]], ["index", 157, "comesFrom", ["index"], [95]], ["s", 63, "comesFrom", ["s"], [31]], ["s", 178, "comesFrom", ["s"], [31]], ["s", 42, "comesFrom", ["s"], [31]], ["s", 138, "comesFrom", ["s"], [31]], ["s", 155, "comesFrom", ["s"], [31]], ["s", 77, "comesFrom", ["s"], [31]], ["N", 213, "comesFrom", ["N"], [205]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int N ) { return int ( sqrt ( N ) ) - 1 ; } int main ( ) { int N = 36 ; cout << countNumbers ( N ) ; return 0 ; }", "docstring": "Count number less than N which are product of perfect squares | C ++ program to count number less than N which are product of any two perfect squares ; Function to count number less than N which are product of any two perfect squares ; Driver program", "dfg": [["N", 40, "comesFrom", ["N"], [32]], ["N", 19, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= int ( sqrt ( N - 1 ) ) ; return count_pairs ; } int main ( ) { int N = 5 ; cout << countOrderedPairs ( N ) ; return 0 ; }", "docstring": "Count ordered pairs with product less than N | C ++ implementation of above approach ; Function to return count of Ordered pairs whose product are less than N ; Initialize count to 0 ; count total pairs ; multiply by 2 to get ordered_pairs ; subtract redundant pairs ( a , b ) where a == b . ; return answer ; Driver code ; function call to print required answer", "dfg": [["count_pairs", 76, "comesFrom", ["count_pairs"], [63]], ["count_pairs", 56, "comesFrom", ["count_pairs"], [15]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 36, "comesFrom", ["i"], [22]], ["i", 48, "comesFrom", ["i"], [44]], ["N", 50, "comesFrom", ["N"], [11]], ["N", 93, "comesFrom", ["N"], [85]], ["N", 30, "comesFrom", ["N"], [11]], ["N", 69, "comesFrom", ["N"], [11]], ["j", 53, "comesFrom", ["j"], [42]], ["j", 46, "comesFrom", ["j"], [42]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = abs ( arr [ i ] - arr [ i + 1 ] ) ; cout << diff << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 4 , 10 , 15 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pairwiseDifference ( arr , n ) ; return 0 ; }", "docstring": "Absolute Difference of all pairwise consecutive elements in an array | C ++ program to print the absolute difference of the consecutive elements ; Function to print pairwise absolute difference of consecutive elements ; absolute difference between consecutive numbers ; Driver Code", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 35, "comesFrom", ["i"], [25]], ["i", 45, "comesFrom", ["i"], [25]], ["i", 50, "comesFrom", ["i"], [25]], ["n", 31, "comesFrom", ["n"], [16]], ["n", 108, "comesFrom", ["n"], [89]], ["diff", 58, "comesFrom", ["diff"], [39]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long sumAP ( long long n , long long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } long long sumMultiples ( long long n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; } int main ( ) { long long n = 20 ; cout << sumMultiples ( n ) ; return 0 ; }", "docstring": "Find the sum of all multiples of 2 and 5 below N | CPP program to find the sum of all multiples of 2 and 5 below N ; Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of 2 and 5 below N ; Since , we need the sum of multiples less than N ; Driver code", "dfg": [["d", 22, "comesFrom", ["d"], [17]], ["d", 35, "comesFrom", ["d"], [17]], ["n", 49, "comesFrom", ["n"], [46]], ["n", 69, "comesFrom", ["n"], [46]], ["n", 90, "comesFrom", ["n"], [82]], ["n", 26, "comesFrom", ["n"], [20]], ["n", 55, "comesFrom", ["n"], [46]], ["n", 62, "comesFrom", ["n"], [46]], ["n", 32, "comesFrom", ["n"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int markingScheme ( int N , int answerKey [ ] , int studentAnswer [ ] ) { int positive = 0 , negative = 0 , notattempt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * -1 ) ; } int main ( ) { int answerKey [ ] = { 1 , 2 , 3 , 4 , 1 } ; int studentAnswer [ ] = { 1 , 2 , 3 , 4 , 0 } ; int N = sizeof ( answerKey ) / sizeof ( answerKey [ 0 ] ) ; cout << markingScheme ( N , answerKey , studentAnswer ) ; return 0 ; }", "docstring": "Find the total marks obtained according to given marking scheme | C ++ implementation of above approach ; Function that calculates marks . ; for not attempt score + 0 ; for each correct answer score + 3 ; for each wrong answer score - 1 ; calculate total marks ; Driver code", "dfg": [["i", 44, "comesFrom", ["i"], [40]], ["i", 48, "comesFrom", ["i"], [40]], ["i", 56, "comesFrom", ["i"], [40]], ["i", 69, "comesFrom", ["i"], [40]], ["i", 74, "comesFrom", ["i"], [40]], ["i", 85, "comesFrom", ["i"], [40]], ["i", 90, "comesFrom", ["i"], [40]], ["N", 46, "comesFrom", ["N"], [11]], ["N", 170, "comesFrom", ["N"], [151]], ["positive", 99, "comesFrom", ["positive"], [25]], ["positive", 77, "comesFrom", ["positive"], [25]], ["negative", 105, "comesFrom", ["negative"], [29]], ["negative", 93, "comesFrom", ["negative"], [29]], ["notattempt", 61, "comesFrom", ["notattempt"], [33]]]}
{"code": "#include \" cstring \" NEW_LINE #include <iostream> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE bool prime [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } int solve ( int n ) { int count = 0 , num = 1 ; long long int prod = 1 ; while ( count < n ) { if ( prime [ num ] ) { prod *= num ; count ++ ; } num ++ ; } return prod ; } int main ( ) { SieveOfEratosthenes ( ) ; int n = 5 ; cout << solve ( n ) ; return 0 ; }", "docstring": "Find the Product of first N Prime Numbers | C ++ implementation of above solution ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; find the product of 1 st N prime numbers ; count of prime numbers ; product of prime numbers ; if the number is prime add it ; increase the count ; get to next number ; Driver code ; create the sieve ; find the value of 1 st n prime numbers", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int divisor ( int a ) { int div = 1 , count = 0 ; for ( int i = 2 ; i <= sqrt ( a ) ; i ++ ) { while ( a % i == 0 ) { count ++ ; a = a / i ; } div = div * ( count + 1 ) ; count = 0 ; } if ( a > 1 ) { div = div * ( 2 ) ; } return div ; } int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = divisor ( i ) ; if ( divCount % 2 ) { ++ res ; } } return res ; } int main ( ) { int a = 1 , b = 10 ; cout << OddDivCount ( a , b ) ; return 0 ; }", "docstring": "Program to find count of numbers having odd number of divisors in given range | C ++ implementation of the approach ; Function to return the count of divisors of a number ; Count the powers of the current prime i which divides a ; Update the count of divisors ; Reset the count ; If the remaining a is prime then a ^ 1 will be one of its prime factors ; Function to count numbers having odd number of divisors in range [ A , B ] ; To store the count of elements having odd number of divisors ; Iterate from a to b and find the count of their divisors ; To store the count of divisors of i ; If the divisor count of i is odd ; Driver code", "dfg": [["div", 92, "comesFrom", ["div"], [82]], ["div", 62, "comesFrom", ["div"], [60]], ["div", 84, "comesFrom", ["div"], [82]], ["res", 146, "comesFrom", ["res"], [106]], ["res", 141, "comesFrom", ["res"], [106]], ["i", 30, "comesFrom", ["i"], [26]], ["i", 37, "comesFrom", ["i"], [26]], ["i", 117, "comesFrom", ["i"], [113]], ["i", 122, "comesFrom", ["i"], [113]], ["i", 45, "comesFrom", ["i"], [26]], ["i", 130, "comesFrom", ["i"], [113]], ["i", 57, "comesFrom", ["i"], [26]], ["b", 119, "comesFrom", ["b"], [102]], ["b", 169, "comesFrom", ["b"], [159]], ["a", 77, "comesFrom", ["a"], [53]], ["a", 34, "comesFrom", ["a"], [11]], ["a", 167, "comesFrom", ["a"], [155]], ["a", 43, "comesFrom", ["a"], [11]], ["a", 55, "comesFrom", ["a"], [53]], ["divCount", 135, "comesFrom", ["divCount"], [126]], ["count", 50, "comesFrom", ["count"], [19]], ["count", 65, "comesFrom", ["count"], [19]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) div_count ++ ; return ( div_count > 1 ) ; } int main ( ) { int l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) cout << \" YES STRNEWLINE \" ; else cout << \" NO STRNEWLINE \" ; return 0 ; }", "docstring": "Check if there is any pair in a given range with GCD is divisible by k | C ++ program to count the numbers divisible by k in a given range ; Returns count of numbers in [ l r ] that are divisible by k . ; Add 1 explicitly as l is divisible by k ; l is not divisible by k ; Driver Code", "dfg": [["div_count", 43, "comesFrom", ["div_count"], [21]], ["div_count", 48, "comesFrom", ["div_count"], [21]], ["l", 37, "comesFrom", ["l"], [11]], ["l", 76, "comesFrom", ["l"], [60]], ["l", 30, "comesFrom", ["l"], [11]], ["k", 39, "comesFrom", ["k"], [17]], ["k", 80, "comesFrom", ["k"], [68]], ["k", 26, "comesFrom", ["k"], [17]], ["k", 32, "comesFrom", ["k"], [17]], ["r", 78, "comesFrom", ["r"], [64]], ["r", 24, "comesFrom", ["r"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nth_group ( int n ) { return n * ( 2 * pow ( n , 2 ) + 1 ) ; } int main ( ) { int N = 5 ; cout << nth_group ( N ) ; return 0 ; }", "docstring": "Find sum of N | C ++ program to find sum in Nth group ; calculate sum of Nth group ; Driver code", "dfg": [["n", 15, "comesFrom", ["n"], [11]], ["n", 22, "comesFrom", ["n"], [11]], ["N", 45, "comesFrom", ["N"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) cout << \" NO \" ; else cout << \" YES \" ; } int main ( ) { int a = 2 , b = 4 , c = 2 ; printPossible ( a , b , c ) ; return 0 ; }", "docstring": "Find if a molecule can be formed from 3 atoms using their valence numbers | C ++ implementation of the above approach ; Function to check if it is possible ; Driver code", "dfg": [["a", 73, "comesFrom", ["a"], [59]], ["a", 33, "comesFrom", ["a"], [11]], ["a", 23, "comesFrom", ["a"], [11]], ["b", 75, "comesFrom", ["b"], [63]], ["b", 35, "comesFrom", ["b"], [14]], ["b", 25, "comesFrom", ["b"], [14]], ["c", 77, "comesFrom", ["c"], [67]], ["c", 37, "comesFrom", ["c"], [17]], ["c", 27, "comesFrom", ["c"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectPower ( int n ) { if ( n == 1 ) return true ; for ( int x = 2 ; x <= sqrt ( n ) ; x ++ ) { int y = 2 ; int p = pow ( x , y ) ; while ( p <= n && p > 0 ) { if ( p == n ) return true ; y ++ ; p = pow ( x , y ) ; } } return false ; } bool isStrongNumber ( int n ) { unordered_map < int , int > count ; while ( n % 2 == 0 ) { n = n / 2 ; count [ 2 ] ++ ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { n = n / i ; count [ i ] ++ ; } } if ( n > 2 ) count [ n ] ++ ; int flag = 0 ; for ( auto b : count ) { if ( b . second == 1 ) { flag = 1 ; break ; } } if ( flag == 1 ) return false ; else return true ; } bool isTrojan ( int n ) { if ( ! isPerfectPower ( n ) && isStrongNumber ( n ) ) return true ; else return false ; } int main ( ) { int n = 108 ; if ( isTrojan ( n ) ) cout << \" YES \" ; else cout << \" NO \" ; return 0 ; }", "docstring": "Check if a number is a Trojan Number | CPP program to check if a number is Trojan Number or not ; Function to check if a number can be expressed as x ^ y ; Try all numbers from 2 to sqrt ( n ) as base ; Keep increasing y while power ' p ' is smaller than n . ; Function to check if a number is Strong ; count the number for each prime factor ; minimum number of prime divisors should be 2 ; Function to check if a number is Trojan Number ; Driver Code", "dfg": [["count", 195, "comesFrom", ["count"], [107]], ["count", 179, "comesFrom", ["count"], [107]], ["count", 124, "comesFrom", ["count"], [107]], ["count", 165, "comesFrom", ["count"], [107]], ["x", 30, "comesFrom", ["x"], [26]], ["x", 37, "comesFrom", ["x"], [26]], ["x", 51, "comesFrom", ["x"], [26]], ["x", 83, "comesFrom", ["x"], [26]], ["i", 138, "comesFrom", ["i"], [134]], ["i", 154, "comesFrom", ["i"], [145]], ["i", 163, "comesFrom", ["i"], [145]], ["i", 167, "comesFrom", ["i"], [145]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 175, "comesFrom", ["n"], [159]], ["n", 34, "comesFrom", ["n"], [11]], ["n", 111, "comesFrom", ["n"], [98]], ["n", 142, "comesFrom", ["n"], [118]], ["n", 271, "comesFrom", ["n"], [263]], ["n", 120, "comesFrom", ["n"], [118]], ["n", 181, "comesFrom", ["n"], [159]], ["n", 246, "comesFrom", ["n"], [233]], ["n", 60, "comesFrom", ["n"], [11]], ["n", 152, "comesFrom", ["n"], [118]], ["n", 241, "comesFrom", ["n"], [233]], ["n", 71, "comesFrom", ["n"], [11]], ["n", 161, "comesFrom", ["n"], [159]], ["flag", 217, "comesFrom", ["flag"], [207]], ["y", 53, "comesFrom", ["y"], [42]], ["y", 76, "comesFrom", ["y"], [42]], ["y", 85, "comesFrom", ["y"], [42]], ["p", 58, "comesFrom", ["p"], [47]], ["p", 62, "comesFrom", ["p"], [47]], ["p", 69, "comesFrom", ["p"], [47]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; cout << r ; } int main ( ) { int N = 5 ; Sum_upto_nth_Term ( N ) ; return 0 ; }", "docstring": "Find the sum of first N terms of the series 2 Ã — 3 + 4 Ã — 4 + 6 Ã — 5 + 8 Ã — 6 + ... | C ++ program to find sum upto N term of the series : 2 A 3 + 4 A 4 + 6 A 5 + 8 A 6 + ... ; calculate sum upto N term of series ; Driver code", "dfg": [["r", 37, "comesFrom", ["r"], [15]], ["N", 52, "comesFrom", ["N"], [46]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 28, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CalculateDifference ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return abs ( S2 - S1 ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 10 , 15 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CalculateDifference ( arr , n ) ; return 0 ; }", "docstring": "Absolute Difference between the Sum of Non | C ++ program to find the Absolute Difference between the Sum of Non - Prime numbers and Prime numbers of an Array ; Function to find the difference between the sum of non - primes and the sum of primes of an array . ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store the sum of primes in S1 and the sum of non primes in S2 ; the number is prime ; the number is non - prime ; Return the absolute difference ; Driver Code ; Get the array ; Find the absolute difference", "dfg": [["max_val", 70, "comesFrom", ["max_val"], [20]], ["max_val", 38, "comesFrom", ["max_val"], [20]], ["max_val", 97, "comesFrom", ["max_val"], [20]], ["p", 72, "comesFrom", ["p"], [62]], ["p", 66, "comesFrom", ["p"], [62]], ["p", 68, "comesFrom", ["p"], [62]], ["p", 101, "comesFrom", ["p"], [62]], ["p", 80, "comesFrom", ["p"], [62]], ["p", 91, "comesFrom", ["p"], [62]], ["i", 128, "comesFrom", ["i"], [124]], ["i", 132, "comesFrom", ["i"], [124]], ["i", 95, "comesFrom", ["i"], [89]], ["i", 142, "comesFrom", ["i"], [124]], ["i", 151, "comesFrom", ["i"], [124]], ["i", 105, "comesFrom", ["i"], [99]], ["i", 160, "comesFrom", ["i"], [124]], ["i", 170, "comesFrom", ["i"], [124]], ["n", 130, "comesFrom", ["n"], [16]], ["n", 230, "comesFrom", ["n"], [209]], ["n", 29, "comesFrom", ["n"], [16]], ["prime", 45, "comesFrom", ["prime"], [36]], ["prime", 52, "comesFrom", ["prime"], [36]], ["prime", 138, "comesFrom", ["prime"], [36]], ["prime", 78, "comesFrom", ["prime"], [36]], ["prime", 103, "comesFrom", ["prime"], [36]], ["S2", 178, "comesFrom", ["S2"], [166]], ["S1", 180, "comesFrom", ["S1"], [147]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; double sum ( int x , int n ) { double total = 1.0 ; double previous = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { previous = ( previous * x ) / ( i + 1 ) ; total = total + previous ; } return total ; } int main ( ) { int x = 5 , n = 4 ; cout << \" Sum ▁ is : ▁ \" << sum ( x , n ) ; return 0 ; }", "docstring": "Program to find sum of 1 + x / 2 ! + x ^ 2 / 3 ! + ... + x ^ n / ( n + 1 ) ! | C ++ implementation of the approach ; Function to compute the series sum ; To store the value of S [ i - 1 ] ; Iterate over n to store sum in total ; Update previous with S [ i ] ; Driver code ; Get x and n ; Find and print the sum", "dfg": [["total", 64, "comesFrom", ["total"], [56]], ["total", 58, "comesFrom", ["total"], [56]], ["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 51, "comesFrom", ["i"], [30]], ["n", 36, "comesFrom", ["n"], [14]], ["n", 91, "comesFrom", ["n"], [77]], ["x", 89, "comesFrom", ["x"], [73]], ["x", 47, "comesFrom", ["x"], [11]], ["previous", 60, "comesFrom", ["previous"], [42]], ["previous", 45, "comesFrom", ["previous"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfDivisors ( int num ) { int c = 0 ; for ( int i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; } int countNumbers ( int n ) { int c = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; } int main ( ) { int n = 1000 ; cout << countNumbers ( n ) ; return 0 ; }", "docstring": "Count number of integers less than or equal to N which has exactly 9 divisors | C ++ implementation of above approach ; Function to count factors in O ( N ) ; iterate and check if factor or not ; Function to count numbers having exactly 9 divisors ; check for all numbers <= N ; check if exactly 9 factors or not ; Driver Code", "dfg": [["c", 50, "comesFrom", ["c"], [43]], ["c", 95, "comesFrom", ["c"], [89]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 72, "comesFrom", ["i"], [68]], ["i", 76, "comesFrom", ["i"], [68]], ["i", 38, "comesFrom", ["i"], [22]], ["i", 84, "comesFrom", ["i"], [68]], ["num", 28, "comesFrom", ["num"], [11]], ["num", 36, "comesFrom", ["num"], [11]], ["n", 74, "comesFrom", ["n"], [57]], ["n", 112, "comesFrom", ["n"], [104]]]}
{"code": "#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; } int main ( ) { int n = 3 ; cout << numberOfDistinct ( n ) ; return 0 ; }", "docstring": "Number of distinct integers obtained by lcm ( X , N ) / X | C ++ program to find distinct integers ontained by lcm ( x , num ) / x ; Function to count the number of distinct integers ontained by lcm ( x , num ) / x ; iterate to count the number of factors ; Driver Code", "dfg": [["ans", 68, "comesFrom", ["ans"], [18]], ["ans", 49, "comesFrom", ["ans"], [18]], ["ans", 62, "comesFrom", ["ans"], [18]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 36, "comesFrom", ["i"], [25]], ["i", 44, "comesFrom", ["i"], [25]], ["i", 60, "comesFrom", ["i"], [25]], ["i", 57, "comesFrom", ["i"], [25]], ["n", 33, "comesFrom", ["n"], [14]], ["n", 85, "comesFrom", ["n"], [77]], ["n", 42, "comesFrom", ["n"], [14]], ["n", 55, "comesFrom", ["n"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE vector < int > arr ; void ulam ( ) { arr . push_back ( 1 ) ; arr . push_back ( 2 ) ; for ( int i = 3 ; i < MAX ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . size ( ) - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr . size ( ) ; k ++ ) { if ( arr [ j ] + arr [ k ] == i ) { count ++ ; } if ( count > 1 ) break ; } if ( count > 1 ) break ; } if ( count == 1 ) { arr . push_back ( i ) ; } } } int main ( ) { ulam ( ) ; int n = 9 ; cout << arr [ n - 1 ] ; return 0 ; }", "docstring": "Ulam Number Sequence | CPP code to print nth Ulam number ; Array to store Ulam Number ; function to compute ulam Number ; push First 2 two term of the sequence in the array for further calculation ; loop to generate Ulam number ; traverse the array and check if i can be represented as sum of two distinct element of the array ; If count is 1 that means i can be represented as sum of two distinct terms of the sequence ; i is ulam number ; Driver code ; Pre compute Ulam Number sequence ; Print nth Ulam number", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; } int main ( ) { int n = 3 , m = 3 ; cout << NumberOfRectangles ( n , m ) ; return 0 ; }", "docstring": "Find the number of rectangles of size 2 * 1 which can be placed inside a rectangle of size n * m | CPP program to Find the number of rectangles of size 2 * 1 can be placed inside a rectangle of size n * m ; function to Find the number of rectangles of size 2 * 1 can be placed inside a rectangle of size n * m ; if n is even ; if m is even ; if both are odd ; Driver code ; function call", "dfg": [["m", 32, "comesFrom", ["m"], [14]], ["m", 84, "comesFrom", ["m"], [74]], ["m", 56, "comesFrom", ["m"], [14]], ["m", 37, "comesFrom", ["m"], [14]], ["m", 45, "comesFrom", ["m"], [14]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 82, "comesFrom", ["n"], [70]], ["n", 27, "comesFrom", ["n"], [11]], ["n", 50, "comesFrom", ["n"], [11]], ["n", 54, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long findNumUtil ( long res , int a , int aCount , int b , int bCount , int n ) { if ( res > 1e11 ) return 1e11 ; if ( aCount == bCount && res >= n ) return res ; return min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; } int findNum ( int n , int a , int b ) { int result = 0 ; int aCount = 0 ; int bCount = 0 ; return findNumUtil ( result , a , aCount , b , bCount , n ) ; } int main ( ) { int N = 4500 ; int A = 4 ; int B = 7 ; cout << findNum ( N , A , B ) ; return 0 ; }", "docstring": "Next greater Number than N with the same quantity of digits A and B | C ++ program to find next greater Number than N with the same quantity of digits A and B ; Recursive function to find the required number ; If the resulting number is >= n and count of a = count of b , return the number ; select minimum of two and call the function again ; Function to find the number next greater Number than N with the same quantity of digits A and B ; Driver code", "dfg": [["res", 49, "comesFrom", ["res"], [11]], ["res", 31, "comesFrom", ["res"], [11]], ["res", 44, "comesFrom", ["res"], [11]], ["res", 56, "comesFrom", ["res"], [11]], ["res", 77, "comesFrom", ["res"], [11]], ["result", 129, "comesFrom", ["result"], [112]], ["a", 131, "comesFrom", ["a"], [105]], ["a", 62, "comesFrom", ["a"], [14]], ["a", 83, "comesFrom", ["a"], [14]], ["a", 60, "comesFrom", ["a"], [14]], ["aCount", 133, "comesFrom", ["aCount"], [117]], ["aCount", 40, "comesFrom", ["aCount"], [17]], ["aCount", 85, "comesFrom", ["aCount"], [17]], ["aCount", 64, "comesFrom", ["aCount"], [17]], ["b", 135, "comesFrom", ["b"], [108]], ["b", 68, "comesFrom", ["b"], [20]], ["b", 87, "comesFrom", ["b"], [20]], ["b", 81, "comesFrom", ["b"], [20]], ["bCount", 137, "comesFrom", ["bCount"], [122]], ["bCount", 42, "comesFrom", ["bCount"], [23]], ["bCount", 70, "comesFrom", ["bCount"], [23]], ["bCount", 89, "comesFrom", ["bCount"], [23]], ["n", 139, "comesFrom", ["n"], [102]], ["n", 46, "comesFrom", ["n"], [26]], ["n", 72, "comesFrom", ["n"], [26]], ["n", 93, "comesFrom", ["n"], [26]], ["N", 167, "comesFrom", ["N"], [149]], ["A", 169, "comesFrom", ["A"], [154]], ["B", 171, "comesFrom", ["B"], [159]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int n = 7 , k = 3 ; if ( n % k == 0 ) cout << n / k << \" ▁ \" << n / k ; else cout << ( ( n - ( n % k ) ) / k ) << \" ▁ \" << ( ( ( n - ( n % k ) ) / k ) + 1 ) ; return 0 ; }", "docstring": "Minimum and maximum number of N chocolates after distribution among K students | CPP implementation of the above approach ; Driver code", "dfg": [["n", 23, "comesFrom", ["n"], [13]], ["n", 39, "comesFrom", ["n"], [13]], ["n", 31, "comesFrom", ["n"], [13]], ["n", 48, "comesFrom", ["n"], [13]], ["n", 67, "comesFrom", ["n"], [13]], ["n", 51, "comesFrom", ["n"], [13]], ["n", 70, "comesFrom", ["n"], [13]], ["k", 25, "comesFrom", ["k"], [17]], ["k", 41, "comesFrom", ["k"], [17]], ["k", 33, "comesFrom", ["k"], [17]], ["k", 57, "comesFrom", ["k"], [17]], ["k", 76, "comesFrom", ["k"], [17]], ["k", 53, "comesFrom", ["k"], [17]], ["k", 72, "comesFrom", ["k"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { float m = 50 , n = 5 , x = 67 , h = 2927 ; int z = ( ceil ( h / 60 * 1.0 ) ) ; if ( z <= n ) cout << z * m ; else cout << n * m + ( z - n ) * x ; return 0 ; }", "docstring": "Total money to be paid after traveling the given number of hours | CPP implementation of the above approach ; calculating hours travelled", "dfg": [["z", 45, "comesFrom", ["z"], [30]], ["z", 51, "comesFrom", ["z"], [30]], ["z", 63, "comesFrom", ["z"], [30]], ["n", 47, "comesFrom", ["n"], [17]], ["n", 58, "comesFrom", ["n"], [17]], ["n", 65, "comesFrom", ["n"], [17]], ["m", 53, "comesFrom", ["m"], [13]], ["m", 60, "comesFrom", ["m"], [13]], ["x", 68, "comesFrom", ["x"], [21]], ["h", 35, "comesFrom", ["h"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( -1 * b ) / a ; double rootProduct = ( double ) e / a ; return abs ( rootSum - rootProduct ) ; } int main ( ) { cout << sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ; return 0 ; }", "docstring": "Absolute difference between sum and product of roots of a quartic equation | C ++ implementation of above approach ; Function taking coefficient of each term of equation as input ; Finding sum of roots ; Finding product of roots ; Absolute difference ; Driver code", "dfg": [["a", 38, "comesFrom", ["a"], [11]], ["a", 48, "comesFrom", ["a"], [11]], ["e", 46, "comesFrom", ["e"], [23]], ["rootSum", 53, "comesFrom", ["rootSum"], [27]], ["rootProduct", 55, "comesFrom", ["rootProduct"], [41]], ["b", 35, "comesFrom", ["b"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; } int main ( ) { int n = 3 ; cout << numberOfSolutions ( n ) ; return 0 ; }", "docstring": "Number of solutions of n = x + n âŠ • x | C ++ implementation of above approach ; Function to find the number of solutions of n = n xor x ; Counter to store the number of solutions found ; Driver code", "dfg": [["c", 47, "comesFrom", ["c"], [15]], ["c", 44, "comesFrom", ["c"], [15]], ["x", 26, "comesFrom", ["x"], [22]], ["x", 31, "comesFrom", ["x"], [22]], ["x", 41, "comesFrom", ["x"], [22]], ["x", 37, "comesFrom", ["x"], [22]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 64, "comesFrom", ["n"], [56]], ["n", 35, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [11]]]}
{"code": "#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int minimumLectures ( int m , int n ) { int ans = 0 ; if ( n < ( int ) ceil ( 0.75 * m ) ) ans = ( int ) ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; } int main ( ) { int M = 9 , N = 1 ; cout << minimumLectures ( M , N ) ; return 0 ; }", "docstring": "Program to find minimum number of lectures to attend to maintain 75 % | C ++ Program to find minimum number of lectures to attend to maintain 75 % attendance ; Function to compute minimum lecture ; Formula to compute ; Driver function", "dfg": [["ans", 65, "comesFrom", ["ans"], [60]], ["n", 27, "comesFrom", ["n"], [17]], ["n", 53, "comesFrom", ["n"], [17]], ["M", 86, "comesFrom", ["M"], [74]], ["N", 88, "comesFrom", ["N"], [78]], ["m", 36, "comesFrom", ["m"], [14]], ["m", 50, "comesFrom", ["m"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int N ) { return ( pow ( 10 , N ) - pow ( 8 , N ) ) / 2 ; } int main ( ) { int n = 5 ; cout << countNumbers ( n ) << endl ; return 0 ; }", "docstring": "Count Numbers with N digits which consists of odd number of 0 's | C ++ program to count numbers with N digits which consists of odd number of 0 's ; Function to count Numbers with N digits which consists of odd number of 0 's ; Driver code", "dfg": [["n", 48, "comesFrom", ["n"], [40]], ["N", 20, "comesFrom", ["N"], [11]], ["N", 27, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; int prefix [ MAX + 1 ] ; void buildPrefix ( ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] += p ; } } int sumPrimeRange ( int L , int R ) { buildPrefix ( ) ; return prefix [ R ] - prefix [ L - 1 ] ; } int main ( ) { int L = 10 , R = 20 ; cout << sumPrimeRange ( L , R ) << endl ; return 0 ; }", "docstring": "Sum of all Primes in a given range using Sieve of Eratosthenes | CPP program to find sum of primes in range L to R ; prefix [ i ] is going to store sum of primes till i ( including i ) . ; Function to build the prefix sum array ; Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Build prefix array ; Function to return sum of prime in range ; Driver code", "dfg": [["MAX", 16, "comesFrom", ["MAX"], [9]], ["MAX", 57, "comesFrom", ["MAX"], [9]], ["MAX", 120, "comesFrom", ["MAX"], [9]], ["MAX", 29, "comesFrom", ["MAX"], [9]], ["MAX", 84, "comesFrom", ["MAX"], [9]], ["p", 59, "comesFrom", ["p"], [49]], ["p", 118, "comesFrom", ["p"], [114]], ["p", 122, "comesFrom", ["p"], [114]], ["p", 53, "comesFrom", ["p"], [49]], ["p", 55, "comesFrom", ["p"], [49]], ["p", 150, "comesFrom", ["p"], [114]], ["p", 88, "comesFrom", ["p"], [49]], ["p", 128, "comesFrom", ["p"], [114]], ["p", 142, "comesFrom", ["p"], [114]], ["p", 67, "comesFrom", ["p"], [49]], ["p", 133, "comesFrom", ["p"], [114]], ["p", 147, "comesFrom", ["p"], [114]], ["p", 78, "comesFrom", ["p"], [49]], ["R", 171, "comesFrom", ["R"], [161]], ["R", 202, "comesFrom", ["R"], [192]], ["L", 176, "comesFrom", ["L"], [158]], ["L", 200, "comesFrom", ["L"], [188]], ["i", 82, "comesFrom", ["i"], [76]], ["i", 92, "comesFrom", ["i"], [86]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; } int main ( ) { int n = 3 ; cout << \" Sum ▁ = ▁ \" << calculateSum ( n ) ; return 0 ; }", "docstring": "Sum of the first N terms of the series 5 , 12 , 23 , 38. ... | C ++ program to find sum of first n terms ; Function to calculate the sum ; Driver code ; number of terms to be included in sum ; find the Sn", "dfg": [["n", 50, "comesFrom", ["n"], [11]], ["n", 72, "comesFrom", ["n"], [60]], ["n", 37, "comesFrom", ["n"], [11]], ["n", 40, "comesFrom", ["n"], [11]], ["n", 18, "comesFrom", ["n"], [11]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 29, "comesFrom", ["n"], [11]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) cout << \"2 ▁ solutions \" ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) cout << \"1 ▁ solution \" ; else cout << \" No ▁ solutions \" ; } int main ( ) { int a = 2 , b = 5 , c = 2 ; checkSolution ( a , b , c ) ; return 0 ; }", "docstring": "Program to find number of solutions in Quadratic Equation | C ++ Program to find the solutions of specified equations ; Method to check for solutions of equations ; If the expression is greater than 0 , then 2 solutions ; If the expression is equal 0 , then 2 solutions ; Else no solutions ; Driver Code", "dfg": [["a", 101, "comesFrom", ["a"], [87]], ["a", 32, "comesFrom", ["a"], [11]], ["a", 59, "comesFrom", ["a"], [11]], ["b", 103, "comesFrom", ["b"], [91]], ["b", 24, "comesFrom", ["b"], [14]], ["b", 26, "comesFrom", ["b"], [14]], ["b", 51, "comesFrom", ["b"], [14]], ["b", 53, "comesFrom", ["b"], [14]], ["c", 105, "comesFrom", ["c"], [95]], ["c", 34, "comesFrom", ["c"], [17]], ["c", 61, "comesFrom", ["c"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long Bits ( int kilobytes ) { long Bits = 0 ; Bits = kilobytes * 8192 ; return Bits ; } long Bytes ( int kilobytes ) { long Bytes = 0 ; Bytes = kilobytes * 1024 ; return Bytes ; } int main ( ) { int kilobytes = 1 ; cout << kilobytes << \" ▁ Kilobytes ▁ = ▁ \" << Bytes ( kilobytes ) << \" ▁ Bytes ▁ and ▁ \" << Bits ( kilobytes ) << \" ▁ Bits . \" ; return 0 ; }", "docstring": "Program to convert KiloBytes to Bytes and Bits | C ++ implementation of above program ; Function to calculates the bits ; calculates Bits 1 kilobytes ( s ) = 8192 bits ; Function to calculates the bytes ; calculates Bytes 1 KB = 1024 bytes ; Driver code", "dfg": [["Bits", 26, "comesFrom", ["Bits"], [19]], ["Bits", 78, "comesFrom", ["Bits"], [19]], ["Bytes", 48, "comesFrom", ["Bytes"], [41]], ["Bytes", 69, "comesFrom", ["Bytes"], [41]], ["kilobytes", 21, "comesFrom", ["kilobytes"], [11]], ["kilobytes", 43, "comesFrom", ["kilobytes"], [33]], ["kilobytes", 80, "comesFrom", ["kilobytes"], [57]], ["kilobytes", 63, "comesFrom", ["kilobytes"], [57]], ["kilobytes", 71, "comesFrom", ["kilobytes"], [57]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int main ( ) { int n = 3 ; int a [ ] = { 1 , 2 , 3 } ; int i = 0 ; long sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } long x = sum / n ; if ( x * n == sum ) cout << x << endl ; else cout << ( \" - 1\" ) << endl ; return 0 ; }", "docstring": "Program to find the Hidden Number | C ++ Program to find the hidden number ; Driver Code ; Getting the size of array ; Getting the array of size n ; Solution ; Finding sum of the array elements ; Dividing sum by size n ; Print x , if found", "dfg": [["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 58, "comesFrom", ["i"], [42]], ["n", 48, "comesFrom", ["n"], [13]], ["n", 67, "comesFrom", ["n"], [13]], ["n", 73, "comesFrom", ["n"], [13]], ["sum", 65, "comesFrom", ["sum"], [54]], ["sum", 75, "comesFrom", ["sum"], [54]], ["x", 71, "comesFrom", ["x"], [63]], ["x", 79, "comesFrom", ["x"], [63]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; double findSum ( ll n ) { return sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; } int main ( ) { ll n = 10 ; cout << findSum ( n ) << endl ; return 0 ; }", "docstring": "Find sum of the series ? 3 + ? 12 + ... ... ... upto N terms | C ++ implementation of above approach ; Function to find the sum ; Apply AP formula ; Driver code ; number of terms", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int x , int y , int n ) { int sum1 = ( pow ( x , 2 ) * ( pow ( x , 2 * n ) - 1 ) ) / ( pow ( x , 2 ) - 1 ) ; int sum2 = ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; } int main ( ) { int x = 2 , y = 2 , n = 2 ; cout << sum ( x , y , n ) ; return 0 ; }", "docstring": "Find the sum of the series x ( x + y ) + x ^ 2 ( x ^ 2 + y ^ 2 ) + x ^ 3 ( x ^ 3 + y ^ 3 ) + ... + x ^ n ( x ^ n + y ^ n ) | CPP program to find the sum of series ; Function to return required sum ; sum of first series ; sum of second series ; Driver Code ; function call to print sum", "dfg": [["sum1", 92, "comesFrom", ["sum1"], [21]], ["sum2", 94, "comesFrom", ["sum2"], [57]], ["x", 119, "comesFrom", ["x"], [103]], ["x", 60, "comesFrom", ["x"], [11]], ["x", 84, "comesFrom", ["x"], [11]], ["x", 26, "comesFrom", ["x"], [11]], ["x", 48, "comesFrom", ["x"], [11]], ["x", 34, "comesFrom", ["x"], [11]], ["x", 67, "comesFrom", ["x"], [11]], ["y", 121, "comesFrom", ["y"], [107]], ["y", 62, "comesFrom", ["y"], [14]], ["y", 86, "comesFrom", ["y"], [14]], ["y", 74, "comesFrom", ["y"], [14]], ["n", 123, "comesFrom", ["n"], [111]], ["n", 38, "comesFrom", ["n"], [17]], ["n", 69, "comesFrom", ["n"], [17]], ["n", 76, "comesFrom", ["n"], [17]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void printPair ( int g , int l ) { cout << g << \" ▁ \" << l ; } int main ( ) { int g = 3 , l = 12 ; printPair ( g , l ) ; return 0 ; }", "docstring": "Find any pair with given GCD and LCM | C ++ program to print any pair with a given gcd G and lcm L ; Function to print the pairs ; Driver Code", "dfg": [["l", 25, "comesFrom", ["l"], [14]], ["l", 46, "comesFrom", ["l"], [38]], ["g", 44, "comesFrom", ["g"], [34]], ["g", 19, "comesFrom", ["g"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ; } int main ( ) { int n = 5 ; cout << \" Sum ▁ = ▁ \" << calculateSum ( n ) ; return 0 ; }", "docstring": "Sum of first n terms of a given series 3 , 6 , 11 , ... . . | C ++ program to find sum of first n terms ; Function to calculate the sum ; starting number ; Common Ratio ; Common difference ; Driver code ; N th term to be find ; find the Sn", "dfg": [["a2", 54, "comesFrom", ["a2"], [19]], ["n", 92, "comesFrom", ["n"], [80]], ["n", 35, "comesFrom", ["n"], [11]], ["n", 61, "comesFrom", ["n"], [11]], ["n", 44, "comesFrom", ["n"], [11]], ["r", 68, "comesFrom", ["r"], [24]], ["r", 59, "comesFrom", ["r"], [24]], ["a1", 41, "comesFrom", ["a1"], [15]], ["d", 49, "comesFrom", ["d"], [29]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long repeatedSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } long repeatedProduct ( long n ) { long prod = 1 ; while ( n > 0 prod > 9 ) { if ( n == 0 ) { n = prod ; prod = 1 ; } prod *= n % 10 ; n /= 10 ; } return prod ; } long maxSumProduct ( long N ) { if ( N < 10 ) return N ; return max ( repeatedSum ( N ) , repeatedProduct ( N ) ) ; } int main ( ) { long n = 631 ; cout << maxSumProduct ( n ) << endl ; return 0 ; }", "docstring": "Maximum of sum and product of digits until number is reduced to a single digit | CPP implementation of above approach ; Function to sum the digits until it becomes a single digit ; Function to product the digits until it becomes a single digit ; Loop to do sum while sum is not less than or equal to 9 ; Function to find the maximum among repeated sum and repeated product ; Driver code", "dfg": [["prod", 91, "comesFrom", ["prod"], [79]], ["prod", 58, "comesFrom", ["prod"], [49]], ["prod", 72, "comesFrom", ["prod"], [49]], ["N", 108, "comesFrom", ["N"], [98]], ["N", 103, "comesFrom", ["N"], [98]], ["N", 115, "comesFrom", ["N"], [98]], ["N", 120, "comesFrom", ["N"], [98]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 35, "comesFrom", ["n"], [11]], ["n", 55, "comesFrom", ["n"], [45]], ["n", 25, "comesFrom", ["n"], [11]], ["n", 65, "comesFrom", ["n"], [45]], ["n", 81, "comesFrom", ["n"], [70]], ["n", 139, "comesFrom", ["n"], [131]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE int max_value ( int array [ ] [ 2 ] , int M , int K , int N ) { int time [ M ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { time [ array [ i ] [ 0 ] ] = array [ i ] [ 1 ] ; } int dp [ M ] [ 2 ] ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = time [ 0 ] ; for ( int i = 1 ; i < M ; i ++ ) { dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = time [ i ] ; if ( i - K >= 0 ) { dp [ i ] [ 1 ] += max ( dp [ i - K ] [ 0 ] , dp [ i - K ] [ 1 ] ) ; } } return max ( dp [ M - 1 ] [ 0 ] , dp [ M - 1 ] [ 1 ] ) ; } int main ( ) { int array [ ] [ 2 ] = { { 0 , 10 } , { 4 , 110 } , { 5 , 30 } } ; int N = 3 ; int K = 4 ; int M = 6 ; cout << max_value ( array , M , K , N ) ; }", "docstring": "Find maximum possible value of advertising | C ++ program for the above approach ; Function to find maximum possible advertising value ; To store advertising value at i - th minute ; Base Case ; If no advertisement is taken on ith minute ; If advertisement is taken on i - th minute ; Driver 's Code ; array [ ] [ 0 ] start time array [ ] [ 1 ] advertising value", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > digits ; bool vis [ 170 ] = { false } ; int dp [ 19 ] [ 19 ] [ 2 ] [ 170 ] ; void ConvertIntoDigit ( int n ) { while ( n ) { int dig = n % 10 ; digits . push_back ( dig ) ; n /= 10 ; } reverse ( digits . begin ( ) , digits . end ( ) ) ; } int solve ( int idx , int k , int tight , int sum ) { if ( idx == digits . size ( ) && k == 0 && sum & 1 ) { if ( ! vis [ sum ] ) { vis [ sum ] = 1 ; return 1 ; } return 0 ; } if ( idx > digits . size ( ) ) { return 0 ; } if ( dp [ idx ] [ k ] [ tight ] [ sum ] ) { return dp [ idx ] [ k ] [ tight ] [ sum ] ; } int j ; if ( tight == 0 ) { j = digits [ idx ] ; } else { j = 9 ; } int cnt = 0 ; for ( int i = ( k ? 0 : 1 ) ; i <= j ; i ++ ) { int newtight = tight ; if ( i < j ) { newtight = 1 ; } if ( i == 0 ) cnt += solve ( idx + 1 , k - 1 , newtight , sum ) ; else cnt += solve ( idx + 1 , k , newtight , sum + i ) ; } return dp [ idx ] [ k ] [ tight ] [ sum ] = cnt ; } int main ( ) { int N , k ; N = 169 , k = 2 ; ConvertIntoDigit ( N ) ; k = digits . size ( ) - k ; cout << solve ( 0 , k , 0 , 0 ) ; }", "docstring": "Count numbers with exactly K non | C ++ program to Count the numbers having exactly K non - zero digits and sum of digits are odd and distinct . ; To store digits of N ; visited map ; DP Table ; Push all the digits of N into digits vector ; Function returns the count ; If desired number is formed whose sum is odd ; If it is not present in map , mark it as true and return 1 ; Sum is present in map already ; Desired result not found ; If that state is already calculated just return that state value ; Upper limit ; To store the count of desired numbers ; If k is non - zero , i ranges from 0 to j else [ 1 , j ] ; If current digit is 0 , decrement k and recurse sum is not changed as we are just adding 0 that makes no difference ; If i is non zero , then k remains unchanged and value is added to sum ; Memoize and return ; Driver code ; K is the number of exact non - zero elements to have in number ; break N into its digits ; We keep record of 0 s we need to place in the number", "dfg": [["n", 47, "comesFrom", ["n"], [42]], ["n", 53, "comesFrom", ["n"], [42]], ["i", 235, "comesFrom", ["i"], [225]], ["i", 239, "comesFrom", ["i"], [225]], ["i", 250, "comesFrom", ["i"], [225]], ["i", 262, "comesFrom", ["i"], [225]], ["i", 298, "comesFrom", ["i"], [225]], ["j", 237, "comesFrom", ["j"], [212]], ["j", 252, "comesFrom", ["j"], [212]], ["cnt", 317, "comesFrom", ["cnt"], [284]], ["idx", 146, "comesFrom", ["idx"], [89]], ["idx", 103, "comesFrom", ["idx"], [89]], ["idx", 206, "comesFrom", ["idx"], [89]], ["idx", 163, "comesFrom", ["idx"], [89]], ["idx", 305, "comesFrom", ["idx"], [89]], ["idx", 179, "comesFrom", ["idx"], [89]], ["idx", 270, "comesFrom", ["idx"], [89]], ["idx", 288, "comesFrom", ["idx"], [89]], ["tight", 197, "comesFrom", ["tight"], [95]], ["tight", 169, "comesFrom", ["tight"], [95]], ["tight", 311, "comesFrom", ["tight"], [246]], ["tight", 185, "comesFrom", ["tight"], [95]], ["N", 340, "comesFrom", ["N"], [330]], ["k", 351, "comesFrom", ["k"], [343]], ["k", 359, "comesFrom", ["k"], [343]], ["k", 111, "comesFrom", ["k"], [92]], ["k", 228, "comesFrom", ["k"], [92]], ["k", 166, "comesFrom", ["k"], [92]], ["k", 308, "comesFrom", ["k"], [92]], ["k", 182, "comesFrom", ["k"], [92]], ["k", 274, "comesFrom", ["k"], [92]], ["k", 292, "comesFrom", ["k"], [92]], ["sum", 115, "comesFrom", ["sum"], [98]], ["sum", 172, "comesFrom", ["sum"], [98]], ["sum", 314, "comesFrom", ["sum"], [98]], ["sum", 188, "comesFrom", ["sum"], [98]], ["sum", 125, "comesFrom", ["sum"], [98]], ["sum", 280, "comesFrom", ["sum"], [98]], ["sum", 131, "comesFrom", ["sum"], [98]], ["sum", 296, "comesFrom", ["sum"], [98]], ["digits", 57, "comesFrom", ["digits"], [11]], ["digits", 71, "comesFrom", ["digits"], [11]], ["digits", 77, "comesFrom", ["digits"], [11]], ["digits", 148, "comesFrom", ["digits"], [11]], ["digits", 204, "comesFrom", ["digits"], [11]], ["digits", 345, "comesFrom", ["digits"], [11]], ["digits", 105, "comesFrom", ["digits"], [11]], ["dig", 61, "comesFrom", ["dig"], [51]], ["newtight", 278, "comesFrom", ["newtight"], [255]], ["newtight", 294, "comesFrom", ["newtight"], [255]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsets ( int N ) { if ( N <= 2 ) return N ; if ( N == 3 ) return 2 ; int DP [ N + 1 ] = { 0 } ; DP [ 0 ] = 0 , DP [ 1 ] = 1 , DP [ 2 ] = 2 , DP [ 3 ] = 2 ; for ( int i = 4 ; i <= N ; i ++ ) { DP [ i ] = DP [ i - 2 ] + DP [ i - 3 ] ; } return DP [ N ] ; } int main ( ) { int N = 20 ; cout << countSubsets ( N ) ; return 0 ; }", "docstring": "Count of subsets of integers from 1 to N having no adjacent elements | C ++ Code to count subsets not containing adjacent elements from 1 to N ; Function to count subsets ; Driver Code", "dfg": [["N", 21, "comesFrom", ["N"], [11]], ["N", 81, "comesFrom", ["N"], [11]], ["N", 16, "comesFrom", ["N"], [11]], ["N", 25, "comesFrom", ["N"], [11]], ["N", 110, "comesFrom", ["N"], [11]], ["N", 35, "comesFrom", ["N"], [11]], ["N", 128, "comesFrom", ["N"], [120]], ["i", 79, "comesFrom", ["i"], [75]], ["i", 83, "comesFrom", ["i"], [75]], ["i", 89, "comesFrom", ["i"], [75]], ["i", 94, "comesFrom", ["i"], [75]], ["i", 101, "comesFrom", ["i"], [75]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 500 ] [ 500 ] ; int CountSets ( int x , int pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; if ( dp [ x ] [ pos ] != -1 ) return dp [ x ] [ pos ] ; int answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return dp [ x ] [ pos ] = answer ; } int CountOrderedSets ( int n ) { int factorial [ 10000 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; int answer = 0 ; memset ( dp , -1 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { int sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; } int main ( ) { int N = 3 ; cout << CountOrderedSets ( N ) ; return 0 ; }", "docstring": "Count the number of ordered sets not containing consecutive numbers | C ++ program to Count the number of ordered sets not containing consecutive numbers ; DP table ; Function to calculate the count of ordered set for a given size ; Base cases ; If subproblem has been soved before ; Store and return answer to this subproblem ; Function returns the count of all ordered sets ; Prestore the factorial value ; Initialise the dp table ; Iterate all ordered set sizes and find the count for each one maximum ordered set size will be smaller than N as all elements are distinct and non consecutive . ; Multiply ny size ! for all the arrangements because sets are ordered . ; Add to total answer ; Driver code", "dfg": [["answer", 215, "comesFrom", ["answer"], [207]], ["answer", 109, "comesFrom", ["answer"], [78]], ["answer", 209, "comesFrom", ["answer"], [207]], ["i", 139, "comesFrom", ["i"], [135]], ["i", 143, "comesFrom", ["i"], [135]], ["i", 184, "comesFrom", ["i"], [180]], ["i", 188, "comesFrom", ["i"], [180]], ["i", 158, "comesFrom", ["i"], [135]], ["i", 148, "comesFrom", ["i"], [135]], ["i", 153, "comesFrom", ["i"], [135]], ["i", 199, "comesFrom", ["i"], [180]], ["i", 204, "comesFrom", ["i"], [180]], ["n", 186, "comesFrom", ["n"], [116]], ["n", 197, "comesFrom", ["n"], [116]], ["x", 28, "comesFrom", ["x"], [20]], ["x", 71, "comesFrom", ["x"], [20]], ["x", 103, "comesFrom", ["x"], [20]], ["x", 60, "comesFrom", ["x"], [20]], ["x", 82, "comesFrom", ["x"], [20]], ["x", 91, "comesFrom", ["x"], [20]], ["pos", 49, "comesFrom", ["pos"], [23]], ["pos", 74, "comesFrom", ["pos"], [23]], ["pos", 106, "comesFrom", ["pos"], [23]], ["pos", 35, "comesFrom", ["pos"], [23]], ["pos", 63, "comesFrom", ["pos"], [23]], ["pos", 86, "comesFrom", ["pos"], [23]], ["pos", 95, "comesFrom", ["pos"], [23]], ["N", 232, "comesFrom", ["N"], [224]], ["sets", 211, "comesFrom", ["sets"], [193]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfArithmeticSequences ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; } int main ( ) { int L [ ] = { 1 , 3 , 5 , 6 , 7 , 8 } ; int N = sizeof ( L ) / sizeof ( L [ 0 ] ) ; cout << numberOfArithmeticSequences ( L , N ) ; return 0 ; }", "docstring": "Count the Arithmetic sequences in the Array of size at least 3 | C ++ program to find all arithmetic sequences of size atleast 3 ; Function to find all arithmetic sequences of size atleast 3 ; If array size is less than 3 ; Finding arithmetic subarray length ; To store all arithmetic subarray of length at least 3 ; Check if current element makes arithmetic sequence with previous two elements ; Begin with a new element for new arithmetic sequences ; Accumulate result in till i . ; Return final count ; Driver code ; Function to find arithmetic sequences", "dfg": [["res", 99, "comesFrom", ["res"], [93]], ["i", 45, "comesFrom", ["i"], [41]], ["i", 50, "comesFrom", ["i"], [41]], ["i", 57, "comesFrom", ["i"], [41]], ["i", 62, "comesFrom", ["i"], [41]], ["i", 69, "comesFrom", ["i"], [41]], ["i", 76, "comesFrom", ["i"], [41]], ["N", 47, "comesFrom", ["N"], [16]], ["N", 21, "comesFrom", ["N"], [16]], ["N", 148, "comesFrom", ["N"], [127]], ["count", 95, "comesFrom", ["count"], [88]], ["count", 83, "comesFrom", ["count"], [29]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountOfTriplets ( int a [ ] , int n ) { int answer = 0 ; int x = 0 ; int count [ 100005 ] = { 0 } ; int ways [ 100005 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { x ^= a [ i ] ; answer += count [ x ] * i - ways [ x ] ; count [ x ] ++ ; ways [ x ] += ( i + 1 ) ; } return answer ; } int main ( ) { int Arr [ ] = { 3 , 6 , 12 , 8 , 6 , 2 , 1 , 5 } ; int N = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ; cout << CountOfTriplets ( Arr , N ) ; return 0 ; }", "docstring": "Count triplet of indices ( i , j , k ) such that XOR of elements between [ i , j ) equals [ j , k ] | C ++ program to count the Number of triplets in array having subarray XOR equal ; Function return the count of triplets having subarray XOR equal ; XOR value till i ; Count and ways array as defined above ; Using the formula stated ; Increase the frequency of x ; Add i + 1 to ways [ x ] for upcoming indices ; Driver code", "dfg": [["answer", 104, "comesFrom", ["answer"], [71]], ["i", 56, "comesFrom", ["i"], [52]], ["i", 60, "comesFrom", ["i"], [52]], ["i", 68, "comesFrom", ["i"], [52]], ["i", 78, "comesFrom", ["i"], [52]], ["i", 97, "comesFrom", ["i"], [52]], ["n", 58, "comesFrom", ["n"], [16]], ["N", 157, "comesFrom", ["N"], [136]], ["x", 87, "comesFrom", ["x"], [64]], ["x", 93, "comesFrom", ["x"], [64]], ["x", 82, "comesFrom", ["x"], [64]], ["x", 75, "comesFrom", ["x"], [64]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 5000 ] [ ( 1 << 10 ) + 5 ] ; int getmask ( int val ) { int mask = 0 ; if ( val == 0 ) return 1 ; while ( val ) { int d = val % 10 ; mask |= ( 1 << d ) ; val /= 10 ; } return mask ; } int countWays ( int pos , int mask , int a [ ] , int n ) { if ( pos == n ) return ( mask > 0 ? 1 : 0 ) ; if ( dp [ pos ] [ mask ] != -1 ) return dp [ pos ] [ mask ] ; int count = 0 ; count = count + countWays ( pos + 1 , mask , a , n ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { int new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; count = count + countWays ( pos + 1 , new_mask , a , n ) ; } return dp [ pos ] [ mask ] = count ; } int numberOfSubarrays ( int a [ ] , int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; return countWays ( 0 , 0 , a , n ) ; } int main ( ) { int N = 4 ; int A [ ] = { 1 , 12 , 23 , 34 } ; cout << numberOfSubarrays ( A , N ) ; return 0 ; }", "docstring": "Count of subarrays of an Array having all unique digits | C ++ program to find the count of subarrays of an Array having all unique digits ; Dynamic programming table ; Function to obtain the mask for any integer ; Function to count the number of ways ; Subarray must not be empty ; If subproblem has been solved ; Excluding this element in the subarray ; If there are no common digits then only this element can be included ; Calculate the new mask if this element is included ; Store and return the answer ; Function to find the count of subarray with all digits unique ; initializing dp ; Driver code", "dfg": [["mask", 69, "comesFrom", ["mask"], [55]], ["mask", 125, "comesFrom", ["mask"], [79]], ["mask", 208, "comesFrom", ["mask"], [79]], ["mask", 98, "comesFrom", ["mask"], [79]], ["mask", 114, "comesFrom", ["mask"], [79]], ["mask", 143, "comesFrom", ["mask"], [79]], ["mask", 161, "comesFrom", ["mask"], [79]], ["mask", 171, "comesFrom", ["mask"], [79]], ["val", 45, "comesFrom", ["val"], [26]], ["val", 36, "comesFrom", ["val"], [26]], ["val", 51, "comesFrom", ["val"], [26]], ["count", 211, "comesFrom", ["count"], [184]], ["count", 135, "comesFrom", ["count"], [133]], ["count", 186, "comesFrom", ["count"], [184]], ["pos", 92, "comesFrom", ["pos"], [76]], ["pos", 122, "comesFrom", ["pos"], [76]], ["pos", 205, "comesFrom", ["pos"], [76]], ["pos", 111, "comesFrom", ["pos"], [76]], ["pos", 139, "comesFrom", ["pos"], [76]], ["pos", 190, "comesFrom", ["pos"], [76]], ["pos", 157, "comesFrom", ["pos"], [76]], ["pos", 178, "comesFrom", ["pos"], [76]], ["n", 94, "comesFrom", ["n"], [87]], ["n", 247, "comesFrom", ["n"], [223]], ["n", 147, "comesFrom", ["n"], [87]], ["n", 198, "comesFrom", ["n"], [87]], ["N", 282, "comesFrom", ["N"], [257]], ["d", 60, "comesFrom", ["d"], [49]], ["new_mask", 194, "comesFrom", ["new_mask"], [168]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > fib ; struct node { struct node * left ; int data ; struct node * right ; } ; node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int height ( node * root ) { int ht = 0 ; if ( root == NULL ) return 0 ; return ( max ( height ( root -> left ) , height ( root -> right ) ) + 1 ) ; } void FibonacciSeries ( int n ) { fib . push_back ( 0 ) ; fib . push_back ( 1 ) ; for ( int i = 2 ; i < n ; i ++ ) fib . push_back ( fib [ i - 1 ] + fib [ i - 2 ] ) ; } int CountPathUtil ( node * root , int i , int count ) { if ( root == NULL || ! ( fib [ i ] == root -> data ) ) { return count ; } if ( ! root -> left && ! root -> right ) { count ++ ; } count = CountPathUtil ( root -> left , i + 1 , count ) ; return CountPathUtil ( root -> right , i + 1 , count ) ; } void CountPath ( node * root ) { int ht = height ( root ) ; FibonacciSeries ( ht ) ; cout << CountPathUtil ( root , 0 , 0 ) ; } int main ( ) { node * root = newNode ( 0 ) ; root -> left = newNode ( 1 ) ; root -> right = newNode ( 1 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> right = newNode ( 1 ) ; root -> right -> right -> left = newNode ( 2 ) ; CountPath ( root ) ; return 0 ; }", "docstring": "Count of Fibonacci paths in a Binary tree | C ++ program to count all of Fibonacci paths in a Binary tree ; Vector to store the fibonacci series ; Binary Tree Node ; Function to create a new tree node ; Function to find the height of the given tree ; Function to make fibonacci series upto n terms ; Preorder Utility function to count exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to find whether fibonacci path exists or not ; To find the height ; Making fibonacci series upto ht terms ; Driver code ; Create binary tree ; Function Call", "dfg": [["data", 50, "comesFrom", ["data"], [36]], ["data", 48, "comesFrom", ["data"], [36]], ["data", 197, "comesFrom", ["data"], [36]], ["i", 141, "comesFrom", ["i"], [137]], ["i", 145, "comesFrom", ["i"], [137]], ["i", 244, "comesFrom", ["i"], [176]], ["i", 230, "comesFrom", ["i"], [176]], ["i", 154, "comesFrom", ["i"], [137]], ["i", 161, "comesFrom", ["i"], [137]], ["i", 192, "comesFrom", ["i"], [176]], ["n", 143, "comesFrom", ["n"], [117]], ["fib", 120, "comesFrom", ["fib"], [11]], ["fib", 127, "comesFrom", ["fib"], [11]], ["fib", 148, "comesFrom", ["fib"], [11]], ["fib", 152, "comesFrom", ["fib"], [11]], ["fib", 159, "comesFrom", ["fib"], [11]], ["fib", 190, "comesFrom", ["fib"], [11]], ["count", 202, "comesFrom", ["count"], [179]], ["count", 248, "comesFrom", ["count"], [222]], ["count", 218, "comesFrom", ["count"], [179]], ["count", 234, "comesFrom", ["count"], [222]], ["ht", 270, "comesFrom", ["ht"], [261]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 18 ; int a , b , dp [ M ] [ 90 ] [ 90 ] [ 2 ] ; set < int > fib ; void fibonacci ( ) { int prev = 0 , curr = 1 ; fib . insert ( prev ) ; fib . insert ( curr ) ; while ( curr <= 100 ) { int temp = curr + prev ; fib . insert ( temp ) ; prev = curr ; curr = temp ; } } int count ( int pos , int even , int odd , int tight , vector < int > num ) { if ( pos == num . size ( ) ) { if ( num . size ( ) & 1 ) swap ( odd , even ) ; int d = even - odd ; if ( fib . find ( d ) != fib . end ( ) ) return 1 ; return 0 ; } if ( dp [ pos ] [ even ] [ odd ] [ tight ] != -1 ) return dp [ pos ] [ even ] [ odd ] [ tight ] ; int ans = 0 ; int limit = ( tight ? 9 : num [ pos ] ) ; for ( int d = 0 ; d <= limit ; d ++ ) { int currF = tight , currEven = even ; int currOdd = odd ; if ( d < num [ pos ] ) currF = 1 ; if ( pos & 1 ) currOdd += d ; else currEven += d ; ans += count ( pos + 1 , currEven , currOdd , currF , num ) ; } return dp [ pos ] [ even ] [ odd ] [ tight ] = ans ; } int solve ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return count ( 0 , 0 , 0 , 0 , num ) ; } int main ( ) { fibonacci ( ) ; int L = 1 , R = 50 ; cout << solve ( R ) - solve ( L - 1 ) << endl ; L = 50 , R = 100 ; cout << solve ( R ) - solve ( L - 1 ) << endl ; return 0 ; }", "docstring": "Numbers with a Fibonacci difference between Sum of digits at even and odd positions in a given range | C ++ program to count the numbers in the range having the difference between the sum of digits at even and odd positions as a Fibonacci Number ; To store all the Fibonacci numbers ; Function to generate Fibonacci numbers upto 100 ; Adding the first two Fibonacci numbers in the set ; Computing the remaining Fibonacci numbers using the first two Fibonacci numbers ; Function to return the count of required numbers from 0 to num ; Base Case ; Check if the difference is equal to any fibonacci number ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; If the current position is odd add it to currOdd , otherwise to currEven ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Initialize dp ; Driver Code ; Generate fibonacci numbers", "dfg": [["d", 235, "comesFrom", ["d"], [231]], ["d", 239, "comesFrom", ["d"], [231]], ["d", 259, "comesFrom", ["d"], [231]], ["d", 278, "comesFrom", ["d"], [231]], ["d", 283, "comesFrom", ["d"], [231]], ["d", 160, "comesFrom", ["d"], [148]], ["limit", 237, "comesFrom", ["limit"], [215]], ["ans", 318, "comesFrom", ["ans"], [285]], ["x", 336, "comesFrom", ["x"], [325]], ["x", 343, "comesFrom", ["x"], [325]], ["M", 20, "comesFrom", ["M"], [9]], ["fib", 52, "comesFrom", ["fib"], [36]], ["fib", 59, "comesFrom", ["fib"], [36]], ["fib", 80, "comesFrom", ["fib"], [36]], ["fib", 156, "comesFrom", ["fib"], [36]], ["fib", 163, "comesFrom", ["fib"], [36]], ["prev", 56, "comesFrom", ["prev"], [44]], ["prev", 78, "comesFrom", ["prev"], [44]], ["curr", 63, "comesFrom", ["curr"], [48]], ["curr", 68, "comesFrom", ["curr"], [48]], ["curr", 89, "comesFrom", ["curr"], [48]], ["curr", 76, "comesFrom", ["curr"], [48]], ["pos", 121, "comesFrom", ["pos"], [101]], ["pos", 272, "comesFrom", ["pos"], [101]], ["pos", 224, "comesFrom", ["pos"], [101]], ["pos", 197, "comesFrom", ["pos"], [101]], ["pos", 263, "comesFrom", ["pos"], [101]], ["pos", 289, "comesFrom", ["pos"], [101]], ["pos", 306, "comesFrom", ["pos"], [101]], ["pos", 180, "comesFrom", ["pos"], [101]], ["num", 391, "comesFrom", ["num"], [332]], ["num", 123, "comesFrom", ["num"], [116]], ["num", 222, "comesFrom", ["num"], [116]], ["num", 339, "comesFrom", ["num"], [332]], ["num", 355, "comesFrom", ["num"], [332]], ["num", 361, "comesFrom", ["num"], [332]], ["num", 261, "comesFrom", ["num"], [116]], ["num", 299, "comesFrom", ["num"], [116]], ["num", 132, "comesFrom", ["num"], [116]], ["temp", 93, "comesFrom", ["temp"], [74]], ["temp", 84, "comesFrom", ["temp"], [74]], ["tight", 206, "comesFrom", ["tight"], [110]], ["tight", 218, "comesFrom", ["tight"], [110]], ["tight", 315, "comesFrom", ["tight"], [246]], ["tight", 189, "comesFrom", ["tight"], [110]], ["even", 150, "comesFrom", ["even"], [104]], ["even", 144, "comesFrom", ["even"], [104]], ["even", 200, "comesFrom", ["even"], [104]], ["even", 309, "comesFrom", ["even"], [250]], ["even", 183, "comesFrom", ["even"], [104]], ["odd", 152, "comesFrom", ["odd"], [107]], ["odd", 203, "comesFrom", ["odd"], [107]], ["odd", 312, "comesFrom", ["odd"], [255]], ["odd", 142, "comesFrom", ["odd"], [107]], ["odd", 186, "comesFrom", ["odd"], [107]], ["currEven", 293, "comesFrom", ["currEven"], [281]], ["currOdd", 295, "comesFrom", ["currOdd"], [276]], ["currF", 297, "comesFrom", ["currF"], [266]], ["R", 417, "comesFrom", ["R"], [409]], ["R", 441, "comesFrom", ["R"], [433]], ["L", 422, "comesFrom", ["L"], [405]], ["L", 446, "comesFrom", ["L"], [429]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumOccurrence ( string s ) { int n = s . length ( ) ; int freq [ 26 ] = { 0 } ; int dp [ 26 ] [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int c = ( s [ i ] - ' a ' ) ; for ( int j = 0 ; j < 26 ; j ++ ) dp [ j ] += freq [ j ] ; freq ++ ; } int answer = INT_MIN ; for ( int i = 0 ; i < 26 ; i ++ ) answer = max ( answer , freq [ i ] ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { answer = max ( answer , dp [ i ] [ j ] ) ; } } return answer ; } int main ( ) { string s = \" xxxyy \" ; cout << maximumOccurrence ( s ) ; return 0 ; }", "docstring": "Count maximum occurrence of subsequence in string such that indices in subsequence is in A . P . | C ++ implementation to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Function to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Frequency for characters ; Loop to count the occurrence of ith character before jth character in the given string ; Increase the frequency of s [ i ] or c of string ; Maximum occurrence of subsequence of length 1 in given string ; Maximum occurrence of subsequence of length 2 in given string ; Driver Code", "dfg": [["answer", 184, "comesFrom", ["answer"], [166]], ["answer", 128, "comesFrom", ["answer"], [124]], ["answer", 170, "comesFrom", ["answer"], [166]], ["i", 53, "comesFrom", ["i"], [49]], ["i", 57, "comesFrom", ["i"], [49]], ["i", 117, "comesFrom", ["i"], [113]], ["i", 121, "comesFrom", ["i"], [113]], ["i", 143, "comesFrom", ["i"], [139]], ["i", 147, "comesFrom", ["i"], [139]], ["i", 132, "comesFrom", ["i"], [113]], ["i", 67, "comesFrom", ["i"], [49]], ["i", 174, "comesFrom", ["i"], [139]], ["n", 55, "comesFrom", ["n"], [15]], ["s", 17, "comesFrom", ["s"], [11]], ["s", 203, "comesFrom", ["s"], [193]], ["s", 65, "comesFrom", ["s"], [11]], ["j", 84, "comesFrom", ["j"], [80]], ["j", 88, "comesFrom", ["j"], [80]], ["j", 158, "comesFrom", ["j"], [154]], ["j", 162, "comesFrom", ["j"], [154]], ["j", 93, "comesFrom", ["j"], [80]], ["j", 98, "comesFrom", ["j"], [80]], ["j", 177, "comesFrom", ["j"], [154]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1000000007 ; int dp [ 1005 ] [ 105 ] [ 2 ] ; int powers [ 1005 ] ; int powersModk [ 1005 ] ; int calculate ( int pos , int rem , int z , int k , int n ) { if ( rem == 0 && z ) { if ( pos != n ) return ( powers [ n - pos - 1 ] * 9 ) % mod ; else return 1 ; } if ( pos == n ) return 0 ; if ( dp [ pos ] [ rem ] [ z ] != -1 ) return dp [ pos ] [ rem ] [ z ] ; int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 0 ) count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod ; else count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod ; } return dp [ pos ] [ rem ] [ z ] = count ; } int countNumbers ( int n , int k ) { int st = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { powers [ i ] = st ; st *= 10 ; st %= mod ; } st = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { powersModk [ i ] = st ; st *= 10 ; st %= mod ; } memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 0 , 0 , k , n ) ; } int main ( ) { int N = 2 ; int K = 2 ; cout << countNumbers ( N , K ) ; return 0 ; }", "docstring": "Count the numbers with N digits and whose suffix is divisible by K | C ++ implementation to Count the numbers with N digits and whose suffix is divisible by K ; Suffix of length pos with remainder rem and Z representing whether the suffix has a non zero digit until now ; Base case ; If count of digits is less than n ; Placing all possible digits in remaining positions ; If remainder non zero and suffix has n digits ; If the subproblem is already solved ; Placing all digits at MSB of suffix and increasing it 's length by 1 ; Non zero digit is placed ; Store and return the solution to this subproblem ; Function to Count the numbers with N digits and whose suffix is divisible by K ; Since we need powers of 10 for counting , it 's better to  pre store them along with their  modulo with 1e9 + 7 for counting ; Since at each recursive step we increase the suffix length by 1 by placing digits at its leftmost position , we need powers of 10 modded with k , in order to fpos the new remainder efficiently ; Initialising dp table values - 1 represents subproblem hasn 't  been solved yet ; Driver Code", "dfg": [["i", 139, "comesFrom", ["i"], [135]], ["i", 143, "comesFrom", ["i"], [135]], ["i", 272, "comesFrom", ["i"], [268]], ["i", 276, "comesFrom", ["i"], [268]], ["i", 307, "comesFrom", ["i"], [303]], ["i", 311, "comesFrom", ["i"], [303]], ["i", 149, "comesFrom", ["i"], [135]], ["i", 282, "comesFrom", ["i"], [268]], ["i", 317, "comesFrom", ["i"], [303]], ["i", 169, "comesFrom", ["i"], [135]], ["i", 210, "comesFrom", ["i"], [135]], ["count", 247, "comesFrom", ["count"], [194]], ["count", 156, "comesFrom", ["count"], [153]], ["count", 197, "comesFrom", ["count"], [194]], ["n", 274, "comesFrom", ["n"], [254]], ["n", 309, "comesFrom", ["n"], [254]], ["n", 95, "comesFrom", ["n"], [52]], ["n", 354, "comesFrom", ["n"], [254]], ["n", 68, "comesFrom", ["n"], [52]], ["n", 74, "comesFrom", ["n"], [52]], ["n", 186, "comesFrom", ["n"], [52]], ["n", 227, "comesFrom", ["n"], [52]], ["z", 61, "comesFrom", ["z"], [46]], ["z", 124, "comesFrom", ["z"], [46]], ["z", 244, "comesFrom", ["z"], [46]], ["z", 110, "comesFrom", ["z"], [46]], ["z", 182, "comesFrom", ["z"], [46]], ["pos", 93, "comesFrom", ["pos"], [40]], ["pos", 66, "comesFrom", ["pos"], [40]], ["pos", 118, "comesFrom", ["pos"], [40]], ["pos", 238, "comesFrom", ["pos"], [40]], ["pos", 104, "comesFrom", ["pos"], [40]], ["pos", 76, "comesFrom", ["pos"], [40]], ["pos", 161, "comesFrom", ["pos"], [40]], ["pos", 202, "comesFrom", ["pos"], [40]], ["pos", 173, "comesFrom", ["pos"], [40]], ["pos", 214, "comesFrom", ["pos"], [40]], ["k", 352, "comesFrom", ["k"], [257]], ["k", 184, "comesFrom", ["k"], [49]], ["k", 180, "comesFrom", ["k"], [49]], ["k", 225, "comesFrom", ["k"], [49]], ["k", 221, "comesFrom", ["k"], [49]], ["k", 177, "comesFrom", ["k"], [49]], ["k", 218, "comesFrom", ["k"], [49]], ["rem", 57, "comesFrom", ["rem"], [43]], ["rem", 121, "comesFrom", ["rem"], [43]], ["rem", 241, "comesFrom", ["rem"], [43]], ["rem", 107, "comesFrom", ["rem"], [43]], ["rem", 166, "comesFrom", ["rem"], [43]], ["rem", 207, "comesFrom", ["rem"], [43]], ["st", 285, "comesFrom", ["st"], [261]], ["st", 320, "comesFrom", ["st"], [296]], ["mod", 293, "comesFrom", ["mod"], [8]], ["mod", 328, "comesFrom", ["mod"], [8]], ["mod", 84, "comesFrom", ["mod"], [8]], ["mod", 191, "comesFrom", ["mod"], [8]], ["mod", 232, "comesFrom", ["mod"], [8]], ["N", 377, "comesFrom", ["N"], [364]], ["K", 379, "comesFrom", ["K"], [369]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define inf  100000000 NEW_LINE using namespace std ; double smPath ( int s , int d , vector < pair < pair < int , int > , int > > ed , int n , int k ) { int dis [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dis [ i ] = inf ; dis [ s ] = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int dis1 [ n + 1 ] ; for ( int j = 0 ; j <= n ; j ++ ) dis1 [ j ] = inf ; for ( auto it : ed ) dis1 [ it . first . second ] = min ( dis1 [ it . first . second ] , dis [ it . first . first ] + it . second ) ; for ( int i = 0 ; i <= n ; i ++ ) dis [ i ] = dis1 [ i ] ; } if ( dis [ d ] == inf ) return -1 ; else return dis [ d ] ; } int main ( ) { int n = 4 ; vector < pair < pair < int , int > , int > > ed ; ed = { { { 0 , 1 } , 10 } , { { 0 , 2 } , 3 } , { { 0 , 3 } , 2 } , { { 1 , 3 } , 7 } , { { 2 , 3 } , 7 } } ; int s = 0 , d = 3 ; int k = 2 ; cout << smPath ( s , d , ed , n , k ) ; }", "docstring": "Shortest path with exactly k edges in a directed and weighted graph | Set 2 | C ++ implementation of the above approach ; Function to find the smallest path with exactly K edges ; Array to store dp ; Initialising the array ; Loop to solve DP ; Initialising next state ; Recurrence relation ; Returning final answer ; Driver code ; Input edges ; Source and Destination ; Number of edges in path ; Calling the function", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double inf = std :: numeric_limits < double > :: infinity ( ) ; double bellman ( int s , int d , vector < pair < pair < int , int > , double > > ed , int n ) { if ( s == d ) return 0 ; double dis [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dis [ i ] = inf ; dis [ s ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( auto it : ed ) dis [ it . first . second ] = min ( dis [ it . first . second ] , dis [ it . first . first ] * it . second ) ; for ( auto it : ed ) { if ( dis [ it . first . second ] > dis [ it . first . first ] * it . second ) return -2 ; } if ( dis [ d ] == inf ) return -1 ; else return dis [ d ] ; } int main ( ) { int n = 3 ; vector < pair < pair < int , int > , double > > ed ; ed = { { { 1 , 2 } , 0.5 } , { { 1 , 3 } , 1.9 } , { { 2 , 3 } , 3 } } ; int s = 1 , d = 3 ; double get = bellman ( s , d , ed , n ) ; if ( get == -2 ) cout << \" Cycle ▁ Detected \" ; else cout << get ; }", "docstring": "Path with smallest product of edges with weight > 0 | C ++ implementation of the approach . ; Function to return the smallest product of edges ; If the source is equal to the destination ; Array to store distances ; Initialising the array ; Bellman ford algorithm ; Loop to detect cycle ; Returning final answer ; Driver code ; Input edges ; Source and Destination ; Bellman ford", "dfg": [["ed", 157, "comesFrom", ["ed"], [44]], ["ed", 116, "comesFrom", ["ed"], [44]], ["ed", 286, "comesFrom", ["ed"], [234]], ["i", 74, "comesFrom", ["i"], [70]], ["i", 78, "comesFrom", ["i"], [70]], ["i", 102, "comesFrom", ["i"], [98]], ["i", 108, "comesFrom", ["i"], [98]], ["i", 83, "comesFrom", ["i"], [70]], ["n", 76, "comesFrom", ["n"], [47]], ["n", 62, "comesFrom", ["n"], [47]], ["n", 104, "comesFrom", ["n"], [47]], ["n", 288, "comesFrom", ["n"], [214]], ["s", 52, "comesFrom", ["s"], [25]], ["s", 90, "comesFrom", ["s"], [25]], ["s", 282, "comesFrom", ["s"], [269]], ["d", 54, "comesFrom", ["d"], [28]], ["d", 284, "comesFrom", ["d"], [273]], ["d", 192, "comesFrom", ["d"], [28]], ["d", 204, "comesFrom", ["d"], [28]], ["inf", 86, "comesFrom", ["inf"], [8]], ["inf", 195, "comesFrom", ["inf"], [8]], ["get", 293, "comesFrom", ["get"], [278]], ["get", 306, "comesFrom", ["get"], [278]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int maxLengthSquare ( int row , int column , int arr [ ] [ 4 ] , int k ) { int sum [ row + 1 ] [ column + 1 ] ; for ( int i = 1 ; i <= row ; i ++ ) for ( int j = 0 ; j <= column ; j ++ ) sum [ i ] [ j ] = 0 ; int cur_max = 1 ; int max = 0 ; for ( int i = 1 ; i <= row ; i ++ ) { for ( int j = 1 ; j <= column ; j ++ ) { sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; } int main ( ) { int row = 4 , column = 4 ; int matrix [ 4 ] [ 4 ] = { { 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } } ; int k = 6 ; int ans = maxLengthSquare ( row , column , matrix , k ) ; cout << ans ; return 0 ; }", "docstring": "Find Maximum Length Of A Square Submatrix Having Sum Of Elements At | C ++ implementation of the above approach ; Function to return maximum length of square submatrix having sum of elements at - most K ; Matrix to store prefix sum ; Current maximum length ; Variable for storing maximum length of square ; Calculating prefix sum ; Checking whether there exits square with length cur_max + 1 or not ; Returning the maximum length ; Driver code", "dfg": [["max", 233, "comesFrom", ["max"], [224]], ["i", 48, "comesFrom", ["i"], [44]], ["i", 52, "comesFrom", ["i"], [44]], ["i", 96, "comesFrom", ["i"], [92]], ["i", 100, "comesFrom", ["i"], [92]], ["i", 71, "comesFrom", ["i"], [44]], ["i", 121, "comesFrom", ["i"], [92]], ["i", 173, "comesFrom", ["i"], [92]], ["i", 161, "comesFrom", ["i"], [92]], ["i", 139, "comesFrom", ["i"], [92]], ["i", 149, "comesFrom", ["i"], [92]], ["i", 129, "comesFrom", ["i"], [92]], ["i", 201, "comesFrom", ["i"], [92]], ["i", 211, "comesFrom", ["i"], [92]], ["i", 183, "comesFrom", ["i"], [92]], ["i", 191, "comesFrom", ["i"], [92]], ["row", 50, "comesFrom", ["row"], [11]], ["row", 98, "comesFrom", ["row"], [11]], ["row", 31, "comesFrom", ["row"], [11]], ["row", 311, "comesFrom", ["row"], [242]], ["ans", 322, "comesFrom", ["ans"], [307]], ["column", 36, "comesFrom", ["column"], [14]], ["column", 64, "comesFrom", ["column"], [14]], ["column", 113, "comesFrom", ["column"], [14]], ["column", 313, "comesFrom", ["column"], [246]], ["j", 62, "comesFrom", ["j"], [58]], ["j", 66, "comesFrom", ["j"], [58]], ["j", 111, "comesFrom", ["j"], [107]], ["j", 115, "comesFrom", ["j"], [107]], ["j", 74, "comesFrom", ["j"], [58]], ["j", 124, "comesFrom", ["j"], [107]], ["j", 177, "comesFrom", ["j"], [107]], ["j", 166, "comesFrom", ["j"], [107]], ["j", 134, "comesFrom", ["j"], [107]], ["j", 154, "comesFrom", ["j"], [107]], ["j", 142, "comesFrom", ["j"], [107]], ["j", 216, "comesFrom", ["j"], [107]], ["j", 186, "comesFrom", ["j"], [107]], ["j", 196, "comesFrom", ["j"], [107]], ["j", 204, "comesFrom", ["j"], [107]], ["k", 317, "comesFrom", ["k"], [302]], ["k", 221, "comesFrom", ["k"], [25]], ["cur_max", 175, "comesFrom", ["cur_max"], [80]], ["cur_max", 179, "comesFrom", ["cur_max"], [80]], ["cur_max", 226, "comesFrom", ["cur_max"], [80]], ["cur_max", 218, "comesFrom", ["cur_max"], [80]], ["cur_max", 206, "comesFrom", ["cur_max"], [80]], ["cur_max", 213, "comesFrom", ["cur_max"], [80]], ["cur_max", 193, "comesFrom", ["cur_max"], [80]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 101 ; const int mod = 1e9 + 7 ; int exactsum [ N ] [ N ] [ N ] ; int exactnum [ N ] [ N ] [ N ] ; int getSum ( int x , int y , int z ) { int ans = 0 ; exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i <= x ; ++ i ) { for ( int j = 0 ; j <= y ; ++ j ) { for ( int k = 0 ; k <= z ; ++ k ) { if ( i > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; } if ( j > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; } if ( k > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; } ans += exactsum [ i ] [ j ] [ k ] % mod ; ans %= mod ; } } } return ans ; } int main ( ) { int x = 1 , y = 1 , z = 1 ; cout << ( getSum ( x , y , z ) % mod ) ; return 0 ; }", "docstring": "Sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times | C ++ program to find sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times ; exactsum [ i ] [ j ] [ k ] stores the sum of all the numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; exactnum [ i ] [ j ] [ k ] stores numbers of numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; Utility function to calculate the sum for x 4 ' s , ▁ y ▁ 5' s and z 6 's ; Computing exactsum [ i ] [ j ] [ k ] as explained above ; Driver code", "dfg": [["N", 30, "comesFrom", ["N"], [9]], ["N", 42, "comesFrom", ["N"], [9]], ["N", 27, "comesFrom", ["N"], [9]], ["N", 39, "comesFrom", ["N"], [9]], ["N", 24, "comesFrom", ["N"], [9]], ["N", 36, "comesFrom", ["N"], [9]], ["ans", 381, "comesFrom", ["ans"], [373]], ["i", 83, "comesFrom", ["i"], [79]], ["i", 88, "comesFrom", ["i"], [79]], ["i", 123, "comesFrom", ["i"], [79]], ["i", 362, "comesFrom", ["i"], [79]], ["i", 130, "comesFrom", ["i"], [79]], ["i", 175, "comesFrom", ["i"], [79]], ["i", 209, "comesFrom", ["i"], [79]], ["i", 254, "comesFrom", ["i"], [79]], ["i", 288, "comesFrom", ["i"], [79]], ["i", 333, "comesFrom", ["i"], [79]], ["i", 265, "comesFrom", ["i"], [79]], ["i", 344, "comesFrom", ["i"], [79]], ["i", 186, "comesFrom", ["i"], [79]], ["i", 221, "comesFrom", ["i"], [79]], ["i", 238, "comesFrom", ["i"], [79]], ["i", 300, "comesFrom", ["i"], [79]], ["i", 317, "comesFrom", ["i"], [79]], ["i", 142, "comesFrom", ["i"], [79]], ["i", 159, "comesFrom", ["i"], [79]], ["x", 85, "comesFrom", ["x"], [49]], ["x", 407, "comesFrom", ["x"], [390]], ["j", 98, "comesFrom", ["j"], [94]], ["j", 103, "comesFrom", ["j"], [94]], ["j", 202, "comesFrom", ["j"], [94]], ["j", 365, "comesFrom", ["j"], [94]], ["j", 133, "comesFrom", ["j"], [94]], ["j", 178, "comesFrom", ["j"], [94]], ["j", 212, "comesFrom", ["j"], [94]], ["j", 257, "comesFrom", ["j"], [94]], ["j", 291, "comesFrom", ["j"], [94]], ["j", 336, "comesFrom", ["j"], [94]], ["j", 191, "comesFrom", ["j"], [94]], ["j", 347, "comesFrom", ["j"], [94]], ["j", 268, "comesFrom", ["j"], [94]], ["j", 147, "comesFrom", ["j"], [94]], ["j", 164, "comesFrom", ["j"], [94]], ["j", 303, "comesFrom", ["j"], [94]], ["j", 320, "comesFrom", ["j"], [94]], ["j", 224, "comesFrom", ["j"], [94]], ["j", 241, "comesFrom", ["j"], [94]], ["y", 100, "comesFrom", ["y"], [52]], ["y", 409, "comesFrom", ["y"], [394]], ["mod", 414, "comesFrom", ["mod"], [15]], ["mod", 375, "comesFrom", ["mod"], [15]], ["mod", 371, "comesFrom", ["mod"], [15]], ["mod", 171, "comesFrom", ["mod"], [15]], ["mod", 197, "comesFrom", ["mod"], [15]], ["mod", 250, "comesFrom", ["mod"], [15]], ["mod", 276, "comesFrom", ["mod"], [15]], ["mod", 329, "comesFrom", ["mod"], [15]], ["mod", 355, "comesFrom", ["mod"], [15]], ["k", 113, "comesFrom", ["k"], [109]], ["k", 118, "comesFrom", ["k"], [109]], ["k", 281, "comesFrom", ["k"], [109]], ["k", 368, "comesFrom", ["k"], [109]], ["k", 136, "comesFrom", ["k"], [109]], ["k", 181, "comesFrom", ["k"], [109]], ["k", 215, "comesFrom", ["k"], [109]], ["k", 260, "comesFrom", ["k"], [109]], ["k", 294, "comesFrom", ["k"], [109]], ["k", 339, "comesFrom", ["k"], [109]], ["k", 194, "comesFrom", ["k"], [109]], ["k", 273, "comesFrom", ["k"], [109]], ["k", 350, "comesFrom", ["k"], [109]], ["k", 150, "comesFrom", ["k"], [109]], ["k", 167, "comesFrom", ["k"], [109]], ["k", 229, "comesFrom", ["k"], [109]], ["k", 246, "comesFrom", ["k"], [109]], ["k", 306, "comesFrom", ["k"], [109]], ["k", 323, "comesFrom", ["k"], [109]], ["z", 115, "comesFrom", ["z"], [55]], ["z", 411, "comesFrom", ["z"], [398]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMax ( int a [ ] , int n ) { int dp [ n ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } cout << max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) ; } int main ( ) { int arr [ ] = { 5 , -1 , -5 , -3 , 2 , 9 , -4 } ; findMax ( arr , 7 ) ; }", "docstring": "Maximum value obtained by performing given operations in an Array | C ++ implementation of the above approach ; A function to calculate the maximum value ; basecases ; Loop to iterate and add the max value in the dp array ; Driver Code", "dfg": [["i", 83, "comesFrom", ["i"], [79]], ["i", 89, "comesFrom", ["i"], [79]], ["i", 95, "comesFrom", ["i"], [79]], ["i", 133, "comesFrom", ["i"], [79]], ["i", 126, "comesFrom", ["i"], [79]], ["i", 151, "comesFrom", ["i"], [79]], ["i", 156, "comesFrom", ["i"], [79]], ["i", 161, "comesFrom", ["i"], [79]], ["i", 141, "comesFrom", ["i"], [79]], ["i", 105, "comesFrom", ["i"], [79]], ["i", 115, "comesFrom", ["i"], [79]], ["n", 22, "comesFrom", ["n"], [16]], ["n", 85, "comesFrom", ["n"], [16]], ["n", 173, "comesFrom", ["n"], [16]], ["n", 183, "comesFrom", ["n"], [16]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll sum ( int arr [ ] , int l , int r ) { ll s = 0 ; for ( int i = l ; i <= r ; i ++ ) { s += arr [ i ] ; } return s ; } ll dp [ 101 ] [ 101 ] [ 101 ] = { 0 } ; ll solve ( int arr [ ] , int l , int r , int k ) { if ( r - l + 1 <= k ) return sum ( arr , l , r ) ; if ( dp [ l ] [ r ] [ k ] ) return dp [ l ] [ r ] [ k ] ; ll sum_ = sum ( arr , l , r ) ; ll len_r = ( r - l + 1 ) - k ; ll len = ( r - l + 1 ) ; ll ans = 0 ; for ( int i = 0 ; i < len - len_r + 1 ; i ++ ) { ll sum_sub = sum ( arr , i + l , i + l + len_r - 1 ) ; ans = max ( ans , ( sum_ - sum_sub ) + ( sum_sub - solve ( arr , i + l , i + l + len_r - 1 , k ) ) ) ; } dp [ l ] [ r ] [ k ] = ans ; return ans ; } int main ( ) { int arr [ ] = { 10 , 15 , 20 , 9 , 2 , 5 } , k = 2 ; int n = sizeof ( arr ) / sizeof ( int ) ; memset ( dp , 0 , sizeof ( dp ) ) ; cout << solve ( arr , 0 , n - 1 , k ) ; return 0 ; }", "docstring": "Optimal strategy for a Game with modifications | C ++ implementation of the above approach ; Function to return sum of subarray from l to r ; calculate sum by a loop from l to r ; dp to store the values of sub problems ; if length of the array is less than k return the sum ; if the value is previously calculated ; else calculate the value ; select all the sub array of length len_r ; get the sum of that sub array ; check if it is the maximum or not ; store it in the table ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXI  50 NEW_LINE int dp [ MAXI ] [ MAXI ] [ MAXI * MAXI ] ; int n , m ; int minDifference ( int x , int y , int k , vector < vector < int > > b , vector < vector < int > > c ) { if ( x >= n or y >= m ) return INT_MAX ; if ( x == n - 1 and y == m - 1 ) { int diff = b [ x ] [ y ] - c [ x ] [ y ] ; return min ( abs ( k - diff ) , abs ( k + diff ) ) ; } int & ans = dp [ x ] [ y ] [ k ] ; if ( ans != -1 ) return ans ; ans = INT_MAX ; int diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x , y + 1 , abs ( k + diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x + 1 , y , abs ( k - diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; return ans ; } int main ( ) { n = 2 , m = 2 ; vector < vector < int > > b = { { 1 , 4 } , { 2 , 4 } } ; vector < vector < int > > c = { { 3 , 2 } , { 3 , 1 } } ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << minDifference ( 0 , 0 , 0 , b , c ) ; return 0 ; }", "docstring": "Find the minimum difference path from ( 0 , 0 ) to ( N | C ++ implementation of the approach ; Function to return the minimum difference path from ( 0 , 0 ) to ( N - 1 , M - 1 ) ; Terminating case ; Base case ; If it is already visited ; Recursive calls ; Return the value ; Driver code ; Function call", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longest_subseq ( int n , int k , string s ) { vector < int > dp ( n , 0 ) ; int max_length [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s [ i ] - ' a ' ; int lower = max ( 0 , curr - k ) ; int upper = min ( 25 , curr + k ) ; for ( int j = lower ; j < upper + 1 ; j ++ ) { dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) ; } max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) ; } int ans = 0 ; for ( int i : dp ) ans = max ( i , ans ) ; return ans ; } int main ( ) { string s = \" geeksforgeeks \" ; int n = s . size ( ) ; int k = 3 ; cout << ( longest_subseq ( n , k , s ) ) ; return 0 ; }", "docstring": "Longest subsequence having difference atmost K | C ++ program for the above approach ; Function to find the longest Special Sequence ; Creating a list with all 0 's of size  equal to the length of string ; Supporting list with all 0 's of size 26 since  the given string consists  of only lower case alphabets ; Converting the ascii value to list indices ; Determining the lower bound ; Determining the upper bound ; Filling the dp array with values ; Filling the max_length array with max length of subsequence till now ; return the max length of subsequence ; Driver Code", "dfg": [["i", 159, "comesFrom", ["i"], [44]], ["i", 48, "comesFrom", ["i"], [44]], ["i", 52, "comesFrom", ["i"], [44]], ["i", 167, "comesFrom", ["i"], [44]], ["i", 61, "comesFrom", ["i"], [44]], ["i", 113, "comesFrom", ["i"], [44]], ["i", 141, "comesFrom", ["i"], [44]], ["i", 120, "comesFrom", ["i"], [44]], ["dp", 161, "comesFrom", ["dp"], [24]], ["dp", 111, "comesFrom", ["dp"], [24]], ["dp", 139, "comesFrom", ["dp"], [24]], ["dp", 118, "comesFrom", ["dp"], [24]], ["ans", 173, "comesFrom", ["ans"], [163]], ["ans", 169, "comesFrom", ["ans"], [163]], ["n", 50, "comesFrom", ["n"], [11]], ["n", 26, "comesFrom", ["n"], [11]], ["n", 207, "comesFrom", ["n"], [189]], ["j", 101, "comesFrom", ["j"], [97]], ["j", 107, "comesFrom", ["j"], [97]], ["j", 125, "comesFrom", ["j"], [97]], ["s", 191, "comesFrom", ["s"], [182]], ["s", 211, "comesFrom", ["s"], [182]], ["s", 59, "comesFrom", ["s"], [17]], ["upper", 103, "comesFrom", ["upper"], [83]], ["k", 209, "comesFrom", ["k"], [198]], ["k", 79, "comesFrom", ["k"], [14]], ["k", 91, "comesFrom", ["k"], [14]], ["curr", 134, "comesFrom", ["curr"], [57]], ["curr", 77, "comesFrom", ["curr"], [57]], ["curr", 89, "comesFrom", ["curr"], [57]], ["curr", 146, "comesFrom", ["curr"], [57]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areAllNegative ( vector < int > arr ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] > 0 ) return false ; } return true ; } vector < int > getRightToLeftKadane ( vector < int > arr ) { int max_so_far = 0 , max_ending_here = 0 ; int size = arr . size ( ) ; for ( int i = size - 1 ; i >= 0 ; i -- ) { max_ending_here = max_ending_here + arr [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; else if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; arr [ i ] = max_so_far ; } return arr ; } vector < int > getPrefixSum ( vector < int > arr ) { for ( int i = 1 ; i < arr . size ( ) ; i ++ ) arr [ i ] = arr [ i - 1 ] + arr [ i ] ; return arr ; } int maxSumSubArr ( vector < int > a ) { int max_so_far = 0 , max_ending_here = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; else if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; } int maxSumSubWithOp ( vector < int > arr ) { vector < int > kadane_r_to_l = getRightToLeftKadane ( arr ) ; vector < int > prefixSum = getPrefixSum ( arr ) ; int size = arr . size ( ) ; for ( int i = 1 ; i < size ; i ++ ) { prefixSum [ i ] = max ( prefixSum [ i - 1 ] , prefixSum [ i ] ) ; } int max_subarray_sum = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { max_subarray_sum = max ( max_subarray_sum , prefixSum [ i ] + kadane_r_to_l [ i + 1 ] ) ; } return max_subarray_sum ; } int maxSum ( vector < int > arr , int size ) { if ( areAllNegative ( arr ) ) { return ( * max_element ( arr . begin ( ) , arr . end ( ) ) ) ; } int resSum = maxSumSubArr ( arr ) ; resSum = max ( resSum , maxSumSubWithOp ( arr ) ) ; reverse ( arr . begin ( ) , arr . end ( ) ) ; resSum = max ( resSum , maxSumSubWithOp ( arr ) ) ; return resSum ; } int main ( ) { vector < int > arr { -9 , 21 , 24 , 24 , -51 , -6 , 17 , -42 , -39 , 33 } ; int size = arr . size ( ) ; cout << maxSum ( arr , size ) ; return 0 ; }", "docstring": "Maximum sum subarray after altering the array | C ++ implementation of the approach ; Function that returns true if all the array element are <= 0 ; If any element is non - negative ; Function to return the vector representing the right to left Kadane array as described in the approach ; Function to return the prefix_sum vector ; Function to return the maximum sum subarray ; Function to get the maximum sum subarray in the modified array ; kadane_r_to_l [ i ] will store the maximum subarray sum for thre subarray arr [ i ... N - 1 ] ; Get the prefix sum array ; To get max_prefix_sum_at_any_index ; Summation of both gives the maximum subarray sum after applying the operation ; Function to return the maximum subarray sum after performing the given operation at most once ; If all element are negative then return the maximum element ; Maximum subarray sum without performing any operation ; Maximum subarray sum after performing the operations of first type ; Reversing the array to use the same existing function for operations of the second type ; Driver code", "dfg": [["arr", 140, "comesFrom", ["arr"], [63]], ["arr", 192, "comesFrom", ["arr"], [153]], ["arr", 26, "comesFrom", ["arr"], [14]], ["arr", 78, "comesFrom", ["arr"], [63]], ["arr", 165, "comesFrom", ["arr"], [153]], ["arr", 174, "comesFrom", ["arr"], [153]], ["arr", 286, "comesFrom", ["arr"], [275]], ["arr", 297, "comesFrom", ["arr"], [275]], ["arr", 303, "comesFrom", ["arr"], [275]], ["arr", 408, "comesFrom", ["arr"], [398]], ["arr", 437, "comesFrom", ["arr"], [398]], ["arr", 518, "comesFrom", ["arr"], [492]], ["arr", 528, "comesFrom", ["arr"], [492]], ["arr", 131, "comesFrom", ["arr"], [63]], ["arr", 179, "comesFrom", ["arr"], [153]], ["arr", 186, "comesFrom", ["arr"], [153]], ["arr", 454, "comesFrom", ["arr"], [398]], ["arr", 460, "comesFrom", ["arr"], [398]], ["arr", 38, "comesFrom", ["arr"], [14]], ["arr", 105, "comesFrom", ["arr"], [63]], ["arr", 448, "comesFrom", ["arr"], [398]], ["arr", 475, "comesFrom", ["arr"], [398]], ["arr", 417, "comesFrom", ["arr"], [398]], ["arr", 423, "comesFrom", ["arr"], [398]], ["max_so_far", 265, "comesFrom", ["max_so_far"], [259]], ["max_so_far", 136, "comesFrom", ["max_so_far"], [127]], ["max_so_far", 123, "comesFrom", ["max_so_far"], [67]], ["max_so_far", 255, "comesFrom", ["max_so_far"], [206]], ["max_subarray_sum", 388, "comesFrom", ["max_subarray_sum"], [367]], ["max_subarray_sum", 371, "comesFrom", ["max_subarray_sum"], [367]], ["resSum", 480, "comesFrom", ["resSum"], [467]], ["resSum", 444, "comesFrom", ["resSum"], [440]], ["resSum", 471, "comesFrom", ["resSum"], [467]], ["i", 24, "comesFrom", ["i"], [20]], ["i", 32, "comesFrom", ["i"], [20]], ["i", 93, "comesFrom", ["i"], [87]], ["i", 97, "comesFrom", ["i"], [87]], ["i", 163, "comesFrom", ["i"], [159]], ["i", 171, "comesFrom", ["i"], [159]], ["i", 221, "comesFrom", ["i"], [217]], ["i", 229, "comesFrom", ["i"], [217]], ["i", 316, "comesFrom", ["i"], [312]], ["i", 320, "comesFrom", ["i"], [312]], ["i", 357, "comesFrom", ["i"], [353]], ["i", 363, "comesFrom", ["i"], [353]], ["i", 176, "comesFrom", ["i"], [159]], ["i", 133, "comesFrom", ["i"], [87]], ["i", 188, "comesFrom", ["i"], [159]], ["i", 326, "comesFrom", ["i"], [312]], ["i", 40, "comesFrom", ["i"], [20]], ["i", 107, "comesFrom", ["i"], [87]], ["i", 181, "comesFrom", ["i"], [159]], ["i", 239, "comesFrom", ["i"], [217]], ["i", 340, "comesFrom", ["i"], [312]], ["i", 333, "comesFrom", ["i"], [312]], ["i", 375, "comesFrom", ["i"], [353]], ["i", 380, "comesFrom", ["i"], [353]], ["size", 318, "comesFrom", ["size"], [301]], ["size", 359, "comesFrom", ["size"], [301]], ["size", 80, "comesFrom", ["size"], [76]], ["size", 89, "comesFrom", ["size"], [76]], ["size", 167, "comesFrom", ["size"], [76]], ["size", 225, "comesFrom", ["size"], [76]], ["size", 305, "comesFrom", ["size"], [301]], ["size", 520, "comesFrom", ["size"], [516]], ["size", 530, "comesFrom", ["size"], [516]], ["a", 223, "comesFrom", ["a"], [202]], ["a", 237, "comesFrom", ["a"], [202]], ["max_ending_here", 103, "comesFrom", ["max_ending_here"], [101]], ["max_ending_here", 112, "comesFrom", ["max_ending_here"], [101]], ["max_ending_here", 235, "comesFrom", ["max_ending_here"], [233]], ["max_ending_here", 244, "comesFrom", ["max_ending_here"], [233]], ["max_ending_here", 125, "comesFrom", ["max_ending_here"], [116]], ["max_ending_here", 129, "comesFrom", ["max_ending_here"], [116]], ["max_ending_here", 257, "comesFrom", ["max_ending_here"], [248]], ["max_ending_here", 261, "comesFrom", ["max_ending_here"], [248]], ["prefixSum", 324, "comesFrom", ["prefixSum"], [293]], ["prefixSum", 331, "comesFrom", ["prefixSum"], [293]], ["prefixSum", 338, "comesFrom", ["prefixSum"], [293]], ["prefixSum", 373, "comesFrom", ["prefixSum"], [293]], ["kadane_r_to_l", 378, "comesFrom", ["kadane_r_to_l"], [282]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_sum ( int a [ ] , int n ) { vector < vector < int > > dp ( n + 1 , vector < int > ( 2 , 0 ) ) ; dp [ 0 ] [ 0 ] = 0 , dp [ 0 ] [ 1 ] = -999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; } int main ( ) { int a [ ] = { -10 , 5 , -4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << max_sum ( a , n ) ; return 0 ; }", "docstring": "Maximum possible array sum after performing the given operation | C ++ implementation of the approach ; Function to return the maximum possible sum after performing the given operation ; Dp vector to store the answer ; Base value ; Return the maximum sum ; Driver code", "dfg": [["i", 70, "comesFrom", ["i"], [66]], ["i", 76, "comesFrom", ["i"], [66]], ["i", 82, "comesFrom", ["i"], [66]], ["i", 121, "comesFrom", ["i"], [66]], ["i", 102, "comesFrom", ["i"], [66]], ["i", 115, "comesFrom", ["i"], [66]], ["i", 141, "comesFrom", ["i"], [66]], ["i", 154, "comesFrom", ["i"], [66]], ["i", 94, "comesFrom", ["i"], [66]], ["i", 107, "comesFrom", ["i"], [66]], ["i", 133, "comesFrom", ["i"], [66]], ["i", 146, "comesFrom", ["i"], [66]], ["n", 72, "comesFrom", ["n"], [16]], ["n", 28, "comesFrom", ["n"], [16]], ["n", 162, "comesFrom", ["n"], [16]], ["n", 209, "comesFrom", ["n"], [188]], ["dp", 160, "comesFrom", ["dp"], [26]], ["dp", 43, "comesFrom", ["dp"], [26]], ["dp", 53, "comesFrom", ["dp"], [26]], ["dp", 80, "comesFrom", ["dp"], [26]], ["dp", 119, "comesFrom", ["dp"], [26]], ["dp", 92, "comesFrom", ["dp"], [26]], ["dp", 105, "comesFrom", ["dp"], [26]], ["dp", 131, "comesFrom", ["dp"], [26]], ["dp", 144, "comesFrom", ["dp"], [26]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1000000007 ; int number_of_ways ( int arr [ ] , int n , int k ) { if ( k == 1 ) return 1 ; int dp [ k + 1 ] ; memset ( dp , -1 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == -1 ) ? 1 : dp [ 1 ] ; for ( int i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; } int main ( ) { int arr [ ] = { 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 6 ; cout << number_of_ways ( arr , n , k ) ; return 0 ; }", "docstring": "Find the number of ways to reach Kth step in stair case | C ++ implementation of the approach ; Function to return the number of ways to reach the kth step ; Create the dp array ; Broken steps ; Calculate the number of ways for the rest of the positions ; If it is a blocked position ; Number of ways to get to the ith step ; Return the required answer ; Driver code", "dfg": [["i", 62, "comesFrom", ["i"], [58]], ["i", 66, "comesFrom", ["i"], [58]], ["i", 114, "comesFrom", ["i"], [110]], ["i", 119, "comesFrom", ["i"], [110]], ["i", 135, "comesFrom", ["i"], [110]], ["i", 154, "comesFrom", ["i"], [110]], ["i", 73, "comesFrom", ["i"], [58]], ["i", 126, "comesFrom", ["i"], [110]], ["i", 140, "comesFrom", ["i"], [110]], ["i", 147, "comesFrom", ["i"], [110]], ["n", 64, "comesFrom", ["n"], [22]], ["n", 208, "comesFrom", ["n"], [182]], ["k", 116, "comesFrom", ["k"], [25]], ["k", 30, "comesFrom", ["k"], [25]], ["k", 40, "comesFrom", ["k"], [25]], ["k", 163, "comesFrom", ["k"], [25]], ["k", 210, "comesFrom", ["k"], [198]], ["MOD", 157, "comesFrom", ["MOD"], [9]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCount ( int n ) { return log ( n ) / log ( 2 ) + 1 ; } int main ( ) { int N = 10 ; cout << findCount ( N ) << endl ; return 0 ; }", "docstring": "Minimum number of coins that can generate all the values in the given range | C ++ program to find minimum number of coins ; Function to find minimum number of coins ; Driver code", "dfg": [["n", 17, "comesFrom", ["n"], [11]], ["N", 42, "comesFrom", ["N"], [34]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSetBits ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) cout << __builtin_popcount ( i ) << \" ▁ \" ; } int main ( ) { int n = 5 ; findSetBits ( n ) ; return 0 ; }", "docstring": "Calculate the number of set bits for every number from 0 to N | C ++ implementation of the approach ; Function to find the count of set bits in all the integers from 0 to n ; Driver code", "dfg": [["i", 21, "comesFrom", ["i"], [17]], ["i", 25, "comesFrom", ["i"], [17]], ["i", 32, "comesFrom", ["i"], [17]], ["n", 23, "comesFrom", ["n"], [11]], ["n", 52, "comesFrom", ["n"], [46]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n ) { vector < int > a ; int i = 1 ; while ( i <= n ) a . push_back ( i ++ ) ; int ways = 0 ; do { bool flag = ( a [ 0 ] == 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( abs ( a [ i ] - a [ i - 1 ] ) > 2 ) flag = 0 ; } if ( flag ) ways ++ ; } while ( next_permutation ( a . begin ( ) , a . end ( ) ) ) ; return ways ; } int main ( ) { int n = 6 ; cout << countWays ( n ) ; return 0 ; }", "docstring": "Count number of ways to arrange first N numbers | C ++ implementation of the approach ; Function to return the count of required arrangements ; Create a vector ; Store numbers from 1 to n ; To store the count of ways ; Generate all the permutations using next_permutation in STL ; Initialize flag to true if first element is 1 else false ; Checking if the current permutation satisfies the given conditions ; If the current permutation is invalid then set the flag to false ; If valid arrangement ; Generate the next permutation ; Driver code", "dfg": [["ways", 124, "comesFrom", ["ways"], [40]], ["ways", 101, "comesFrom", ["ways"], [40]], ["i", 27, "comesFrom", ["i"], [21]], ["i", 65, "comesFrom", ["i"], [61]], ["i", 69, "comesFrom", ["i"], [61]], ["i", 35, "comesFrom", ["i"], [21]], ["i", 79, "comesFrom", ["i"], [61]], ["i", 84, "comesFrom", ["i"], [61]], ["n", 29, "comesFrom", ["n"], [11]], ["n", 67, "comesFrom", ["n"], [11]], ["n", 141, "comesFrom", ["n"], [133]], ["a", 31, "comesFrom", ["a"], [18]], ["a", 109, "comesFrom", ["a"], [18]], ["a", 115, "comesFrom", ["a"], [18]], ["a", 50, "comesFrom", ["a"], [18]], ["a", 77, "comesFrom", ["a"], [18]], ["a", 82, "comesFrom", ["a"], [18]], ["flag", 99, "comesFrom", ["flag"], [92]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; } int main ( ) { int n = 6 ; cout << countWays ( n ) ; return 0 ; }", "docstring": "Count number of ways to arrange first N numbers | C ++ implementation of the approach ; Function to return the count of required arrangements ; Create the dp array ; Initialize the base cases as explained above ; ( 12 ) as the only possibility ; Generate answer for greater values ; dp [ n ] contains the desired answer ; Driver code", "dfg": [["i", 50, "comesFrom", ["i"], [46]], ["i", 54, "comesFrom", ["i"], [46]], ["i", 60, "comesFrom", ["i"], [46]], ["i", 65, "comesFrom", ["i"], [46]], ["i", 72, "comesFrom", ["i"], [46]], ["n", 52, "comesFrom", ["n"], [11]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 83, "comesFrom", ["n"], [11]], ["n", 101, "comesFrom", ["n"], [93]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void NumberOfShortestPaths ( int n , int m ) { int a [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) memset ( a [ i ] , 0 , sizeof ( a [ i ] ) ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < m ; j ++ ) { if ( j == 0 or i == n - 1 ) a [ i ] [ j ] = 1 ; else a [ i ] [ j ] = a [ i ] [ j - 1 ] + a [ i + 1 ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { cout << a [ i ] [ j ] << \" ▁ \" ; } cout << endl ; } } int main ( ) { int n = 5 , m = 2 ; NumberOfShortestPaths ( n , m ) ; return 0 ; }", "docstring": "Number of shortest paths to reach every cell from bottom | CPP program to find number of shortest paths ; Function to find number of shortest paths ; Compute the grid starting from the bottom - left corner ; Print the grid ; Driver code ; Function call", "dfg": [["m", 23, "comesFrom", ["m"], [14]], ["m", 212, "comesFrom", ["m"], [204]], ["m", 84, "comesFrom", ["m"], [14]], ["m", 167, "comesFrom", ["m"], [14]], ["i", 33, "comesFrom", ["i"], [29]], ["i", 37, "comesFrom", ["i"], [29]], ["i", 67, "comesFrom", ["i"], [61]], ["i", 71, "comesFrom", ["i"], [61]], ["i", 150, "comesFrom", ["i"], [146]], ["i", 154, "comesFrom", ["i"], [146]], ["i", 44, "comesFrom", ["i"], [29]], ["i", 53, "comesFrom", ["i"], [29]], ["i", 96, "comesFrom", ["i"], [61]], ["i", 104, "comesFrom", ["i"], [61]], ["i", 177, "comesFrom", ["i"], [146]], ["i", 115, "comesFrom", ["i"], [61]], ["i", 123, "comesFrom", ["i"], [61]], ["i", 133, "comesFrom", ["i"], [61]], ["n", 35, "comesFrom", ["n"], [11]], ["n", 152, "comesFrom", ["n"], [11]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 210, "comesFrom", ["n"], [200]], ["n", 63, "comesFrom", ["n"], [11]], ["n", 98, "comesFrom", ["n"], [11]], ["j", 82, "comesFrom", ["j"], [78]], ["j", 86, "comesFrom", ["j"], [78]], ["j", 165, "comesFrom", ["j"], [161]], ["j", 169, "comesFrom", ["j"], [161]], ["j", 92, "comesFrom", ["j"], [78]], ["j", 107, "comesFrom", ["j"], [78]], ["j", 180, "comesFrom", ["j"], [161]], ["j", 118, "comesFrom", ["j"], [78]], ["j", 138, "comesFrom", ["j"], [78]], ["j", 126, "comesFrom", ["j"], [78]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Max_Sum ( int arr1 [ ] , int arr2 [ ] , int n ) { int dp [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; } int main ( ) { int arr1 [ ] = { 9 , 3 , 5 , 7 , 3 } ; int arr2 [ ] = { 5 , 8 , 1 , 4 , 5 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << Max_Sum ( arr1 , arr2 , n ) ; return 0 ; }", "docstring": "Maximum sum combination from two arrays | CPP program to maximum sum combination from two arrays ; Function to maximum sum combination from two arrays ; To store dp value ; For loop to calculate the value of dp ; Return the required answer ; Driver code ; Function call", "dfg": [["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 50, "comesFrom", ["i"], [36]], ["i", 86, "comesFrom", ["i"], [36]], ["i", 122, "comesFrom", ["i"], [36]], ["i", 65, "comesFrom", ["i"], [36]], ["i", 78, "comesFrom", ["i"], [36]], ["i", 57, "comesFrom", ["i"], [36]], ["i", 70, "comesFrom", ["i"], [36]], ["i", 116, "comesFrom", ["i"], [36]], ["i", 152, "comesFrom", ["i"], [36]], ["i", 96, "comesFrom", ["i"], [36]], ["i", 132, "comesFrom", ["i"], [36]], ["i", 106, "comesFrom", ["i"], [36]], ["i", 142, "comesFrom", ["i"], [36]], ["n", 42, "comesFrom", ["n"], [21]], ["n", 27, "comesFrom", ["n"], [21]], ["n", 245, "comesFrom", ["n"], [222]], ["n", 162, "comesFrom", ["n"], [21]], ["n", 172, "comesFrom", ["n"], [21]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkpossible ( int mask , int * arr , int * prefix , int n , int k ) { bool dp [ n + 1 ] [ k + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { for ( int l = i - 1 ; l >= 0 ; -- l ) { if ( dp [ l ] [ j - 1 ] && ( ( ( prefix [ i ] - prefix [ l ] ) & mask ) == mask ) ) { dp [ i ] [ j ] = 1 ; break ; } } } } return dp [ n ] [ k ] ; } int Partition ( int arr [ ] , int n , int k ) { int prefix [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; } int LOGS = 20 ; int ans = 0 ; for ( int i = LOGS ; i >= 0 ; -- i ) { if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) { ans = ans | ( 1 << i ) ; } } return ans ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 7 , 10 , 23 , 21 , 6 , 8 , 7 , 3 } , k = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) - 1 ; cout << Partition ( arr , n , k ) ; return 0 ; }", "docstring": "Partition the array in K segments such that bitwise AND of individual segment sum is maximized | CPP program to find maximum possible AND ; Function to check whether a k segment partition is possible such that bitwise AND is ' mask ' ; dp [ i ] [ j ] stores whether it is possible to partition first i elements into j segments such that all j segments are ' good ' ; Initialising dp ; Filling dp in bottom - up manner ; Finding a cut such that first l elements can be partitioned into j - 1 ' good ' segments and arr [ l + 1 ] + ... + arr [ i ] is a ' good ' segment ; Function to find maximum possible AND ; Array to store prefix sums ; Maximum no of bits in the possible answer ; This will store the final answer ; Constructing answer greedily selecting from the higher most bit ; Checking if array can be partitioned such that the bitwise AND is ans | ( 1 << i ) ; if possible , update the answer ; Return the final answer ; Driver code ; n = 11 , first element is zero to make array 1 based indexing . So , number of elements are 10 ; Function call", "dfg": [["ans", 285, "comesFrom", ["ans"], [272]], ["ans", 254, "comesFrom", ["ans"], [231]], ["ans", 274, "comesFrom", ["ans"], [272]], ["i", 70, "comesFrom", ["i"], [66]], ["i", 74, "comesFrom", ["i"], [66]], ["i", 199, "comesFrom", ["i"], [195]], ["i", 203, "comesFrom", ["i"], [195]], ["i", 242, "comesFrom", ["i"], [238]], ["i", 247, "comesFrom", ["i"], [238]], ["i", 209, "comesFrom", ["i"], [195]], ["i", 221, "comesFrom", ["i"], [195]], ["i", 98, "comesFrom", ["i"], [66]], ["i", 214, "comesFrom", ["i"], [195]], ["i", 259, "comesFrom", ["i"], [238]], ["i", 279, "comesFrom", ["i"], [238]], ["i", 145, "comesFrom", ["i"], [66]], ["i", 127, "comesFrom", ["i"], [66]], ["n", 72, "comesFrom", ["n"], [22]], ["n", 201, "comesFrom", ["n"], [178]], ["n", 187, "comesFrom", ["n"], [178]], ["n", 31, "comesFrom", ["n"], [22]], ["n", 162, "comesFrom", ["n"], [22]], ["n", 350, "comesFrom", ["n"], [327]], ["n", 266, "comesFrom", ["n"], [178]], ["k", 36, "comesFrom", ["k"], [25]], ["k", 165, "comesFrom", ["k"], [25]], ["k", 87, "comesFrom", ["k"], [25]], ["k", 352, "comesFrom", ["k"], [322]], ["k", 268, "comesFrom", ["k"], [181]], ["j", 85, "comesFrom", ["j"], [81]], ["j", 89, "comesFrom", ["j"], [81]], ["j", 117, "comesFrom", ["j"], [81]], ["j", 148, "comesFrom", ["j"], [81]], ["l", 102, "comesFrom", ["l"], [96]], ["l", 107, "comesFrom", ["l"], [96]], ["l", 114, "comesFrom", ["l"], [96]], ["l", 132, "comesFrom", ["l"], [96]], ["mask", 139, "comesFrom", ["mask"], [11]], ["mask", 136, "comesFrom", ["mask"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define RODS  3 NEW_LINE #define N  3 NEW_LINE int dp [ N + 1 ] [ RODS + 1 ] [ RODS + 1 ] ; void initialize ( ) { for ( int i = 0 ; i <= N ; i += 1 ) { for ( int j = 1 ; j <= RODS ; j ++ ) { for ( int k = 1 ; k <= RODS ; k += 1 ) { dp [ i ] [ j ] [ k ] = INT_MAX ; } } } } int mincost ( int idx , int src , int dest , int costs [ RODS ] [ RODS ] ) { if ( idx > N ) return 0 ; if ( dp [ idx ] [ src ] [ dest ] != INT_MAX ) return dp [ idx ] [ src ] [ dest ] ; int rem = 6 - ( src + dest ) ; int ans = INT_MAX ; int case1 = costs [ src - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ; int case2 = costs [ src - 1 ] [ rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ; ans = min ( case1 , case2 ) ; dp [ idx ] [ src ] [ dest ] = ans ; return ans ; } int main ( ) { int costs [ RODS ] [ RODS ] = { { 0 , 1 , 2 } , { 2 , 0 , 1 } , { 3 , 2 , 0 } } ; initialize ( ) ; cout << mincost ( 1 , 1 , 3 , costs ) ; return 0 ; }", "docstring": "Cost Based Tower of Hanoi | C ++ implementation of the approach ; Function to initialize the dp table ; Initialize with maximum value ; Function to return the minimum cost ; Base case ; If problem is already solved , return the pre - calculated answer ; Number of the auxiliary disk ; Initialize the minimum cost as Infinity ; Calculationg the cost for first case ; Calculating the cost for second case ; Minimum of both the above cases ; Store it in the dp table ; Return the minimum cost ; Driver code", "dfg": []}
{"code": "#include <iostream> NEW_LINE using namespace std ; #define C  5 NEW_LINE #define R  3 NEW_LINE #define INT_MAX  10000000 NEW_LINE int table [ R ] [ C ] = { 0 } ; int visited [ R ] [ C ] = { 0 } ; int min ( int p , int q , int r , int s ) { int temp1 = p < q ? p : q ; int temp2 = r < s ? r : s ; if ( temp1 < temp2 ) return temp1 ; return temp2 ; } int Distance ( int arr [ R ] [ C ] , int i , int j ) { if ( i >= R j >= C i < 0 j < 0 ) return INT_MAX ; else if ( arr [ i ] [ j ] == 0 ) { table [ i ] [ j ] = INT_MAX ; return INT_MAX ; } else if ( arr [ i ] [ j ] == 2 ) { table [ i ] [ j ] = 0 ; return 0 ; } else if ( visited [ i ] [ j ] ) { return INT_MAX ; } else { visited [ i ] [ j ] = 1 ; int temp1 = Distance ( arr , i + 1 , j ) ; int temp2 = Distance ( arr , i - 1 , j ) ; int temp3 = Distance ( arr , i , j + 1 ) ; int temp4 = Distance ( arr , i , j - 1 ) ; int min_value = 1 + min ( temp1 , temp2 , temp3 , temp4 ) ; if ( table [ i ] [ j ] > 0 && table [ i ] [ j ] < INT_MAX ) { if ( min_value < table [ i ] [ j ] ) table [ i ] [ j ] = min_value ; } else table [ i ] [ j ] = min_value ; visited [ i ] [ j ] = 0 ; return table [ i ] [ j ] ; } } int minTime ( int arr [ ] [ C ] ) { int max = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 ) Distance ( arr , i , j ) ; } } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 && table [ i ] [ j ] > max ) max = table [ i ] [ j ] ; } } if ( max < INT_MAX ) return max ; return -1 ; } int main ( ) { int arr [ R ] [ C ] = { { 2 , 1 , 0 , 2 , 1 } , { 0 , 0 , 1 , 2 , 1 } , { 1 , 0 , 0 , 2 , 1 } } ; cout << minTime ( arr ) ; return 0 ; }", "docstring": "Minimum time required to rot all oranges | Dynamic Programming | C ++ implementation of the approach ; DP table to memoize the values ; Visited array to keep track of visited nodes in order to avoid infinite loops ; Function to return the minimum of four numbers ; Function to return the minimum distance to any rotten orange from [ i , j ] ; If i , j lie outside the array ; If 0 then it can 't lead to  any path so return INT_MAX ; If 2 then we have reached our rotten oranges so return from here ; If this node is already visited then return to avoid infinite loops ; Mark the current node as visited ; Check in all four possible directions ; Take the minimum of all ; If result already exists in the table check if min_value is less than existing value ; Function to return the minimum time required to rot all the oranges ; Calculate the minimum distances to any rotten orange from all the fresh oranges ; Pick the maximum distance of fresh orange to some rotten orange ; If all oranges can be rotten ; Driver Code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE #define maxLen  10 NEW_LINE using namespace std ; int dp [ maxLen ] ; bool visit [ maxLen ] ; int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = 1 ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < i + k and j < n ; j ++ ) { tot += arr [ j ] ; dp [ i ] = max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; } int main ( ) { int arr [ ] = { -1 , 2 , -3 , 4 , 5 } ; int k = 2 ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxSum ( arr , 0 , n , k ) ; return 0 ; }", "docstring": "Maximum sum of non | C ++ program to implement above approach ; Variable to store states of dp ; Variable to check if a given state has been solved ; Function to find the maximum sum subsequence such that no two elements are adjacent ; Base case ; To check if a state has been solved ; Variable to store prefix sum for sub - array { i , j } ; Required recurrence relation ; Returning the value ; Driver code ; Input array", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 1024 ] ; int get_binary ( int u ) { int ans = 0 ; while ( u ) { int rem = u % 10 ; ans |= ( 1 << rem ) ; u /= 10 ; } return ans ; } int recur ( int u , int array [ ] , int n ) { if ( u == 0 ) return 0 ; if ( dp [ u ] != -1 ) return dp [ u ] ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int mask = get_binary ( array [ i ] ) ; if ( ( mask u ) == u ) { dp [ u ] = max ( max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; } } return dp [ u ] ; } int solve ( int array [ ] , int n ) { for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { dp [ i ] = -1 ; } int ans = 0 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { ans = max ( ans , recur ( i , array , n ) ) ; } return ans ; } int main ( ) { int array [ ] = { 22 , 132 , 4 , 45 , 12 , 223 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << solve ( array , n ) ; }", "docstring": "Maximum subset sum such that no two elements in set have same digit in them | C ++ implementation of above approach ; Function to create mask for every number ; Recursion for Filling DP array ; Base Condition ; Recurrence Relation ; Function to find Maximum Subset Sum ; Initialize DP array ; Iterate over all possible masks of 10 bit number ; Driver Code", "dfg": [["ans", 51, "comesFrom", ["ans"], [37]], ["ans", 254, "comesFrom", ["ans"], [236]], ["ans", 240, "comesFrom", ["ans"], [236]], ["u", 27, "comesFrom", ["u"], [17]], ["u", 71, "comesFrom", ["u"], [58]], ["u", 169, "comesFrom", ["u"], [58]], ["u", 90, "comesFrom", ["u"], [58]], ["u", 33, "comesFrom", ["u"], [17]], ["u", 82, "comesFrom", ["u"], [58]], ["u", 131, "comesFrom", ["u"], [58]], ["u", 128, "comesFrom", ["u"], [58]], ["u", 136, "comesFrom", ["u"], [58]], ["u", 160, "comesFrom", ["u"], [58]], ["u", 147, "comesFrom", ["u"], [58]], ["i", 105, "comesFrom", ["i"], [101]], ["i", 109, "comesFrom", ["i"], [101]], ["i", 192, "comesFrom", ["i"], [188]], ["i", 200, "comesFrom", ["i"], [188]], ["i", 224, "comesFrom", ["i"], [220]], ["i", 232, "comesFrom", ["i"], [220]], ["i", 206, "comesFrom", ["i"], [188]], ["i", 120, "comesFrom", ["i"], [101]], ["i", 244, "comesFrom", ["i"], [220]], ["i", 155, "comesFrom", ["i"], [101]], ["n", 107, "comesFrom", ["n"], [66]], ["n", 303, "comesFrom", ["n"], [282]], ["n", 248, "comesFrom", ["n"], [182]], ["rem", 42, "comesFrom", ["rem"], [31]], ["mask", 127, "comesFrom", ["mask"], [114]], ["mask", 149, "comesFrom", ["mask"], [114]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  3 NEW_LINE const int N = 3 ; int minSum ( int A [ ] , int B [ ] , int C [ ] , int i , int n , int curr , int dp [ SIZE ] [ N ] ) { if ( n <= 0 ) return 0 ; if ( dp [ n ] [ curr ] != -1 ) return dp [ n ] [ curr ] ; if ( curr == 0 ) { return dp [ n ] [ curr ] = min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; } int main ( ) { int A [ ] = { 1 , 50 , 1 } ; int B [ ] = { 50 , 50 , 50 } ; int C [ ] = { 50 , 50 , 50 } ; int dp [ SIZE ] [ N ] ; for ( int i = 0 ; i < SIZE ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) dp [ i ] [ j ] = -1 ; cout << min ( A [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 0 , dp ) , min ( B [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 1 , dp ) , C [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 2 , dp ) ) ) ; return 0 ; }", "docstring": "Minimize the sum after choosing elements from the given three arrays | C ++ implementation of the above approach ; Function to return the minimized sum ; If all the indices have been used ; If this value is pre - calculated then return its value from dp array instead of re - computing it ; If A [ i - 1 ] was chosen previously then only B [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If B [ i - 1 ] was chosen previously then only A [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If C [ i - 1 ] was chosen previously then only A [ i ] or B [ i ] can chosen now choose the one which leads to the minimum sum ; Driver code ; Initialize the dp [ ] [ ] array ; min ( start with A [ 0 ] , start with B [ 0 ] , start with C [ 0 ] )", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  3 NEW_LINE int dp [ n ] [ n ] [ 2 ] ; bool v [ n ] [ n ] [ 2 ] ; int max ( int a , int b , int c ) { int m = a ; if ( m < b ) m = b ; if ( m < c ) m = c ; return m ; } int maxScore ( int arr [ ] [ n ] , int i , int j , int s ) { if ( i > n - 1 i < 0 j > n - 1 ) return 0 ; if ( i == 0 and j == n - 1 ) return arr [ i ] [ j ] ; if ( v [ i ] [ j ] [ s ] ) return dp [ i ] [ j ] [ s ] ; v [ i ] [ j ] [ s ] = 1 ; if ( ! s ) dp [ i ] [ j ] [ s ] = arr [ i ] [ j ] + max ( maxScore ( arr , i + 1 , j , s ) , maxScore ( arr , i , j + 1 , s ) , maxScore ( arr , i - 1 , j , ! s ) ) ; else dp [ i ] [ j ] [ s ] = arr [ i ] [ j ] + max ( maxScore ( arr , i - 1 , j , s ) , maxScore ( arr , i , j + 1 , s ) ) ; return dp [ i ] [ j ] [ s ] ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 1 , 1 } , { 1 , 5 , 1 } , { 1 , 1 , 1 } } ; cout << maxScore ( arr , 0 , 0 , 0 ) ; return 0 ; }", "docstring": "Maximise matrix sum by following the given Path | C ++ implementation of the approach ; To store the states of the DP ; Function to return the maximum of the three integers ; Function to return the maximum score ; Base cases ; If the state has already been solved then return it ; Marking the state as solved ; Growing phase ; Shrinking phase ; Returning the solved state ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumMarks ( int marksarr [ ] , int timearr [ ] , int h , int n , int p ) { int no_of_topics = n + 1 ; int total_time = h + 1 ; int T [ no_of_topics ] [ total_time ] ; for ( int i = 0 ; i < no_of_topics ; i ++ ) { T [ i ] [ 0 ] = 0 ; } for ( int j = 0 ; j < total_time ; j ++ ) { T [ 0 ] [ j ] = 0 ; } for ( int i = 1 ; i < no_of_topics ; i ++ ) { for ( int j = 1 ; j < total_time ; j ++ ) { if ( j < timearr [ i ] ) { T [ i ] [ j ] = T [ i - 1 ] [ j ] ; } else { T [ i ] [ j ] = max ( marksarr [ i ] + T [ i - 1 ] [ j - timearr [ i ] ] , T [ i - 1 ] [ j ] ) ; } } } int i = no_of_topics - 1 , j = total_time - 1 ; int sum = 0 ; while ( i > 0 && j > 0 ) { if ( T [ i ] [ j ] == T [ i - 1 ] [ j ] ) { i -- ; } else { sum += timearr [ i ] ; j -= timearr [ i ] ; i -- ; } } int marks = T [ no_of_topics - 1 ] [ total_time - 1 ] ; if ( marks < p ) return -1 ; return sum ; } int main ( ) { int n = 4 , h = 10 , p = 10 ; int marksarr [ n + 1 ] = { 0 , 6 , 4 , 2 , 8 } ; int timearr [ n + 1 ] = { 0 , 4 , 6 , 2 , 7 } ; cout << MaximumMarks ( marksarr , timearr , h , n , p ) ; return 0 ; }", "docstring": "Find maximum topics to prepare in order to pass the exam | C ++ implementation of the approach ; Function to return the maximum marks by considering topics which can be completed in the given time duration ; If we are given 0 time then nothing can be done So all values are 0 ; If we are given 0 topics then the time required will be 0 for sure ; Calculating the maximum marks that can be achieved under the given time constraints ; If time taken to read that topic is more than the time left now at position j then do no read that topic ; Two cases arise : 1 ) Considering current topic 2 ) Ignoring current topic We are finding maximum of ( current topic weightage + topics which can be done in leftover time - current topic time ) and ignoring current topic weightage sum ; Moving upwards in table from bottom right to calculate the total time taken to read the topics which can be done in given time and have highest weightage sum ; It means we have not considered reading this topic for max weightage sum ; Adding the topic time ; Evaluating the left over time after considering this current topic ; One topic completed ; It contains the maximum weightage sum formed by considering the topics ; Condition when exam cannot be passed ; Return the marks that can be obtained after passing the exam ; Driver code ; Number of topics , hours left and the passing marks ; n + 1 is taken for simplicity in loops Array will be indexed starting from 1", "dfg": [["sum", 310, "comesFrom", ["sum"], [266]], ["total_time", 50, "comesFrom", ["total_time"], [38]], ["total_time", 88, "comesFrom", ["total_time"], [38]], ["total_time", 219, "comesFrom", ["total_time"], [38]], ["total_time", 129, "comesFrom", ["total_time"], [38]], ["total_time", 295, "comesFrom", ["total_time"], [38]], ["i", 60, "comesFrom", ["i"], [56]], ["i", 64, "comesFrom", ["i"], [56]], ["i", 112, "comesFrom", ["i"], [108]], ["i", 116, "comesFrom", ["i"], [108]], ["i", 230, "comesFrom", ["i"], [211]], ["i", 260, "comesFrom", ["i"], [211]], ["i", 70, "comesFrom", ["i"], [56]], ["i", 280, "comesFrom", ["i"], [211]], ["i", 243, "comesFrom", ["i"], [211]], ["i", 141, "comesFrom", ["i"], [108]], ["i", 251, "comesFrom", ["i"], [211]], ["i", 270, "comesFrom", ["i"], [211]], ["i", 277, "comesFrom", ["i"], [211]], ["i", 147, "comesFrom", ["i"], [108]], ["i", 155, "comesFrom", ["i"], [108]], ["i", 168, "comesFrom", ["i"], [108]], ["i", 178, "comesFrom", ["i"], [108]], ["i", 198, "comesFrom", ["i"], [108]], ["i", 183, "comesFrom", ["i"], [108]], ["i", 192, "comesFrom", ["i"], [108]], ["no_of_topics", 62, "comesFrom", ["no_of_topics"], [31]], ["no_of_topics", 114, "comesFrom", ["no_of_topics"], [31]], ["no_of_topics", 47, "comesFrom", ["no_of_topics"], [31]], ["no_of_topics", 213, "comesFrom", ["no_of_topics"], [31]], ["no_of_topics", 290, "comesFrom", ["no_of_topics"], [31]], ["j", 86, "comesFrom", ["j"], [82]], ["j", 90, "comesFrom", ["j"], [82]], ["j", 127, "comesFrom", ["j"], [123]], ["j", 131, "comesFrom", ["j"], [123]], ["j", 234, "comesFrom", ["j"], [217]], ["j", 99, "comesFrom", ["j"], [82]], ["j", 137, "comesFrom", ["j"], [123]], ["j", 246, "comesFrom", ["j"], [217]], ["j", 256, "comesFrom", ["j"], [217]], ["j", 150, "comesFrom", ["j"], [123]], ["j", 160, "comesFrom", ["j"], [123]], ["j", 171, "comesFrom", ["j"], [123]], ["j", 203, "comesFrom", ["j"], [123]], ["j", 188, "comesFrom", ["j"], [123]], ["n", 33, "comesFrom", ["n"], [24]], ["n", 334, "comesFrom", ["n"], [319]], ["n", 354, "comesFrom", ["n"], [319]], ["n", 381, "comesFrom", ["n"], [319]], ["h", 40, "comesFrom", ["h"], [21]], ["h", 379, "comesFrom", ["h"], [323]], ["marks", 302, "comesFrom", ["marks"], [286]], ["p", 304, "comesFrom", ["p"], [27]], ["p", 383, "comesFrom", ["p"], [327]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define maxLen  10 NEW_LINE #define maskLen  130 NEW_LINE using namespace std ; int dp [ maxLen ] [ maskLen ] ; bool v [ maxLen ] [ maskLen ] ; int minSteps ( int arr [ ] , int i , int mask , int n ) { if ( i == n - 1 ) return 0 ; if ( i > n - 1 i < 0 ) return 9999999 ; if ( ( mask >> i ) & 1 ) return 9999999 ; if ( v [ i ] [ mask ] ) return dp [ i ] [ mask ] ; v [ i ] [ mask ] = 1 ; dp [ i ] [ mask ] = 1 + min ( minSteps ( arr , i - arr [ i ] , ( mask | ( 1 << i ) ) , n ) , minSteps ( arr , i + arr [ i ] , ( mask | ( 1 << i ) ) , n ) ) ; return dp [ i ] [ mask ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 2 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int ans = minSteps ( arr , 0 , 0 , n ) ; if ( ans >= 9999999 ) cout << -1 ; else cout << ans ; }", "docstring": "Minimize the number of steps required to reach the end of the array | C ++ implementation of the above approach ; variable to store states of dp ; variable to check if a given state has been solved ; Function to find the minimum number of steps required to reach the end of the array ; base case ; to check if a state has been solved ; required recurrence relation ; returning the value ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int oSRec ( int arr [ ] , int i , int j , int sum ) { if ( j == i + 1 ) return max ( arr [ i ] , arr [ j ] ) ; return max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; } int optimalStrategyOfGame ( int * arr , int n ) { int sum = 0 ; sum = accumulate ( arr , arr + n , sum ) ; return oSRec ( arr , 0 , n - 1 , sum ) ; } int main ( ) { int arr1 [ ] = { 8 , 15 , 3 , 7 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; printf ( \" % d STRNEWLINE \" , optimalStrategyOfGame ( arr1 , n ) ) ; int arr2 [ ] = { 2 , 2 , 2 , 2 } ; n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printf ( \" % d STRNEWLINE \" , optimalStrategyOfGame ( arr2 , n ) ) ; int arr3 [ ] = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; printf ( \" % d STRNEWLINE \" , optimalStrategyOfGame ( arr3 , n ) ) ; return 0 ; }", "docstring": "Optimal Strategy for a Game | Set 2 | C ++ program to find out maximum value from a given sequence of coins ; For both of your choices , the opponent gives you total sum minus maximum of his value ; Returns optimal value possible that a player can collect from an array of coins of size n . Note than n must be even ; Driver program to test above function", "dfg": [["j", 27, "comesFrom", ["j"], [19]], ["j", 43, "comesFrom", ["j"], [19]], ["j", 61, "comesFrom", ["j"], [19]], ["j", 81, "comesFrom", ["j"], [19]], ["j", 89, "comesFrom", ["j"], [19]], ["sum", 136, "comesFrom", ["sum"], [112]], ["sum", 122, "comesFrom", ["sum"], [112]], ["sum", 51, "comesFrom", ["sum"], [22]], ["sum", 73, "comesFrom", ["sum"], [22]], ["sum", 63, "comesFrom", ["sum"], [22]], ["sum", 85, "comesFrom", ["sum"], [22]], ["i", 29, "comesFrom", ["i"], [16]], ["i", 38, "comesFrom", ["i"], [16]], ["i", 79, "comesFrom", ["i"], [16]], ["i", 57, "comesFrom", ["i"], [16]], ["i", 67, "comesFrom", ["i"], [16]], ["n", 132, "comesFrom", ["n"], [104]], ["n", 120, "comesFrom", ["n"], [104]], ["n", 186, "comesFrom", ["n"], [161]], ["n", 230, "comesFrom", ["n"], [205]], ["n", 278, "comesFrom", ["n"], [253]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  unsigned long long NEW_LINE bool ispower ( ll n ) { if ( n < 125 ) return ( n == 1 n == 5 n == 25 ) ; if ( n % 125 != 0 ) return false ; else return ispower ( n / 125 ) ; } ll number ( string s , int i , int j ) { ll ans = 0 ; for ( int x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s [ x ] - '0' ) ; } return ans ; } int minCuts ( string s , int n ) { int dp [ n + 1 ] ; memset ( dp , n + 1 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( s [ i - 1 ] == '0' ) continue ; for ( int j = 0 ; j < i ; j ++ ) { if ( s [ j ] == '0' ) continue ; ll num = number ( s , j , i ) ; if ( ! ispower ( num ) ) continue ; dp [ i ] = min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : -1 ) ; } int main ( ) { string s = \"101101101\" ; int n = s . length ( ) ; cout << minCuts ( s , n ) ; return 0 ; }", "docstring": "Minimum number of sub | C ++ implementation of the approach ; Function that returns true if n is a power of 5 ; Function to return the decimal value of binary equivalent ; Function to return the minimum cuts required ; Allocating memory for dp [ ] array ; From length 1 to n ; If previous character is '0' then ignore to avoid number with leading 0 s . ; Ignore s [ j ] = '0' starting numbers ; Number formed from s [ j ... . i ] ; Check for power of 5 ; Assigning min value to get min cut possible ; ( n + 1 ) to check if all the strings are traversed and no divisible by 5 is obtained like 000000 ; Driver code", "dfg": []}
{"code": "#include <iostream> NEW_LINE using namespace std ; int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; } int main ( ) { int num = 15 ; cout << MinOfCubed ( num ) ; return 0 ; }", "docstring": "Minimum number of cubes whose sum equals to given number N | C ++ implementation of the approach ; Function to return the minimum number of cubes whose sum is k ; If k is less than the 2 ^ 3 ; Initialize with the maximum number of cubes required ; Driver code", "dfg": [["res", 82, "comesFrom", ["res"], [58]], ["res", 56, "comesFrom", ["res"], [24]], ["res", 62, "comesFrom", ["res"], [58]], ["k", 21, "comesFrom", ["k"], [11]], ["k", 37, "comesFrom", ["k"], [26]], ["k", 16, "comesFrom", ["k"], [11]], ["k", 53, "comesFrom", ["k"], [26]], ["k", 66, "comesFrom", ["k"], [26]], ["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 50, "comesFrom", ["i"], [31]], ["i", 46, "comesFrom", ["i"], [31]], ["i", 48, "comesFrom", ["i"], [31]], ["i", 73, "comesFrom", ["i"], [31]], ["i", 69, "comesFrom", ["i"], [31]], ["i", 71, "comesFrom", ["i"], [31]], ["num", 99, "comesFrom", ["num"], [91]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOfCubedDP ( int k ) { int * DP = new int [ k + 1 ] , j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = INT_MAX ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; } int main ( ) { int num = 15 ; cout << MinOfCubedDP ( num ) ; return 0 ; }", "docstring": "Minimum number of cubes whose sum equals to given number N | C ++ implementation of the approach ; Function to return the minimum number of cubes whose sum is k ; While current perfect cube is less than current element ; If i is a perfect cube ; i = ( i - 1 ) + 1 ^ 3 ; Next perfect cube ; Re - initialization for next element ; Driver code", "dfg": [["i", 48, "comesFrom", ["i"], [44]], ["i", 52, "comesFrom", ["i"], [44]], ["i", 67, "comesFrom", ["i"], [44]], ["i", 58, "comesFrom", ["i"], [44]], ["i", 74, "comesFrom", ["i"], [44]], ["i", 78, "comesFrom", ["i"], [44]], ["i", 88, "comesFrom", ["i"], [44]], ["i", 100, "comesFrom", ["i"], [44]], ["i", 93, "comesFrom", ["i"], [44]], ["i", 105, "comesFrom", ["i"], [44]], ["k", 50, "comesFrom", ["k"], [11]], ["k", 134, "comesFrom", ["k"], [11]], ["k", 21, "comesFrom", ["k"], [11]], ["num", 152, "comesFrom", ["num"], [144]], ["j", 65, "comesFrom", ["j"], [26]], ["j", 72, "comesFrom", ["j"], [26]], ["j", 95, "comesFrom", ["j"], [26]], ["j", 107, "comesFrom", ["j"], [26]], ["t", 112, "comesFrom", ["t"], [30]], ["t", 121, "comesFrom", ["t"], [30]], ["t", 117, "comesFrom", ["t"], [30]], ["t", 119, "comesFrom", ["t"], [30]]]}
{"code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int maxSum ( int a [ ] , int n ) { int ans = 0 ; int * arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int * * dp = new int * [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = new int [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = max ( ans , dp [ i ] [ 0 ] ) ; ans = max ( ans , dp [ i ] [ 1 ] ) ; ans = max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; } int main ( ) { int arr [ ] = { -5 , 3 , 2 , 7 , -8 , 3 , 7 , -9 , 10 , 12 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) ; return 0 ; }", "docstring": "Maximum Subarray Sum after inverting at most two elements | C ++ implementation of the approach ; Function to return the maximum required sub - array sum ; Creating one based indexing ; 2d array to contain solution for each step ; Case 1 : Choosing current or ( current + previous ) whichever is smaller ; Case 2 : ( a ) Altering sign and add to previous case 1 or value 0 ; Case 2 : ( b ) Adding current element with previous case 2 and updating the maximum ; Case 3 : ( a ) Altering sign and add to previous case 2 ; Case 3 : ( b ) Adding current element with previous case 3 ; Updating the maximum value of variable ans ; Return the final solution ; Driver code", "dfg": [["ans", 334, "comesFrom", ["ans"], [317]], ["ans", 291, "comesFrom", ["ans"], [287]], ["ans", 306, "comesFrom", ["ans"], [302]], ["ans", 321, "comesFrom", ["ans"], [317]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 86, "comesFrom", ["i"], [82]], ["i", 90, "comesFrom", ["i"], [82]], ["i", 111, "comesFrom", ["i"], [107]], ["i", 116, "comesFrom", ["i"], [107]], ["i", 55, "comesFrom", ["i"], [42]], ["i", 95, "comesFrom", ["i"], [82]], ["i", 180, "comesFrom", ["i"], [107]], ["i", 220, "comesFrom", ["i"], [107]], ["i", 249, "comesFrom", ["i"], [107]], ["i", 60, "comesFrom", ["i"], [42]], ["i", 121, "comesFrom", ["i"], [107]], ["i", 152, "comesFrom", ["i"], [107]], ["i", 175, "comesFrom", ["i"], [107]], ["i", 131, "comesFrom", ["i"], [107]], ["i", 186, "comesFrom", ["i"], [107]], ["i", 226, "comesFrom", ["i"], [107]], ["i", 244, "comesFrom", ["i"], [107]], ["i", 255, "comesFrom", ["i"], [107]], ["i", 146, "comesFrom", ["i"], [107]], ["i", 295, "comesFrom", ["i"], [107]], ["i", 310, "comesFrom", ["i"], [107]], ["i", 325, "comesFrom", ["i"], [107]], ["i", 196, "comesFrom", ["i"], [107]], ["i", 214, "comesFrom", ["i"], [107]], ["i", 234, "comesFrom", ["i"], [107]], ["i", 265, "comesFrom", ["i"], [107]], ["i", 283, "comesFrom", ["i"], [107]], ["i", 136, "comesFrom", ["i"], [107]], ["i", 164, "comesFrom", ["i"], [107]], ["i", 204, "comesFrom", ["i"], [107]], ["i", 273, "comesFrom", ["i"], [107]], ["n", 48, "comesFrom", ["n"], [19]], ["n", 88, "comesFrom", ["n"], [19]], ["n", 113, "comesFrom", ["n"], [19]], ["n", 74, "comesFrom", ["n"], [19]], ["n", 393, "comesFrom", ["n"], [372]], ["n", 34, "comesFrom", ["n"], [19]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int * arr , int k , int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return max ( arr [ 0 ] , arr [ 1 ] ) ; int dp [ n ] ; dp [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] = max ( arr [ i ] , dp [ i - 1 ] ) ; for ( int i = k + 1 ; i < n ; i ++ ) dp [ i ] = max ( arr [ i ] , dp [ i - ( k + 1 ) ] + arr [ i ] ) ; int max = * ( std :: max_element ( dp , dp + n ) ) ; return max ; } int main ( ) { int arr [ ] = { 6 , 7 , 1 , 3 , 8 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << maxSum ( arr , k , n ) ; return 0 ; }", "docstring": "Maximum sum possible for a sub | C ++ implementation of the approach ; Function to return the maximum sum possible ; dp [ i ] represent the maximum sum so far after reaching current position i ; Initialize dp [ 0 ] ; Initialize the dp values till k since any two elements included in the sub - sequence must be atleast k indices apart , and thus first element and second element will be k indices apart ; Fill remaining positions ; Return the maximum sum ; Driver code", "dfg": [["max", 175, "comesFrom", ["max"], [158]], ["n", 65, "comesFrom", ["n"], [18]], ["n", 123, "comesFrom", ["n"], [18]], ["n", 23, "comesFrom", ["n"], [18]], ["n", 32, "comesFrom", ["n"], [18]], ["n", 44, "comesFrom", ["n"], [18]], ["n", 233, "comesFrom", ["n"], [205]], ["n", 170, "comesFrom", ["n"], [18]], ["i", 85, "comesFrom", ["i"], [81]], ["i", 89, "comesFrom", ["i"], [81]], ["i", 121, "comesFrom", ["i"], [115]], ["i", 125, "comesFrom", ["i"], [115]], ["i", 94, "comesFrom", ["i"], [81]], ["i", 130, "comesFrom", ["i"], [115]], ["i", 101, "comesFrom", ["i"], [81]], ["i", 137, "comesFrom", ["i"], [115]], ["i", 106, "comesFrom", ["i"], [81]], ["i", 153, "comesFrom", ["i"], [115]], ["i", 142, "comesFrom", ["i"], [115]], ["k", 87, "comesFrom", ["k"], [15]], ["k", 117, "comesFrom", ["k"], [15]], ["k", 231, "comesFrom", ["k"], [221]], ["k", 145, "comesFrom", ["k"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumCost ( int a [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ; while ( x ) { if ( x & 1 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; } int main ( ) { int a [ ] = { 20 , 50 , 60 , 90 } ; int x = 7 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinimumCost ( a , n , x ) ; return 0 ; }", "docstring": "Minimum cost to form a number X by adding up powers of 2 | C ++ implementation of the approach ; Function to return the minimum cost ; Re - compute the array ; Add answers for set bits ; If bit is set ; Increase the counter ; Right shift the number ; Driver code", "dfg": [["sum", 99, "comesFrom", ["sum"], [81]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 39, "comesFrom", ["i"], [25]], ["i", 46, "comesFrom", ["i"], [25]], ["i", 53, "comesFrom", ["i"], [25]], ["n", 31, "comesFrom", ["n"], [16]], ["n", 149, "comesFrom", ["n"], [128]], ["x", 72, "comesFrom", ["x"], [19]], ["x", 151, "comesFrom", ["x"], [123]], ["x", 77, "comesFrom", ["x"], [19]], ["x", 93, "comesFrom", ["x"], [91]], ["ind", 88, "comesFrom", ["ind"], [61]], ["ind", 85, "comesFrom", ["ind"], [61]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n , int l , int r ) { int tL = l , tR = r ; int L [ 2 ] = { 0 } , R [ 2 ] = { 0 } ; L [ l % 2 ] = l , R [ r % 2 ] = r ; l ++ , r -- ; if ( l <= tR && r >= tL ) L [ l % 2 ] = l , R [ r % 2 ] = r ; int cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] && L [ 0 ] ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] && L [ 1 ] ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; int dp [ n ] [ 2 ] ; dp [ 1 ] [ 0 ] = cnt0 ; dp [ 1 ] [ 1 ] = cnt1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) ; } return dp [ n ] [ 0 ] ; } int main ( ) { int n = 2 , l = 1 , r = 3 ; cout << countWays ( n , l , r ) ; return 0 ; }", "docstring": "Ways to form an array having integers in given range such that total sum is divisible by 2 | C ++ implementation of the approach ; Function to return the number of ways to form an array of size n such that sum of all elements is divisible by 2 ; Represents first and last numbers of each type ( modulo 0 and 1 ) ; Count of numbers of each type between range ; Base Cases ; Ways to form array whose sum upto i numbers modulo 2 is 0 ; Ways to form array whose sum upto i numbers modulo 2 is 1 ; Return the required count of ways ; Driver Code", "dfg": [["cnt0", 186, "comesFrom", ["cnt0"], [121]], ["cnt0", 222, "comesFrom", ["cnt0"], [121]], ["cnt0", 256, "comesFrom", ["cnt0"], [121]], ["cnt1", 196, "comesFrom", ["cnt1"], [151]], ["cnt1", 234, "comesFrom", ["cnt1"], [151]], ["cnt1", 268, "comesFrom", ["cnt1"], [151]], ["i", 205, "comesFrom", ["i"], [201]], ["i", 209, "comesFrom", ["i"], [201]], ["i", 215, "comesFrom", ["i"], [201]], ["i", 249, "comesFrom", ["i"], [201]], ["i", 226, "comesFrom", ["i"], [201]], ["i", 238, "comesFrom", ["i"], [201]], ["i", 260, "comesFrom", ["i"], [201]], ["i", 272, "comesFrom", ["i"], [201]], ["n", 207, "comesFrom", ["n"], [11]], ["n", 172, "comesFrom", ["n"], [11]], ["n", 285, "comesFrom", ["n"], [11]], ["n", 314, "comesFrom", ["n"], [298]], ["l", 55, "comesFrom", ["l"], [23]], ["l", 66, "comesFrom", ["l"], [23]], ["l", 74, "comesFrom", ["l"], [23]], ["l", 89, "comesFrom", ["l"], [23]], ["l", 316, "comesFrom", ["l"], [302]], ["l", 50, "comesFrom", ["l"], [23]], ["l", 84, "comesFrom", ["l"], [23]], ["r", 64, "comesFrom", ["r"], [27]], ["r", 69, "comesFrom", ["r"], [27]], ["r", 78, "comesFrom", ["r"], [27]], ["r", 98, "comesFrom", ["r"], [27]], ["r", 318, "comesFrom", ["r"], [306]], ["r", 59, "comesFrom", ["r"], [27]], ["r", 93, "comesFrom", ["r"], [27]], ["tR", 76, "comesFrom", ["tR"], [25]], ["tL", 80, "comesFrom", ["tL"], [21]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 1001 ; const int MOD = 998244353 ; int dp [ M ] [ M ] ; int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != -1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; } int main ( ) { int N = 3 , M = 3 , K = 0 ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << ( M * solve ( 2 , 0 , N , M , K ) ) << endl ; return 0 ; }", "docstring": "Color N boxes using M colors such that K boxes have different color from the box on its left | CPP Program to Paint N boxes using M colors such that K boxes have color different from color of box on its left ; This function returns the required number of ways where idx is the current index and diff is number of boxes having different color from box on its left ; Base Case ; If already computed ; Either paint with same color as previous one ; Or paint with remaining ( M - 1 ) colors ; Driver code ; Multiply M since first box can be painted with any of the M colors and start solving from 2 nd box", "dfg": [["M", 25, "comesFrom", ["M"], [9]], ["M", 22, "comesFrom", ["M"], [9]], ["M", 101, "comesFrom", ["M"], [41]], ["M", 109, "comesFrom", ["M"], [41]], ["M", 126, "comesFrom", ["M"], [41]], ["M", 178, "comesFrom", ["M"], [155]], ["M", 188, "comesFrom", ["M"], [155]], ["idx", 49, "comesFrom", ["idx"], [32]], ["idx", 82, "comesFrom", ["idx"], [32]], ["idx", 93, "comesFrom", ["idx"], [32]], ["idx", 134, "comesFrom", ["idx"], [32]], ["idx", 71, "comesFrom", ["idx"], [32]], ["idx", 116, "comesFrom", ["idx"], [32]], ["N", 51, "comesFrom", ["N"], [38]], ["N", 99, "comesFrom", ["N"], [38]], ["N", 124, "comesFrom", ["N"], [38]], ["N", 186, "comesFrom", ["N"], [151]], ["ans", 140, "comesFrom", ["ans"], [106]], ["MOD", 142, "comesFrom", ["MOD"], [15]], ["diff", 85, "comesFrom", ["diff"], [35]], ["diff", 97, "comesFrom", ["diff"], [35]], ["diff", 137, "comesFrom", ["diff"], [35]], ["diff", 56, "comesFrom", ["diff"], [35]], ["diff", 74, "comesFrom", ["diff"], [35]], ["diff", 120, "comesFrom", ["diff"], [35]], ["K", 103, "comesFrom", ["K"], [44]], ["K", 58, "comesFrom", ["K"], [44]], ["K", 128, "comesFrom", ["K"], [44]], ["K", 190, "comesFrom", ["K"], [159]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE int maxPathSum ( int tri [ ] [ N ] ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = max ( ans , tri [ i ] [ j ] ) ; } } return ans ; } int main ( ) { int tri [ N ] [ N ] = { { 1 , 5 , 3 } , { 4 , 8 , 0 } , { 1 , 0 , 0 } } ; cout << maxPathSum ( tri ) ; return 0 ; }", "docstring": "Maximum path sum in an Inverted triangle | SET 2 | C ++ program implementation of Max sum problem in a triangle ; Function for finding maximum sum ; Loop for bottom - up calculation ; For each element , check both elements just below the number and below left to the number add the maximum of them to it ; Return the maximum sum ; Driver Code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int subsetXOR ( int arr [ ] , int n , int K ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( log2 ( max_ele ) + 1 ) ) - 1 ; int dp [ n + 1 ] [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) dp [ i ] [ j ] [ k ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( k != 0 ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int k = 1 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subsetXOR ( arr , n , k ) ; return 0 ; }", "docstring": "Count no . of ordered subsets having a particular XOR value | C ++ implementation of the approach ; Returns count of ordered subsets of arr [ ] with XOR value = K ; Find maximum element in arr [ ] ; Maximum possible XOR value ; The value of dp [ i ] [ j ] [ k ] is the number of subsets of length k having XOR of their elements as j from the set arr [ 0. . . i - 1 ] ; Initializing all the values of dp [ i ] [ j ] [ k ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subsets of all lengths from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver program to test above function", "dfg": [["ans", 331, "comesFrom", ["ans"], [316]], ["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 106, "comesFrom", ["i"], [102]], ["i", 110, "comesFrom", ["i"], [102]], ["i", 161, "comesFrom", ["i"], [157]], ["i", 165, "comesFrom", ["i"], [157]], ["i", 188, "comesFrom", ["i"], [184]], ["i", 192, "comesFrom", ["i"], [184]], ["i", 308, "comesFrom", ["i"], [304]], ["i", 312, "comesFrom", ["i"], [304]], ["i", 48, "comesFrom", ["i"], [33]], ["i", 57, "comesFrom", ["i"], [33]], ["i", 326, "comesFrom", ["i"], [304]], ["i", 170, "comesFrom", ["i"], [157]], ["i", 143, "comesFrom", ["i"], [102]], ["i", 228, "comesFrom", ["i"], [184]], ["i", 239, "comesFrom", ["i"], [184]], ["i", 259, "comesFrom", ["i"], [184]], ["i", 272, "comesFrom", ["i"], [184]], ["i", 281, "comesFrom", ["i"], [184]], ["n", 39, "comesFrom", ["n"], [16]], ["n", 108, "comesFrom", ["n"], [16]], ["n", 163, "comesFrom", ["n"], [16]], ["n", 190, "comesFrom", ["n"], [16]], ["n", 310, "comesFrom", ["n"], [16]], ["n", 94, "comesFrom", ["n"], [16]], ["n", 136, "comesFrom", ["n"], [16]], ["n", 379, "comesFrom", ["n"], [358]], ["n", 84, "comesFrom", ["n"], [16]], ["n", 220, "comesFrom", ["n"], [16]], ["n", 320, "comesFrom", ["n"], [16]], ["j", 120, "comesFrom", ["j"], [116]], ["j", 124, "comesFrom", ["j"], [116]], ["j", 203, "comesFrom", ["j"], [199]], ["j", 207, "comesFrom", ["j"], [199]], ["j", 146, "comesFrom", ["j"], [116]], ["j", 231, "comesFrom", ["j"], [199]], ["j", 244, "comesFrom", ["j"], [199]], ["j", 262, "comesFrom", ["j"], [199]], ["j", 277, "comesFrom", ["j"], [199]], ["m", 122, "comesFrom", ["m"], [61]], ["m", 89, "comesFrom", ["m"], [61]], ["m", 205, "comesFrom", ["m"], [61]], ["max_ele", 51, "comesFrom", ["max_ele"], [23]], ["max_ele", 72, "comesFrom", ["max_ele"], [53]], ["k", 134, "comesFrom", ["k"], [130]], ["k", 138, "comesFrom", ["k"], [130]], ["k", 381, "comesFrom", ["k"], [353]], ["k", 218, "comesFrom", ["k"], [214]], ["k", 222, "comesFrom", ["k"], [214]], ["k", 149, "comesFrom", ["k"], [130]], ["k", 252, "comesFrom", ["k"], [214]], ["k", 234, "comesFrom", ["k"], [214]], ["k", 247, "comesFrom", ["k"], [214]], ["k", 268, "comesFrom", ["k"], [214]], ["k", 265, "comesFrom", ["k"], [214]], ["k", 287, "comesFrom", ["k"], [214]], ["K", 323, "comesFrom", ["K"], [19]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int get_max_splits ( string num_string ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_string . length ( ) ; i ++ ) { current_num = num_string [ i ] - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; } int main ( ) { cout << get_max_splits ( \"12345\" ) << endl ; return 0 ; }", "docstring": "Possible cuts of a number such that maximum parts are divisible by 3 | C ++ program to find the maximum number of numbers divisible by 3 in large number ; This will contain the count of the splits ; This will keep sum of all successive integers , when they are indivisible by 3 ; This is the condition of finding a split ; Driver code", "dfg": [["count", 92, "comesFrom", ["count"], [81]], ["i", 33, "comesFrom", ["i"], [29]], ["i", 41, "comesFrom", ["i"], [29]], ["i", 49, "comesFrom", ["i"], [29]], ["num_string", 35, "comesFrom", ["num_string"], [11]], ["num_string", 47, "comesFrom", ["num_string"], [11]], ["current_num", 58, "comesFrom", ["current_num"], [45]], ["current_num", 62, "comesFrom", ["current_num"], [45]], ["running_sum", 69, "comesFrom", ["running_sum"], [56]], ["running_sum", 73, "comesFrom", ["running_sum"], [56]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 20 ; int dp [ M ] [ M ] [ 2 ] [ 2 ] ; int d , K ; int count ( int pos , int cnt , int tight , int nonz , vector < int > num ) { if ( pos == num . size ( ) ) { if ( cnt == K ) return 1 ; return 0 ; } if ( dp [ pos ] [ cnt ] [ tight ] [ nonz ] != -1 ) return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; int ans = 0 ; int limit = ( tight ? 9 : num [ pos ] ) ; for ( int dig = 0 ; dig <= limit ; dig ++ ) { int currCnt = cnt ; if ( dig == d ) { if ( d != 0 || ( ! d && nonz ) ) currCnt ++ ; } int currTight = tight ; if ( dig < num [ pos ] ) currTight = 1 ; ans += count ( pos + 1 , currCnt , currTight , nonz || ( dig != 0 ) , num ) ; } return dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans ; } int solve ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return count ( 0 , 0 , 0 , 0 , num ) ; } int main ( ) { int L = 11 , R = 100 ; d = 2 , K = 1 ; cout << solve ( R ) - solve ( L - 1 ) << endl ; return 0 ; }", "docstring": "Count of Numbers in a Range where digit d occurs exactly K times | CPP Program to find the count of numbers in a range where digit d occurs exactly K times ; states - position , count , tight , nonz ; d is required digit and K is occurrence ; This function returns the count of required numbers from 0 to num ; Last position ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; Nonz is true if we placed a non zero digit at the starting of the number ; At this position , number becomes smaller ; Next recursive call , also set nonz to 1 if current digit is non zero ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Initialize dp ; Driver Code to test above functions", "dfg": [["M", 19, "comesFrom", ["M"], [9]], ["M", 16, "comesFrom", ["M"], [9]], ["dig", 138, "comesFrom", ["dig"], [134]], ["dig", 142, "comesFrom", ["dig"], [134]], ["dig", 153, "comesFrom", ["dig"], [134]], ["dig", 182, "comesFrom", ["dig"], [134]], ["dig", 208, "comesFrom", ["dig"], [134]], ["limit", 140, "comesFrom", ["limit"], [118]], ["ans", 232, "comesFrom", ["ans"], [193]], ["x", 250, "comesFrom", ["x"], [239]], ["x", 257, "comesFrom", ["x"], [239]], ["pos", 57, "comesFrom", ["pos"], [37]], ["pos", 127, "comesFrom", ["pos"], [37]], ["pos", 100, "comesFrom", ["pos"], [37]], ["pos", 186, "comesFrom", ["pos"], [37]], ["pos", 197, "comesFrom", ["pos"], [37]], ["pos", 220, "comesFrom", ["pos"], [37]], ["pos", 83, "comesFrom", ["pos"], [37]], ["num", 305, "comesFrom", ["num"], [246]], ["num", 59, "comesFrom", ["num"], [52]], ["num", 125, "comesFrom", ["num"], [52]], ["num", 253, "comesFrom", ["num"], [246]], ["num", 269, "comesFrom", ["num"], [246]], ["num", 275, "comesFrom", ["num"], [246]], ["num", 184, "comesFrom", ["num"], [52]], ["num", 213, "comesFrom", ["num"], [52]], ["nonz", 109, "comesFrom", ["nonz"], [46]], ["nonz", 229, "comesFrom", ["nonz"], [46]], ["nonz", 92, "comesFrom", ["nonz"], [46]], ["nonz", 205, "comesFrom", ["nonz"], [46]], ["nonz", 168, "comesFrom", ["nonz"], [46]], ["tight", 121, "comesFrom", ["tight"], [43]], ["tight", 106, "comesFrom", ["tight"], [43]], ["tight", 226, "comesFrom", ["tight"], [178]], ["tight", 89, "comesFrom", ["tight"], [43]], ["cnt", 68, "comesFrom", ["cnt"], [40]], ["cnt", 103, "comesFrom", ["cnt"], [40]], ["cnt", 223, "comesFrom", ["cnt"], [149]], ["cnt", 86, "comesFrom", ["cnt"], [40]], ["K", 70, "comesFrom", ["K"], [31]], ["d", 155, "comesFrom", ["d"], [29]], ["d", 160, "comesFrom", ["d"], [29]], ["d", 166, "comesFrom", ["d"], [29]], ["currCnt", 201, "comesFrom", ["currCnt"], [147]], ["currCnt", 171, "comesFrom", ["currCnt"], [147]], ["currTight", 203, "comesFrom", ["currTight"], [189]], ["R", 335, "comesFrom", ["R"], [319]], ["L", 340, "comesFrom", ["L"], [315]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int solve ( int x ) { int ans = 0 , first , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; } int main ( ) { int L = 2 , R = 60 ; cout << solve ( R ) - solve ( L - 1 ) << endl ; L = 1 , R = 1000 ; cout << solve ( R ) - solve ( L - 1 ) << endl ; return 0 ; }", "docstring": "Count of Numbers in Range where first digit is equal to last digit of the number | C ++ program to implement the above approach ; Base Case ; Calculating the last digit ; Calculating the first digit ; Drivers Code", "dfg": [["ans", 82, "comesFrom", ["ans"], [73]], ["x", 34, "comesFrom", ["x"], [25]], ["x", 44, "comesFrom", ["x"], [25]], ["x", 29, "comesFrom", ["x"], [25]], ["x", 38, "comesFrom", ["x"], [25]], ["x", 49, "comesFrom", ["x"], [25]], ["first", 60, "comesFrom", ["first"], [47]], ["last", 62, "comesFrom", ["last"], [36]], ["temp", 68, "comesFrom", ["temp"], [23]], ["temp", 77, "comesFrom", ["temp"], [23]], ["R", 103, "comesFrom", ["R"], [95]], ["R", 127, "comesFrom", ["R"], [119]], ["L", 108, "comesFrom", ["L"], [91]], ["L", 132, "comesFrom", ["L"], [115]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumCost ( int n , int x , int y ) { int * dp = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i & 1 ) { dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; } int main ( ) { int n = 4 , x = 2 , y = 1 ; cout << findMinimumCost ( n , x , y ) ; return 0 ; }", "docstring": "Form N | CPP code to find minimum cost to form a N - copy string ; Returns the minimum cost to form a n - copy string Here , x -> Cost to add / remove a single character ' G ' and y -> cost to append the string to itself ; Base Case : to form a 1 - copy string we need to perform an operation of type 1 ( i . e Add ) ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 2 operation on ( ( i + 1 ) / 2 ) - copy string ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 3 operation on ( i / 2 ) - copy string ; Driver Code", "dfg": [["x", 37, "comesFrom", ["x"], [14]], ["x", 155, "comesFrom", ["x"], [141]], ["x", 75, "comesFrom", ["x"], [14]], ["x", 90, "comesFrom", ["x"], [14]], ["x", 110, "comesFrom", ["x"], [14]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 56, "comesFrom", ["i"], [42]], ["i", 63, "comesFrom", ["i"], [42]], ["i", 98, "comesFrom", ["i"], [42]], ["i", 70, "comesFrom", ["i"], [42]], ["i", 105, "comesFrom", ["i"], [42]], ["i", 114, "comesFrom", ["i"], [42]], ["i", 80, "comesFrom", ["i"], [42]], ["n", 48, "comesFrom", ["n"], [11]], ["n", 127, "comesFrom", ["n"], [11]], ["n", 153, "comesFrom", ["n"], [137]], ["n", 27, "comesFrom", ["n"], [11]], ["y", 157, "comesFrom", ["y"], [145]], ["y", 88, "comesFrom", ["y"], [17]], ["y", 119, "comesFrom", ["y"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define r  4 NEW_LINE #define col  5 NEW_LINE int findMinSteps ( int mat [ r ] [ col ] , int n , int m , int dp [ r ] [ col ] , bool vis [ r ] [ col ] ) { if ( n == 0 || m == 0 || n == ( r - 1 ) || m == ( col - 1 ) ) { return 0 ; } if ( dp [ n ] [ m ] != -1 ) return dp [ n ] [ m ] ; vis [ n ] [ m ] = true ; int ans1 , ans2 , ans3 , ans4 ; ans1 = ans2 = ans3 = ans4 = 1e9 ; if ( mat [ n - 1 ] [ m ] == 0 ) { if ( ! vis [ n - 1 ] [ m ] ) ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) ; } if ( mat [ n ] [ m + 1 ] == 0 ) { if ( ! vis [ n ] [ m + 1 ] ) ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) ; } if ( mat [ n ] [ m - 1 ] == 0 ) { if ( ! vis [ n ] [ m - 1 ] ) ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) ; } if ( mat [ n + 1 ] [ m ] == 0 ) { if ( ! vis [ n + 1 ] [ m ] ) ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) ; } dp [ n ] [ m ] = min ( ans1 , min ( ans2 , min ( ans3 , ans4 ) ) ) ; return dp [ n ] [ m ] ; } int minimumSteps ( int mat [ r ] [ col ] , int n , int m ) { int twox = -1 ; int twoy = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 2 ) { twox = i ; twoy = j ; break ; } } if ( twox != -1 ) break ; } int dp [ r ] [ col ] ; memset ( dp , -1 , sizeof dp ) ; bool vis [ r ] [ col ] ; memset ( vis , false , sizeof vis ) ; int res = findMinSteps ( mat , twox , twoy , dp , vis ) ; if ( res >= 1e9 ) return -1 ; else return res ; } int main ( ) { int mat [ r ] [ col ] = { { 1 , 1 , 1 , 0 , 1 } , { 1 , 0 , 2 , 0 , 1 } , { 0 , 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } } ; cout << minimumSteps ( mat , r , col ) ; }", "docstring": "Minimum steps to reach any of the boundary edges of a matrix | Set 1 | C ++ program to find Minimum steps to reach any of the boundary edges of a matrix ; Function to find out minimum steps ; boundary edges reached ; already had a route through this point , hence no need to re - visit ; visiting a position ; vertically up ; horizontally right ; horizontally left ; vertically down ; minimum of every path ; Function that returns the minimum steps ; index to store the location at which you are standing ; find '2' in the matrix ; Initialize dp matrix with - 1 ; Initialize vis matrix with false ; Call function to find out minimum steps using memoization and recursion ; if not possible ; Driver Code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE int nCr ( int n , int r ) { int ans = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { ans *= ( n - i ) ; ans /= ( i + 1 ) ; } return ans ; } int countDerangements ( int n ) { int der [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; } ll countPermutations ( int n , int k ) { ll ans = 0 ; for ( int i = n - k ; i <= n ; i ++ ) { int ways = nCr ( n , i ) ; ans += ways * countDerangements ( n - i ) ; } return ans ; } int main ( ) { int n = 5 , k = 3 ; cout << countPermutations ( n , k ) ; return 0 ; }", "docstring": "Count the number of special permutations | C ++ program to count the number of required permutations ; Function to return the number of ways to choose r objects out of n objects ; Function to return the number of derangements of n ; Function to return the required number of permutations ; Ways to choose i indices from n indices ; Dearangements of ( n - i ) indices ; Driver Code to test above functions", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 3 ; int dp [ n ] [ n ] ; void answerQueries ( pair < int , int > queries [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int x = queries [ i ] . first ; x -- ; int y = queries [ i ] . second ; y -- ; cout << dp [ x ] [ y ] << endl ; } } void pre_compute ( char a [ ] [ n ] ) { if ( a [ 0 ] [ 0 ] == ' a ' ) dp [ 0 ] [ 0 ] = 0 ; else dp [ 0 ] [ 0 ] = 1 ; for ( int row = 0 ; row < n ; row ++ ) { for ( int col = 0 ; col < n ; col ++ ) { if ( row != 0 col != 0 ) dp [ row ] [ col ] = INT_MAX ; if ( row != 0 ) { dp [ row ] [ col ] = min ( dp [ row ] [ col ] , dp [ row - 1 ] [ col ] ) ; } if ( col != 0 ) { dp [ row ] [ col ] = min ( dp [ row ] [ col ] , dp [ row ] [ col - 1 ] ) ; } if ( a [ row ] [ col ] != ' a ' && ( row != 0 col != 0 ) ) dp [ row ] [ col ] += 1 ; } } } int main ( ) { char a [ ] [ 3 ] = { { ' a ' , ' b ' , ' a ' } , { ' a ' , ' c ' , ' d ' } , { ' b ' , ' a ' , ' b ' } } ; pair < int , int > queries [ ] = { { 1 , 3 } , { 3 , 3 } } ; int q = 2 ; pre_compute ( a ) ; answerQueries ( queries , q ) ; }", "docstring": "Paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally | C ++ program to find paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally ; Function to answer queries ; Iterate till query ; Decrease to get 0 - based indexing ; Print answer ; Function that pre - computes the dp array ; Check fo the first character ; Iterate in row and columns ; If not first row or not first column ; Not first row ; Not first column ; If it is not ' a ' then increase by 1 ; Driver code ; character N X N array ; queries ; number of queries ; function call to pre - compute ; function call to answer every query", "dfg": [["n", 19, "comesFrom", ["n"], [9]], ["n", 16, "comesFrom", ["n"], [9]], ["n", 152, "comesFrom", ["n"], [9]], ["n", 102, "comesFrom", ["n"], [9]], ["n", 167, "comesFrom", ["n"], [9]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 59, "comesFrom", ["i"], [42]], ["i", 72, "comesFrom", ["i"], [42]], ["q", 48, "comesFrom", ["q"], [36]], ["q", 417, "comesFrom", ["q"], [404]], ["row", 150, "comesFrom", ["row"], [146]], ["row", 154, "comesFrom", ["row"], [146]], ["row", 194, "comesFrom", ["row"], [146]], ["row", 175, "comesFrom", ["row"], [146]], ["row", 184, "comesFrom", ["row"], [146]], ["row", 283, "comesFrom", ["row"], [146]], ["row", 293, "comesFrom", ["row"], [146]], ["row", 201, "comesFrom", ["row"], [146]], ["row", 238, "comesFrom", ["row"], [146]], ["row", 270, "comesFrom", ["row"], [146]], ["row", 211, "comesFrom", ["row"], [146]], ["row", 248, "comesFrom", ["row"], [146]], ["row", 256, "comesFrom", ["row"], [146]], ["row", 219, "comesFrom", ["row"], [146]], ["x", 64, "comesFrom", ["x"], [55]], ["x", 84, "comesFrom", ["x"], [55]], ["y", 77, "comesFrom", ["y"], [68]], ["y", 87, "comesFrom", ["y"], [68]], ["col", 165, "comesFrom", ["col"], [161]], ["col", 169, "comesFrom", ["col"], [161]], ["col", 231, "comesFrom", ["col"], [161]], ["col", 178, "comesFrom", ["col"], [161]], ["col", 187, "comesFrom", ["col"], [161]], ["col", 296, "comesFrom", ["col"], [161]], ["col", 204, "comesFrom", ["col"], [161]], ["col", 241, "comesFrom", ["col"], [161]], ["col", 273, "comesFrom", ["col"], [161]], ["col", 286, "comesFrom", ["col"], [161]], ["col", 214, "comesFrom", ["col"], [161]], ["col", 224, "comesFrom", ["col"], [161]], ["col", 251, "comesFrom", ["col"], [161]], ["col", 259, "comesFrom", ["col"], [161]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int squares ( int i ) { if ( ( i & 1 ) == 1 ) return i / 4 * 2 + 1 ; else return ( i - 1 ) / 4 * 2 + 2 ; } long bishop_placements ( int n , int k ) { if ( k > 2 * n - 1 ) return 0 ; long dp [ n * 2 ] [ k + 1 ] ; for ( int i = 0 ; i < n * 2 ; i ++ ) { for ( int j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < n * 2 ; i ++ ) dp [ i ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n * 2 ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp [ i ] [ j ] = dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ; } } long ans = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ; } return ans ; } int main ( ) { int n = 2 ; int k = 2 ; long ans = bishop_placements ( n , k ) ; cout << ( ans ) ; }", "docstring": "Ways to place K bishops on an NÃ — N chessboard so that no two attack | CPP implementation of the approach ; returns the number of squares in diagonal i ; returns the number of ways to fill a n * n chessboard with k bishops so that no two bishops attack each other . ; return 0 if the number of valid places to be filled is less than the number of bishops ; dp table to store the values ; Setting the base conditions ; calculate the required number of ways ; stores the answer ; Driver code", "dfg": [["ans", 291, "comesFrom", ["ans"], [261]], ["ans", 322, "comesFrom", ["ans"], [310]], ["i", 91, "comesFrom", ["i"], [87]], ["i", 97, "comesFrom", ["i"], [87]], ["i", 137, "comesFrom", ["i"], [133]], ["i", 143, "comesFrom", ["i"], [133]], ["i", 173, "comesFrom", ["i"], [169]], ["i", 179, "comesFrom", ["i"], [169]], ["i", 253, "comesFrom", ["i"], [249]], ["i", 257, "comesFrom", ["i"], [249]], ["i", 17, "comesFrom", ["i"], [11]], ["i", 25, "comesFrom", ["i"], [11]], ["i", 148, "comesFrom", ["i"], [133]], ["i", 272, "comesFrom", ["i"], [249]], ["i", 36, "comesFrom", ["i"], [11]], ["i", 286, "comesFrom", ["i"], [249]], ["i", 120, "comesFrom", ["i"], [87]], ["i", 200, "comesFrom", ["i"], [169]], ["i", 208, "comesFrom", ["i"], [169]], ["i", 218, "comesFrom", ["i"], [169]], ["i", 231, "comesFrom", ["i"], [169]], ["k", 255, "comesFrom", ["k"], [55]], ["k", 60, "comesFrom", ["k"], [55]], ["k", 79, "comesFrom", ["k"], [55]], ["k", 192, "comesFrom", ["k"], [55]], ["k", 316, "comesFrom", ["k"], [305]], ["k", 110, "comesFrom", ["k"], [55]], ["k", 284, "comesFrom", ["k"], [55]], ["n", 93, "comesFrom", ["n"], [52]], ["n", 139, "comesFrom", ["n"], [52]], ["n", 175, "comesFrom", ["n"], [52]], ["n", 74, "comesFrom", ["n"], [52]], ["n", 314, "comesFrom", ["n"], [300]], ["n", 64, "comesFrom", ["n"], [52]], ["n", 265, "comesFrom", ["n"], [52]], ["n", 277, "comesFrom", ["n"], [52]], ["j", 108, "comesFrom", ["j"], [104]], ["j", 114, "comesFrom", ["j"], [104]], ["j", 190, "comesFrom", ["j"], [186]], ["j", 194, "comesFrom", ["j"], [186]], ["j", 123, "comesFrom", ["j"], [104]], ["j", 203, "comesFrom", ["j"], [186]], ["j", 213, "comesFrom", ["j"], [186]], ["j", 223, "comesFrom", ["j"], [186]], ["j", 234, "comesFrom", ["j"], [186]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10 ; int F [ MAX ] [ MAX ] ; int C [ MAX ] ; int noOfAssignments ( string & S , int & n , int i , int c_x ) { if ( F [ i ] [ c_x ] != -1 ) return F [ i ] [ c_x ] ; if ( i == n ) { F [ i ] [ c_x ] = ! c_x ; return F [ i ] [ c_x ] ; } int c_y = C [ i ] - c_x ; if ( S [ i ] == ' ( ' ) { F [ i ] [ c_x ] = noOfAssignments ( S , n , i + 1 , c_x + 1 ) + noOfAssignments ( S , n , i + 1 , c_x ) ; return F [ i ] [ c_x ] ; } F [ i ] [ c_x ] = 0 ; if ( c_x ) F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x - 1 ) ; if ( c_y ) F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x ) ; return F [ i ] [ c_x ] ; } int main ( ) { string S = \" ( ) \" ; int n = S . length ( ) ; memset ( F , -1 , sizeof ( F ) ) ; C [ 0 ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( S [ i ] == ' ( ' ) C [ i + 1 ] = C [ i ] + 1 ; else C [ i + 1 ] = C [ i ] - 1 ; cout << noOfAssignments ( S , n , 0 , 0 ) ; return 0 ; }", "docstring": "Number of ways to partition a string into two balanced subsequences | C ++ implementation of the above approach ; For maximum length of input string ; Declaring the DP table ; Declaring the prefix array ; Function to calculate the number of valid assignments ; Return 1 if X is balanced . ; Increment the count if it an opening bracket ; Decrement the count if it a closing bracket ; Driver code ; Initializing the DP table ; Creating the prefix array ; Initial value for c_x and c_y is zero", "dfg": [["MAX", 19, "comesFrom", ["MAX"], [9]], ["MAX", 25, "comesFrom", ["MAX"], [9]], ["MAX", 16, "comesFrom", ["MAX"], [9]], ["c_x", 177, "comesFrom", ["c_x"], [43]], ["c_x", 103, "comesFrom", ["c_x"], [43]], ["c_x", 233, "comesFrom", ["c_x"], [43]], ["c_x", 64, "comesFrom", ["c_x"], [43]], ["c_x", 170, "comesFrom", ["c_x"], [43]], ["c_x", 53, "comesFrom", ["c_x"], [43]], ["c_x", 83, "comesFrom", ["c_x"], [43]], ["c_x", 91, "comesFrom", ["c_x"], [43]], ["c_x", 161, "comesFrom", ["c_x"], [43]], ["c_x", 184, "comesFrom", ["c_x"], [43]], ["c_x", 211, "comesFrom", ["c_x"], [43]], ["c_x", 224, "comesFrom", ["c_x"], [43]], ["c_x", 79, "comesFrom", ["c_x"], [43]], ["c_x", 124, "comesFrom", ["c_x"], [43]], ["c_x", 197, "comesFrom", ["c_x"], [43]], ["c_x", 152, "comesFrom", ["c_x"], [43]], ["c_x", 137, "comesFrom", ["c_x"], [43]], ["c_y", 204, "comesFrom", ["c_y"], [96]], ["i", 284, "comesFrom", ["i"], [280]], ["i", 289, "comesFrom", ["i"], [280]], ["i", 69, "comesFrom", ["i"], [40]], ["i", 230, "comesFrom", ["i"], [40]], ["i", 61, "comesFrom", ["i"], [40]], ["i", 100, "comesFrom", ["i"], [40]], ["i", 109, "comesFrom", ["i"], [40]], ["i", 167, "comesFrom", ["i"], [40]], ["i", 50, "comesFrom", ["i"], [40]], ["i", 88, "comesFrom", ["i"], [40]], ["i", 158, "comesFrom", ["i"], [40]], ["i", 181, "comesFrom", ["i"], [40]], ["i", 193, "comesFrom", ["i"], [40]], ["i", 208, "comesFrom", ["i"], [40]], ["i", 220, "comesFrom", ["i"], [40]], ["i", 295, "comesFrom", ["i"], [280]], ["i", 76, "comesFrom", ["i"], [40]], ["i", 121, "comesFrom", ["i"], [40]], ["i", 306, "comesFrom", ["i"], [280]], ["i", 313, "comesFrom", ["i"], [280]], ["i", 133, "comesFrom", ["i"], [40]], ["i", 148, "comesFrom", ["i"], [40]], ["i", 321, "comesFrom", ["i"], [280]], ["i", 328, "comesFrom", ["i"], [280]], ["n", 286, "comesFrom", ["n"], [250]], ["n", 339, "comesFrom", ["n"], [250]], ["S", 252, "comesFrom", ["S"], [243]], ["S", 337, "comesFrom", ["S"], [243]], ["S", 293, "comesFrom", ["S"], [243]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 3 ; int minFallingPathSum ( int ( & A ) [ n ] [ n ] ) { for ( int R = n - 2 ; R >= 0 ; -- R ) { for ( int C = 0 ; C < n ; ++ C ) { int best = A [ R + 1 ] [ C ] ; if ( C > 0 ) best = min ( best , A [ R + 1 ] [ C - 1 ] ) ; if ( C + 1 < n ) best = min ( best , A [ R + 1 ] [ C + 1 ] ) ; A [ R ] [ C ] = A [ R ] [ C ] + best ; } } int ans = INT_MAX ; for ( int i = 0 ; i < n ; ++ i ) ans = min ( ans , A [ 0 ] [ i ] ) ; return ans ; } int main ( ) { int A [ n ] [ n ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << minFallingPathSum ( A ) ; return 0 ; }", "docstring": "Minimum sum falling path in a NxN grid | C ++ Program to minimum required sum ; Function to return minimum path falling sum ; R = Row and C = Column We begin from second last row and keep adding maximum sum . ; best = min ( A [ R + 1 ] [ C - 1 ] , A [ R + 1 ] [ C ] , A [ R + 1 ] [ C + 1 ] ) ; Driver program ; function to print required answer", "dfg": [["ans", 181, "comesFrom", ["ans"], [165]], ["ans", 169, "comesFrom", ["ans"], [165]], ["R", 38, "comesFrom", ["R"], [32]], ["R", 43, "comesFrom", ["R"], [32]], ["R", 128, "comesFrom", ["R"], [32]], ["R", 66, "comesFrom", ["R"], [32]], ["R", 136, "comesFrom", ["R"], [32]], ["R", 88, "comesFrom", ["R"], [32]], ["R", 115, "comesFrom", ["R"], [32]], ["i", 158, "comesFrom", ["i"], [154]], ["i", 163, "comesFrom", ["i"], [154]], ["i", 176, "comesFrom", ["i"], [154]], ["n", 160, "comesFrom", ["n"], [9]], ["n", 25, "comesFrom", ["n"], [9]], ["n", 195, "comesFrom", ["n"], [9]], ["n", 22, "comesFrom", ["n"], [9]], ["n", 34, "comesFrom", ["n"], [9]], ["n", 55, "comesFrom", ["n"], [9]], ["n", 192, "comesFrom", ["n"], [9]], ["n", 105, "comesFrom", ["n"], [9]], ["C", 53, "comesFrom", ["C"], [49]], ["C", 58, "comesFrom", ["C"], [49]], ["C", 76, "comesFrom", ["C"], [49]], ["C", 71, "comesFrom", ["C"], [49]], ["C", 101, "comesFrom", ["C"], [49]], ["C", 131, "comesFrom", ["C"], [49]], ["C", 139, "comesFrom", ["C"], [49]], ["C", 93, "comesFrom", ["C"], [49]], ["C", 120, "comesFrom", ["C"], [49]], ["best", 142, "comesFrom", ["best"], [107]], ["best", 84, "comesFrom", ["best"], [80]], ["best", 111, "comesFrom", ["best"], [107]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE const int n = 3 , m = 4 ; int maxPlus ( int ( & arr ) [ n ] [ m ] ) { int ans = INT_MIN ; int left [ N ] [ N ] , right [ N ] [ N ] , up [ N ] [ N ] , down [ N ] [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { left [ i ] [ j ] = max ( 0LL , ( j ? left [ i ] [ j - 1 ] : 0LL ) ) + arr [ i ] [ j ] ; up [ i ] [ j ] = max ( 0LL , ( i ? up [ i - 1 ] [ j ] : 0LL ) ) + arr [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { right [ i ] [ j ] = max ( 0LL , ( j + 1 == m ? 0LL : right [ i ] [ j + 1 ] ) ) + arr [ i ] [ j ] ; down [ i ] [ j ] = max ( 0LL , ( i + 1 == n ? 0LL : down [ i + 1 ] [ j ] ) ) + arr [ i ] [ j ] ; } } for ( int i = 1 ; i < n - 1 ; ++ i ) for ( int j = 1 ; j < m - 1 ; ++ j ) ans = max ( ans , up [ i - 1 ] [ j ] + down [ i + 1 ] [ j ] + left [ i ] [ j - 1 ] + right [ i ] [ j + 1 ] + arr [ i ] [ j ] ) ; return ans ; } int main ( ) { int arr [ n ] [ m ] = { { 1 , 1 , 1 , 1 } , { -6 , 1 , 1 , -4 } , { 1 , 1 , 1 , 1 } } ; cout << maxPlus ( arr ) ; return 0 ; }", "docstring": "Find the maximum sum of Plus shape pattern in a 2 | C ++ program to find the maximum value of a + shaped pattern in 2 - D array ; Function to return maximum Plus value ; Initializing answer with the minimum value ; Initializing all four arrays ; Initializing left and up array . ; Initializing right and down array . ; calculating value of maximum Plus ( + ) sign ; Driver code ; Function call to find maximum value", "dfg": []}
{"code": "#include <iostream> NEW_LINE using namespace std ; int countStaircases ( int N ) { int memo [ N + 5 ] [ N + 5 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { memo [ i ] [ j ] = 0 ; } } memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 ; for ( int i = 5 ; i <= N ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 ; } else { memo [ i ] [ j ] = memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ; } } } int answer = 0 ; for ( int i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N ] [ i ] ; return answer ; } int main ( ) { int N = 7 ; cout << countStaircases ( N ) ; return 0 ; }", "docstring": "Total number of different staircase that can made from N boxes | C ++ program to find the total number of different staircase that can made from N boxes ; Function to find the total number of different staircase that can made from N boxes ; DP table , there are two states . First describes the number of boxes and second describes the step ; Initialize all the elements of the table to zero ; Base case ; When step is equal to 2 ; When step is greater than 2 ; Count the total staircase from all the steps ; Driver Code", "dfg": [["answer", 212, "comesFrom", ["answer"], [199]], ["answer", 201, "comesFrom", ["answer"], [199]], ["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 94, "comesFrom", ["i"], [90]], ["i", 98, "comesFrom", ["i"], [90]], ["i", 192, "comesFrom", ["i"], [188]], ["i", 196, "comesFrom", ["i"], [188]], ["i", 111, "comesFrom", ["i"], [90]], ["i", 208, "comesFrom", ["i"], [188]], ["i", 59, "comesFrom", ["i"], [30]], ["i", 126, "comesFrom", ["i"], [90]], ["i", 149, "comesFrom", ["i"], [90]], ["i", 134, "comesFrom", ["i"], [90]], ["i", 157, "comesFrom", ["i"], [90]], ["i", 167, "comesFrom", ["i"], [90]], ["N", 36, "comesFrom", ["N"], [11]], ["N", 96, "comesFrom", ["N"], [11]], ["N", 194, "comesFrom", ["N"], [11]], ["N", 22, "comesFrom", ["N"], [11]], ["N", 17, "comesFrom", ["N"], [11]], ["N", 51, "comesFrom", ["N"], [11]], ["N", 229, "comesFrom", ["N"], [221]], ["N", 205, "comesFrom", ["N"], [11]], ["j", 49, "comesFrom", ["j"], [45]], ["j", 53, "comesFrom", ["j"], [45]], ["j", 109, "comesFrom", ["j"], [105]], ["j", 113, "comesFrom", ["j"], [105]], ["j", 119, "comesFrom", ["j"], [105]], ["j", 62, "comesFrom", ["j"], [45]], ["j", 129, "comesFrom", ["j"], [105]], ["j", 139, "comesFrom", ["j"], [105]], ["j", 152, "comesFrom", ["j"], [105]], ["j", 162, "comesFrom", ["j"], [105]], ["j", 136, "comesFrom", ["j"], [105]], ["j", 172, "comesFrom", ["j"], [105]], ["j", 159, "comesFrom", ["j"], [105]], ["j", 169, "comesFrom", ["j"], [105]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCost ( int a [ ] , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = max ( mx , a [ i ] ) ; int count [ mx + 1 ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int res [ mx + 1 ] ; res [ 0 ] = 0 ; l = min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = max ( num - l - 1 , 0 ) ; res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; } int main ( ) { int a [ ] = { 2 , 1 , 2 , 3 , 2 , 2 , 1 } , l = 1 , r = 1 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxCost ( a , n , l , r ) ; return 0 ; }", "docstring": "Find maximum points which can be obtained by deleting elements from array | C ++ program to find maximum cost after deleting all the elements form the array ; function to return maximum cost obtained ; find maximum element of the array . ; initialize count of all elements to zero . ; calculate frequency of all elements of array . ; stores cost of deleted elements . ; selecting minimum range from L and R . ; finds upto which elements are to be deleted when element num is selected . ; get maximum when selecting element num or not . ; Driver program ; size of array ; function call to find maximum cost", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 44, "comesFrom", ["i"], [35]], ["i", 85, "comesFrom", ["i"], [81]], ["i", 89, "comesFrom", ["i"], [81]], ["i", 54, "comesFrom", ["i"], [35]], ["i", 96, "comesFrom", ["i"], [81]], ["n", 41, "comesFrom", ["n"], [16]], ["n", 87, "comesFrom", ["n"], [16]], ["n", 244, "comesFrom", ["n"], [223]], ["num", 132, "comesFrom", ["num"], [128]], ["num", 136, "comesFrom", ["num"], [128]], ["num", 155, "comesFrom", ["num"], [128]], ["num", 144, "comesFrom", ["num"], [128]], ["num", 167, "comesFrom", ["num"], [128]], ["num", 162, "comesFrom", ["num"], [128]], ["num", 171, "comesFrom", ["num"], [128]], ["mx", 134, "comesFrom", ["mx"], [46]], ["mx", 61, "comesFrom", ["mx"], [46]], ["mx", 104, "comesFrom", ["mx"], [46]], ["mx", 184, "comesFrom", ["mx"], [46]], ["mx", 50, "comesFrom", ["mx"], [46]], ["l", 120, "comesFrom", ["l"], [116]], ["l", 246, "comesFrom", ["l"], [214]], ["l", 146, "comesFrom", ["l"], [116]], ["r", 122, "comesFrom", ["r"], [22]], ["r", 248, "comesFrom", ["r"], [218]], ["k", 176, "comesFrom", ["k"], [140]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; } int main ( ) { int n = 5 ; int m = 5 ; cout << countPaths ( n , m ) ; return 0 ; }", "docstring": "Count the number of ways to traverse a Matrix | C ++ program using recursive solution to count number of ways to reach mat [ m - 1 ] [ n - 1 ] from mat [ 0 ] [ 0 ] in a matrix mat [ ] [ ] ; Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Return 1 if it is the first row or first column ; Recursively find the no of way to reach the last cell . ; Driver code", "dfg": [["m", 19, "comesFrom", ["m"], [11]], ["m", 41, "comesFrom", ["m"], [11]], ["m", 70, "comesFrom", ["m"], [60]], ["m", 32, "comesFrom", ["m"], [11]], ["n", 22, "comesFrom", ["n"], [14]], ["n", 36, "comesFrom", ["n"], [14]], ["n", 68, "comesFrom", ["n"], [55]], ["n", 43, "comesFrom", ["n"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; } int main ( ) { int n = 5 ; int m = 5 ; cout << countPaths ( n , m ) ; return 0 ; }", "docstring": "Count the number of ways to traverse a Matrix | A simple recursive solution to count number of ways to reach mat [ m - 1 ] [ n - 1 ] from mat [ 0 ] [ 0 ] in a matrix mat [ ] [ ] ; Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Driver code", "dfg": [["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 62, "comesFrom", ["i"], [33]], ["i", 71, "comesFrom", ["i"], [33]], ["i", 82, "comesFrom", ["i"], [33]], ["i", 100, "comesFrom", ["i"], [33]], ["i", 90, "comesFrom", ["i"], [33]], ["m", 39, "comesFrom", ["m"], [11]], ["m", 20, "comesFrom", ["m"], [11]], ["m", 113, "comesFrom", ["m"], [11]], ["m", 141, "comesFrom", ["m"], [131]], ["n", 25, "comesFrom", ["n"], [14]], ["n", 116, "comesFrom", ["n"], [14]], ["n", 54, "comesFrom", ["n"], [14]], ["n", 139, "comesFrom", ["n"], [126]], ["j", 52, "comesFrom", ["j"], [48]], ["j", 56, "comesFrom", ["j"], [48]], ["j", 65, "comesFrom", ["j"], [48]], ["j", 74, "comesFrom", ["j"], [48]], ["j", 85, "comesFrom", ["j"], [48]], ["j", 95, "comesFrom", ["j"], [48]], ["j", 103, "comesFrom", ["j"], [48]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < long long > > dp ; int createPalindrome ( int input , bool isOdd ) { int n = input ; int palin = input ; if ( isOdd ) n /= 10 ; while ( n > 0 ) { palin = palin * 10 + ( n % 10 ) ; n /= 10 ; } return palin ; } vector < int > generatePalindromes ( int N ) { vector < int > palindromes ; int number ; for ( int j = 0 ; j < 2 ; j ++ ) { int i = 1 ; while ( ( number = createPalindrome ( i ++ , j ) ) <= N ) palindromes . push_back ( number ) ; } return palindromes ; } long long minimumSubsetSize ( vector < int > & A , int i , int j , int N ) { if ( ! N ) return 0 ; if ( i > j A [ i ] > N ) return INT_MAX ; if ( dp [ i ] [ N ] ) return dp [ i ] [ N ] ; dp [ i ] [ N ] = min ( 1 + minimumSubsetSize ( A , i + 1 , j , N - A [ i ] ) , minimumSubsetSize ( A , i + 1 , j , N ) ) ; return dp [ i ] [ N ] ; } int minimumNoOfPalindromes ( int N ) { vector < int > palindromes = generatePalindromes ( N ) ; sort ( palindromes . begin ( ) , palindromes . end ( ) ) ; dp = vector < vector < long long > > ( palindromes . size ( ) , vector < long long > ( N + 1 , 0 ) ) ; return minimumSubsetSize ( palindromes , 0 , palindromes . size ( ) - 1 , N ) ; } int main ( ) { int N = 65 ; cout << minimumNoOfPalindromes ( N ) ; return 0 ; }", "docstring": "Minimum number of palindromes required to express N as a sum | Set 1 | C ++ implementation of above approach ; Declaring the DP table as global variable ; A utility for creating palindrome ; checks if number of digits is odd or even if odd then neglect the last digit of input in finding reverse as in case of odd number of digits middle element occur once ; Creates palindrome by just appending reverse of number to itself ; Function to generate palindromes ; Run two times for odd and even length palindromes ; Creates palindrome numbers with first half as i . Value of j decides whether we need an odd length or even length palindrome . ; Function to find the minimum number of elements in a sorted array A [ i . . j ] such that their sum is N ; Function to find the minimum number of palindromes that N can be expressed as a sum of ; Getting the list of all palindromes upto N ; Sorting the list of palindromes ; Initializing the DP table ; Returning the required value ; Driver code", "dfg": [["palin", 70, "comesFrom", ["palin"], [52]], ["palin", 54, "comesFrom", ["palin"], [52]], ["palindromes", 137, "comesFrom", ["palindromes"], [87]], ["palindromes", 324, "comesFrom", ["palindromes"], [268]], ["palindromes", 277, "comesFrom", ["palindromes"], [268]], ["palindromes", 283, "comesFrom", ["palindromes"], [268]], ["palindromes", 128, "comesFrom", ["palindromes"], [87]], ["palindromes", 301, "comesFrom", ["palindromes"], [268]], ["palindromes", 328, "comesFrom", ["palindromes"], [268]], ["isOdd", 39, "comesFrom", ["isOdd"], [24]], ["j", 99, "comesFrom", ["j"], [95]], ["j", 103, "comesFrom", ["j"], [95]], ["j", 173, "comesFrom", ["j"], [155]], ["j", 241, "comesFrom", ["j"], [155]], ["j", 223, "comesFrom", ["j"], [155]], ["j", 122, "comesFrom", ["j"], [95]], ["n", 47, "comesFrom", ["n"], [41]], ["n", 59, "comesFrom", ["n"], [41]], ["N", 164, "comesFrom", ["N"], [158]], ["N", 179, "comesFrom", ["N"], [158]], ["N", 253, "comesFrom", ["N"], [158]], ["N", 336, "comesFrom", ["N"], [261]], ["N", 191, "comesFrom", ["N"], [158]], ["N", 200, "comesFrom", ["N"], [158]], ["N", 208, "comesFrom", ["N"], [158]], ["N", 272, "comesFrom", ["N"], [261]], ["N", 354, "comesFrom", ["N"], [346]], ["N", 126, "comesFrom", ["N"], [80]], ["N", 243, "comesFrom", ["N"], [158]], ["N", 313, "comesFrom", ["N"], [261]], ["N", 225, "comesFrom", ["N"], [158]], ["dp", 248, "comesFrom", ["dp"], [15]], ["dp", 186, "comesFrom", ["dp"], [15]], ["dp", 195, "comesFrom", ["dp"], [15]], ["dp", 203, "comesFrom", ["dp"], [15]], ["i", 171, "comesFrom", ["i"], [152]], ["i", 250, "comesFrom", ["i"], [152]], ["i", 188, "comesFrom", ["i"], [152]], ["i", 197, "comesFrom", ["i"], [152]], ["i", 205, "comesFrom", ["i"], [152]], ["i", 176, "comesFrom", ["i"], [152]], ["i", 237, "comesFrom", ["i"], [152]], ["i", 219, "comesFrom", ["i"], [152]], ["i", 119, "comesFrom", ["i"], [108]], ["i", 229, "comesFrom", ["i"], [152]], ["number", 132, "comesFrom", ["number"], [115]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } int main ( ) { int n = 3 ; cout << catalan ( n ) << endl ; return 0 ; }", "docstring": "Number of ways a convex polygon of n + 2 sides can split into triangles by connecting vertices | C ++ program to find the nth catalan number ; Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn / ( n + 1 ) ; Driver code", "dfg": [["res", 75, "comesFrom", ["res"], [65]], ["i", 49, "comesFrom", ["i"], [45]], ["i", 54, "comesFrom", ["i"], [45]], ["i", 62, "comesFrom", ["i"], [45]], ["i", 68, "comesFrom", ["i"], [45]], ["k", 51, "comesFrom", ["k"], [36]], ["k", 30, "comesFrom", ["k"], [18]], ["k", 34, "comesFrom", ["k"], [18]], ["k", 40, "comesFrom", ["k"], [36]], ["c", 103, "comesFrom", ["c"], [91]], ["n", 32, "comesFrom", ["n"], [14]], ["n", 38, "comesFrom", ["n"], [14]], ["n", 99, "comesFrom", ["n"], [85]], ["n", 106, "comesFrom", ["n"], [85]], ["n", 97, "comesFrom", ["n"], [85]], ["n", 126, "comesFrom", ["n"], [118]], ["n", 60, "comesFrom", ["n"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; cout << f1 << \" ▁ \" ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) cout << f3 << \" ▁ \" ; f1 = f2 ; f2 = f3 ; } } int main ( ) { int N = 15 ; alternateFib ( N ) ; return 0 ; }", "docstring": "Alternate Fibonacci Numbers | Alternate Fibonacci Series using Dynamic Programming ; 0 th and 1 st number of the series are 0 and 1 ; Driver Code", "dfg": [["i", 47, "comesFrom", ["i"], [43]], ["i", 51, "comesFrom", ["i"], [43]], ["i", 64, "comesFrom", ["i"], [43]], ["n", 49, "comesFrom", ["n"], [11]], ["n", 16, "comesFrom", ["n"], [11]], ["f1", 34, "comesFrom", ["f1"], [23]], ["f1", 60, "comesFrom", ["f1"], [23]], ["N", 100, "comesFrom", ["N"], [94]], ["f2", 80, "comesFrom", ["f2"], [28]], ["f2", 58, "comesFrom", ["f2"], [28]], ["f3", 84, "comesFrom", ["f3"], [56]], ["f3", 72, "comesFrom", ["f3"], [56]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalWays ( int N , int M , int X ) { int dp [ N + 1 ] [ 2 ] ; if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; } int main ( ) { int N = 4 , M = 3 , X = 2 ; cout << totalWays ( N , M , X ) << endl ; return 0 ; }", "docstring": "Number of ways to form an array with distinct adjacent elements | C ++ program to count the number of ways to form arrays of N numbers such that the first and last numbers are fixed and all consecutive numbers are distinct ; Returns the total ways to form arrays such that every consecutive element is different and each element except the first and last can take values from 1 to M ; define the dp [ ] [ ] array ; if the first element is 1 ; there is only one way to place a 1 at the first index ; the value at first index needs to be 1 , thus there is no way to place a non - one integer ; if the first element was 1 then at index 1 , only non one integer can be placed thus there are M - 1 ways to place a non one integer at index 2 and 0 ways to place a 1 at the 2 nd index ; Else there is one way to place a one at index 2 and if a non one needs to be placed here , there are ( M - 2 ) options , i . e neither the element at this index should be 1 , neither should it be equal to the previous element ; Build the dp array in bottom up manner ; f ( i , one ) = f ( i - 1 , non - one ) ; f ( i , non - one ) = f ( i - 1 , one ) * ( M - 1 ) + f ( i - 1 , non - one ) * ( M - 2 ) ; last element needs to be one , so return dp [ n - 1 ] [ 0 ] ; Driver Code", "dfg": [["i", 126, "comesFrom", ["i"], [122]], ["i", 130, "comesFrom", ["i"], [122]], ["i", 136, "comesFrom", ["i"], [122]], ["i", 154, "comesFrom", ["i"], [122]], ["i", 144, "comesFrom", ["i"], [122]], ["i", 162, "comesFrom", ["i"], [122]], ["i", 178, "comesFrom", ["i"], [122]], ["N", 128, "comesFrom", ["N"], [11]], ["N", 23, "comesFrom", ["N"], [11]], ["N", 196, "comesFrom", ["N"], [11]], ["N", 227, "comesFrom", ["N"], [211]], ["X", 33, "comesFrom", ["X"], [17]], ["X", 64, "comesFrom", ["X"], [17]], ["X", 231, "comesFrom", ["X"], [219]], ["M", 87, "comesFrom", ["M"], [14]], ["M", 229, "comesFrom", ["M"], [215]], ["M", 113, "comesFrom", ["M"], [14]], ["M", 171, "comesFrom", ["M"], [14]], ["M", 187, "comesFrom", ["M"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } int main ( ) { int n = 6 ; printf ( \" % d \" , fib ( n ) ) ; return 0 ; }", "docstring": "Memoization ( 1D , 2D and 3D ) | C ++ program to find the Nth term of Fibonacci series ; Fibonacci Series using Recursion ; Base case ; recursive calls ; Driver Code", "dfg": [["n", 21, "comesFrom", ["n"], [11]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 26, "comesFrom", ["n"], [11]], ["n", 33, "comesFrom", ["n"], [11]], ["n", 57, "comesFrom", ["n"], [45]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int term [ 1000 ] ; int fib ( int n ) { if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } } int main ( ) { int n = 6 ; printf ( \" % d \" , fib ( n ) ) ; return 0 ; }", "docstring": "Memoization ( 1D , 2D and 3D ) | CPP program to find the Nth term of Fibonacci series ; Fibonacci Series using memoized Recursion ; base case ; if fib ( n ) has already been computed we do not do further recursive calls and hence reduce the number of repeated work ; store the computed value of fib ( n ) in an array term at index n to so that it does not needs to be precomputed again ; Driver Code", "dfg": [["n", 27, "comesFrom", ["n"], [17]], ["n", 22, "comesFrom", ["n"], [17]], ["n", 41, "comesFrom", ["n"], [17]], ["n", 33, "comesFrom", ["n"], [17]], ["n", 91, "comesFrom", ["n"], [79]], ["n", 68, "comesFrom", ["n"], [17]], ["n", 48, "comesFrom", ["n"], [17]], ["n", 53, "comesFrom", ["n"], [17]], ["n", 60, "comesFrom", ["n"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE int max ( int a , int b ) ; int max ( int a , int b ) { return ( a > b ) ? a : b ; } int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } int main ( ) { char X [ ] = \" AGGTAB \" ; char Y [ ] = \" GXTXAYB \" ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printf ( \" Length ▁ of ▁ LCS ▁ is ▁ % dn \" , lcs ( X , Y , m , n ) ) ; return 0 ; }", "docstring": "Memoization ( 1D , 2D and 3D ) | A Naive recursive implementation of LCS problem ; Utility function to get max of 2 integers ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Driver Code", "dfg": [["a", 30, "comesFrom", ["a"], [17]], ["a", 25, "comesFrom", ["a"], [17]], ["b", 32, "comesFrom", ["b"], [20]], ["b", 27, "comesFrom", ["b"], [20]], ["m", 55, "comesFrom", ["m"], [47]], ["m", 182, "comesFrom", ["m"], [155]], ["m", 69, "comesFrom", ["m"], [47]], ["m", 90, "comesFrom", ["m"], [47]], ["m", 109, "comesFrom", ["m"], [47]], ["m", 122, "comesFrom", ["m"], [47]], ["n", 58, "comesFrom", ["n"], [50]], ["n", 184, "comesFrom", ["n"], [163]], ["n", 76, "comesFrom", ["n"], [50]], ["n", 94, "comesFrom", ["n"], [50]], ["n", 126, "comesFrom", ["n"], [50]], ["n", 111, "comesFrom", ["n"], [50]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 901 ] [ 8101 ] ; int minimumNumberOfDigits ( int a , int b ) { if ( a > b a < 0 b < 0 a > 900 b > 8100 ) return -1 ; if ( a == 0 && b == 0 ) return 0 ; if ( dp [ a ] [ b ] != -1 ) return dp [ a ] [ b ] ; int ans = 101 ; for ( int i = 9 ; i >= 1 ; i -- ) { int k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( k != -1 ) ans = min ( ans , k + 1 ) ; } return dp [ a ] [ b ] = ans ; } void printSmallestNumber ( int a , int b ) { memset ( dp , -1 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 0 ; int k = minimumNumberOfDigits ( a , b ) ; if ( k == -1 k > 100 ) cout << \" - 1\" ; else { while ( a > 0 && b > 0 ) { for ( int i = 1 ; i <= 9 ; i ++ ) { if ( a >= i && b >= i * i && 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) { cout << i ; a -= i ; b -= i * i ; break ; } } } } } int main ( ) { int a = 18 , b = 162 ; printSmallestNumber ( a , b ) ; }", "docstring": "Smallest number with given sum of digits and sum of square of digits | CPP program to find the Smallest number with given sum of digits and sum of square of digits ; Top down dp to find minimum number of digits with given sum of dits a and sum of square of digits as b ; Invalid condition ; Number of digits satisfied ; Memoization ; Initialize ans as maximum as we have to find the minimum number of digits ; Check for all possible combinations of digits ; recurrence call ; If the combination of digits cannot give sum as a and sum of square of digits as b ; Returns the minimum number of digits ; Function to print the digits that gives sum as a and sum of square of digits as b ; initialize the dp array as - 1 ; base condition ; function call to get the minimum number of digits ; When there does not exists any number ; Printing the digits from the most significant digit ; Trying all combinations ; checking conditions for minimum digits ; Driver Code ; Function call to print the smallest number", "dfg": [["i", 93, "comesFrom", ["i"], [89]], ["i", 97, "comesFrom", ["i"], [89]], ["i", 108, "comesFrom", ["i"], [89]], ["i", 226, "comesFrom", ["i"], [222]], ["i", 230, "comesFrom", ["i"], [222]], ["i", 113, "comesFrom", ["i"], [89]], ["i", 115, "comesFrom", ["i"], [89]], ["i", 273, "comesFrom", ["i"], [222]], ["i", 277, "comesFrom", ["i"], [222]], ["i", 238, "comesFrom", ["i"], [222]], ["i", 281, "comesFrom", ["i"], [222]], ["i", 283, "comesFrom", ["i"], [222]], ["i", 242, "comesFrom", ["i"], [222]], ["i", 244, "comesFrom", ["i"], [222]], ["i", 252, "comesFrom", ["i"], [222]], ["i", 257, "comesFrom", ["i"], [222]], ["i", 259, "comesFrom", ["i"], [222]], ["ans", 146, "comesFrom", ["ans"], [125]], ["ans", 129, "comesFrom", ["ans"], [125]], ["a", 28, "comesFrom", ["a"], [20]], ["a", 308, "comesFrom", ["a"], [298]], ["a", 49, "comesFrom", ["a"], [20]], ["a", 186, "comesFrom", ["a"], [153]], ["a", 75, "comesFrom", ["a"], [20]], ["a", 140, "comesFrom", ["a"], [20]], ["a", 64, "comesFrom", ["a"], [20]], ["a", 106, "comesFrom", ["a"], [20]], ["a", 210, "comesFrom", ["a"], [153]], ["a", 37, "comesFrom", ["a"], [20]], ["a", 236, "comesFrom", ["a"], [153]], ["a", 264, "comesFrom", ["a"], [153]], ["a", 250, "comesFrom", ["a"], [153]], ["k", 193, "comesFrom", ["k"], [182]], ["k", 196, "comesFrom", ["k"], [182]], ["k", 121, "comesFrom", ["k"], [102]], ["k", 131, "comesFrom", ["k"], [102]], ["b", 310, "comesFrom", ["b"], [302]], ["b", 30, "comesFrom", ["b"], [23]], ["b", 53, "comesFrom", ["b"], [23]], ["b", 78, "comesFrom", ["b"], [23]], ["b", 143, "comesFrom", ["b"], [23]], ["b", 188, "comesFrom", ["b"], [156]], ["b", 67, "comesFrom", ["b"], [23]], ["b", 40, "comesFrom", ["b"], [23]], ["b", 110, "comesFrom", ["b"], [23]], ["b", 214, "comesFrom", ["b"], [156]], ["b", 34, "comesFrom", ["b"], [23]], ["b", 240, "comesFrom", ["b"], [156]], ["b", 267, "comesFrom", ["b"], [156]], ["b", 255, "comesFrom", ["b"], [156]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; } int main ( ) { int n = 3 ; cout << sumOfproduct ( n ) << endl ; return 0 ; }", "docstring": "Sum of product of consecutive Binomial Coefficients | CPP Program to find sum of product of consecutive Binomial Coefficient . ; Find the binomial coefficient up to nth term ; C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Return the sum of the product of consecutive binomial coefficient . ; Driven Program", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE int check ( int i , int sum , int n , int k , int a [ ] , int dp [ MAX ] [ MAX ] ) { if ( sum <= 0 ) return false ; if ( i >= n ) { if ( sum == k ) return true ; return false ; } if ( dp [ i ] [ sum ] != -1 ) return dp [ i ] [ sum ] ; dp [ i ] [ sum ] = check ( i + 1 , sum - 2 * a [ i ] , n , k , a , dp ) || check ( i + 1 , sum , n , k , a , dp ) ; dp [ i ] [ sum ] = check ( i + 1 , sum - ( i + 1 ) , n , k , a , dp ) || dp [ i ] [ sum ] ; dp [ i ] [ sum ] = check ( i + 1 , sum + i + 1 , n , k , a , dp ) || dp [ i ] [ sum ] ; return dp [ i ] [ sum ] ; } bool wrapper ( int n , int k , int a [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof ( dp ) ) ; return check ( 0 , sum , n , k , a , dp ) ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 } ; int n = 4 , k = 5 ; ( wrapper ( n , k , a ) ? ( cout << \" Yes \" ) : ( cout << \" No \" ) ) ; return 0 ; }", "docstring": "Check if array sum can be made K by three operations on it | C ++ Program to find if Array can have a sum of K by applying three types of possible operations on it ; Check if it is possible to achieve a sum with three operation allowed . ; If sum is negative . ; If going out of bound . ; If sum is achieved . ; If the current state is not evaluated yet . ; Replacing element with negative value of the element . ; Substracting index number from the element . ; Adding index number to the element . ; Wrapper Function ; Driver Code", "dfg": []}
{"code": "#include <iostream> NEW_LINE using std :: cout ; void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) cout << a << \" ▁ \" ; if ( n >= 1 ) cout << b << \" ▁ \" ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; cout << c << \" ▁ \" ; a = b ; b = c ; } } int main ( ) { fib ( 9 ) ; return 0 ; }", "docstring": "Print Fibonacci sequence using 2 variables | Simple CPP Program to print Fibonacci sequence ; Driver code", "dfg": [["i", 61, "comesFrom", ["i"], [57]], ["i", 65, "comesFrom", ["i"], [57]], ["n", 63, "comesFrom", ["n"], [12]], ["n", 28, "comesFrom", ["n"], [12]], ["n", 42, "comesFrom", ["n"], [12]], ["a", 34, "comesFrom", ["a"], [16]], ["a", 71, "comesFrom", ["a"], [16]], ["b", 48, "comesFrom", ["b"], [20]], ["b", 85, "comesFrom", ["b"], [20]], ["b", 73, "comesFrom", ["b"], [20]], ["c", 89, "comesFrom", ["c"], [69]], ["c", 77, "comesFrom", ["c"], [69]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll pre_compute ( ll a [ ] , ll n , ll index , ll k ) { ll dp [ n ] [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; } int main ( ) { ll a [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; ll n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; ll index = 4 , k = 6 ; printf ( \" % lld \" , pre_compute ( a , n , index , k ) ) ; return 0 ; }", "docstring": "Maximum sum increasing subsequence from a prefix and a given element after prefix is must | C ++ program to find maximum sum increasing subsequence till i - th index and including k - th index . ; Initializing the first row of the dp [ ] [ ] . ; Creating the dp [ ] [ ] matrix . ; To calculate for i = 4 and k = 6. ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gen ( int n ) { int S [ n + 1 ] ; S [ 0 ] = 0 ; S [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ i / 2 ] ; else S [ i ] = 4 * S [ i / 2 ] + 1 ; } return S [ n ] ; } void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << gen ( i ) << \" ▁ \" ; cout << \" STRNEWLINE \" ; } int main ( ) { int n = 15 ; cout << \" First ▁ \" << n << \" ▁ terms ▁ of ▁ \" << \" Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ STRNEWLINE \" ; moserDeBruijn ( n ) ; return 0 ; }", "docstring": "Moser | CPP code to generate first ' n ' terms of the Moser - de Bruijn Sequence ; Function to generate nth term of Moser - de Bruijn Sequence ; S ( 2 * n ) = 4 * S ( n ) ; S ( 2 * n + 1 ) = 4 * S ( n ) + 1 ; Generating the first ' n ' terms of Moser - de Bruijn Sequence ; Driver Code", "dfg": [["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["i", 112, "comesFrom", ["i"], [108]], ["i", 116, "comesFrom", ["i"], [108]], ["i", 53, "comesFrom", ["i"], [39]], ["i", 123, "comesFrom", ["i"], [108]], ["i", 61, "comesFrom", ["i"], [39]], ["i", 76, "comesFrom", ["i"], [39]], ["i", 68, "comesFrom", ["i"], [39]], ["i", 83, "comesFrom", ["i"], [39]], ["n", 45, "comesFrom", ["n"], [11]], ["n", 114, "comesFrom", ["n"], [102]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 94, "comesFrom", ["n"], [11]], ["n", 165, "comesFrom", ["n"], [143]], ["n", 153, "comesFrom", ["n"], [143]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCSubStr ( string X , string Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int len [ 2 ] [ n ] ; int currRow = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow ] [ j ] = len [ 1 - currRow ] [ j - 1 ] + 1 ; result = max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; } int main ( ) { string X = \" GeeksforGeeks \" ; string Y = \" GeeksQuiz \" ; cout << LCSubStr ( X , Y ) ; return 0 ; }", "docstring": "Longest Common Substring ( Space optimized DP solution ) | Space optimized CPP implementation of longest common substring . ; Function to find longest common substring . ; Find length of both the strings . ; Variable to store length of longest common substring . ; Matrix to store result of two consecutive rows at a time . ; Variable to represent which row of matrix is current row . ; For a particular value of i and j , len [ currRow ] [ j ] stores length of longest common substring in string X [ 0. . i ] and Y [ 0. . j ] . ; Make current row as previous row and previous row as new current row . ; Driver Code", "dfg": [["result", 183, "comesFrom", ["result"], [145]], ["result", 149, "comesFrom", ["result"], [145]], ["n", 46, "comesFrom", ["n"], [27]], ["n", 78, "comesFrom", ["n"], [27]], ["i", 61, "comesFrom", ["i"], [57]], ["i", 65, "comesFrom", ["i"], [57]], ["i", 86, "comesFrom", ["i"], [57]], ["i", 110, "comesFrom", ["i"], [57]], ["m", 63, "comesFrom", ["m"], [18]], ["X", 20, "comesFrom", ["X"], [11]], ["X", 209, "comesFrom", ["X"], [192]], ["X", 108, "comesFrom", ["X"], [11]], ["Y", 29, "comesFrom", ["Y"], [14]], ["Y", 211, "comesFrom", ["Y"], [199]], ["Y", 115, "comesFrom", ["Y"], [14]], ["j", 76, "comesFrom", ["j"], [72]], ["j", 80, "comesFrom", ["j"], [72]], ["j", 89, "comesFrom", ["j"], [72]], ["j", 99, "comesFrom", ["j"], [72]], ["j", 117, "comesFrom", ["j"], [72]], ["j", 128, "comesFrom", ["j"], [72]], ["j", 168, "comesFrom", ["j"], [72]], ["j", 138, "comesFrom", ["j"], [72]], ["j", 156, "comesFrom", ["j"], [72]], ["currRow", 179, "comesFrom", ["currRow"], [175]], ["currRow", 96, "comesFrom", ["currRow"], [50]], ["currRow", 125, "comesFrom", ["currRow"], [50]], ["currRow", 165, "comesFrom", ["currRow"], [50]], ["currRow", 135, "comesFrom", ["currRow"], [50]], ["currRow", 153, "comesFrom", ["currRow"], [50]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimalSteps ( string s , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = INT_MAX ; string s1 = \" \" , s2 = \" \" ; dp [ 0 ] = 1 ; s1 += s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ; s2 = s . substr ( i + 1 , i + 1 ) ; dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; } int main ( ) { string s = \" aaaaaaaa \" ; int n = s . length ( ) ; cout << minimalSteps ( s , n ) ; return 0 ; }", "docstring": "Minimal moves to form a string by adding characters or appending string itself | CPP program to print the Minimal moves to form a string by appending string and adding characters ; function to return the minimal number of moves ; initializing dp [ i ] to INT_MAX ; initialize both strings to null ; base case ; check if it can be appended ; addition of character takes one step ; appending takes 1 step , and we directly reach index i * 2 + 1 after appending so the number of steps is stord in i * 2 + 1 ; Driver Code ; function call to return minimal number of moves", "dfg": [["n", 20, "comesFrom", ["n"], [14]], ["n", 32, "comesFrom", ["n"], [14]], ["n", 80, "comesFrom", ["n"], [14]], ["n", 168, "comesFrom", ["n"], [14]], ["n", 201, "comesFrom", ["n"], [187]], ["i", 30, "comesFrom", ["i"], [26]], ["i", 34, "comesFrom", ["i"], [26]], ["i", 78, "comesFrom", ["i"], [74]], ["i", 82, "comesFrom", ["i"], [74]], ["i", 39, "comesFrom", ["i"], [26]], ["i", 90, "comesFrom", ["i"], [74]], ["i", 110, "comesFrom", ["i"], [74]], ["i", 99, "comesFrom", ["i"], [74]], ["i", 103, "comesFrom", ["i"], [74]], ["i", 117, "comesFrom", ["i"], [74]], ["i", 138, "comesFrom", ["i"], [74]], ["i", 122, "comesFrom", ["i"], [74]], ["i", 149, "comesFrom", ["i"], [74]], ["i", 156, "comesFrom", ["i"], [74]], ["s", 66, "comesFrom", ["s"], [11]], ["s", 189, "comesFrom", ["s"], [180]], ["s", 199, "comesFrom", ["s"], [180]], ["s", 88, "comesFrom", ["s"], [11]], ["s", 95, "comesFrom", ["s"], [11]], ["s1", 132, "comesFrom", ["s1"], [86]], ["s2", 134, "comesFrom", ["s2"], [93]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void func ( int n , int m , int A [ ] ) { vector < int > ModArray ( n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ModArray [ i ] = A [ i ] % m ; sum += ModArray [ i ] ; } sum = sum % m ; if ( sum % m == 0 ) { cout << \" True \" ; return ; } if ( sum % 2 != 0 ) { cout << \" False \" ; } else { ModArray . erase ( ModArray . begin ( ) ) ; int i = 0 ; int j = ModArray . size ( ) - 1 ; sort ( ModArray . begin ( ) , ModArray . end ( ) ) ; sum = sum / 2 ; int i1 , i2 ; while ( i <= j ) { int s = ModArray [ i ] + ModArray [ j ] ; if ( s == sum ) { i1 = i ; i2 = j ; cout << \" True \" ; break ; } else if ( s > sum ) j -- ; else i ++ ; } } } int main ( ) { int m = 2 ; int a [ ] = { 1 , 3 , 9 } ; int n = sizeof a / sizeof a [ 0 ] ; func ( n , m , a ) ; }", "docstring": "Check if any valid sequence is divisible by M | C ++ program for the above approach ; Function to check if any valid sequence is divisible by M ; DEclare mod array ; Calculate the mod array ; Check if sum is divisible by M ; Check if sum is not divisible by 2 ; Remove the first element from the ModArray since it is not possible to place minus on the first element ; Decrease the size of array ; Sort the array ; Loop until the pointer cross each other ; Check if sum becomes equal ; Increase and decrease the pointer accordingly ; Driver code ; Function call", "dfg": [["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["i", 53, "comesFrom", ["i"], [39]], ["i", 67, "comesFrom", ["i"], [39]], ["i", 168, "comesFrom", ["i"], [125]], ["i", 58, "comesFrom", ["i"], [39]], ["i", 195, "comesFrom", ["i"], [125]], ["i", 178, "comesFrom", ["i"], [125]], ["i", 221, "comesFrom", ["i"], [125]], ["n", 45, "comesFrom", ["n"], [11]], ["n", 264, "comesFrom", ["n"], [251]], ["sum", 73, "comesFrom", ["sum"], [71]], ["sum", 79, "comesFrom", ["sum"], [71]], ["sum", 97, "comesFrom", ["sum"], [71]], ["sum", 157, "comesFrom", ["sum"], [155]], ["sum", 190, "comesFrom", ["sum"], [155]], ["sum", 215, "comesFrom", ["sum"], [155]], ["m", 75, "comesFrom", ["m"], [14]], ["m", 266, "comesFrom", ["m"], [233]], ["m", 81, "comesFrom", ["m"], [14]], ["m", 61, "comesFrom", ["m"], [14]], ["j", 170, "comesFrom", ["j"], [130]], ["j", 199, "comesFrom", ["j"], [130]], ["j", 183, "comesFrom", ["j"], [130]], ["j", 217, "comesFrom", ["j"], [130]], ["s", 188, "comesFrom", ["s"], [174]], ["s", 213, "comesFrom", ["s"], [174]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printGolomb ( int n ) { int dp [ n + 1 ] ; dp [ 1 ] = 1 ; cout << dp [ 1 ] << \" ▁ \" ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; cout << dp [ i ] << \" ▁ \" ; } } int main ( ) { int n = 9 ; printGolomb ( n ) ; return 0 ; }", "docstring": "Golomb sequence | C ++ Program to find first n terms of Golomb sequence . ; Print the first n term of Golomb Sequence ; base cases ; Finding and printing first n terms of Golomb Sequence . ; Driver Code", "dfg": [["i", 47, "comesFrom", ["i"], [43]], ["i", 51, "comesFrom", ["i"], [43]], ["i", 57, "comesFrom", ["i"], [43]], ["i", 81, "comesFrom", ["i"], [43]], ["i", 64, "comesFrom", ["i"], [43]], ["i", 70, "comesFrom", ["i"], [43]], ["n", 49, "comesFrom", ["n"], [11]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 102, "comesFrom", ["n"], [96]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000 NEW_LINE long long arrangeBraces ( int n , int pos [ ] , int k ) { bool h [ N ] ; int dp [ N ] [ N ] ; memset ( h , 0 , sizeof h ) ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < k ; i ++ ) h [ pos [ i ] ] = 1 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 0 ; } else { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; } int main ( ) { int n = 3 ; int pos [ ] = { 2 } ; int k = sizeof ( pos ) / sizeof ( pos [ 0 ] ) ; cout << arrangeBraces ( n , pos , k ) ; return 0 ; }", "docstring": "Balanced expressions such that given positions have opening brackets | CPP code to find number of ways of arranging bracket with proper expressions ; function to calculate the number of proper bracket sequence ; hash array to mark the positions of opening brackets ; dp 2d array ; mark positions in hash array ; first position marked as 1 ; iterate and formulate the recurrences ; if position has a opening bracket ; return answer ; driver code ; positions where opening braces will be placed", "dfg": []}
{"code": "#include <iostream> NEW_LINE using namespace std ; int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : -1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = max ( current_sum , max_sum ) ; } return max_sum == 0 ? -1 : max_sum ; } int main ( ) { string s = \"11000010001\" ; int n = 11 ; cout << findLength ( s , n ) << endl ; return 0 ; }", "docstring": "Maximum difference of zeros and ones in binary string | Set 2 ( O ( n ) time ) | CPP Program to find the length of substring with maximum difference of zeros and ones in binary string . ; Returns the length of substring with maximum difference of zeroes and ones in binary string ; traverse a binary string from left to right ; add current value to the current_sum according to the Character if it ' s ▁ ' 0 ' add 1 else -1 ; update maximum sum ; return - 1 if string does not contain any zero that means all ones otherwise max_sum ; Driven Program", "dfg": [["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 47, "comesFrom", ["i"], [30]], ["n", 36, "comesFrom", ["n"], [14]], ["n", 112, "comesFrom", ["n"], [102]], ["max_sum", 86, "comesFrom", ["max_sum"], [69]], ["max_sum", 80, "comesFrom", ["max_sum"], [69]], ["max_sum", 75, "comesFrom", ["max_sum"], [69]], ["current_sum", 61, "comesFrom", ["current_sum"], [42]], ["current_sum", 73, "comesFrom", ["current_sum"], [65]], ["s", 110, "comesFrom", ["s"], [95]], ["str", 45, "comesFrom", ["str"], [11]]]}
{"code": "#include <cstring> NEW_LINE #include <iostream> NEW_LINE int static const DP_s = 9 ; int getNumStrictMonotone ( int len ) { int DP [ len ] [ DP_s ] ; memset ( DP , 0 , sizeof ( DP ) ) ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; } int main ( ) { std :: cout << getNumStrictMonotone ( 2 ) ; return 0 ; }", "docstring": "Number of decimal numbers of length k , that are strict monotone | CPP program to count numbers of k digits that are strictly monotone . ; DP [ i ] [ j ] is going to store monotone numbers of length i + 1 considering j + 1 digits ( 1 , 2 , 3 , . .9 ) ; Unit length numbers ; Building dp [ ] in bottom up ; Driver code", "dfg": [["DP_s", 26, "comesFrom", ["DP_s"], [9]], ["DP_s", 50, "comesFrom", ["DP_s"], [9]], ["DP_s", 90, "comesFrom", ["DP_s"], [9]], ["DP_s", 133, "comesFrom", ["DP_s"], [9]], ["i", 48, "comesFrom", ["i"], [44]], ["i", 53, "comesFrom", ["i"], [44]], ["i", 74, "comesFrom", ["i"], [70]], ["i", 79, "comesFrom", ["i"], [70]], ["i", 63, "comesFrom", ["i"], [44]], ["i", 60, "comesFrom", ["i"], [44]], ["i", 97, "comesFrom", ["i"], [70]], ["i", 117, "comesFrom", ["i"], [70]], ["i", 105, "comesFrom", ["i"], [70]], ["len", 76, "comesFrom", ["len"], [17]], ["len", 23, "comesFrom", ["len"], [17]], ["len", 128, "comesFrom", ["len"], [17]], ["j", 88, "comesFrom", ["j"], [84]], ["j", 93, "comesFrom", ["j"], [84]], ["j", 100, "comesFrom", ["j"], [84]], ["j", 110, "comesFrom", ["j"], [84]], ["j", 120, "comesFrom", ["j"], [84]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int chordCnt ( int A ) { int n = 2 * A ; int dpArray [ n + 1 ] = { 0 } ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; } int main ( ) { int N ; N = 2 ; cout << chordCnt ( N ) << ' ' ; N = 1 ; cout << chordCnt ( N ) << ' ' ; N = 4 ; cout << chordCnt ( N ) << ' ' ; return 0 ; }", "docstring": "Count ways to divide circle using N non | cpp code to count ways to divide circle using N non - intersecting chords . ; n = no of points required ; dp array containing the sum ; returning the required number ; Driver function", "dfg": [["i", 54, "comesFrom", ["i"], [50]], ["i", 72, "comesFrom", ["i"], [58]], ["i", 83, "comesFrom", ["i"], [58]], ["i", 94, "comesFrom", ["i"], [58]], ["n", 56, "comesFrom", ["n"], [15]], ["n", 107, "comesFrom", ["n"], [15]], ["n", 24, "comesFrom", ["n"], [15]], ["A", 19, "comesFrom", ["A"], [11]], ["j", 70, "comesFrom", ["j"], [66]], ["j", 89, "comesFrom", ["j"], [76]], ["j", 98, "comesFrom", ["j"], [76]], ["N", 127, "comesFrom", ["N"], [119]], ["N", 142, "comesFrom", ["N"], [134]], ["N", 157, "comesFrom", ["N"], [149]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; #define row  5 NEW_LINE #define col  5 NEW_LINE bool isPath ( int arr [ row ] [ col ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < row ; i ++ ) if ( arr [ i ] [ 0 ] != -1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < col ; j ++ ) if ( arr [ 0 ] [ j ] != -1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i < row ; i ++ ) for ( int j = 1 ; j < col ; j ++ ) if ( arr [ i ] [ j ] != -1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; } int main ( ) { int arr [ row ] [ col ] = { { 0 , 0 , 0 , -1 , 0 } , { -1 , 0 , 0 , -1 , -1 } , { 0 , 0 , 0 , -1 , 0 } , { -1 , 0 , -1 , 0 , -1 } , { 0 , 0 , -1 , 0 , 0 } } ; if ( isPath ( arr ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check for possible path in 2D matrix | C ++ program to find if there is path from top left to right bottom ; to find the path from top left to bottom right ; set arr [ 0 ] [ 0 ] = 1 ; Mark reachable ( from top left ) nodes in first row and first column . ; Mark reachable nodes in remaining matrix . ; return yes if right bottom index is 1 ; Driver Code ; Given array ; path from arr [ 0 ] [ 0 ] to arr [ row ] [ col ]", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; } int main ( ) { int n = 3 ; cout << nswp ( n ) << endl ; return 0 ; }", "docstring": "Newmanâ €“ Shanksâ €“ Williams prime | CPP Program to find NewmanaShanksaWilliams prime ; return nth NewmanaShanksaWilliams prime ; Base case ; Recursive step ; Driven Program", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 38, "comesFrom", ["n"], [11]], ["n", 58, "comesFrom", ["n"], [50]], ["n", 31, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nswp ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; } int main ( ) { int n = 3 ; cout << nswp ( n ) << endl ; return 0 ; }", "docstring": "Newman Shanks Williams prime | CPP Program to find Newman Shanks Williams prime ; return nth Newman Shanks Williams prime ; Base case ; Finding nth Newman Shanks Williams prime ; Driver Program", "dfg": [["i", 41, "comesFrom", ["i"], [37]], ["i", 45, "comesFrom", ["i"], [37]], ["i", 50, "comesFrom", ["i"], [37]], ["i", 64, "comesFrom", ["i"], [37]], ["i", 57, "comesFrom", ["i"], [37]], ["n", 43, "comesFrom", ["n"], [11]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 72, "comesFrom", ["n"], [11]], ["n", 90, "comesFrom", ["n"], [82]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define MAX  256 NEW_LINE using namespace std ; int numberofways ( string A , string B , int N , int M ) { vector < int > pos [ MAX ] ; for ( int i = 0 ; i < M ; i ++ ) pos [ B [ i ] ] . push_back ( i + 1 ) ; int dpl [ N + 2 ] [ M + 2 ] ; memset ( dpl , 0 , sizeof ( dpl ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int LCS = dpl [ N ] [ M ] ; int dpr [ N + 2 ] [ M + 2 ] ; memset ( dpr , 0 , sizeof ( dpr ) ) ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { for ( auto x : pos [ j ] ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; } int main ( ) { string A = \" aa \" , B = \" baaa \" ; int N = A . length ( ) , M = B . length ( ) ; cout << numberofways ( A , B , N , M ) << endl ; return 0 ; }", "docstring": "Number of ways to insert a character to increase the LCS by one | CPP Program to Number of ways to insert a character to increase LCS by one ; Return the Number of ways to insert a character to increase the Longest Common Subsequence by one ; Insert all positions of all characters in string B . ; Longest Common Subsequence ; Longest Common Subsequence from reverse ; inserting character between position i and i + 1 ; Driver Program", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( X [ i - 1 ] - '0' ) ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } int findMinCost ( char X [ ] , char Y [ ] ) { int m = strlen ( X ) , n = strlen ( Y ) ; int cost = 0 ; for ( int i = 0 ; i < m ; ++ i ) cost += X [ i ] - '0' ; for ( int i = 0 ; i < n ; ++ i ) cost += Y [ i ] - '0' ; return cost - lcs ( X , Y , m , n ) ; } int main ( ) { char X [ ] = \"3759\" ; char Y [ ] = \"9350\" ; cout << \" Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ \" << \" identical ▁ is ▁ = ▁ \" << findMinCost ( X , Y ) ; return 0 ; }", "docstring": "Minimum cost to make two strings identical by deleting the digits | C ++ code to find minimum cost to make two strings identical ; Function to returns cost of removing the identical characters in LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains cost of removing identical characters in LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; If both characters are same , add both of them ; Otherwise find the maximum cost among them ; Returns cost of making X [ ] and Y [ ] identical ; Find LCS of X [ ] and Y [ ] ; Initialize the cost variable ; Find cost of all characters in both strings ; Driver program to test above function", "dfg": [["i", 45, "comesFrom", ["i"], [41]], ["i", 50, "comesFrom", ["i"], [41]], ["i", 224, "comesFrom", ["i"], [220]], ["i", 229, "comesFrom", ["i"], [220]], ["i", 249, "comesFrom", ["i"], [245]], ["i", 254, "comesFrom", ["i"], [245]], ["i", 235, "comesFrom", ["i"], [220]], ["i", 260, "comesFrom", ["i"], [245]], ["i", 70, "comesFrom", ["i"], [41]], ["i", 79, "comesFrom", ["i"], [41]], ["i", 92, "comesFrom", ["i"], [41]], ["i", 106, "comesFrom", ["i"], [41]], ["i", 142, "comesFrom", ["i"], [41]], ["i", 114, "comesFrom", ["i"], [41]], ["i", 162, "comesFrom", ["i"], [41]], ["i", 129, "comesFrom", ["i"], [41]], ["i", 152, "comesFrom", ["i"], [41]], ["m", 47, "comesFrom", ["m"], [19]], ["m", 226, "comesFrom", ["m"], [198]], ["m", 28, "comesFrom", ["m"], [19]], ["m", 176, "comesFrom", ["m"], [19]], ["m", 276, "comesFrom", ["m"], [198]], ["n", 251, "comesFrom", ["n"], [205]], ["n", 33, "comesFrom", ["n"], [22]], ["n", 179, "comesFrom", ["n"], [22]], ["n", 62, "comesFrom", ["n"], [22]], ["n", 278, "comesFrom", ["n"], [205]], ["cost", 268, "comesFrom", ["cost"], [256]], ["j", 60, "comesFrom", ["j"], [56]], ["j", 64, "comesFrom", ["j"], [56]], ["j", 73, "comesFrom", ["j"], [56]], ["j", 82, "comesFrom", ["j"], [56]], ["j", 109, "comesFrom", ["j"], [56]], ["j", 99, "comesFrom", ["j"], [56]], ["j", 145, "comesFrom", ["j"], [56]], ["j", 119, "comesFrom", ["j"], [56]], ["j", 157, "comesFrom", ["j"], [56]], ["j", 165, "comesFrom", ["j"], [56]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSubSeqDivisible ( string str ) { int l = str . length ( ) ; int arr [ l ] ; for ( int i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - '0' ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j ++ ) { for ( int k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; } int main ( ) { string str = \"3144\" ; if ( isSubSeqDivisible ( str ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Given a large number , check if a subsequence of digits is divisible by 8 | C ++ program to check if a subsequence of digits is divisible by 8. ; Function to calculate any permutation divisible by 8. If such permutation exists , the function will return that permutation else it will return - 1 ; Converting string to integer array for ease of computations ( Indexing in arr [ ] is considered to be starting from 1 ) ; Generating all possible permutations and checking if any such permutation is divisible by 8 ; Driver function", "dfg": [["l", 26, "comesFrom", ["l"], [15]], ["l", 38, "comesFrom", ["l"], [15]], ["l", 66, "comesFrom", ["l"], [15]], ["l", 81, "comesFrom", ["l"], [15]], ["l", 96, "comesFrom", ["l"], [15]], ["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 64, "comesFrom", ["i"], [60]], ["i", 68, "comesFrom", ["i"], [60]], ["i", 45, "comesFrom", ["i"], [32]], ["i", 50, "comesFrom", ["i"], [32]], ["i", 106, "comesFrom", ["i"], [77]], ["i", 137, "comesFrom", ["i"], [77]], ["i", 180, "comesFrom", ["i"], [77]], ["i", 172, "comesFrom", ["i"], [77]], ["i", 122, "comesFrom", ["i"], [77]], ["i", 150, "comesFrom", ["i"], [77]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 210, "comesFrom", ["str"], [200]], ["str", 48, "comesFrom", ["str"], [11]], ["j", 79, "comesFrom", ["j"], [75]], ["j", 83, "comesFrom", ["j"], [75]], ["j", 139, "comesFrom", ["j"], [92]], ["j", 176, "comesFrom", ["j"], [92]], ["j", 174, "comesFrom", ["j"], [92]], ["j", 129, "comesFrom", ["j"], [92]], ["j", 157, "comesFrom", ["j"], [92]], ["k", 94, "comesFrom", ["k"], [90]], ["k", 98, "comesFrom", ["k"], [90]], ["k", 182, "comesFrom", ["k"], [90]], ["k", 178, "comesFrom", ["k"], [90]], ["k", 164, "comesFrom", ["k"], [90]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSubSeqDivisible ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ 10 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int arr [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = str [ i - 1 ] - '0' ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; } int main ( ) { string str = \"3144\" ; if ( isSubSeqDivisible ( str ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Given a large number , check if a subsequence of digits is divisible by 8 | C ++ program to find if there is a subsequence of digits divisible by 8. ; Function takes in an array of numbers , dynamically goes on the location and makes combination of numbers . ; Converting string to integer array for ease of computations ( Indexing in arr [ ] is considered to be starting from 1 ) ; If we consider the number in our combination , we add it to the previous combination ; If we exclude the number from our combination ; If at dp [ i ] [ 0 ] , we find value 1 / true , it shows that the number exists at the value of ' i ' ; Driver function", "dfg": [["i", 61, "comesFrom", ["i"], [57]], ["i", 65, "comesFrom", ["i"], [57]], ["i", 91, "comesFrom", ["i"], [87]], ["i", 95, "comesFrom", ["i"], [87]], ["i", 236, "comesFrom", ["i"], [232]], ["i", 240, "comesFrom", ["i"], [232]], ["i", 70, "comesFrom", ["i"], [57]], ["i", 75, "comesFrom", ["i"], [57]], ["i", 101, "comesFrom", ["i"], [87]], ["i", 248, "comesFrom", ["i"], [232]], ["i", 106, "comesFrom", ["i"], [87]], ["i", 143, "comesFrom", ["i"], [87]], ["i", 162, "comesFrom", ["i"], [87]], ["i", 203, "comesFrom", ["i"], [87]], ["i", 211, "comesFrom", ["i"], [87]], ["i", 133, "comesFrom", ["i"], [87]], ["i", 181, "comesFrom", ["i"], [87]], ["i", 193, "comesFrom", ["i"], [87]], ["i", 219, "comesFrom", ["i"], [87]], ["i", 153, "comesFrom", ["i"], [87]], ["i", 172, "comesFrom", ["i"], [87]], ["n", 63, "comesFrom", ["n"], [15]], ["n", 93, "comesFrom", ["n"], [15]], ["n", 238, "comesFrom", ["n"], [15]], ["n", 49, "comesFrom", ["n"], [15]], ["n", 26, "comesFrom", ["n"], [15]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 280, "comesFrom", ["str"], [270]], ["str", 73, "comesFrom", ["str"], [11]], ["j", 121, "comesFrom", ["j"], [117]], ["j", 125, "comesFrom", ["j"], [117]], ["j", 138, "comesFrom", ["j"], [117]], ["j", 186, "comesFrom", ["j"], [117]], ["j", 198, "comesFrom", ["j"], [117]], ["j", 206, "comesFrom", ["j"], [117]], ["j", 214, "comesFrom", ["j"], [117]], ["j", 224, "comesFrom", ["j"], [117]], ["j", 147, "comesFrom", ["j"], [117]], ["j", 166, "comesFrom", ["j"], [117]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { string str = \"129365\" ; map < int , int > mp ; int no = 8 ; while ( no < 100 ) { no = no + 8 ; mp . insert ( { ( no / 10 ) % 10 , no % 10 } ) ; } vector < bool > visited ( 10 , false ) ; int i ; for ( i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '8' ) { cout << \" Yes \" ; break ; } if ( visited [ mp [ str [ i ] - '0' ] ] ) { cout << \" Yes \" ; break ; } visited [ str [ i ] - '0' ] = true ; } if ( i == -1 ) cout << \" No \" ; return 0 ; }", "docstring": "Given a large number , check if a subsequence of digits is divisible by 8 | C ++ program to check if given string has a subsequence divisible by 8 ; Driver function ; map key will be tens place digit of number that is divisible by 8 and value will be units place digit ; For filling the map let start with initial value 8 ; key is digit at tens place and value is digit at units place mp . insert ( { key , value } ) ; Create a hash to check if we visited a number ; Iterate from last index to 0 th index ; If 8 is present in string then 8 divided 8 hence print yes ; considering present character as the second digit of two digits no we check if the value of this key is marked in hash or not If marked then we a have a number divisible by 8 ; If no subsequence divisible by 8", "dfg": [["i", 91, "comesFrom", ["i"], [81]], ["i", 95, "comesFrom", ["i"], [81]], ["i", 164, "comesFrom", ["i"], [81]], ["i", 103, "comesFrom", ["i"], [81]], ["i", 151, "comesFrom", ["i"], [81]], ["i", 128, "comesFrom", ["i"], [81]], ["no", 34, "comesFrom", ["no"], [28]], ["no", 41, "comesFrom", ["no"], [39]], ["no", 58, "comesFrom", ["no"], [39]], ["no", 51, "comesFrom", ["no"], [39]], ["mp", 45, "comesFrom", ["mp"], [25]], ["mp", 124, "comesFrom", ["mp"], [25]], ["str", 83, "comesFrom", ["str"], [13]], ["str", 101, "comesFrom", ["str"], [13]], ["str", 149, "comesFrom", ["str"], [13]], ["str", 126, "comesFrom", ["str"], [13]], ["visited", 122, "comesFrom", ["visited"], [69]], ["visited", 147, "comesFrom", ["visited"], [69]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( char s [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; } int main ( ) { char s [ ] = \" ( ) ( ( ( ( ( ( ) \" ; int n = strlen ( s ) ; cout << maxLength ( s , n ) << endl ; return 0 ; }", "docstring": "Length of Longest Balanced Subsequence | C ++ program to find length of the longest balanced subsequence ; Considering all balanced substrings of length 2 ; Considering all other substrings ; Driver Code", "dfg": [["n", 25, "comesFrom", ["n"], [16]], ["n", 103, "comesFrom", ["n"], [16]], ["n", 22, "comesFrom", ["n"], [16]], ["n", 49, "comesFrom", ["n"], [16]], ["n", 122, "comesFrom", ["n"], [16]], ["n", 236, "comesFrom", ["n"], [16]], ["n", 270, "comesFrom", ["n"], [257]], ["i", 47, "comesFrom", ["i"], [43]], ["i", 53, "comesFrom", ["i"], [43]], ["i", 124, "comesFrom", ["i"], [112]], ["i", 60, "comesFrom", ["i"], [43]], ["i", 84, "comesFrom", ["i"], [43]], ["i", 87, "comesFrom", ["i"], [43]], ["i", 71, "comesFrom", ["i"], [43]], ["i", 135, "comesFrom", ["i"], [112]], ["i", 157, "comesFrom", ["i"], [112]], ["i", 193, "comesFrom", ["i"], [182]], ["i", 167, "comesFrom", ["i"], [112]], ["i", 203, "comesFrom", ["i"], [182]], ["i", 211, "comesFrom", ["i"], [182]], ["l", 101, "comesFrom", ["l"], [97]], ["l", 105, "comesFrom", ["l"], [97]], ["j", 120, "comesFrom", ["j"], [116]], ["j", 127, "comesFrom", ["j"], [116]], ["j", 186, "comesFrom", ["j"], [116]], ["j", 160, "comesFrom", ["j"], [116]], ["j", 196, "comesFrom", ["j"], [116]], ["j", 146, "comesFrom", ["j"], [116]], ["j", 172, "comesFrom", ["j"], [116]], ["j", 206, "comesFrom", ["j"], [116]], ["j", 224, "comesFrom", ["j"], [116]], ["k", 184, "comesFrom", ["k"], [180]], ["k", 188, "comesFrom", ["k"], [180]], ["k", 214, "comesFrom", ["k"], [180]], ["k", 219, "comesFrom", ["k"], [180]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumBitonicSubArr ( int arr [ ] , int n ) { int max_sum = INT_MIN ; int i = 0 ; while ( i < n ) { int j = i ; while ( j + 1 < n && arr [ j ] < arr [ j + 1 ] ) j ++ ; while ( i < j && arr [ i ] <= 0 ) i ++ ; int k = j ; while ( k + 1 < n && arr [ k ] > arr [ k + 1 ] ) k ++ ; int last = k ; while ( k > j && arr [ k ] <= 0 ) k -- ; int sum_inc = accumulate ( arr + i , arr + j + 1 , 0 ) ; int sum_dec = accumulate ( arr + j , arr + k + 1 , 0 ) ; int sum_all = sum_inc + sum_dec - arr [ j ] ; max_sum = max ( { max_sum , sum_inc , sum_dec , sum_all } ) ; i = max ( last , i + 1 ) ; } return max_sum ; } int main ( ) { int arr [ ] = { 5 , 3 , 9 , 2 , 7 , 6 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Maximum ▁ Sum ▁ = ▁ \" << maxSumBitonicSubArr ( arr , n ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << \" Maximum ▁ Sum ▁ = ▁ \" << maxSumBitonicSubArr ( arr2 , n2 ) << endl ; int arr3 [ ] = { 5 , 4 , 3 , 2 , 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << \" Maximum ▁ Sum ▁ = ▁ \" << maxSumBitonicSubArr ( arr3 , n3 ) << endl ; int arr4 [ ] = { 5 , 5 , 5 , 5 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << \" Maximum ▁ Sum ▁ = ▁ \" << maxSumBitonicSubArr ( arr4 , n4 ) << endl ; int arr5 [ ] = { -1 , 0 , 1 , 2 , 3 , 1 , 0 , -1 , -10 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << \" Maximum ▁ Sum ▁ = ▁ \" << maxSumBitonicSubArr ( arr5 , n5 ) << endl ; int arr6 [ ] = { -1 , 0 , 1 , 2 , 0 , -1 , -2 , 0 , 1 , 3 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << \" Maximum ▁ Sum ▁ = ▁ \" << maxSumBitonicSubArr ( arr6 , n6 ) << endl ; return 0 ; }", "docstring": "Maximum sum bitonic subarray | C ++ implementation to find the maximum sum bitonic subarray ; Function to find the maximum sum bitonic subarray . ; to store the maximum sum bitonic subarray ; Find the longest increasing subarray starting at i . ; Now we know that a [ i . . j ] is an increasing subarray . Remove non - positive elements from the left side as much as possible . ; Find the longest decreasing subarray starting at j . ; Now we know that a [ j . . k ] is a decreasing subarray . Remove non - positive elements from the right side as much as possible . last is needed to keep the last seen element . ; Compute the max sum of the increasing part . ; Compute the max sum of the decreasing part . ; The overall max sum is the sum of both parts minus the peak element , because it was counted twice . ; If the next element is equal to the current , i . e . arr [ i + 1 ] == arr [ i ] , last == i . To ensure the algorithm has progress , get the max of last and i + 1. ; required maximum sum ; Driver program to test above ; The example from the article , the answer is 19. ; Always increasing , the answer is 15. ; Always decreasing , the answer is 15. ; All are equal , the answer is 5. ; The whole array is bitonic , but the answer is 7. ; The answer is 4 ( the tail ) .", "dfg": [["max_sum", 205, "comesFrom", ["max_sum"], [177]], ["max_sum", 182, "comesFrom", ["max_sum"], [177]], ["i", 31, "comesFrom", ["i"], [25]], ["i", 77, "comesFrom", ["i"], [39]], ["i", 66, "comesFrom", ["i"], [39]], ["i", 136, "comesFrom", ["i"], [39]], ["i", 198, "comesFrom", ["i"], [192]], ["i", 72, "comesFrom", ["i"], [39]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 260, "comesFrom", ["n"], [235]], ["n", 47, "comesFrom", ["n"], [16]], ["n", 91, "comesFrom", ["n"], [16]], ["j", 61, "comesFrom", ["j"], [37]], ["j", 68, "comesFrom", ["j"], [37]], ["j", 117, "comesFrom", ["j"], [83]], ["j", 43, "comesFrom", ["j"], [37]], ["j", 154, "comesFrom", ["j"], [83]], ["j", 174, "comesFrom", ["j"], [83]], ["j", 51, "comesFrom", ["j"], [37]], ["j", 140, "comesFrom", ["j"], [83]], ["j", 56, "comesFrom", ["j"], [37]], ["k", 105, "comesFrom", ["k"], [81]], ["k", 126, "comesFrom", ["k"], [111]], ["k", 115, "comesFrom", ["k"], [111]], ["k", 87, "comesFrom", ["k"], [81]], ["k", 95, "comesFrom", ["k"], [81]], ["k", 121, "comesFrom", ["k"], [111]], ["k", 158, "comesFrom", ["k"], [111]], ["k", 100, "comesFrom", ["k"], [81]], ["n2", 308, "comesFrom", ["n2"], [283]], ["n3", 356, "comesFrom", ["n3"], [331]], ["n4", 402, "comesFrom", ["n4"], [377]], ["n5", 458, "comesFrom", ["n5"], [433]], ["n6", 516, "comesFrom", ["n6"], [491]], ["sum_inc", 168, "comesFrom", ["sum_inc"], [130]], ["sum_inc", 184, "comesFrom", ["sum_inc"], [130]], ["sum_dec", 170, "comesFrom", ["sum_dec"], [148]], ["sum_dec", 186, "comesFrom", ["sum_dec"], [148]], ["last", 196, "comesFrom", ["last"], [109]], ["sum_all", 188, "comesFrom", ["sum_all"], [166]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = INT_MAX ; int min_so_far = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = min ( min_so_far , min_ending_here ) ; } return min_so_far ; } int main ( ) { int arr [ ] = { 3 , -4 , 2 , -3 , -1 , 7 , -5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Smallest ▁ sum : ▁ \" << smallestSumSubarr ( arr , n ) ; return 0 ; }", "docstring": "Smallest sum contiguous subarray | C ++ implementation to find the smallest sum contiguous subarray ; function to find the smallest sum contiguous subarray ; to store the minimum value that is ending up to the current index ; to store the minimum value encountered so far ; traverse the array elements ; if min_ending_here > 0 , then it could not possibly contribute to the minimum sum further ; else add the value arr [ i ] to min_ending_here ; update min_so_far ; required smallest sum contiguous subarray value ; Driver program to test above", "dfg": [["min_so_far", 76, "comesFrom", ["min_so_far"], [65]], ["min_so_far", 69, "comesFrom", ["min_so_far"], [65]], ["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 54, "comesFrom", ["i"], [32]], ["i", 62, "comesFrom", ["i"], [32]], ["n", 38, "comesFrom", ["n"], [16]], ["n", 131, "comesFrom", ["n"], [106]], ["min_ending_here", 46, "comesFrom", ["min_ending_here"], [20]], ["min_ending_here", 71, "comesFrom", ["min_ending_here"], [58]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int ans ( int n ) { if ( n < 6 ) { return n ; } return n % 6 + 10 * ( ans ( n / 6 ) ) ; } int getSpecialNumber ( int N ) { return ans ( -- N ) ; } int main ( ) { int N = 17 ; int answer = getSpecialNumber ( N ) ; cout << answer << endl ; return 0 ; }", "docstring": "n | C ++ code to find nth number with digits 0 , 1 , 2 , 3 , 4 , 5 ; If the Number is less than 6 return the number as it is . ; Call the function again and again the get the desired result . And convert the number to base 6. ; Decrease the Number by 1 and Call ans function to convert N to base 6 ; Driver code", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 22, "comesFrom", ["n"], [11]], ["n", 26, "comesFrom", ["n"], [11]], ["n", 35, "comesFrom", ["n"], [11]], ["answer", 77, "comesFrom", ["answer"], [68]], ["N", 53, "comesFrom", ["N"], [46]], ["N", 72, "comesFrom", ["N"], [63]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 300 ; int dp [ MAX ] [ MAX ] ; int minimumSquare ( int m , int n ) { int vertical_min = INT_MAX ; int horizontal_min = INT_MAX ; if ( n == 13 && m == 11 ) return 6 ; if ( m == 13 && n == 11 ) return 6 ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] ) return dp [ m ] [ n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) ; return dp [ m ] [ n ] ; } int main ( ) { int m = 30 , n = 35 ; cout << minimumSquare ( m , n ) ; return 0 ; }", "docstring": "Paper Cut into Minimum Number of Squares | Set 2 | C ++ program to find minimum number of squares to cut a paper using Dynamic Programming ; Returns min number of squares needed ; Initializing max values to vertical_min and horizontal_min ; N = 11 & M = 13 is a special case ; If the given rectangle is already a square ; If the answer for the given rectangle is previously calculated return that answer ; The rectangle is cut horizontally and vertically into two parts and the cut with minimum value is found for every recursive call . ; Calculating the minimum answer for the rectangles with width equal to n and length less than m for finding the cut point for the minimum answer ; Calculating the minimum answer for the rectangles with width less than n and length equal to m for finding the cut point for the minimum answer ; Minimum of the vertical cut or horizontal cut to form a square is the answer ; Driver code ; Function call", "dfg": [["MAX", 19, "comesFrom", ["MAX"], [9]], ["MAX", 16, "comesFrom", ["MAX"], [9]], ["i", 103, "comesFrom", ["i"], [99]], ["i", 109, "comesFrom", ["i"], [99]], ["i", 119, "comesFrom", ["i"], [99]], ["i", 128, "comesFrom", ["i"], [99]], ["j", 144, "comesFrom", ["j"], [140]], ["j", 150, "comesFrom", ["j"], [140]], ["j", 162, "comesFrom", ["j"], [140]], ["j", 171, "comesFrom", ["j"], [140]], ["m", 70, "comesFrom", ["m"], [26]], ["m", 105, "comesFrom", ["m"], [26]], ["m", 48, "comesFrom", ["m"], [26]], ["m", 57, "comesFrom", ["m"], [26]], ["m", 196, "comesFrom", ["m"], [26]], ["m", 221, "comesFrom", ["m"], [209]], ["m", 81, "comesFrom", ["m"], [26]], ["m", 90, "comesFrom", ["m"], [26]], ["m", 180, "comesFrom", ["m"], [26]], ["m", 160, "comesFrom", ["m"], [26]], ["m", 167, "comesFrom", ["m"], [26]], ["m", 126, "comesFrom", ["m"], [26]], ["n", 72, "comesFrom", ["n"], [29]], ["n", 146, "comesFrom", ["n"], [29]], ["n", 199, "comesFrom", ["n"], [29]], ["n", 44, "comesFrom", ["n"], [29]], ["n", 61, "comesFrom", ["n"], [29]], ["n", 84, "comesFrom", ["n"], [29]], ["n", 93, "comesFrom", ["n"], [29]], ["n", 183, "comesFrom", ["n"], [29]], ["n", 223, "comesFrom", ["n"], [213]], ["n", 121, "comesFrom", ["n"], [29]], ["n", 130, "comesFrom", ["n"], [29]], ["n", 169, "comesFrom", ["n"], [29]], ["vertical_min", 188, "comesFrom", ["vertical_min"], [154]], ["vertical_min", 174, "comesFrom", ["vertical_min"], [154]], ["horizontal_min", 190, "comesFrom", ["horizontal_min"], [113]], ["horizontal_min", 133, "comesFrom", ["horizontal_min"], [113]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int fact ( int n ) { long long int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } long long int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } int main ( ) { int n = 2 ; cout << \" Number ▁ of ▁ Non - Decreasing ▁ digits : ▁ \" << nCr ( n + 9 , 9 ) ; return 0 ; }", "docstring": "Number of n | CPP program To calculate Number of n - digits non - decreasing integers Contributed by Parishrut Kushwaha ; Returns factorial of n ; returns nCr ; Driver code", "dfg": [["res", 44, "comesFrom", ["res"], [37]], ["res", 39, "comesFrom", ["res"], [37]], ["i", 30, "comesFrom", ["i"], [26]], ["i", 34, "comesFrom", ["i"], [26]], ["i", 41, "comesFrom", ["i"], [26]], ["n", 32, "comesFrom", ["n"], [13]], ["n", 62, "comesFrom", ["n"], [53]], ["n", 98, "comesFrom", ["n"], [86]], ["n", 73, "comesFrom", ["n"], [53]], ["r", 68, "comesFrom", ["r"], [56]], ["r", 75, "comesFrom", ["r"], [56]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; } int main ( ) { int n = 3 , k = 2 ; cout << countWays ( n , k ) << endl ; return 0 ; }", "docstring": "Painting Fence Algorithm | C ++ program for Painting Fence Algorithm ; Returns count of ways to color k posts using k colors ; There are k ways to color first post ; There are 0 ways for single post to violate ( same color ) and k ways to not violate ( different color ) ; Fill for 2 posts onwards ; Current same is same as previous diff ; We always have k - 1 choices for next post ; Total choices till i . ; Driver code", "dfg": [["total", 83, "comesFrom", ["total"], [71]], ["total", 57, "comesFrom", ["total"], [18]], ["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["n", 45, "comesFrom", ["n"], [11]], ["n", 104, "comesFrom", ["n"], [92]], ["diff", 53, "comesFrom", ["diff"], [32]], ["diff", 67, "comesFrom", ["diff"], [65]], ["diff", 76, "comesFrom", ["diff"], [65]], ["mod", 69, "comesFrom", ["mod"], [23]], ["mod", 79, "comesFrom", ["mod"], [23]], ["k", 106, "comesFrom", ["k"], [96]], ["k", 60, "comesFrom", ["k"], [34]], ["same", 74, "comesFrom", ["same"], [51]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfSubstrings ( string num ) { long long int mf = 1 ; for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; } int main ( ) { string num = \"6759\" ; cout << sumOfSubstrings ( num ) << endl ; return 0 ; }", "docstring": "Sum of all substrings of a string representing a number | Set 2 ( Constant Extra Space ) | C ++ program to print sum of all substring of a number represented as a string ; Returns sum of all substring of num ; Here traversing the array in reverse order . Initializing loop from last element . mf is multiplying factor . ; Each time sum is added to its previous sum . Multiplying the three factors as explained above . s [ i ] - '0' is done to convert char to int . ; Making new multiplying factor as explained above . ; Driver code to test above methods", "dfg": [["sum", 73, "comesFrom", ["sum"], [42]], ["i", 34, "comesFrom", ["i"], [24]], ["i", 38, "comesFrom", ["i"], [24]], ["i", 56, "comesFrom", ["i"], [24]], ["i", 47, "comesFrom", ["i"], [24]], ["mf", 61, "comesFrom", ["mf"], [17]], ["mf", 65, "comesFrom", ["mf"], [63]], ["num", 92, "comesFrom", ["num"], [82]], ["num", 26, "comesFrom", ["num"], [11]], ["num", 45, "comesFrom", ["num"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumWithK ( int a [ ] , int n , int k ) { int maxSum [ n ] ; maxSum [ 0 ] = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += a [ i ] ; int result = sum ; for ( int i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = max ( result , sum ) ; result = max ( result , sum + maxSum [ i - k ] ) ; } return result ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , -10 , -3 } ; int k = 4 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxSumWithK ( a , n , k ) ; return 0 ; }", "docstring": "Largest sum subarray with at | C ++ program to find largest subarray sum with at - least k elements in it . ; Returns maximum sum of a subarray with at - least k elements . ; maxSum [ i ] is going to store maximum sum till index i such that a [ i ] is part of the sum . ; We use Kadane 's algorithm to fill maxSum[]  Below code is taken from method 3 of  https:www.geeksforgeeks.org/largest-sum-contiguous-subarray/ ; Sum of first k elements ; Use the concept of sliding window ; Compute sum of k elements ending with a [ i ] . ; Update result if required ; Include maximum sum till [ i - k ] also if it increases overall max . ; Driver code", "dfg": [["result", 175, "comesFrom", ["result"], [157]], ["result", 152, "comesFrom", ["result"], [148]], ["result", 161, "comesFrom", ["result"], [157]], ["n", 25, "comesFrom", ["n"], [16]], ["n", 55, "comesFrom", ["n"], [16]], ["n", 126, "comesFrom", ["n"], [16]], ["n", 227, "comesFrom", ["n"], [206]], ["i", 53, "comesFrom", ["i"], [49]], ["i", 57, "comesFrom", ["i"], [49]], ["i", 98, "comesFrom", ["i"], [94]], ["i", 102, "comesFrom", ["i"], [94]], ["i", 124, "comesFrom", ["i"], [120]], ["i", 128, "comesFrom", ["i"], [120]], ["i", 109, "comesFrom", ["i"], [94]], ["i", 80, "comesFrom", ["i"], [49]], ["i", 67, "comesFrom", ["i"], [49]], ["i", 138, "comesFrom", ["i"], [120]], ["i", 143, "comesFrom", ["i"], [120]], ["i", 74, "comesFrom", ["i"], [49]], ["i", 167, "comesFrom", ["i"], [120]], ["k", 100, "comesFrom", ["k"], [19]], ["k", 229, "comesFrom", ["k"], [201]], ["k", 145, "comesFrom", ["k"], [122]], ["k", 169, "comesFrom", ["k"], [122]], ["curr_max", 83, "comesFrom", ["curr_max"], [61]], ["curr_max", 70, "comesFrom", ["curr_max"], [61]], ["sum", 134, "comesFrom", ["sum"], [132]], ["sum", 154, "comesFrom", ["sum"], [132]], ["sum", 163, "comesFrom", ["sum"], [132]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int arr [ ] , int m , int N ) { int count [ N + 1 ] ; memset ( count , 0 , sizeof ( count ) ) ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 6 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int N = 7 ; cout << \" Total ▁ number ▁ of ▁ ways ▁ = ▁ \" << countWays ( arr , m , N ) ; return 0 ; }", "docstring": "Ways to sum to N using array elements with repetition allowed | C ++ implementation to count ways to sum up to a given value N ; function to count the total number of ways to sum up to ' N ' ; base case ; count ways for all values up to ' N ' and store the result ; if i >= arr [ j ] then accumulate count for value ' i ' as ways to form value ' i - arr [ j ] ' ; required number of ways ; Driver code", "dfg": [["i", 56, "comesFrom", ["i"], [52]], ["i", 60, "comesFrom", ["i"], [52]], ["i", 79, "comesFrom", ["i"], [52]], ["i", 88, "comesFrom", ["i"], [52]], ["i", 93, "comesFrom", ["i"], [52]], ["N", 58, "comesFrom", ["N"], [19]], ["N", 25, "comesFrom", ["N"], [19]], ["N", 104, "comesFrom", ["N"], [19]], ["N", 159, "comesFrom", ["N"], [143]], ["j", 70, "comesFrom", ["j"], [66]], ["j", 74, "comesFrom", ["j"], [66]], ["j", 83, "comesFrom", ["j"], [66]], ["j", 97, "comesFrom", ["j"], [66]], ["m", 72, "comesFrom", ["m"], [16]], ["m", 157, "comesFrom", ["m"], [127]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; } int main ( ) { int m = 10 ; int n = 4 ; cout << \" Total ▁ number ▁ of ▁ possible ▁ sequences ▁ \" << getTotalNumberOfSequences ( m , n ) ; return 0 ; }", "docstring": "Sequences of given length where every element is more than or equal to twice of previous | C ++ program to count total number of special sequences of length n where ; Recursive function to find the number of special sequences ; A special sequence cannot exist if length n is more than the maximum value m . ; If n is 0 , found an empty special sequence ; There can be two possibilities : ( 1 ) Reduce last element value ( 2 ) Consider last element as m and reduce number of terms ; Driver code", "dfg": [["m", 19, "comesFrom", ["m"], [11]], ["m", 80, "comesFrom", ["m"], [63]], ["m", 38, "comesFrom", ["m"], [11]], ["m", 47, "comesFrom", ["m"], [11]], ["n", 21, "comesFrom", ["n"], [14]], ["n", 28, "comesFrom", ["n"], [14]], ["n", 42, "comesFrom", ["n"], [14]], ["n", 82, "comesFrom", ["n"], [68]], ["n", 51, "comesFrom", ["n"], [14]]]}
{"code": "#include <stdio.h> NEW_LINE int getTotalNumberOfSequences ( int m , int n ) { int T [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; } int main ( ) { int m = 10 ; int n = 4 ; printf ( \" Total ▁ number ▁ of ▁ possible ▁ sequences ▁ % d \" , getTotalNumberOfSequences ( m , n ) ) ; return 0 ; }", "docstring": "Sequences of given length where every element is more than or equal to twice of previous | C program to count total number of special sequences of length N where ; DP based function to find the number of special sequences ; define T and build in bottom manner to store number of special sequences of length n and maximum value m ; Base case : If length of sequence is 0 or maximum value is 0 , there cannot exist any special sequence ; if length of sequence is more than the maximum value , special sequence cannot exist ; If length of sequence is 1 then the number of special sequences is equal to the maximum value For example with maximum value 2 and length 1 , there can be 2 special sequences { 1 } , { 2 } ; otherwise calculate ; Driver Code", "dfg": [["i", 33, "comesFrom", ["i"], [29]], ["i", 39, "comesFrom", ["i"], [29]], ["i", 62, "comesFrom", ["i"], [29]], ["i", 82, "comesFrom", ["i"], [29]], ["i", 71, "comesFrom", ["i"], [29]], ["i", 111, "comesFrom", ["i"], [29]], ["i", 88, "comesFrom", ["i"], [29]], ["i", 105, "comesFrom", ["i"], [29]], ["i", 116, "comesFrom", ["i"], [29]], ["i", 124, "comesFrom", ["i"], [29]], ["i", 134, "comesFrom", ["i"], [29]], ["n", 21, "comesFrom", ["n"], [10]], ["n", 152, "comesFrom", ["n"], [10]], ["n", 52, "comesFrom", ["n"], [10]], ["n", 181, "comesFrom", ["n"], [167]], ["m", 35, "comesFrom", ["m"], [7]], ["m", 16, "comesFrom", ["m"], [7]], ["m", 149, "comesFrom", ["m"], [7]], ["m", 179, "comesFrom", ["m"], [162]], ["j", 50, "comesFrom", ["j"], [46]], ["j", 56, "comesFrom", ["j"], [46]], ["j", 65, "comesFrom", ["j"], [46]], ["j", 74, "comesFrom", ["j"], [46]], ["j", 84, "comesFrom", ["j"], [46]], ["j", 91, "comesFrom", ["j"], [46]], ["j", 99, "comesFrom", ["j"], [46]], ["j", 108, "comesFrom", ["j"], [46]], ["j", 119, "comesFrom", ["j"], [46]], ["j", 129, "comesFrom", ["j"], [46]], ["j", 139, "comesFrom", ["j"], [46]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcs ( string str1 , string str2 , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( str1 . at ( i - 1 ) == str2 . at ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } void printMinDelAndInsert ( string str1 , string str2 ) { int m = str1 . size ( ) ; int n = str2 . size ( ) ; int len = lcs ( str1 , str2 , m , n ) ; cout << \" Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ \" << ( m - len ) << endl ; cout << \" Minimum ▁ number ▁ of ▁ insertions ▁ = ▁ \" << ( n - len ) << endl ; } int main ( ) { string str1 = \" heap \" ; string str2 = \" pea \" ; printMinDelAndInsert ( str1 , str2 ) ; return 0 ; }", "docstring": "Minimum number of deletions and insertions to transform one string into another | Dynamic Programming C ++ implementation to find minimum number of deletions and insertions ; Returns length of length common subsequence for str1 [ 0. . m - 1 ] , str2 [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains length of LCS of str1 [ 0. . i - 1 ] and str2 [ 0. . j - 1 ] ; L [ m ] [ n ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; function to find minimum number of deletions and insertions ; Driver Code ; Function Call", "dfg": [["i", 47, "comesFrom", ["i"], [43]], ["i", 51, "comesFrom", ["i"], [43]], ["i", 71, "comesFrom", ["i"], [43]], ["i", 80, "comesFrom", ["i"], [43]], ["i", 95, "comesFrom", ["i"], [43]], ["i", 111, "comesFrom", ["i"], [43]], ["i", 134, "comesFrom", ["i"], [43]], ["i", 119, "comesFrom", ["i"], [43]], ["i", 154, "comesFrom", ["i"], [43]], ["i", 144, "comesFrom", ["i"], [43]], ["m", 49, "comesFrom", ["m"], [17]], ["m", 26, "comesFrom", ["m"], [17]], ["m", 168, "comesFrom", ["m"], [17]], ["m", 212, "comesFrom", ["m"], [186]], ["m", 224, "comesFrom", ["m"], [186]], ["n", 31, "comesFrom", ["n"], [20]], ["n", 171, "comesFrom", ["n"], [20]], ["n", 63, "comesFrom", ["n"], [20]], ["n", 214, "comesFrom", ["n"], [195]], ["n", 238, "comesFrom", ["n"], [195]], ["str1", 267, "comesFrom", ["str1"], [252]], ["str1", 188, "comesFrom", ["str1"], [179]], ["str1", 208, "comesFrom", ["str1"], [179]], ["str1", 91, "comesFrom", ["str1"], [11]], ["str2", 269, "comesFrom", ["str2"], [259]], ["str2", 197, "comesFrom", ["str2"], [182]], ["str2", 210, "comesFrom", ["str2"], [182]], ["str2", 100, "comesFrom", ["str2"], [14]], ["j", 61, "comesFrom", ["j"], [57]], ["j", 65, "comesFrom", ["j"], [57]], ["j", 74, "comesFrom", ["j"], [57]], ["j", 83, "comesFrom", ["j"], [57]], ["j", 114, "comesFrom", ["j"], [57]], ["j", 104, "comesFrom", ["j"], [57]], ["j", 137, "comesFrom", ["j"], [57]], ["j", 124, "comesFrom", ["j"], [57]], ["j", 149, "comesFrom", ["j"], [57]], ["j", 157, "comesFrom", ["j"], [57]], ["len", 226, "comesFrom", ["len"], [204]], ["len", 240, "comesFrom", ["len"], [204]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int lis ( int arr [ ] , int n ) { int result = 0 ; int lis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; } int minimumNumberOfDeletions ( int arr [ ] , int n ) { int len = lis ( arr , n ) ; return ( n - len ) ; } int main ( ) { int arr [ ] = { 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ \" << minimumNumberOfDeletions ( arr , n ) ; return 0 ; }", "docstring": "Minimum number of deletions to make a sorted sequence | C ++ implementation to find minimum number of deletions to make a sorted sequence ; lis ( ) returns the length of the longest increasing subsequence in arr [ ] of size n ; Initialize LIS values for all indexes ; Compute optimized LIS values in bottom up manner ; Pick resultimum of all LIS values ; function to calculate minimum number of deletions ; Find longest increasing subsequence ; After removing elements other than the lis , we get sorted sequence . ; Driver Code", "dfg": [["result", 146, "comesFrom", ["result"], [138]], ["result", 131, "comesFrom", ["result"], [20]], ["n", 27, "comesFrom", ["n"], [16]], ["n", 39, "comesFrom", ["n"], [16]], ["n", 60, "comesFrom", ["n"], [16]], ["n", 124, "comesFrom", ["n"], [16]], ["n", 173, "comesFrom", ["n"], [158]], ["n", 168, "comesFrom", ["n"], [158]], ["n", 235, "comesFrom", ["n"], [210]], ["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 58, "comesFrom", ["i"], [54]], ["i", 62, "comesFrom", ["i"], [54]], ["i", 122, "comesFrom", ["i"], [118]], ["i", 126, "comesFrom", ["i"], [118]], ["i", 74, "comesFrom", ["i"], [54]], ["i", 46, "comesFrom", ["i"], [33]], ["i", 135, "comesFrom", ["i"], [118]], ["i", 142, "comesFrom", ["i"], [118]], ["i", 105, "comesFrom", ["i"], [54]], ["i", 83, "comesFrom", ["i"], [54]], ["i", 93, "comesFrom", ["i"], [54]], ["j", 72, "comesFrom", ["j"], [68]], ["j", 76, "comesFrom", ["j"], [68]], ["j", 88, "comesFrom", ["j"], [68]], ["j", 110, "comesFrom", ["j"], [68]], ["j", 98, "comesFrom", ["j"], [68]], ["len", 175, "comesFrom", ["len"], [162]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; const int inf = 1000000000 ; int minCost ( int a [ ] , int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; } int main ( ) { int k = 2 ; int a [ ] = { 1 , 5 , 8 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minCost ( a , n , k ) << endl ; return 0 ; }", "docstring": "Clustering / Partitioning an array such that sum of square differences is minimum | C ++ program to find minimum cost k partitions of array . ; Returns minimum cost of partitioning a [ ] in k clusters . ; Create a dp [ ] [ ] table and initialize all values as infinite . dp [ i ] [ j ] is going to store optimal partition cost for arr [ 0. . i - 1 ] and j partitions ; Fill dp [ ] [ ] in bottom up manner ; Current ending position ( After i - th iteration result for a [ 0. . i - 1 ] is computed . ; j is number of partitions ; Picking previous partition for current i . ; Driver code", "dfg": [["i", 48, "comesFrom", ["i"], [44]], ["i", 52, "comesFrom", ["i"], [44]], ["i", 96, "comesFrom", ["i"], [92]], ["i", 100, "comesFrom", ["i"], [92]], ["i", 122, "comesFrom", ["i"], [92]], ["i", 71, "comesFrom", ["i"], [44]], ["i", 135, "comesFrom", ["i"], [92]], ["i", 145, "comesFrom", ["i"], [92]], ["i", 164, "comesFrom", ["i"], [92]], ["i", 178, "comesFrom", ["i"], [92]], ["n", 50, "comesFrom", ["n"], [22]], ["n", 98, "comesFrom", ["n"], [22]], ["n", 31, "comesFrom", ["n"], [22]], ["n", 193, "comesFrom", ["n"], [22]], ["n", 247, "comesFrom", ["n"], [226]], ["k", 36, "comesFrom", ["k"], [25]], ["k", 64, "comesFrom", ["k"], [25]], ["k", 112, "comesFrom", ["k"], [25]], ["k", 196, "comesFrom", ["k"], [25]], ["k", 249, "comesFrom", ["k"], [206]], ["j", 62, "comesFrom", ["j"], [58]], ["j", 66, "comesFrom", ["j"], [58]], ["j", 110, "comesFrom", ["j"], [106]], ["j", 114, "comesFrom", ["j"], [106]], ["j", 74, "comesFrom", ["j"], [58]], ["j", 138, "comesFrom", ["j"], [106]], ["j", 148, "comesFrom", ["j"], [106]], ["j", 156, "comesFrom", ["j"], [106]], ["inf", 77, "comesFrom", ["inf"], [9]], ["m", 126, "comesFrom", ["m"], [120]], ["m", 130, "comesFrom", ["m"], [120]], ["m", 153, "comesFrom", ["m"], [120]], ["m", 171, "comesFrom", ["m"], [120]], ["m", 185, "comesFrom", ["m"], [120]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int lps ( string str ) { int n = str . size ( ) ; int L [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } int minimumNumberOfDeletions ( string str ) { int n = str . size ( ) ; int len = lps ( str ) ; return ( n - len ) ; } int main ( ) { string str = \" geeksforgeeks \" ; cout << \" Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ \" << minimumNumberOfDeletions ( str ) ; return 0 ; }", "docstring": "Minimum number of deletions to make a string palindrome | C ++ implementation to find minimum number of deletions to make a string palindromic ; Returns the length of the longest palindromic subsequence in ' str ' ; Create a table to store results of subproblems ; Strings of length 1 are palindrome of length 1 ; Build the table . Note that the lower diagonal values of table are useless and not filled in the process . c1 is length of substring ; length of longest palindromic subseq ; function to calculate minimum number of deletions ; Find longest palindromic subsequence ; After removing characters other than the lps , we get palindrome . ; Driver Code", "dfg": [["n", 29, "comesFrom", ["n"], [15]], ["n", 41, "comesFrom", ["n"], [15]], ["n", 65, "comesFrom", ["n"], [15]], ["n", 26, "comesFrom", ["n"], [15]], ["n", 232, "comesFrom", ["n"], [214]], ["n", 200, "comesFrom", ["n"], [15]], ["n", 80, "comesFrom", ["n"], [15]], ["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 78, "comesFrom", ["i"], [74]], ["i", 86, "comesFrom", ["i"], [74]], ["i", 51, "comesFrom", ["i"], [35]], ["i", 48, "comesFrom", ["i"], [35]], ["i", 93, "comesFrom", ["i"], [74]], ["i", 103, "comesFrom", ["i"], [74]], ["i", 117, "comesFrom", ["i"], [74]], ["i", 130, "comesFrom", ["i"], [74]], ["i", 140, "comesFrom", ["i"], [74]], ["i", 163, "comesFrom", ["i"], [74]], ["i", 148, "comesFrom", ["i"], [74]], ["i", 173, "comesFrom", ["i"], [74]], ["i", 183, "comesFrom", ["i"], [74]], ["cl", 63, "comesFrom", ["cl"], [59]], ["cl", 67, "comesFrom", ["cl"], [59]], ["cl", 82, "comesFrom", ["cl"], [59]], ["cl", 95, "comesFrom", ["cl"], [59]], ["cl", 111, "comesFrom", ["cl"], [59]], ["len", 234, "comesFrom", ["len"], [223]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 216, "comesFrom", ["str"], [210]], ["str", 227, "comesFrom", ["str"], [210]], ["str", 258, "comesFrom", ["str"], [244]], ["str", 101, "comesFrom", ["str"], [11]], ["str", 106, "comesFrom", ["str"], [11]], ["str", 128, "comesFrom", ["str"], [11]], ["str", 133, "comesFrom", ["str"], [11]], ["j", 120, "comesFrom", ["j"], [91]], ["j", 108, "comesFrom", ["j"], [91]], ["j", 135, "comesFrom", ["j"], [91]], ["j", 143, "comesFrom", ["j"], [91]], ["j", 166, "comesFrom", ["j"], [91]], ["j", 153, "comesFrom", ["j"], [91]], ["j", 188, "comesFrom", ["j"], [91]], ["j", 176, "comesFrom", ["j"], [91]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int offeringNumber ( int n , int templeHeight [ ] ) { for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += max ( right , left ) + 1 ; } return sum ; } int main ( ) { int arr1 [ 3 ] = { 1 , 2 , 2 } ; cout << offeringNumber ( 3 , arr1 ) << \" STRNEWLINE \" ; int arr2 [ 6 ] = { 1 , 4 , 3 , 6 , 2 , 1 } ; cout << offeringNumber ( 6 , arr2 ) << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Temple Offerings | Program to find minimum total offerings required ; Returns minimum offerings required ; Go through all templs one by one ; Go to left while height keeps increasing ; Go to right while height keeps increasing ; This temple should offer maximum of two values to follow the rule . ; Driver code", "dfg": [["sum", 132, "comesFrom", ["sum"], [119]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 31, "comesFrom", ["i"], [22]], ["i", 48, "comesFrom", ["i"], [22]], ["i", 86, "comesFrom", ["i"], [22]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 92, "comesFrom", ["n"], [11]], ["j", 52, "comesFrom", ["j"], [46]], ["j", 57, "comesFrom", ["j"], [46]], ["j", 90, "comesFrom", ["j"], [84]], ["j", 95, "comesFrom", ["j"], [84]], ["j", 64, "comesFrom", ["j"], [46]], ["j", 102, "comesFrom", ["j"], [84]], ["j", 69, "comesFrom", ["j"], [46]], ["j", 107, "comesFrom", ["j"], [84]], ["left", 75, "comesFrom", ["left"], [35]], ["left", 125, "comesFrom", ["left"], [35]], ["right", 113, "comesFrom", ["right"], [39]], ["right", 123, "comesFrom", ["right"], [39]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; bool DP [ m ] ; memset ( DP , false , m ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool temp [ m ] ; memset ( temp , false , m ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; } int main ( ) { int arr [ ] = { 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 5 ; modularSum ( arr , n , m ) ? cout << \" YES STRNEWLINE \" : cout << \" NO STRNEWLINE \" ; return 0 ; }", "docstring": "Subset with sum divisible by m | C ++ program to check if there is a subset with sum divisible by m . ; Returns true if there is a subset of arr [ ] with sum divisible by m ; This array will keep track of all the possible sum ( after modulo m ) which can be made using subsets of arr [ ] initialising boolean array with all false ; we 'll loop through all the elements of arr[] ; anytime we encounter a sum divisible by m , we are done ; To store all the new encountered sum ( after modulo ) . It is used to make sure that arr [ i ] is added only to those entries for which DP [ j ] was true before current iteration . ; For each element of arr [ ] , we loop through all elements of DP table from 1 to m and we add current element i . e . , arr [ i ] to all those elements which are true in DP table ; if an element is true in DP table ; We update it in temp and update to DP once loop of j is over ; Updating all the elements of temp to DP table since iteration over j is over ; Also since arr [ i ] is a single element subset , arr [ i ] % m is one of the possible sum ; Driver code", "dfg": [["m", 34, "comesFrom", ["m"], [19]], ["m", 26, "comesFrom", ["m"], [19]], ["m", 43, "comesFrom", ["m"], [19]], ["m", 74, "comesFrom", ["m"], [19]], ["m", 95, "comesFrom", ["m"], [19]], ["m", 156, "comesFrom", ["m"], [19]], ["m", 238, "comesFrom", ["m"], [228]], ["m", 83, "comesFrom", ["m"], [19]], ["m", 182, "comesFrom", ["m"], [19]], ["m", 124, "comesFrom", ["m"], [19]], ["m", 140, "comesFrom", ["m"], [19]], ["i", 53, "comesFrom", ["i"], [49]], ["i", 57, "comesFrom", ["i"], [49]], ["i", 179, "comesFrom", ["i"], [49]], ["i", 120, "comesFrom", ["i"], [49]], ["i", 136, "comesFrom", ["i"], [49]], ["n", 55, "comesFrom", ["n"], [16]], ["n", 24, "comesFrom", ["n"], [16]], ["n", 236, "comesFrom", ["n"], [212]], ["j", 93, "comesFrom", ["j"], [89]], ["j", 97, "comesFrom", ["j"], [89]], ["j", 154, "comesFrom", ["j"], [150]], ["j", 158, "comesFrom", ["j"], [150]], ["j", 165, "comesFrom", ["j"], [150]], ["j", 170, "comesFrom", ["j"], [150]], ["j", 105, "comesFrom", ["j"], [89]], ["j", 116, "comesFrom", ["j"], [89]], ["j", 132, "comesFrom", ["j"], [89]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int tri [ ] [ 3 ] , int n ) { if ( n > 1 ) tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] ; tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] ; tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j < i ; j ++ ) { if ( tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ) tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] ; else tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ; } } int max = tri [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 ] [ i ] ) max = tri [ n - 1 ] [ i ] ; } return max ; } int main ( ) { int tri [ 3 ] [ 3 ] = { { 1 } , { 2 , 1 } , { 3 , 3 , 2 } } ; cout << maxSum ( tri , 3 ) ; return 0 ; }", "docstring": "Maximum sum of a path in a Right Number Triangle | C ++ program to print maximum sum in a right triangle of numbers ; function to find maximum sum path ; Adding the element of row 1 to both the elements of row 2 to reduce a step from the loop ; Traverse remaining rows ; Loop to traverse columns ; tri [ i ] would store the possible combinations of sum of the paths ; array at n - 1 index ( tri [ i ] ) stores all possible adding combination , finding the maximum one out of them ; driver program", "dfg": [["max", 313, "comesFrom", ["max"], [299]], ["max", 287, "comesFrom", ["max"], [258]], ["i", 83, "comesFrom", ["i"], [79]], ["i", 87, "comesFrom", ["i"], [79]], ["i", 277, "comesFrom", ["i"], [273]], ["i", 281, "comesFrom", ["i"], [273]], ["i", 154, "comesFrom", ["i"], [79]], ["i", 122, "comesFrom", ["i"], [79]], ["i", 93, "comesFrom", ["i"], [79]], ["i", 119, "comesFrom", ["i"], [79]], ["i", 130, "comesFrom", ["i"], [79]], ["i", 296, "comesFrom", ["i"], [273]], ["i", 308, "comesFrom", ["i"], [273]], ["i", 101, "comesFrom", ["i"], [79]], ["i", 127, "comesFrom", ["i"], [79]], ["i", 140, "comesFrom", ["i"], [79]], ["i", 109, "comesFrom", ["i"], [79]], ["i", 135, "comesFrom", ["i"], [79]], ["i", 202, "comesFrom", ["i"], [79]], ["i", 164, "comesFrom", ["i"], [79]], ["i", 184, "comesFrom", ["i"], [79]], ["i", 210, "comesFrom", ["i"], [79]], ["i", 231, "comesFrom", ["i"], [79]], ["i", 172, "comesFrom", ["i"], [79]], ["i", 192, "comesFrom", ["i"], [79]], ["i", 218, "comesFrom", ["i"], [79]], ["i", 239, "comesFrom", ["i"], [79]], ["i", 247, "comesFrom", ["i"], [79]], ["n", 85, "comesFrom", ["n"], [19]], ["n", 279, "comesFrom", ["n"], [19]], ["n", 24, "comesFrom", ["n"], [19]], ["n", 262, "comesFrom", ["n"], [19]], ["n", 291, "comesFrom", ["n"], [19]], ["n", 303, "comesFrom", ["n"], [19]], ["j", 152, "comesFrom", ["j"], [148]], ["j", 156, "comesFrom", ["j"], [148]], ["j", 205, "comesFrom", ["j"], [148]], ["j", 167, "comesFrom", ["j"], [148]], ["j", 187, "comesFrom", ["j"], [148]], ["j", 197, "comesFrom", ["j"], [148]], ["j", 213, "comesFrom", ["j"], [148]], ["j", 234, "comesFrom", ["j"], [148]], ["j", 177, "comesFrom", ["j"], [148]], ["j", 223, "comesFrom", ["j"], [148]], ["j", 242, "comesFrom", ["j"], [148]], ["j", 252, "comesFrom", ["j"], [148]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumDifferenceSum ( arr , N ) << endl ; return 0 ; }", "docstring": "Modify array to maximize sum of adjacent differences | C ++ program to get maximum consecutive element difference sum ; Returns maximum - difference - sum with array modifications allowed . ; Initialize dp [ ] [ ] with 0 values . ; for [ i + 1 ] [ 0 ] ( i . e . current modified value is 1 ) , choose maximum from dp [ i ] [ 0 ] + abs ( 1 - 1 ) = dp [ i ] [ 0 ] and dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ; for [ i + 1 ] [ 1 ] ( i . e . current modified value is arr [ i + 1 ] ) , choose maximum from dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) and dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ; Driver code to test above methods", "dfg": [["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 67, "comesFrom", ["i"], [63]], ["i", 75, "comesFrom", ["i"], [63]], ["i", 44, "comesFrom", ["i"], [31]], ["i", 52, "comesFrom", ["i"], [31]], ["i", 81, "comesFrom", ["i"], [63]], ["i", 120, "comesFrom", ["i"], [63]], ["i", 93, "comesFrom", ["i"], [63]], ["i", 101, "comesFrom", ["i"], [63]], ["i", 132, "comesFrom", ["i"], [63]], ["i", 152, "comesFrom", ["i"], [63]], ["i", 113, "comesFrom", ["i"], [63]], ["i", 169, "comesFrom", ["i"], [63]], ["i", 142, "comesFrom", ["i"], [63]], ["i", 162, "comesFrom", ["i"], [63]], ["N", 37, "comesFrom", ["N"], [16]], ["N", 22, "comesFrom", ["N"], [16]], ["N", 70, "comesFrom", ["N"], [16]], ["N", 244, "comesFrom", ["N"], [223]], ["N", 180, "comesFrom", ["N"], [16]], ["N", 190, "comesFrom", ["N"], [16]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countStrUtil ( int dp [ ] [ 2 ] [ 3 ] , int n , int bCount = 1 , int cCount = 2 ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; if ( dp [ n ] [ bCount ] [ cCount ] != -1 ) return dp [ n ] [ bCount ] [ cCount ] ; int res = countStrUtil ( dp , n - 1 , bCount , cCount ) ; res += countStrUtil ( dp , n - 1 , bCount - 1 , cCount ) ; res += countStrUtil ( dp , n - 1 , bCount , cCount - 1 ) ; return ( dp [ n ] [ bCount ] [ cCount ] = res ) ; } int countStr ( int n ) { int dp [ n + 1 ] [ 2 ] [ 3 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; return countStrUtil ( dp , n ) ; } int main ( ) { int n = 3 ; cout << countStr ( n ) ; return 0 ; }", "docstring": "Count of strings that can be formed using a , b and c under given constraints | C ++ program to count number of strings of n characters with ; n is total number of characters . bCount and cCount are counts of ' b ' and ' c ' respectively . ; Base cases ; if we had saw this combination previously ; Three cases , we choose , a or b or c In all three cases n decreases by 1. ; A wrapper over countStrUtil ( ) ; Driver code ; Total number of characters", "dfg": [["n", 50, "comesFrom", ["n"], [22]], ["n", 202, "comesFrom", ["n"], [168]], ["n", 220, "comesFrom", ["n"], [212]], ["n", 104, "comesFrom", ["n"], [22]], ["n", 119, "comesFrom", ["n"], [22]], ["n", 136, "comesFrom", ["n"], [22]], ["n", 174, "comesFrom", ["n"], [168]], ["n", 88, "comesFrom", ["n"], [22]], ["n", 74, "comesFrom", ["n"], [22]], ["n", 151, "comesFrom", ["n"], [22]], ["res", 160, "comesFrom", ["res"], [130]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  8 NEW_LINE int dx [ ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ; int dy [ ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ; bool inside ( int x , int y ) { return ( x >= 0 and x < N and y > = 0 and y < N ) ; } double findProb ( int start_x , int start_y , int steps ) { double dp1 [ N ] [ N ] [ steps + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) dp1 [ i ] [ j ] [ 0 ] = 1 ; for ( int s = 1 ; s <= steps ; ++ s ) { for ( int x = 0 ; x < N ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) { double prob = 0.0 ; for ( int i = 0 ; i < 8 ; ++ i ) { int nx = x + dx [ i ] ; int ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 ; } dp1 [ x ] [ y ] [ s ] = prob ; } } } return dp1 [ start_x ] [ start_y ] [ steps ] ; } int main ( ) { int K = 3 ; cout << findProb ( 0 , 0 , K ) << endl ; return 0 ; }", "docstring": "Probability of Knight to remain in the chessboard | C ++ program to find the probability of the Knight to remain inside the chessboard after taking exactly K number of steps ; size of the chessboard ; direction vector for the Knight ; returns true if the knight is inside the chessboard ; Bottom up approach for finding the probability to go out of chessboard . ; dp array ; for 0 number of steps , each position will have probability 1 ; for every number of steps s ; for every position ( x , y ) after s number of steps ; for every position reachable from ( x , y ) ; if this position lie inside the board ; store the result ; return the result ; Driver Code ; number of steps ; Function Call", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubarray ( int arr [ ] , int n , int k ) { int s = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += ( ( count * ( count + 1 ) ) / 2 ) ; } return ( n * ( n + 1 ) / 2 - s ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int k = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubarray ( arr , n , k ) ; return 0 ; }", "docstring": "Count of subarrays whose maximum element is greater than k | C ++ program to count number of subarrays whose maximum element is greater than K . ; Return number of subarrays whose maximum element is less than or equal to K . ; To store count of subarrays with all elements less than or equal to k . ; Traversing the array . ; If element is greater than k , ignore . ; Counting the subarray length whose each element is less than equal to k . ; Suming number of subarray whose maximum element is less than equal to k . ; Driven Program", "dfg": [["i", 34, "comesFrom", ["i"], [28]], ["i", 49, "comesFrom", ["i"], [28]], ["i", 62, "comesFrom", ["i"], [28]], ["i", 74, "comesFrom", ["i"], [28]], ["i", 43, "comesFrom", ["i"], [28]], ["i", 68, "comesFrom", ["i"], [28]], ["n", 36, "comesFrom", ["n"], [16]], ["n", 159, "comesFrom", ["n"], [138]], ["n", 100, "comesFrom", ["n"], [16]], ["n", 64, "comesFrom", ["n"], [16]], ["n", 103, "comesFrom", ["n"], [16]], ["s", 110, "comesFrom", ["s"], [81]], ["k", 161, "comesFrom", ["k"], [133]], ["k", 46, "comesFrom", ["k"], [19]], ["k", 71, "comesFrom", ["k"], [19]], ["count", 77, "comesFrom", ["count"], [56]], ["count", 85, "comesFrom", ["count"], [56]], ["count", 88, "comesFrom", ["count"], [56]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } double resultOfAllSubsets ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( int n = 1 ; n <= N ; n ++ ) result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << resultOfAllSubsets ( arr , N ) << endl ; return 0 ; }", "docstring": "Sum of average of all subsets | C ++ program to get sum of average of all subsets ; Returns value of Binomial Coefficient C ( n , k ) ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; method returns sum of average of all subsets ; Find sum of elements ; looping once for all subset of same size ; each element occurs nCr ( N - 1 , n - 1 ) times while considering subset of size n ; Driver code to test above methods", "dfg": [["result", 207, "comesFrom", ["result"], [182]], ["i", 41, "comesFrom", ["i"], [37]], ["i", 45, "comesFrom", ["i"], [37]], ["i", 154, "comesFrom", ["i"], [150]], ["i", 158, "comesFrom", ["i"], [150]], ["i", 165, "comesFrom", ["i"], [150]], ["i", 59, "comesFrom", ["i"], [37]], ["i", 75, "comesFrom", ["i"], [37]], ["i", 79, "comesFrom", ["i"], [37]], ["i", 90, "comesFrom", ["i"], [37]], ["i", 98, "comesFrom", ["i"], [37]], ["i", 110, "comesFrom", ["i"], [37]], ["n", 43, "comesFrom", ["n"], [11]], ["n", 175, "comesFrom", ["n"], [171]], ["n", 179, "comesFrom", ["n"], [171]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 123, "comesFrom", ["n"], [11]], ["n", 204, "comesFrom", ["n"], [171]], ["n", 197, "comesFrom", ["n"], [171]], ["N", 156, "comesFrom", ["N"], [139]], ["N", 177, "comesFrom", ["N"], [139]], ["N", 249, "comesFrom", ["N"], [231]], ["N", 193, "comesFrom", ["N"], [139]], ["k", 25, "comesFrom", ["k"], [14]], ["k", 126, "comesFrom", ["k"], [14]], ["k", 61, "comesFrom", ["k"], [14]], ["j", 55, "comesFrom", ["j"], [51]], ["j", 64, "comesFrom", ["j"], [51]], ["j", 70, "comesFrom", ["j"], [51]], ["j", 73, "comesFrom", ["j"], [51]], ["j", 82, "comesFrom", ["j"], [51]], ["j", 93, "comesFrom", ["j"], [51]], ["j", 115, "comesFrom", ["j"], [51]], ["j", 103, "comesFrom", ["j"], [51]], ["sum", 188, "comesFrom", ["sum"], [161]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int arr [ ] = { 100 , 1000 , 100 , 1000 , 1 } ; int sum [ 10000 ] ; int maxSumWO3Consec ( int n ) { if ( sum [ n ] != -1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; } int main ( ) { int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; memset ( sum , -1 , sizeof ( sum ) ) ; cout << maxSumWO3Consec ( n ) ; return 0 ; }", "docstring": "Maximum subsequence sum such that no three are consecutive | C ++ program to find the maximum sum such that no three are consecutive using recursion . ; Returns maximum subsequence sum such that no three elements are consecutive ; Base cases ( process first three elements ) ; Process rest of the elements We have three cases ; Driver code", "dfg": [["n", 54, "comesFrom", ["n"], [34]], ["n", 68, "comesFrom", ["n"], [34]], ["n", 85, "comesFrom", ["n"], [34]], ["n", 49, "comesFrom", ["n"], [34]], ["n", 108, "comesFrom", ["n"], [34]], ["n", 193, "comesFrom", ["n"], [162]], ["n", 41, "comesFrom", ["n"], [34]], ["n", 61, "comesFrom", ["n"], [34]], ["n", 75, "comesFrom", ["n"], [34]], ["n", 92, "comesFrom", ["n"], [34]], ["n", 137, "comesFrom", ["n"], [34]], ["n", 149, "comesFrom", ["n"], [34]], ["n", 117, "comesFrom", ["n"], [34]], ["n", 131, "comesFrom", ["n"], [34]], ["n", 142, "comesFrom", ["n"], [34]], ["n", 124, "comesFrom", ["n"], [34]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumPair ( int arr [ ] , int N , int k ) { int maxSum = 0 ; sort ( arr , arr + N ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; } int main ( ) { int arr [ ] = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 4 ; cout << maxSumPair ( arr , N , K ) ; return 0 ; }", "docstring": "Maximum sum of pairs with specific difference | C ++ program to find maximum pair sum whose difference is less than K ; Method to return maximum sum we can get by finding less than K difference pairs ; Sort elements to ensure every i and i - 1 is closest possible pair ; To get maximum possible sum , iterate from largest to smallest , giving larger numbers priority over smaller numbers . ; Case I : Diff of arr [ i ] and arr [ i - 1 ] is less then K , add to maxSum Case II : Diff between arr [ i ] and arr [ i - 1 ] is not less then K , move to next i since with sorting we know , arr [ i ] - arr [ i - 1 ] < rr [ i ] - arr [ i - 2 ] and so on . ; Assuming only positive numbers . ; When a match is found skip this pair ; Driver code", "dfg": [["maxSum", 92, "comesFrom", ["maxSum"], [77]], ["i", 45, "comesFrom", ["i"], [39]], ["i", 50, "comesFrom", ["i"], [39]], ["i", 87, "comesFrom", ["i"], [39]], ["i", 57, "comesFrom", ["i"], [39]], ["i", 74, "comesFrom", ["i"], [39]], ["i", 62, "comesFrom", ["i"], [39]], ["i", 81, "comesFrom", ["i"], [39]], ["N", 33, "comesFrom", ["N"], [16]], ["N", 41, "comesFrom", ["N"], [16]], ["N", 145, "comesFrom", ["N"], [122]], ["K", 147, "comesFrom", ["K"], [135]], ["k", 67, "comesFrom", ["k"], [19]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countGroups ( int position , int previous_sum , int length , char * num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; } int main ( ) { char num [ ] = \"1119\" ; int len = strlen ( num ) ; cout << countGroups ( 0 , 0 , len , num ) ; return 0 ; }", "docstring": "Count digit groupings of a number with given constraints | C ++ program to count number of ways to group digits of a number such that sum of digits in every subgroup is less than or equal to its immediate right subgroup . ; Function to find the subgroups ; Terminating Condition ; sum of digits ; Traverse all digits from current position to rest of the length of string ; If forward_sum is greater than the previous sum , then call the method again ; Note : We pass current sum as previous sum ; Total number of subgroups till current position ; Driver Code", "dfg": [["res", 94, "comesFrom", ["res"], [77]], ["i", 50, "comesFrom", ["i"], [46]], ["i", 54, "comesFrom", ["i"], [46]], ["i", 63, "comesFrom", ["i"], [46]], ["i", 81, "comesFrom", ["i"], [46]], ["length", 52, "comesFrom", ["length"], [17]], ["length", 28, "comesFrom", ["length"], [17]], ["length", 87, "comesFrom", ["length"], [17]], ["position", 26, "comesFrom", ["position"], [11]], ["len", 127, "comesFrom", ["len"], [112]], ["sum", 73, "comesFrom", ["sum"], [58]], ["sum", 85, "comesFrom", ["sum"], [58]], ["previous_sum", 75, "comesFrom", ["previous_sum"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 40 ; int dp [ MAX ] [ 9 * MAX + 1 ] ; int countGroups ( int position , int previous_sum , int length , char * num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != -1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; } int main ( ) { char num [ ] = \"1119\" ; int len = strlen ( num ) ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << countGroups ( 0 , 0 , len , num ) ; return 0 ; }", "docstring": "Count digit groupings of a number with given constraints | C ++ program to count number of ways to group digits of a number such that sum of digits in every subgroup is less than or equal to its immediate right subgroup . ; Maximum length of input number string ; A memoization table to store results of subproblems length of string is 40 and maximum sum will be 9 * 40 = 360. ; Function to find the count of splits with given condition ; Terminating Condition ; If already evaluated for a given sub problem then return the value ; countGroups for current sub - group is 0 ; sum of digits ; Traverse all digits from current position to rest of the length of string ; If forward_sum is greater than the previous sum , then call the method again ; Note : We pass current sum as previous sum ; total number of subgroups till current position ; Driver Code ; Initialize dp table", "dfg": [["MAX", 16, "comesFrom", ["MAX"], [9]], ["MAX", 21, "comesFrom", ["MAX"], [9]], ["res", 154, "comesFrom", ["res"], [127]], ["res", 151, "comesFrom", ["res"], [127]], ["i", 100, "comesFrom", ["i"], [96]], ["i", 104, "comesFrom", ["i"], [96]], ["i", 113, "comesFrom", ["i"], [96]], ["i", 131, "comesFrom", ["i"], [96]], ["length", 102, "comesFrom", ["length"], [36]], ["length", 47, "comesFrom", ["length"], [36]], ["length", 137, "comesFrom", ["length"], [36]], ["position", 45, "comesFrom", ["position"], [30]], ["position", 67, "comesFrom", ["position"], [30]], ["position", 75, "comesFrom", ["position"], [30]], ["position", 145, "comesFrom", ["position"], [98]], ["position", 56, "comesFrom", ["position"], [30]], ["previous_sum", 70, "comesFrom", ["previous_sum"], [33]], ["previous_sum", 78, "comesFrom", ["previous_sum"], [33]], ["previous_sum", 148, "comesFrom", ["previous_sum"], [33]], ["previous_sum", 59, "comesFrom", ["previous_sum"], [33]], ["previous_sum", 125, "comesFrom", ["previous_sum"], [33]], ["len", 199, "comesFrom", ["len"], [172]], ["sum", 123, "comesFrom", ["sum"], [108]], ["sum", 135, "comesFrom", ["sum"], [108]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int dp [ W + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; } int main ( ) { int val [ ] = { 7 , 8 , 4 } , wt [ ] = { 3 , 8 , 6 } , W = 10 , n = 3 ; cout << KnapSack ( val , wt , n , W ) << endl ; return 0 ; }", "docstring": "A Space Optimized DP solution for 0 | C ++ program of a space optimized DP solution for 0 - 1 knapsack problem . ; val [ ] is for storing maximum profit for each weight wt [ ] is for storing weights n number of item W maximum capacity of bag dp [ W + 1 ] to store final result ; array to store final result dp [ i ] stores the profit with KnapSack capacity \" i \" ; initially profit with 0 to W KnapSack capacity is 0 ; iterate through all items ; traverse dp array from right to left ; above line finds out maximum of dp [ j ] ( excluding ith element value ) and val [ i ] + dp [ j - wt [ i ] ] ( including ith element value and the profit with \" KnapSack ▁ capacity ▁ - ▁ ith ▁ element ▁ weight \" ) ; Driver program to test the cases", "dfg": [["i", 54, "comesFrom", ["i"], [50]], ["i", 58, "comesFrom", ["i"], [50]], ["i", 72, "comesFrom", ["i"], [50]], ["i", 92, "comesFrom", ["i"], [50]], ["i", 101, "comesFrom", ["i"], [50]], ["n", 56, "comesFrom", ["n"], [21]], ["n", 159, "comesFrom", ["n"], [147]], ["W", 30, "comesFrom", ["W"], [24]], ["W", 109, "comesFrom", ["W"], [66]], ["W", 161, "comesFrom", ["W"], [143]], ["j", 68, "comesFrom", ["j"], [64]], ["j", 75, "comesFrom", ["j"], [64]], ["j", 80, "comesFrom", ["j"], [64]], ["j", 87, "comesFrom", ["j"], [64]], ["j", 97, "comesFrom", ["j"], [64]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int count ( string a , string b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ m + 1 ] [ n + 1 ] = { { 0 } } ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; } int main ( ) { string a = \" GeeksforGeeks \" ; string b = \" Gks \" ; cout << count ( a , b ) ; return 0 ; }", "docstring": "Find number of times a string occurs as a subsequence in given string | A Dynamic Programming based C ++ program to find the number of times the second string occurs in the first string , whether continuous or discontinuous ; Iterative DP function to find the number of times the second string occurs in the first string , whether continuous or discontinuous ; Create a table to store results of sub - problems ; If first string is empty ; If second string is empty ; Fill lookup [ ] [ ] in bottom up manner ; If last characters are same , we have two options - 1. consider last characters of both strings in solution 2. ignore last character of first string ; If last character are different , ignore last character of first string ; Driver code", "dfg": [["i", 61, "comesFrom", ["i"], [57]], ["i", 66, "comesFrom", ["i"], [57]], ["i", 85, "comesFrom", ["i"], [81]], ["i", 90, "comesFrom", ["i"], [81]], ["i", 109, "comesFrom", ["i"], [105]], ["i", 113, "comesFrom", ["i"], [105]], ["i", 73, "comesFrom", ["i"], [57]], ["i", 94, "comesFrom", ["i"], [81]], ["i", 136, "comesFrom", ["i"], [105]], ["i", 150, "comesFrom", ["i"], [105]], ["i", 181, "comesFrom", ["i"], [105]], ["i", 158, "comesFrom", ["i"], [105]], ["i", 170, "comesFrom", ["i"], [105]], ["i", 189, "comesFrom", ["i"], [105]], ["n", 63, "comesFrom", ["n"], [27]], ["n", 205, "comesFrom", ["n"], [27]], ["n", 43, "comesFrom", ["n"], [27]], ["n", 126, "comesFrom", ["n"], [27]], ["m", 87, "comesFrom", ["m"], [18]], ["m", 111, "comesFrom", ["m"], [18]], ["m", 202, "comesFrom", ["m"], [18]], ["m", 38, "comesFrom", ["m"], [18]], ["a", 20, "comesFrom", ["a"], [11]], ["a", 232, "comesFrom", ["a"], [215]], ["a", 134, "comesFrom", ["a"], [11]], ["b", 29, "comesFrom", ["b"], [14]], ["b", 234, "comesFrom", ["b"], [222]], ["b", 141, "comesFrom", ["b"], [14]], ["j", 124, "comesFrom", ["j"], [120]], ["j", 128, "comesFrom", ["j"], [120]], ["j", 153, "comesFrom", ["j"], [120]], ["j", 143, "comesFrom", ["j"], [120]], ["j", 175, "comesFrom", ["j"], [120]], ["j", 184, "comesFrom", ["j"], [120]], ["j", 194, "comesFrom", ["j"], [120]], ["j", 163, "comesFrom", ["j"], [120]]]}
{"code": "#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; int lenOfLongestGP ( int set [ ] , int n ) { if ( n < 2 ) return n ; if ( n == 2 ) return ( set [ 1 ] % set [ 0 ] == 0 ) ? 2 : 1 ; sort ( set , set + n ) ; int L [ n ] [ n ] ; int llgp = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( set [ n - 1 ] % set [ i ] == 0 ) { L [ i ] [ n - 1 ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ n - 1 ] = 1 ; } } L [ n - 1 ] [ n - 1 ] = 1 ; for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) { ++ k ; } else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } else { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] ; } else { L [ i ] [ j ] = 1 ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else L [ i ] [ j ] = 1 ; -- i ; } } return llgp ; } int main ( ) { int set1 [ ] = { 1 , 3 , 9 , 27 , 81 , 243 } ; int n1 = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; cout << lenOfLongestGP ( set1 , n1 ) << \" STRNEWLINE \" ; int set2 [ ] = { 1 , 3 , 4 , 9 , 7 , 27 } ; int n2 = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << lenOfLongestGP ( set2 , n2 ) << \" STRNEWLINE \" ; int set3 [ ] = { 2 , 3 , 5 , 7 , 11 , 13 } ; int n3 = sizeof ( set3 ) / sizeof ( set3 [ 0 ] ) ; cout << lenOfLongestGP ( set3 , n3 ) << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Longest Geometric Progression | C ++ program to find length of the longest geometric progression in a given set ; Returns length of the longest GP subset of set [ ] ; Base cases ; Let us sort the set first ; An entry L [ i ] [ j ] in this table stores LLGP with set [ i ] and set [ j ] as first two elements of GP and j > i . ; Initialize result ( A single element is always a GP ) ; Initialize values of last column ; Consider every element as second element of GP ; Search for i and k for j ; Two cases when i , j and k don 't form  a GP. ; i , j and k form GP , LLGP with i and j as first two elements is equal to LLGP with j and k as first two elements plus 1. L [ j ] [ k ] must have been filled before as we run the loop from right side ; Update overall LLGP ; Change i and k to fill more L [ i ] [ j ] values for current j ; If the loop was stopped due to k becoming more than n - 1 , set the remaining entries in column j as 1 or 2 based on divisibility of set [ j ] by set [ i ] ; Return result ; Driver code", "dfg": [["llgp", 442, "comesFrom", ["llgp"], [420]], ["llgp", 129, "comesFrom", ["llgp"], [75]], ["llgp", 418, "comesFrom", ["llgp"], [350]], ["llgp", 348, "comesFrom", ["llgp"], [131]], ["n", 29, "comesFrom", ["n"], [19]], ["n", 71, "comesFrom", ["n"], [19]], ["n", 24, "comesFrom", ["n"], [19]], ["n", 33, "comesFrom", ["n"], [19]], ["n", 68, "comesFrom", ["n"], [19]], ["n", 88, "comesFrom", ["n"], [19]], ["n", 62, "comesFrom", ["n"], [19]], ["n", 171, "comesFrom", ["n"], [19]], ["n", 159, "comesFrom", ["n"], [19]], ["n", 154, "comesFrom", ["n"], [19]], ["n", 204, "comesFrom", ["n"], [19]], ["n", 100, "comesFrom", ["n"], [19]], ["n", 118, "comesFrom", ["n"], [19]], ["n", 143, "comesFrom", ["n"], [19]], ["i", 86, "comesFrom", ["i"], [82]], ["i", 93, "comesFrom", ["i"], [82]], ["i", 384, "comesFrom", ["i"], [184]], ["i", 198, "comesFrom", ["i"], [184]], ["i", 437, "comesFrom", ["i"], [184]], ["i", 107, "comesFrom", ["i"], [82]], ["i", 115, "comesFrom", ["i"], [82]], ["i", 140, "comesFrom", ["i"], [82]], ["i", 213, "comesFrom", ["i"], [184]], ["i", 300, "comesFrom", ["i"], [184]], ["i", 398, "comesFrom", ["i"], [184]], ["i", 375, "comesFrom", ["i"], [184]], ["i", 406, "comesFrom", ["i"], [184]], ["i", 428, "comesFrom", ["i"], [184]], ["i", 241, "comesFrom", ["i"], [184]], ["i", 269, "comesFrom", ["i"], [184]], ["i", 277, "comesFrom", ["i"], [184]], ["i", 314, "comesFrom", ["i"], [184]], ["i", 290, "comesFrom", ["i"], [184]], ["i", 322, "comesFrom", ["i"], [184]], ["i", 342, "comesFrom", ["i"], [184]], ["i", 354, "comesFrom", ["i"], [184]], ["i", 365, "comesFrom", ["i"], [184]], ["j", 175, "comesFrom", ["j"], [169]], ["j", 180, "comesFrom", ["j"], [169]], ["j", 186, "comesFrom", ["j"], [169]], ["j", 192, "comesFrom", ["j"], [169]], ["j", 223, "comesFrom", ["j"], [169]], ["j", 228, "comesFrom", ["j"], [169]], ["j", 393, "comesFrom", ["j"], [169]], ["j", 409, "comesFrom", ["j"], [169]], ["j", 431, "comesFrom", ["j"], [169]], ["j", 251, "comesFrom", ["j"], [169]], ["j", 256, "comesFrom", ["j"], [169]], ["j", 264, "comesFrom", ["j"], [169]], ["j", 280, "comesFrom", ["j"], [169]], ["j", 293, "comesFrom", ["j"], [169]], ["j", 309, "comesFrom", ["j"], [169]], ["j", 325, "comesFrom", ["j"], [169]], ["j", 345, "comesFrom", ["j"], [169]], ["j", 357, "comesFrom", ["j"], [169]], ["j", 368, "comesFrom", ["j"], [169]], ["j", 330, "comesFrom", ["j"], [169]], ["n1", 491, "comesFrom", ["n1"], [470]], ["n2", 539, "comesFrom", ["n2"], [518]], ["n3", 587, "comesFrom", ["n3"], [566]], ["k", 202, "comesFrom", ["k"], [190]], ["k", 233, "comesFrom", ["k"], [190]], ["k", 218, "comesFrom", ["k"], [190]], ["k", 378, "comesFrom", ["k"], [190]], ["k", 246, "comesFrom", ["k"], [190]], ["k", 333, "comesFrom", ["k"], [190]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Pair { int a ; int b ; } ; int compare ( Pair x , Pair y ) { return x . a < y . a ; } void maxChainLength ( vector < Pair > arr ) { sort ( arr . begin ( ) , arr . end ( ) , compare ) ; vector < vector < Pair > > L ( arr . size ( ) ) ; L [ 0 ] . push_back ( arr [ 0 ] ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] . b < arr [ i ] . a ) && ( L [ j ] . size ( ) > L [ i ] . size ( ) ) ) L [ i ] = L [ j ] ; } L [ i ] . push_back ( arr [ i ] ) ; } vector < Pair > maxChain ; for ( vector < Pair > x : L ) if ( x . size ( ) > maxChain . size ( ) ) maxChain = x ; for ( Pair pair : maxChain ) cout << \" ( \" << pair . a << \" , ▁ \" << pair . b << \" ) ▁ \" ; } int main ( ) { Pair a [ ] = { { 5 , 29 } , { 39 , 40 } , { 15 , 28 } , { 27 , 40 } , { 50 , 90 } } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; vector < Pair > arr ( a , a + n ) ; maxChainLength ( arr ) ; return 0 ; }", "docstring": "Print Maximum Length Chain of Pairs | Dynamic Programming solution to construct Maximum Length Chain of Pairs ; comparator function for sort function ; Function to construct Maximum Length Chain of Pairs ; Sort by start time ; L [ i ] stores maximum length of chain of arr [ 0. . i ] that ends with arr [ i ] . ; L [ 0 ] is equal to arr [ 0 ] ; start from index 1 ; for every j less than i ; L [ i ] = { Max ( L [ j ] ) } + arr [ i ] where j < i and arr [ j ] . b < arr [ i ] . a ; print max length vector ; Driver Function", "dfg": [["x", 203, "comesFrom", ["x"], [22]], ["x", 29, "comesFrom", ["x"], [22]], ["x", 223, "comesFrom", ["x"], [22]], ["x", 209, "comesFrom", ["x"], [22]], ["L", 205, "comesFrom", ["L"], [72]], ["L", 81, "comesFrom", ["L"], [72]], ["L", 177, "comesFrom", ["L"], [72]], ["L", 166, "comesFrom", ["L"], [72]], ["L", 171, "comesFrom", ["L"], [72]], ["L", 147, "comesFrom", ["L"], [72]], ["L", 156, "comesFrom", ["L"], [72]], ["maxChain", 230, "comesFrom", ["maxChain"], [221]], ["maxChain", 215, "comesFrom", ["maxChain"], [195]], ["i", 101, "comesFrom", ["i"], [97]], ["i", 109, "comesFrom", ["i"], [97]], ["i", 122, "comesFrom", ["i"], [97]], ["i", 179, "comesFrom", ["i"], [97]], ["i", 186, "comesFrom", ["i"], [97]], ["i", 168, "comesFrom", ["i"], [97]], ["i", 140, "comesFrom", ["i"], [97]], ["i", 158, "comesFrom", ["i"], [97]], ["y", 33, "comesFrom", ["y"], [25]], ["arr", 328, "comesFrom", ["arr"], [317]], ["arr", 88, "comesFrom", ["arr"], [45]], ["arr", 103, "comesFrom", ["arr"], [45]], ["arr", 50, "comesFrom", ["arr"], [45]], ["arr", 56, "comesFrom", ["arr"], [45]], ["arr", 74, "comesFrom", ["arr"], [45]], ["arr", 184, "comesFrom", ["arr"], [45]], ["arr", 131, "comesFrom", ["arr"], [45]], ["arr", 138, "comesFrom", ["arr"], [45]], ["j", 120, "comesFrom", ["j"], [116]], ["j", 124, "comesFrom", ["j"], [116]], ["j", 173, "comesFrom", ["j"], [116]], ["j", 133, "comesFrom", ["j"], [116]], ["j", 149, "comesFrom", ["j"], [116]], ["n", 323, "comesFrom", ["n"], [298]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void print ( vector < int > & arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } void printLBS ( int arr [ ] , int n ) { vector < vector < int > > LIS ( n ) ; LIS [ 0 ] . push_back ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] < arr [ i ] ) && ( LIS [ j ] . size ( ) > LIS [ i ] . size ( ) ) ) LIS [ i ] = LIS [ j ] ; } LIS [ i ] . push_back ( arr [ i ] ) ; } vector < vector < int > > LDS ( n ) ; LDS [ n - 1 ] . push_back ( arr [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j > i ; j -- ) { if ( ( arr [ j ] < arr [ i ] ) && ( LDS [ j ] . size ( ) > LDS [ i ] . size ( ) ) ) LDS [ i ] = LDS [ j ] ; } LDS [ i ] . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) reverse ( LDS [ i ] . begin ( ) , LDS [ i ] . end ( ) ) ; int max = 0 ; int maxIndex = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( LIS [ i ] . size ( ) + LDS [ i ] . size ( ) - 1 > max ) { max = LIS [ i ] . size ( ) + LDS [ i ] . size ( ) - 1 ; maxIndex = i ; } } print ( LIS [ maxIndex ] , LIS [ maxIndex ] . size ( ) - 1 ) ; print ( LDS [ maxIndex ] , LDS [ maxIndex ] . size ( ) ) ; } int main ( ) { int arr [ ] = { 1 , 11 , 2 , 10 , 4 , 5 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLBS ( arr , n ) ; return 0 ; }", "docstring": "Printing Longest Bitonic Subsequence | Dynamic Programming solution to print Longest Bitonic Subsequence ; Utility function to print Longest Bitonic Subsequence ; Function to construct and print Longest Bitonic Subsequence ; LIS [ i ] stores the length of the longest increasing subsequence ending with arr [ i ] ; initialize LIS [ 0 ] to arr [ 0 ] ; Compute LIS values from left to right ; for every j less than i ; LDS [ i ] stores the length of the longest decreasing subsequence starting with arr [ i ] ; initialize LDS [ n - 1 ] to arr [ n - 1 ] ; Compute LDS values from right to left ; for every j greater than i ; reverse as vector as we 're inserting at end ; LDS [ i ] now stores Maximum Decreasing Subsequence of arr [ i . . n ] that starts with arr [ i ] ; Find maximum value of size of LIS [ i ] + size of LDS [ i ] - 1 ; print all but last element of LIS [ maxIndex ] vector ; print all elements of LDS [ maxIndex ] vector ; Driver program", "dfg": [["i", 28, "comesFrom", ["i"], [24]], ["i", 32, "comesFrom", ["i"], [24]], ["i", 91, "comesFrom", ["i"], [87]], ["i", 95, "comesFrom", ["i"], [87]], ["i", 211, "comesFrom", ["i"], [205]], ["i", 215, "comesFrom", ["i"], [205]], ["i", 302, "comesFrom", ["i"], [298]], ["i", 306, "comesFrom", ["i"], [298]], ["i", 347, "comesFrom", ["i"], [343]], ["i", 351, "comesFrom", ["i"], [343]], ["i", 108, "comesFrom", ["i"], [87]], ["i", 230, "comesFrom", ["i"], [205]], ["i", 39, "comesFrom", ["i"], [24]], ["i", 404, "comesFrom", ["i"], [343]], ["i", 161, "comesFrom", ["i"], [87]], ["i", 168, "comesFrom", ["i"], [87]], ["i", 283, "comesFrom", ["i"], [205]], ["i", 290, "comesFrom", ["i"], [205]], ["i", 313, "comesFrom", ["i"], [298]], ["i", 322, "comesFrom", ["i"], [298]], ["i", 150, "comesFrom", ["i"], [87]], ["i", 272, "comesFrom", ["i"], [205]], ["i", 124, "comesFrom", ["i"], [87]], ["i", 246, "comesFrom", ["i"], [205]], ["i", 359, "comesFrom", ["i"], [343]], ["i", 368, "comesFrom", ["i"], [343]], ["i", 384, "comesFrom", ["i"], [343]], ["i", 393, "comesFrom", ["i"], [343]], ["i", 140, "comesFrom", ["i"], [87]], ["i", 262, "comesFrom", ["i"], [205]], ["size", 30, "comesFrom", ["size"], [18]], ["size", 439, "comesFrom", ["size"], [18]], ["size", 420, "comesFrom", ["size"], [18]], ["size", 362, "comesFrom", ["size"], [18]], ["size", 371, "comesFrom", ["size"], [18]], ["size", 387, "comesFrom", ["size"], [18]], ["size", 396, "comesFrom", ["size"], [18]], ["size", 134, "comesFrom", ["size"], [18]], ["size", 143, "comesFrom", ["size"], [18]], ["size", 256, "comesFrom", ["size"], [18]], ["size", 265, "comesFrom", ["size"], [18]], ["n", 93, "comesFrom", ["n"], [56]], ["n", 304, "comesFrom", ["n"], [56]], ["n", 349, "comesFrom", ["n"], [56]], ["n", 493, "comesFrom", ["n"], [474]], ["n", 207, "comesFrom", ["n"], [56]], ["n", 187, "comesFrom", ["n"], [56]], ["n", 196, "comesFrom", ["n"], [56]], ["n", 224, "comesFrom", ["n"], [56]], ["j", 106, "comesFrom", ["j"], [102]], ["j", 110, "comesFrom", ["j"], [102]], ["j", 228, "comesFrom", ["j"], [222]], ["j", 232, "comesFrom", ["j"], [222]], ["j", 155, "comesFrom", ["j"], [102]], ["j", 277, "comesFrom", ["j"], [222]], ["j", 119, "comesFrom", ["j"], [102]], ["j", 241, "comesFrom", ["j"], [222]], ["j", 131, "comesFrom", ["j"], [102]], ["j", 253, "comesFrom", ["j"], [222]], ["max", 377, "comesFrom", ["max"], [331]], ["maxIndex", 412, "comesFrom", ["maxIndex"], [402]], ["maxIndex", 431, "comesFrom", ["maxIndex"], [402]], ["maxIndex", 436, "comesFrom", ["maxIndex"], [402]], ["maxIndex", 417, "comesFrom", ["maxIndex"], [402]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int isKPalDP ( string str1 , string str2 , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) else if ( j == 0 ) else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else } } return dp [ m ] [ n ] ; } bool isKPal ( string str , int k ) { string revStr = str ; reverse ( revStr . begin ( ) , revStr . end ( ) ) ; int len = str . length ( ) ; return ( isKPalDP ( str , revStr , len , len ) <= k * 2 ) ; } int main ( ) { string str = \" acdcb \" ; int k = 2 ; isKPal ( str , k ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }", "docstring": "Find if string is K | C ++ program to find if given string is K - Palindrome or not ; find if given string is K - Palindrome or not ; Create a table to store results of subproblems ; Fill dp [ ] [ ] in bottom up manner ; If first string is empty , only option is to remove all characters of second string ; If second string is empty , only option is to remove all characters of first string ; If last characters are same , ignore last character and recur for remaining string ; If last character are different , remove it and find minimum ; dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , Remove from str1 dp [ i ] [ j - 1 ] ) ; Remove from str2 ; Returns true if str is k palindrome . ; Driver program", "dfg": [["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["i", 68, "comesFrom", ["i"], [39]], ["i", 84, "comesFrom", ["i"], [39]], ["i", 98, "comesFrom", ["i"], [39]], ["i", 106, "comesFrom", ["i"], [39]], ["m", 45, "comesFrom", ["m"], [17]], ["m", 26, "comesFrom", ["m"], [17]], ["m", 123, "comesFrom", ["m"], [17]], ["n", 31, "comesFrom", ["n"], [20]], ["n", 126, "comesFrom", ["n"], [20]], ["n", 60, "comesFrom", ["n"], [20]], ["j", 58, "comesFrom", ["j"], [54]], ["j", 62, "comesFrom", ["j"], [54]], ["j", 75, "comesFrom", ["j"], [54]], ["j", 101, "comesFrom", ["j"], [54]], ["j", 91, "comesFrom", ["j"], [54]], ["j", 111, "comesFrom", ["j"], [54]], ["str", 163, "comesFrom", ["str"], [143]], ["str", 207, "comesFrom", ["str"], [194]], ["str", 173, "comesFrom", ["str"], [143]], ["k", 182, "comesFrom", ["k"], [137]], ["k", 209, "comesFrom", ["k"], [201]], ["revStr", 147, "comesFrom", ["revStr"], [141]], ["revStr", 153, "comesFrom", ["revStr"], [141]], ["revStr", 175, "comesFrom", ["revStr"], [141]], ["len", 177, "comesFrom", ["len"], [161]], ["len", 179, "comesFrom", ["len"], [161]], ["str1", 82, "comesFrom", ["str1"], [11]], ["str2", 89, "comesFrom", ["str2"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcs ( string & X , string & Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ 2 ] [ n + 1 ] ; bool bi ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; } int main ( ) { string X = \" AGGTAB \" ; string Y = \" GXTXAYB \" ; printf ( \" Length ▁ of ▁ LCS ▁ is ▁ % d STRNEWLINE \" , lcs ( X , Y ) ) ; return 0 ; }", "docstring": "A Space Optimized Solution of LCS | Space optimized C ++ implementation of LCS problem ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Find lengths of two strings ; Binary index , used to index current row and previous row . ; Compute current binary index ; Last filled entry contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; Driver code", "dfg": [["i", 57, "comesFrom", ["i"], [53]], ["i", 61, "comesFrom", ["i"], [53]], ["i", 67, "comesFrom", ["i"], [53]], ["i", 88, "comesFrom", ["i"], [53]], ["i", 110, "comesFrom", ["i"], [53]], ["m", 59, "comesFrom", ["m"], [20]], ["X", 215, "comesFrom", ["X"], [194]], ["Y", 217, "comesFrom", ["Y"], [201]], ["n", 42, "comesFrom", ["n"], [28]], ["n", 184, "comesFrom", ["n"], [28]], ["n", 80, "comesFrom", ["n"], [28]], ["j", 78, "comesFrom", ["j"], [74]], ["j", 82, "comesFrom", ["j"], [74]], ["j", 91, "comesFrom", ["j"], [74]], ["j", 100, "comesFrom", ["j"], [74]], ["j", 127, "comesFrom", ["j"], [74]], ["j", 117, "comesFrom", ["j"], [74]], ["j", 150, "comesFrom", ["j"], [74]], ["j", 137, "comesFrom", ["j"], [74]], ["j", 162, "comesFrom", ["j"], [74]], ["j", 170, "comesFrom", ["j"], [74]], ["bi", 181, "comesFrom", ["bi"], [65]], ["bi", 97, "comesFrom", ["bi"], [65]], ["bi", 124, "comesFrom", ["bi"], [65]], ["bi", 147, "comesFrom", ["bi"], [65]], ["bi", 134, "comesFrom", ["bi"], [65]], ["bi", 167, "comesFrom", ["bi"], [65]], ["bi", 159, "comesFrom", ["bi"], [65]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int subsetXOR ( int arr [ ] , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( log2 ( max_ele ) + 1 ) ) - 1 ; if ( k > m ) return 0 ; int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Count ▁ of ▁ subsets ▁ is ▁ \" << subsetXOR ( arr , n , k ) ; return 0 ; }", "docstring": "Count number of subsets having a particular XOR value | arr dynamic programming solution to finding the number of subsets having xor of their elements as k ; Returns count of subsets of arr [ ] with XOR value equals to k . ; Find maximum element in arr [ ] ; Maximum possible XOR value ; The value of dp [ i ] [ j ] is the number of subsets having XOR of their elements as j from the set arr [ 0. . . i - 1 ] ; Initializing all the values of dp [ i ] [ j ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subset from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver program to test above function", "dfg": [["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 110, "comesFrom", ["i"], [106]], ["i", 114, "comesFrom", ["i"], [106]], ["i", 158, "comesFrom", ["i"], [154]], ["i", 162, "comesFrom", ["i"], [154]], ["i", 48, "comesFrom", ["i"], [33]], ["i", 57, "comesFrom", ["i"], [33]], ["i", 133, "comesFrom", ["i"], [106]], ["i", 181, "comesFrom", ["i"], [154]], ["i", 189, "comesFrom", ["i"], [154]], ["i", 199, "comesFrom", ["i"], [154]], ["i", 208, "comesFrom", ["i"], [154]], ["n", 39, "comesFrom", ["n"], [16]], ["n", 112, "comesFrom", ["n"], [16]], ["n", 160, "comesFrom", ["n"], [16]], ["n", 93, "comesFrom", ["n"], [16]], ["n", 217, "comesFrom", ["n"], [16]], ["n", 277, "comesFrom", ["n"], [252]], ["k", 83, "comesFrom", ["k"], [19]], ["k", 220, "comesFrom", ["k"], [19]], ["k", 279, "comesFrom", ["k"], [247]], ["m", 85, "comesFrom", ["m"], [61]], ["m", 98, "comesFrom", ["m"], [61]], ["m", 126, "comesFrom", ["m"], [61]], ["m", 174, "comesFrom", ["m"], [61]], ["j", 124, "comesFrom", ["j"], [120]], ["j", 128, "comesFrom", ["j"], [120]], ["j", 172, "comesFrom", ["j"], [168]], ["j", 176, "comesFrom", ["j"], [168]], ["j", 136, "comesFrom", ["j"], [120]], ["j", 184, "comesFrom", ["j"], [168]], ["j", 194, "comesFrom", ["j"], [168]], ["j", 204, "comesFrom", ["j"], [168]], ["max_ele", 51, "comesFrom", ["max_ele"], [23]], ["max_ele", 72, "comesFrom", ["max_ele"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool dp [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( arr [ i - 1 ] <= j ) dp [ i ] [ j ] |= dp [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } int diff = INT_MAX ; for ( int j = sum / 2 ; j >= 0 ; j -- ) { if ( dp [ n ] [ j ] == true ) { diff = sum - 2 * j ; break ; } } return diff ; } int main ( ) { int arr [ ] = { 3 , 1 , 4 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" The ▁ minimum ▁ difference ▁ between ▁ 2 ▁ sets ▁ is ▁ \" << findMin ( arr , n ) ; return 0 ; }", "docstring": "Partition a set into two subsets such that the difference of subset sums is minimum | A Recursive C program to solve minimum sum partition problem . ; Returns the minimum value of the difference of the two sets . ; Calculate sum of all elements ; Create an array to store results of subproblems ; Initialize first column as true . 0 sum is possible with all elements . ; Initialize top row , except dp [ 0 ] [ 0 ] , as false . With 0 elements , no other sum except 0 is possible ; Fill the partition table in bottom up manner ; If i 'th element is excluded ; If i 'th element is included ; Initialize difference of two sums . ; Find the largest j such that dp [ n ] [ j ] is true where j loops from sum / 2 t0 0 ; Driver program to test above function", "dfg": [["diff", 240, "comesFrom", ["diff"], [227]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 65, "comesFrom", ["i"], [61]], ["i", 69, "comesFrom", ["i"], [61]], ["i", 89, "comesFrom", ["i"], [85]], ["i", 93, "comesFrom", ["i"], [85]], ["i", 113, "comesFrom", ["i"], [109]], ["i", 117, "comesFrom", ["i"], [109]], ["i", 42, "comesFrom", ["i"], [27]], ["i", 101, "comesFrom", ["i"], [85]], ["i", 74, "comesFrom", ["i"], [61]], ["i", 138, "comesFrom", ["i"], [109]], ["i", 146, "comesFrom", ["i"], [109]], ["i", 158, "comesFrom", ["i"], [109]], ["i", 167, "comesFrom", ["i"], [109]], ["i", 175, "comesFrom", ["i"], [109]], ["i", 184, "comesFrom", ["i"], [109]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 67, "comesFrom", ["n"], [16]], ["n", 115, "comesFrom", ["n"], [16]], ["n", 48, "comesFrom", ["n"], [16]], ["n", 293, "comesFrom", ["n"], [268]], ["n", 218, "comesFrom", ["n"], [16]], ["sum", 91, "comesFrom", ["sum"], [38]], ["sum", 53, "comesFrom", ["sum"], [38]], ["sum", 130, "comesFrom", ["sum"], [38]], ["sum", 202, "comesFrom", ["sum"], [38]], ["sum", 229, "comesFrom", ["sum"], [38]], ["j", 206, "comesFrom", ["j"], [200]], ["j", 210, "comesFrom", ["j"], [200]], ["j", 128, "comesFrom", ["j"], [124]], ["j", 132, "comesFrom", ["j"], [124]], ["j", 163, "comesFrom", ["j"], [124]], ["j", 221, "comesFrom", ["j"], [200]], ["j", 141, "comesFrom", ["j"], [124]], ["j", 151, "comesFrom", ["j"], [124]], ["j", 233, "comesFrom", ["j"], [200]], ["j", 170, "comesFrom", ["j"], [124]], ["j", 180, "comesFrom", ["j"], [124]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE int dp [ MAX ] [ MAX ] [ MAX ] [ 2 ] ; int countPathsUtil ( int i , int j , int k , int d ) { if ( i < 0 j < 0 ) return 0 ; if ( i == 0 && j == 0 ) return 1 ; if ( k == 0 ) { if ( d == 0 && i == 0 ) return 1 ; if ( d == 1 && j == 0 ) return 1 ; return 0 ; } if ( dp [ i ] [ j ] [ k ] [ d ] != -1 ) return dp [ i ] [ j ] [ k ] [ d ] ; if ( d == 0 ) return dp [ i ] [ j ] [ k ] [ d ] = countPathsUtil ( i , j - 1 , k , d ) + countPathsUtil ( i - 1 , j , k - 1 , ! d ) ; return dp [ i ] [ j ] [ k ] [ d ] = countPathsUtil ( i - 1 , j , k , d ) + countPathsUtil ( i , j - 1 , k - 1 , ! d ) ; } int countPaths ( int i , int j , int k ) { if ( i == 0 && j == 0 ) return 1 ; memset ( dp , -1 , sizeof dp ) ; } int main ( ) { int m = 3 , n = 3 , k = 2 ; cout << \" Number ▁ of ▁ paths ▁ is ▁ \" << countPaths ( m - 1 , n - 1 , k ) << endl ; return 0 ; }", "docstring": "Count number of paths with at | C ++ program to count number of paths with maximum k turns allowed ; table to store results of subproblems ; Returns count of paths to reach ( i , j ) from ( 0 , 0 ) using at - most k turns . d is current direction d = 0 indicates along row , d = 1 indicates along column . ; If invalid row or column indexes ; If current cell is top left itself ; If 0 turns left ; If direction is row , then we can reach here only if direction is row and row is 0. ; If direction is column , then we can reach here only if direction is column and column is 0. ; If this subproblem is already evaluated ; If current direction is row , then count paths for two cases 1 ) We reach here through previous row . 2 ) We reach here through previous column , so number of turns k reduce by 1. ; Similar to above if direction is column ; This function mainly initializes ' dp ' array as - 1 and calls countPathsUtil ( ) ; If ( 0 , 0 ) is target itself ; Initialize ' dp ' array ; Recur for two cases : moving along row and along column return countPathsUtil ( i - 1 , j , k , 1 ) + Moving along row countPathsUtil ( i , j - 1 , k , 0 ) ; Moving along column ; Driver program", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE int dp [ MAX ] [ MAX ] ; int minSizeRec ( int arr [ ] , int low , int high , int k ) { if ( dp [ low ] [ high ] != -1 ) return dp [ low ] [ high ] ; if ( ( high - low + 1 ) < 3 ) return high - low + 1 ; int res = 1 + minSizeRec ( arr , low + 1 , high , k ) ; for ( int i = low + 1 ; i <= high - 1 ; i ++ ) { for ( int j = i + 1 ; j <= high ; j ++ ) { if ( arr [ i ] == ( arr [ low ] + k ) && arr [ j ] == ( arr [ low ] + 2 * k ) && minSizeRec ( arr , low + 1 , i - 1 , k ) == 0 && minSizeRec ( arr , i + 1 , j - 1 , k ) == 0 ) { res = min ( res , minSizeRec ( arr , j + 1 , high , k ) ) ; } } } return ( dp [ low ] [ high ] = res ) ; } int minSize ( int arr [ ] , int n , int k ) { memset ( dp , -1 , sizeof ( dp ) ) ; return minSizeRec ( arr , 0 , n - 1 , k ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 1 ; cout << minSize ( arr , n , k ) << endl ; return 0 ; }", "docstring": "Find minimum possible size of array with given rules for removing elements | C ++ program to find size of minimum possible array after removing elements according to given rules ; dp [ i ] [ j ] denotes the minimum number of elements left in the subarray arr [ i . . j ] . ; If already evaluated ; If size of array is less than 3 ; Initialize result as the case when first element is separated ( not removed using given rules ) ; Now consider all cases when first element forms a triplet and removed . Check for all possible triplets ( low , i , j ) ; Check if this triplet follows the given rules of removal . And elements between ' low ' and ' i ' , and between ' i ' and ' j ' can be recursively removed . ; Insert value in table and return result ; This function mainly initializes dp table and calls recursive function minSizeRec ; Driver program to test above function", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; } int main ( ) { int coeff [ ] = { 2 , 2 , 5 } ; int rhs = 4 ; int n = sizeof ( coeff ) / sizeof ( coeff [ 0 ] ) ; cout << countSol ( coeff , 0 , n - 1 , rhs ) ; return 0 ; }", "docstring": "Find number of solutions of a linear equation of n variables | A naive recursive C ++ program to find number of non - negative solutions for a given linear equation ; Recursive function that returns count of solutions for given rhs value and coefficients coeff [ start . . end ] ; Base case ; Initialize count of solutions ; One by subtract all smaller or equal coefficiants and recur ; Driver Code", "dfg": [["result", 81, "comesFrom", ["result"], [62]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 57, "comesFrom", ["i"], [42]], ["i", 68, "comesFrom", ["i"], [42]], ["i", 76, "comesFrom", ["i"], [42]], ["end", 48, "comesFrom", ["end"], [19]], ["end", 70, "comesFrom", ["end"], [19]], ["rhs", 27, "comesFrom", ["rhs"], [22]], ["rhs", 60, "comesFrom", ["rhs"], [22]], ["rhs", 135, "comesFrom", ["rhs"], [103]], ["rhs", 72, "comesFrom", ["rhs"], [22]], ["n", 131, "comesFrom", ["n"], [108]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaxRec ( string & str , int i , int n , int lookup [ ] ) { if ( i >= n ) return 0 ; if ( lookup [ i ] != -1 ) return lookup [ i ] ; int ans = 1 + getMaxRec ( str , i + 1 , n , lookup ) ; if ( i + 1 < n ) { if ( str [ i ] != str [ i + 1 ] ) ans = max ( 4 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; else ans = max ( 3 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } return lookup [ i ] = ans ; } int getMaxWeight ( string str ) { int n = str . length ( ) ; int lookup [ n ] ; memset ( lookup , -1 , sizeof lookup ) ; return getMaxRec ( str , 0 , str . length ( ) , lookup ) ; } int main ( ) { string str = \" AAAAABB \" ; cout << \" Maximum ▁ weight ▁ of ▁ a ▁ transformation ▁ of ▁ \" << str << \" ▁ is ▁ \" << getMaxWeight ( str ) ; return 0 ; }", "docstring": "Maximum weight transformation of a given string | C ++ program to find maximum weight transformation of a given string ; Returns weight of the maximum weight transformation ; Base case ; If this subproblem is already solved ; Don 't make pair, so  weight gained is 1 ; If we can make pair ; If elements are dissimilar , weight gained is 4 ; if elements are similar so for making a pair we toggle any of them . Since toggle cost is 1 so overall weight gain becomes 3 ; save and return maximum of above cases ; Initializes lookup table and calls getMaxRec ( ) ; Create and initialize lookup table ; Call recursive function ; Driver Code", "dfg": [["ans", 143, "comesFrom", ["ans"], [114]], ["ans", 110, "comesFrom", ["ans"], [91]], ["ans", 133, "comesFrom", ["ans"], [114]], ["n", 165, "comesFrom", ["n"], [154]], ["n", 30, "comesFrom", ["n"], [18]], ["n", 74, "comesFrom", ["n"], [18]], ["n", 63, "comesFrom", ["n"], [18]], ["n", 105, "comesFrom", ["n"], [18]], ["n", 128, "comesFrom", ["n"], [18]], ["str", 181, "comesFrom", ["str"], [150]], ["str", 156, "comesFrom", ["str"], [150]], ["str", 213, "comesFrom", ["str"], [201]], ["str", 221, "comesFrom", ["str"], [201]], ["str", 185, "comesFrom", ["str"], [150]], ["i", 28, "comesFrom", ["i"], [15]], ["i", 47, "comesFrom", ["i"], [15]], ["i", 70, "comesFrom", ["i"], [15]], ["i", 140, "comesFrom", ["i"], [15]], ["i", 39, "comesFrom", ["i"], [15]], ["i", 59, "comesFrom", ["i"], [15]], ["i", 81, "comesFrom", ["i"], [15]], ["i", 86, "comesFrom", ["i"], [15]], ["i", 101, "comesFrom", ["i"], [15]], ["i", 124, "comesFrom", ["i"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int steps ( int source , int step , int dest ) { if ( abs ( source ) > ( dest ) ) return INT_MAX ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return min ( pos , neg ) ; } int main ( ) { int dest = 11 ; cout << \" No . ▁ of ▁ steps ▁ required ▁ to ▁ reach ▁ \" << dest << \" ▁ is ▁ \" << steps ( 0 , 0 , dest ) ; return 0 ; }", "docstring": "Minimum steps to reach a destination | C ++ program to count number of steps to reach a point ; source -> source vertex step -> value of last step taken dest -> destination vertex ; base cases ; if we go on positive side ; if we go on negative side ; minimum of both cases ; Driver code", "dfg": [["step", 41, "comesFrom", ["step"], [14]], ["step", 54, "comesFrom", ["step"], [14]], ["step", 72, "comesFrom", ["step"], [14]], ["step", 50, "comesFrom", ["step"], [14]], ["step", 68, "comesFrom", ["step"], [14]], ["source", 36, "comesFrom", ["source"], [11]], ["source", 24, "comesFrom", ["source"], [11]], ["source", 48, "comesFrom", ["source"], [11]], ["source", 66, "comesFrom", ["source"], [11]], ["dest", 38, "comesFrom", ["dest"], [17]], ["dest", 28, "comesFrom", ["dest"], [17]], ["dest", 58, "comesFrom", ["dest"], [17]], ["dest", 76, "comesFrom", ["dest"], [17]], ["dest", 104, "comesFrom", ["dest"], [94]], ["dest", 116, "comesFrom", ["dest"], [94]], ["pos", 82, "comesFrom", ["pos"], [44]], ["neg", 84, "comesFrom", ["neg"], [62]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCSubStr ( string s , string t , int n , int m ) { int dp [ 2 ] [ m + 1 ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; } int main ( ) { string X = \" OldSite : GeeksforGeeks . org \" ; string Y = \" NewSite : GeeksQuiz . com \" ; int m = X . length ( ) ; int n = Y . length ( ) ; cout << LCSubStr ( X , Y , m , n ) ; return 0 ; cout << \" GFG ! \" ; return 0 ; }", "docstring": "Longest Common Substring | DP | C ++ implementation of the above approach ; Function to find the length of the longest LCS ; Create DP table ; Driver Code ; Function call", "dfg": [["res", 157, "comesFrom", ["res"], [128]], ["res", 126, "comesFrom", ["res"], [35]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 73, "comesFrom", ["i"], [42]], ["i", 88, "comesFrom", ["i"], [42]], ["i", 144, "comesFrom", ["i"], [42]], ["i", 118, "comesFrom", ["i"], [42]], ["i", 132, "comesFrom", ["i"], [42]], ["i", 99, "comesFrom", ["i"], [42]], ["n", 48, "comesFrom", ["n"], [17]], ["n", 207, "comesFrom", ["n"], [189]], ["m", 29, "comesFrom", ["m"], [20]], ["m", 63, "comesFrom", ["m"], [20]], ["m", 205, "comesFrom", ["m"], [180]], ["j", 61, "comesFrom", ["j"], [57]], ["j", 65, "comesFrom", ["j"], [57]], ["j", 80, "comesFrom", ["j"], [57]], ["j", 93, "comesFrom", ["j"], [57]], ["j", 149, "comesFrom", ["j"], [57]], ["j", 123, "comesFrom", ["j"], [57]], ["j", 137, "comesFrom", ["j"], [57]], ["j", 107, "comesFrom", ["j"], [57]], ["X", 182, "comesFrom", ["X"], [166]], ["X", 201, "comesFrom", ["X"], [166]], ["Y", 191, "comesFrom", ["Y"], [173]], ["Y", 203, "comesFrom", ["Y"], [173]], ["s", 71, "comesFrom", ["s"], [11]], ["t", 78, "comesFrom", ["t"], [14]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; string X , Y ; int lcs ( int i , int j , int count ) { if ( i == 0 j == 0 ) return count ; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; } int main ( ) { int n , m ; X = \" abcdxyz \" ; Y = \" xyzabcd \" ; n = X . size ( ) ; m = Y . size ( ) ; cout << lcs ( n , m , 0 ) ; return 0 ; }", "docstring": "Longest Common Substring | DP | C ++ program using to find length of the longest common substring recursion ; Returns length of function f or longest common substring of X [ 0. . m - 1 ] and Y [ 0. . n - 1 ] ; Driver code", "dfg": [["count", 105, "comesFrom", ["count"], [72]], ["count", 35, "comesFrom", ["count"], [22]], ["count", 76, "comesFrom", ["count"], [72]], ["count", 66, "comesFrom", ["count"], [54]], ["i", 27, "comesFrom", ["i"], [16]], ["i", 41, "comesFrom", ["i"], [16]], ["i", 58, "comesFrom", ["i"], [16]], ["i", 82, "comesFrom", ["i"], [16]], ["i", 93, "comesFrom", ["i"], [16]], ["j", 30, "comesFrom", ["j"], [19]], ["j", 48, "comesFrom", ["j"], [19]], ["j", 62, "comesFrom", ["j"], [19]], ["j", 97, "comesFrom", ["j"], [19]], ["j", 84, "comesFrom", ["j"], [19]], ["X", 39, "comesFrom", ["X"], [8]], ["X", 132, "comesFrom", ["X"], [118]], ["Y", 46, "comesFrom", ["Y"], [10]], ["Y", 140, "comesFrom", ["Y"], [124]], ["n", 150, "comesFrom", ["n"], [130]], ["m", 152, "comesFrom", ["m"], [138]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void possibleEqualArray ( int A [ ] , int N ) { int tot_XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { tot_XOR ^= A [ i ] ; } if ( tot_XOR == 0 ) { cout << \" YES \" ; return ; } int cur_XOR = 0 ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_XOR ^= A [ i ] ; if ( cur_XOR == tot_XOR ) { cnt ++ ; cur_XOR = 0 ; } } if ( cnt > 2 ) { cout << \" YES \" ; } else { cout << \" NO \" ; } } int main ( ) { int A [ ] = { 0 , 2 , 2 } ; int N = sizeof ( A ) / sizeof ( int ) ; possibleEqualArray ( A , N ) ; return 0 ; }", "docstring": "Make Array elements equal by replacing adjacent elements with their XOR | C ++ Program of the above approach ; Function to check if it is possible to make all the array elements equal using the given operation ; Stores the XOR of all elements of array A [ ] ; Case 1 , check if the XOR of the array A [ ] is 0 ; Maintains the XOR till the current element ; Iterate over the array ; If the current XOR is equal to the total XOR increment the count and initialize current XOR as 0 ; Print Answer ; Driver Code ; Function Call", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 80, "comesFrom", ["i"], [76]], ["i", 84, "comesFrom", ["i"], [76]], ["i", 43, "comesFrom", ["i"], [27]], ["i", 92, "comesFrom", ["i"], [76]], ["N", 33, "comesFrom", ["N"], [16]], ["N", 82, "comesFrom", ["N"], [16]], ["N", 170, "comesFrom", ["N"], [154]], ["tot_XOR", 49, "comesFrom", ["tot_XOR"], [39]], ["tot_XOR", 99, "comesFrom", ["tot_XOR"], [39]], ["cnt", 113, "comesFrom", ["cnt"], [69]], ["cnt", 102, "comesFrom", ["cnt"], [69]], ["cur_XOR", 97, "comesFrom", ["cur_XOR"], [88]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPalindromes ( string S ) { int N = ( int ) S . length ( ) ; vector < int > Z ( N ) ; int l = 0 , r = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( i <= r ) Z [ i ] = min ( r - i + 1 , Z [ i - l ] ) ; while ( i + Z [ i ] < N && S [ Z [ i ] ] == S [ i + Z [ i ] ] ) { Z [ i ] ++ ; } if ( i + Z [ i ] - 1 > r ) { l = i ; r = i + Z [ i ] - 1 ; } } int sum = 0 ; for ( int i = 0 ; i < Z . size ( ) ; i ++ ) { sum += Z [ i ] + 1 ; } return sum ; } int main ( ) { string S = \" abab \" ; cout << countPalindromes ( S ) ; return 0 ; }", "docstring": "Count of palindromes that can be obtained by concatenating equal length prefix and substrings | C ++ program the above approach ; Function to calculate the number of palindromes ; Calculation of Z - array ; Calculation of sigma ( Z [ i ] + 1 ) ; Return the count ; Driver Code ; Given String", "dfg": [["sum", 189, "comesFrom", ["sum"], [178]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 55, "comesFrom", ["i"], [47]], ["i", 166, "comesFrom", ["i"], [162]], ["i", 174, "comesFrom", ["i"], [162]], ["i", 61, "comesFrom", ["i"], [47]], ["i", 139, "comesFrom", ["i"], [47]], ["i", 67, "comesFrom", ["i"], [47]], ["i", 88, "comesFrom", ["i"], [47]], ["i", 125, "comesFrom", ["i"], [47]], ["i", 182, "comesFrom", ["i"], [162]], ["i", 118, "comesFrom", ["i"], [47]], ["i", 143, "comesFrom", ["i"], [47]], ["i", 74, "comesFrom", ["i"], [47]], ["i", 92, "comesFrom", ["i"], [47]], ["i", 107, "comesFrom", ["i"], [47]], ["i", 129, "comesFrom", ["i"], [47]], ["i", 80, "comesFrom", ["i"], [47]], ["i", 101, "comesFrom", ["i"], [47]], ["i", 147, "comesFrom", ["i"], [47]], ["i", 111, "comesFrom", ["i"], [47]], ["N", 53, "comesFrom", ["N"], [15]], ["N", 95, "comesFrom", ["N"], [15]], ["S", 208, "comesFrom", ["S"], [198]], ["S", 20, "comesFrom", ["S"], [11]], ["S", 97, "comesFrom", ["S"], [11]], ["S", 105, "comesFrom", ["S"], [11]], ["r", 63, "comesFrom", ["r"], [40]], ["r", 134, "comesFrom", ["r"], [40]], ["r", 72, "comesFrom", ["r"], [40]], ["l", 82, "comesFrom", ["l"], [36]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsInDelimeters ( string str ) { stack < int > dels ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { if ( str [ i ] == ' [ ' ) { dels . push ( i ) ; } else if ( str [ i ] == ' ] ' && ! dels . empty ( ) ) { int pos = dels . top ( ) ; dels . pop ( ) ; int len = i - 1 - pos ; string ans = str . substr ( pos + 1 , len ) ; cout << ans << endl ; } } } int main ( ) { string str = \" [ This ▁ is ▁ first ] ▁ ignored ▁ text ▁ [ This ▁ is ▁ second ] \" ; printSubsInDelimeters ( str ) ; return 0 ; }", "docstring": "Extract substrings between any pair of delimiters | C ++ Program to implement the above approach ; Function to print strings present between any pair of delimeters ; Stores the indices of ; If opening delimeter is encountered ; If closing delimeter is encountered ; Extract the position of opening delimeter ; Length of substring ; Extract the substring ; Driver Code", "dfg": [["i", 27, "comesFrom", ["i"], [23]], ["i", 35, "comesFrom", ["i"], [23]], ["i", 43, "comesFrom", ["i"], [23]], ["i", 57, "comesFrom", ["i"], [23]], ["i", 66, "comesFrom", ["i"], [23]], ["i", 101, "comesFrom", ["i"], [23]], ["str", 144, "comesFrom", ["str"], [136]], ["str", 29, "comesFrom", ["str"], [11]], ["str", 41, "comesFrom", ["str"], [11]], ["str", 64, "comesFrom", ["str"], [11]], ["str", 110, "comesFrom", ["str"], [11]], ["dels", 53, "comesFrom", ["dels"], [18]], ["dels", 92, "comesFrom", ["dels"], [18]], ["dels", 76, "comesFrom", ["dels"], [18]], ["dels", 86, "comesFrom", ["dels"], [18]], ["pos", 105, "comesFrom", ["pos"], [84]], ["pos", 114, "comesFrom", ["pos"], [84]], ["ans", 123, "comesFrom", ["ans"], [108]], ["len", 118, "comesFrom", ["len"], [99]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printDiagonalTraversal ( vector < vector < int > > & nums ) { int m = nums . size ( ) ; queue < pair < int , int > > q ; q . push ( { 0 , 0 } ) ; while ( ! q . empty ( ) ) { pair < int , int > p = q . front ( ) ; q . pop ( ) ; cout << nums [ p . first ] [ p . second ] << \" ▁ \" ; if ( p . second == 0 && p . first + 1 < m ) { q . push ( { p . first + 1 , p . second } ) ; } if ( p . second + 1 < nums [ p . first ] . size ( ) ) q . push ( { p . first , p . second + 1 } ) ; } } int main ( ) { vector < vector < int > > arr = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; printDiagonalTraversal ( arr ) ; return 0 ; }", "docstring": "Print matrix elements from top | C ++ program for the above approach ; Function to traverse the matrix diagonally upwards ; Store the number of rows ; Initialize queue ; Push the index of first element i . e . , ( 0 , 0 ) ; Get the front element ; Pop the element at the front ; Insert the element below if the current element is in first column ; Insert the right neighbour if it exists ; Driver Code ; Given vector of vectors arr ; Function call", "dfg": [["q", 41, "comesFrom", ["q"], [39]], ["q", 55, "comesFrom", ["q"], [39]], ["q", 76, "comesFrom", ["q"], [39]], ["q", 70, "comesFrom", ["q"], [39]], ["q", 154, "comesFrom", ["q"], [39]], ["q", 117, "comesFrom", ["q"], [39]], ["arr", 215, "comesFrom", ["arr"], [185]], ["m", 114, "comesFrom", ["m"], [22]], ["p", 102, "comesFrom", ["p"], [68]], ["p", 137, "comesFrom", ["p"], [68]], ["p", 91, "comesFrom", ["p"], [68]], ["p", 108, "comesFrom", ["p"], [68]], ["p", 159, "comesFrom", ["p"], [68]], ["p", 86, "comesFrom", ["p"], [68]], ["p", 128, "comesFrom", ["p"], [68]], ["p", 163, "comesFrom", ["p"], [68]], ["p", 122, "comesFrom", ["p"], [68]], ["p", 145, "comesFrom", ["p"], [68]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > restore ( int arr [ ] , int N ) { vector < int > result ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp [ arr [ i ] ] == 0 ) { result . push_back ( arr [ i ] ) ; mp [ arr [ i ] ] ++ ; } } return result ; } void print_result ( vector < int > result ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) cout << result [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 13 , 1 , 24 , 13 , 24 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print_result ( restore ( arr , N ) ) ; return 0 ; }", "docstring": "Find original sequence from Array containing the sequence merged many times in order | C ++ program for the above approach ; Function that returns the restored permutation ; Vector to store the result ; Map to mark the elements which are taken in result ; Check if the element is coming first time ; Push in result vector ; Mark it in the map ; Return the answer ; Function to print the result ; Driver Code ; Given Array ; Function Call", "dfg": [["result", 86, "comesFrom", ["result"], [26]], ["result", 108, "comesFrom", ["result"], [96]], ["result", 119, "comesFrom", ["result"], [96]], ["result", 64, "comesFrom", ["result"], [26]], ["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["i", 106, "comesFrom", ["i"], [102]], ["i", 114, "comesFrom", ["i"], [102]], ["i", 121, "comesFrom", ["i"], [102]], ["i", 57, "comesFrom", ["i"], [39]], ["i", 70, "comesFrom", ["i"], [39]], ["i", 78, "comesFrom", ["i"], [39]], ["N", 45, "comesFrom", ["N"], [19]], ["N", 179, "comesFrom", ["N"], [158]], ["mp", 53, "comesFrom", ["mp"], [34]], ["mp", 74, "comesFrom", ["mp"], [34]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > restore ( int arr [ ] , int N ) { vector < int > result ; int count1 = 1 ; set < int > s ; for ( int i = 0 ; i < N ; i ++ ) { s . insert ( arr [ i ] ) ; if ( s . size ( ) == count1 ) { result . push_back ( arr [ i ] ) ; count1 ++ ; } } return result ; } void print_result ( vector < int > result ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) cout << result [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 13 , 1 , 24 , 13 , 24 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print_result ( restore ( arr , N ) ) ; return 0 ; }", "docstring": "Find original sequence from Array containing the sequence merged many times in order | C ++ program for the above approach ; Function that returns the restored permutation ; Vector to store the result ; Set to insert unique elements ; Check if the element is coming first time ; Push in result vector ; Function to print the result ; Driver Code ; Given Array ; Function Call", "dfg": [["result", 91, "comesFrom", ["result"], [26]], ["result", 113, "comesFrom", ["result"], [101]], ["result", 124, "comesFrom", ["result"], [101]], ["result", 75, "comesFrom", ["result"], [26]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 111, "comesFrom", ["i"], [107]], ["i", 119, "comesFrom", ["i"], [107]], ["i", 126, "comesFrom", ["i"], [107]], ["i", 60, "comesFrom", ["i"], [42]], ["i", 81, "comesFrom", ["i"], [42]], ["N", 48, "comesFrom", ["N"], [19]], ["N", 184, "comesFrom", ["N"], [163]], ["s", 54, "comesFrom", ["s"], [37]], ["s", 66, "comesFrom", ["s"], [37]], ["count1", 72, "comesFrom", ["count1"], [29]], ["count1", 85, "comesFrom", ["count1"], [29]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int n ) { return n * ( n - 1 ) / 2 ; } void BSpattern ( int N ) { int Val = 0 , Pthree = 0 , cnt = 0 , initial ; string s = \" * * \" ; for ( int i = 0 ; i < N ; i ++ ) { cnt = 0 ; if ( i > 0 ) { cout << s ; s += \" * * \" ; } for ( int j = i ; j < N ; j ++ ) { if ( i > 0 ) { cnt ++ ; } cout << ++ Val ; cout << 0 ; } if ( i == 0 ) { int Sumbeforelast = sum ( Val ) * 2 ; Pthree = Val + Sumbeforelast + 1 ; initial = Pthree ; } initial = initial - cnt ; Pthree = initial ; for ( int k = i ; k < N ; k ++ ) { cout << Pthree ++ ; if ( k != N - 1 ) { cout << 0 ; } } cout << \" STRNEWLINE \" ; } } int main ( ) { int N = 5 ; BSpattern ( N ) ; return 0 ; }", "docstring": "Program to print the pattern 1020304017018019020 * * 50607014015016 * * * * 809012013 * * * * * * 10011. . . | C ++ implementation to print the given pattern ; Function to find the sum of N integers from 1 to N ; Function to print the given pattern ; Iterate over [ 0 , N - 1 ] ; Sub - Pattern - 1 ; Sub - Pattern - 2 ; Count the number of element in rows and sub - pattern 2 and 3 will have same rows ; Increment Val to print the series 1 , 2 , 3 , 4 , 5 ... ; Finally , add the ( N - 1 ) th element i . e . , 5 and increment it by 1 ; Initial is used to give the initial value of the row in Sub - Pattern 3 ; Sub - Pattern 3 ; Skip printing zero at the last ; Driver Code ; Given N ; Function Call", "dfg": [["i", 62, "comesFrom", ["i"], [58]], ["i", 66, "comesFrom", ["i"], [58]], ["i", 76, "comesFrom", ["i"], [58]], ["i", 130, "comesFrom", ["i"], [97]], ["i", 109, "comesFrom", ["i"], [97]], ["N", 64, "comesFrom", ["N"], [30]], ["N", 223, "comesFrom", ["N"], [217]], ["N", 101, "comesFrom", ["N"], [30]], ["N", 177, "comesFrom", ["N"], [30]], ["N", 192, "comesFrom", ["N"], [30]], ["n", 15, "comesFrom", ["n"], [11]], ["n", 18, "comesFrom", ["n"], [11]], ["j", 99, "comesFrom", ["j"], [95]], ["j", 103, "comesFrom", ["j"], [95]], ["initial", 166, "comesFrom", ["initial"], [158]], ["initial", 160, "comesFrom", ["initial"], [158]], ["k", 175, "comesFrom", ["k"], [171]], ["k", 179, "comesFrom", ["k"], [171]], ["k", 190, "comesFrom", ["k"], [171]], ["cnt", 162, "comesFrom", ["cnt"], [70]], ["cnt", 114, "comesFrom", ["cnt"], [70]], ["s", 83, "comesFrom", ["s"], [49]], ["Pthree", 155, "comesFrom", ["Pthree"], [145]], ["Pthree", 185, "comesFrom", ["Pthree"], [164]], ["Val", 121, "comesFrom", ["Val"], [34]], ["Val", 147, "comesFrom", ["Val"], [34]], ["Val", 140, "comesFrom", ["Val"], [34]], ["Sumbeforelast", 149, "comesFrom", ["Sumbeforelast"], [136]]]}
{"code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; bool checkprefix ( int A , int B ) { string s1 = to_string ( A ) ; string s2 = to_string ( B ) ; int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { return false ; } } return true ; } int main ( ) { int A = 12345 , B = 12 ; bool result = checkprefix ( A , B ) ; if ( result ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "docstring": "Check if a number starts with another number or not | C ++ program for the above approach ; Function to check if B is a prefix of A or not ; Convert numbers into strings ; Find the lengths of strings s1 and s2 ; Base Case ; Traverse the strings s1 & s2 ; If at any index characters are unequals then return false ; Return true ; Driver Code ; Given numbers ; Function Call ; If B is a prefix of A , then print \" Yes \"", "dfg": [["i", 71, "comesFrom", ["i"], [67]], ["i", 75, "comesFrom", ["i"], [67]], ["i", 83, "comesFrom", ["i"], [67]], ["i", 88, "comesFrom", ["i"], [67]], ["n2", 73, "comesFrom", ["n2"], [45]], ["n2", 57, "comesFrom", ["n2"], [45]], ["result", 127, "comesFrom", ["result"], [116]], ["n1", 55, "comesFrom", ["n1"], [36]], ["A", 24, "comesFrom", ["A"], [13]], ["A", 120, "comesFrom", ["A"], [107]], ["B", 32, "comesFrom", ["B"], [16]], ["B", 122, "comesFrom", ["B"], [111]], ["s1", 38, "comesFrom", ["s1"], [20]], ["s1", 81, "comesFrom", ["s1"], [20]], ["s2", 47, "comesFrom", ["s2"], [28]], ["s2", 86, "comesFrom", ["s2"], [28]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void possibleToReach ( int x , int y , int z ) { if ( z < abs ( x ) + abs ( y ) || ( z - abs ( x ) - abs ( y ) ) % 2 ) { cout << \" Not ▁ Possible \" << endl ; } else cout << \" Possible \" << endl ; } int main ( ) { int x = 5 , y = 5 ; int z = 11 ; possibleToReach ( x , y , z ) ; return 0 ; }", "docstring": "Check if it is possible to reach ( x , y ) from origin in exactly Z steps using only plus movements | C ++ program for the above approach ; Function to check if it is possible to reach ( x , y ) from origin in exactly z steps ; Condition if we can 't reach in Z steps ; Driver Code ; Destination point coordinate ; Number of steps allowed ; Function Call", "dfg": [["x", 91, "comesFrom", ["x"], [76]], ["x", 26, "comesFrom", ["x"], [11]], ["x", 39, "comesFrom", ["x"], [11]], ["y", 93, "comesFrom", ["y"], [80]], ["y", 31, "comesFrom", ["y"], [14]], ["y", 44, "comesFrom", ["y"], [14]], ["z", 95, "comesFrom", ["z"], [85]], ["z", 22, "comesFrom", ["z"], [17]], ["z", 35, "comesFrom", ["z"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; } int main ( ) { int N = 4 ; cout << nCycle ( N ) << endl ; return 0 ; }", "docstring": "Number of cycles in a Polygon with lines from Centroid to Vertices | C ++ program to find number of cycles in a Polygon with lines from Centroid to Vertices ; Function to find the Number of Cycles ; Driver code", "dfg": [["N", 16, "comesFrom", ["N"], [11]], ["N", 20, "comesFrom", ["N"], [11]], ["N", 42, "comesFrom", ["N"], [34]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long a [ 65 ] = { 0 } ; long long Count ( int i ) { if ( i == 0 ) return 1 ; else if ( i < 0 ) return 0 ; if ( a [ i ] == 0 ) { a [ i ] = ( i + 1 ) + 2 * Count ( i - 1 ) ; return a [ i ] ; } else return a [ i ] ; } long long solve ( long long n ) { long long i , sum = 0 ; while ( n > 0 ) { i = log2 ( n ) ; n = n - pow ( 2 , i ) ; sum = sum + ( i + 1 ) + Count ( i - 1 ) ; } return sum ; } int main ( ) { long long n = 7 ; cout << solve ( n ) << endl ; return 0 ; }", "docstring": "Sum of consecutive bit differences of first N non | C ++ program for the above problem ; Recursive function to count the sum of bit differences of numbers from 1 to pow ( 2 , ( i + 1 ) ) - 1 ; base cases ; Recursion call if the sum of bit difference of numbers around i are not calculated ; return the sum of bit differences if already calculated ; Function to calculate the sum of bit differences up to N ; nearest smaller power of 2 ; remaining numbers ; calculate the count of bit diff ; Driver code", "dfg": [["sum", 151, "comesFrom", ["sum"], [132]], ["sum", 134, "comesFrom", ["sum"], [132]], ["i", 28, "comesFrom", ["i"], [23]], ["i", 38, "comesFrom", ["i"], [23]], ["i", 49, "comesFrom", ["i"], [23]], ["i", 78, "comesFrom", ["i"], [23]], ["i", 86, "comesFrom", ["i"], [23]], ["i", 57, "comesFrom", ["i"], [23]], ["i", 61, "comesFrom", ["i"], [23]], ["i", 129, "comesFrom", ["i"], [114]], ["i", 137, "comesFrom", ["i"], [114]], ["i", 144, "comesFrom", ["i"], [114]], ["i", 70, "comesFrom", ["i"], [23]], ["n", 109, "comesFrom", ["n"], [96]], ["n", 123, "comesFrom", ["n"], [121]], ["n", 169, "comesFrom", ["n"], [161]], ["n", 118, "comesFrom", ["n"], [96]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > count_ht ( char s , int N ) { pair < int , int > p ; if ( s == ' H ' ) { p . first = floor ( N / 2.0 ) ; p . second = ceil ( N / 2.0 ) ; } else if ( s == ' T ' ) { p . first = ceil ( N / 2.0 ) ; p . second = floor ( N / 2.0 ) ; } return p ; } int main ( ) { char C = ' H ' ; int N = 5 ; pair < int , int > p = count_ht ( C , N ) ; cout << \" Head ▁ = ▁ \" << ( p . first ) << \" STRNEWLINE \" ; cout << \" Tail ▁ = ▁ \" << ( p . second ) << \" STRNEWLINE \" ; }", "docstring": "Count of total Heads and Tails after N flips in a coin | C ++ program to count total heads and tails after N flips in a coin ; Function to find count of head and tail ; Check if initially all the coins are facing towards head ; Check if initially all the coins are facing towards tail ; Driver code", "dfg": [["p", 100, "comesFrom", ["p"], [28]], ["p", 41, "comesFrom", ["p"], [28]], ["p", 52, "comesFrom", ["p"], [28]], ["p", 144, "comesFrom", ["p"], [128]], ["p", 160, "comesFrom", ["p"], [128]], ["p", 76, "comesFrom", ["p"], [28]], ["p", 87, "comesFrom", ["p"], [28]], ["s", 32, "comesFrom", ["s"], [16]], ["s", 67, "comesFrom", ["s"], [16]], ["C", 132, "comesFrom", ["C"], [109]], ["N", 134, "comesFrom", ["N"], [118]], ["N", 47, "comesFrom", ["N"], [19]], ["N", 58, "comesFrom", ["N"], [19]], ["N", 82, "comesFrom", ["N"], [19]], ["N", 93, "comesFrom", ["N"], [19]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string findPalindrome ( string C ) { string S = C ; reverse ( S . begin ( ) , S . end ( ) ) ; C = C + \" & \" + S ; int n = C . length ( ) ; int longestPalindrome [ n ] ; longestPalindrome [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( C [ i ] == C [ len ] ) { len ++ ; longestPalindrome [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = longestPalindrome [ len - 1 ] ; } else { longestPalindrome [ i ] = 0 ; i ++ ; } } } string ans = C . substr ( 0 , longestPalindrome [ n - 1 ] ) ; return ans ; } string findAns ( string s ) { string A = \" \" ; string B = \" \" ; string F = \" \" ; int i = 0 ; int j = s . length ( ) - 1 ; int len = s . length ( ) ; while ( i < j && s [ i ] == s [ j ] ) { i = i + 1 ; j = j - 1 ; } if ( i > 0 ) { A = s . substr ( 0 , i ) ; B = s . substr ( len - i , i ) ; } if ( len > 2 * i ) { string C = s . substr ( i , s . length ( ) - 2 * i ) ; string D = findPalindrome ( C ) ; reverse ( C . begin ( ) , C . end ( ) ) ; string E = findPalindrome ( C ) ; if ( D . length ( ) > E . length ( ) ) { F = D ; } else { F = E ; } } string answer = A + F + B ; return answer ; } int main ( ) { string str = \" abcdefghiedcba \" ; cout << findAns ( str ) << endl ; }", "docstring": "Longest palindromic string possible after removal of a substring | C ++ Implementation of the above approach ; Function to find the longest palindrome from the start of the string using KMP match ; Append S ( reverse of C ) to C ; Use KMP algorithm ; Function to return longest palindromic string possible from the given string after removal of any substring ; Initialize three strings A , B AND F ; Loop to find longest substrings from both ends which are reverse of each other ; Proceed to third step of our approach ; Remove the substrings A and B ; Find the longest palindromic substring from beginning of C ; Find the longest palindromic substring from end of C ; Store the maximum of D and E in F ; Find the final answer ; Driver Code", "dfg": [["ans", 162, "comesFrom", ["ans"], [145]], ["answer", 378, "comesFrom", ["answer"], [369]], ["n", 56, "comesFrom", ["n"], [45]], ["n", 80, "comesFrom", ["n"], [45]], ["n", 155, "comesFrom", ["n"], [45]], ["S", 42, "comesFrom", ["S"], [15]], ["S", 21, "comesFrom", ["S"], [15]], ["S", 27, "comesFrom", ["S"], [15]], ["i", 78, "comesFrom", ["i"], [72]], ["i", 250, "comesFrom", ["i"], [235]], ["i", 220, "comesFrom", ["i"], [194]], ["i", 286, "comesFrom", ["i"], [235]], ["i", 237, "comesFrom", ["i"], [235]], ["i", 106, "comesFrom", ["i"], [72]], ["i", 226, "comesFrom", ["i"], [194]], ["i", 263, "comesFrom", ["i"], [235]], ["i", 276, "comesFrom", ["i"], [235]], ["i", 296, "comesFrom", ["i"], [235]], ["i", 87, "comesFrom", ["i"], [72]], ["i", 274, "comesFrom", ["i"], [235]], ["i", 101, "comesFrom", ["i"], [72]], ["i", 306, "comesFrom", ["i"], [235]], ["i", 138, "comesFrom", ["i"], [72]], ["i", 133, "comesFrom", ["i"], [72]], ["len", 282, "comesFrom", ["len"], [210]], ["len", 96, "comesFrom", ["len"], [67]], ["len", 104, "comesFrom", ["len"], [67]], ["len", 92, "comesFrom", ["len"], [67]], ["len", 272, "comesFrom", ["len"], [210]], ["len", 114, "comesFrom", ["len"], [67]], ["len", 123, "comesFrom", ["len"], [119]], ["B", 375, "comesFrom", ["B"], [266]], ["C", 36, "comesFrom", ["C"], [34]], ["C", 47, "comesFrom", ["C"], [34]], ["C", 147, "comesFrom", ["C"], [34]], ["C", 85, "comesFrom", ["C"], [34]], ["C", 90, "comesFrom", ["C"], [34]], ["C", 314, "comesFrom", ["C"], [290]], ["C", 337, "comesFrom", ["C"], [290]], ["C", 319, "comesFrom", ["C"], [290]], ["C", 325, "comesFrom", ["C"], [290]], ["s", 212, "comesFrom", ["s"], [169]], ["s", 201, "comesFrom", ["s"], [169]], ["s", 224, "comesFrom", ["s"], [169]], ["s", 229, "comesFrom", ["s"], [169]], ["s", 257, "comesFrom", ["s"], [169]], ["s", 268, "comesFrom", ["s"], [169]], ["s", 292, "comesFrom", ["s"], [169]], ["s", 298, "comesFrom", ["s"], [169]], ["j", 222, "comesFrom", ["j"], [199]], ["j", 243, "comesFrom", ["j"], [241]], ["j", 231, "comesFrom", ["j"], [199]], ["A", 371, "comesFrom", ["A"], [255]], ["F", 373, "comesFrom", ["F"], [362]], ["str", 397, "comesFrom", ["str"], [387]], ["D", 357, "comesFrom", ["D"], [310]], ["D", 342, "comesFrom", ["D"], [310]], ["E", 348, "comesFrom", ["E"], [333]], ["E", 364, "comesFrom", ["E"], [333]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; } int main ( ) { int N = 5 ; cout << nthTerm ( N ) << endl ; return 0 ; }", "docstring": "Find Nth term of the series 2 , 3 , 10 , 15 , 26. ... | C ++ program to find Nth term of the series 2 , 3 , 10 , 15 , 26. ... ; Function to find Nth term ; Nth term ; Driver Method", "dfg": [["nth", 49, "comesFrom", ["nth"], [38]], ["N", 21, "comesFrom", ["N"], [11]], ["N", 66, "comesFrom", ["N"], [58]], ["N", 30, "comesFrom", ["N"], [11]], ["N", 32, "comesFrom", ["N"], [11]], ["N", 41, "comesFrom", ["N"], [11]], ["N", 43, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; } int main ( ) { int N = 5 ; cout << nthTerm ( N ) << endl ; return 0 ; }", "docstring": "Find the Nth term in series 12 , 35 , 81 , 173 , 357 , ... | C ++ program to find the Nth term in series 12 , 35 , 81 , 173 , 357 , ... ; Function to find Nth term ; Nth term ; Driver Method", "dfg": [["nth", 58, "comesFrom", ["nth"], [23]], ["first_term", 26, "comesFrom", ["first_term"], [19]], ["N", 75, "comesFrom", ["N"], [67]], ["N", 33, "comesFrom", ["N"], [11]], ["N", 48, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; } int main ( ) { int N = 5 ; cout << nthTerm ( N ) << endl ; return 0 ; }", "docstring": "Find Nth term of the series 4 , 2 , 2 , 3 , 6 , ... | C ++ program to find Nth term of the series 4 , 2 , 2 , 3 , 6 , ... ; Function to find Nth term ; Nth term ; Driver code", "dfg": [["nth", 69, "comesFrom", ["nth"], [58]], ["n", 39, "comesFrom", ["n"], [33]], ["n", 50, "comesFrom", ["n"], [33]], ["n", 46, "comesFrom", ["n"], [33]], ["po", 66, "comesFrom", ["po"], [53]], ["first_term", 61, "comesFrom", ["first_term"], [19]], ["pi", 63, "comesFrom", ["pi"], [44]], ["N", 86, "comesFrom", ["N"], [78]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int finalNum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result = __gcd ( result , arr [ i ] ) ; } return result ; } int main ( ) { int arr [ ] = { 3 , 9 , 6 , 36 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << finalNum ( arr , n ) ; return 0 ; }", "docstring": "Find the final number obtained after performing the given operation | C ++ implementation of the approach ; Function to return the final number obtained after performing the given operation ; Find the gcd of the array elements ; Driver code", "dfg": [["result", 53, "comesFrom", ["result"], [39]], ["result", 43, "comesFrom", ["result"], [39]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 47, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 98, "comesFrom", ["n"], [77]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; } return false ; } bool isSatisfied ( string str , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) ) { return false ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) && ! isVowel ( str [ i + 1 ] ) ) { return false ; } } return true ; } int main ( ) { string str = \" acaba \" ; int n = str . length ( ) ; if ( isSatisfied ( str , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check whether all the substrings have number of vowels atleast as that of consonants | C ++ implementation of the approach ; Function that returns true if character ch is a vowel ; Compares two integers according to their digit sum ; Check if there are two consecutive consonants ; Check if there is any vowel surrounded by two consonants ; Driver code", "dfg": [["ch", 16, "comesFrom", ["ch"], [11]], ["i", 79, "comesFrom", ["i"], [75]], ["i", 83, "comesFrom", ["i"], [75]], ["i", 122, "comesFrom", ["i"], [118]], ["i", 128, "comesFrom", ["i"], [118]], ["i", 94, "comesFrom", ["i"], [75]], ["i", 138, "comesFrom", ["i"], [118]], ["i", 103, "comesFrom", ["i"], [75]], ["i", 158, "comesFrom", ["i"], [118]], ["i", 147, "comesFrom", ["i"], [118]], ["n", 81, "comesFrom", ["n"], [69]], ["n", 124, "comesFrom", ["n"], [69]], ["n", 201, "comesFrom", ["n"], [187]], ["str", 189, "comesFrom", ["str"], [180]], ["str", 199, "comesFrom", ["str"], [180]], ["str", 92, "comesFrom", ["str"], [66]], ["str", 101, "comesFrom", ["str"], [66]], ["str", 136, "comesFrom", ["str"], [66]], ["str", 156, "comesFrom", ["str"], [66]], ["str", 145, "comesFrom", ["str"], [66]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int LengthlongestPrefixSuffix ( string s ) { int n = s . length ( ) ; int lps [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; } string longestPrefixSuffix ( string s ) { int len = LengthlongestPrefixSuffix ( s ) ; string prefix = \" \" ; for ( int i = 0 ; i < len ; i ++ ) prefix += s [ i ] ; return prefix ; } int main ( ) { string s = \" abcab \" ; string ans = longestPrefixSuffix ( s ) ; if ( ans == \" \" ) cout << \" - 1\" ; else cout << ans ; return 0 ; }", "docstring": "Print the longest prefix of the given string which is also the suffix of the same string | C ++ implementation of the approach ; Returns length of the longest prefix which is also suffix and the two do not overlap . This function mainly is copy of computeLPSArray ( ) in KMP Algorithm ; lps [ 0 ] is always 0 ; Length of the previous longest prefix suffix ; Loop to calculate lps [ i ] for i = 1 to n - 1 ; This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step . ; Also , note that we do not increment i here ; If len = 0 ; Since we are looking for non overlapping parts ; Function that returns the prefix ; Get the length of the longest prefix ; Stores the prefix ; Traverse and add characters ; Returns the prefix ; Driver code", "dfg": [["prefix", 184, "comesFrom", ["prefix"], [176]], ["n", 26, "comesFrom", ["n"], [15]], ["n", 50, "comesFrom", ["n"], [15]], ["n", 133, "comesFrom", ["n"], [15]], ["n", 119, "comesFrom", ["n"], [15]], ["n", 128, "comesFrom", ["n"], [15]], ["res", 137, "comesFrom", ["res"], [115]], ["res", 126, "comesFrom", ["res"], [115]], ["i", 169, "comesFrom", ["i"], [165]], ["i", 173, "comesFrom", ["i"], [165]], ["i", 48, "comesFrom", ["i"], [42]], ["i", 180, "comesFrom", ["i"], [165]], ["i", 76, "comesFrom", ["i"], [42]], ["i", 57, "comesFrom", ["i"], [42]], ["i", 71, "comesFrom", ["i"], [42]], ["i", 108, "comesFrom", ["i"], [42]], ["i", 103, "comesFrom", ["i"], [42]], ["len", 171, "comesFrom", ["len"], [148]], ["len", 66, "comesFrom", ["len"], [37]], ["len", 74, "comesFrom", ["len"], [37]], ["len", 62, "comesFrom", ["len"], [37]], ["len", 84, "comesFrom", ["len"], [37]], ["len", 93, "comesFrom", ["len"], [89]], ["ans", 209, "comesFrom", ["ans"], [200]], ["ans", 224, "comesFrom", ["ans"], [200]], ["s", 17, "comesFrom", ["s"], [11]], ["s", 152, "comesFrom", ["s"], [144]], ["s", 178, "comesFrom", ["s"], [144]], ["s", 204, "comesFrom", ["s"], [193]], ["s", 55, "comesFrom", ["s"], [11]], ["s", 60, "comesFrom", ["s"], [11]]]}
{"code": "#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int no_of_characters ( int M ) { int k = 1 ; while ( true ) { if ( pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; } void print_string ( int M ) { int k , num , N ; k = no_of_characters ( M ) ; N = M - ( pow ( 2 , k ) - 2 ) ; while ( k > 0 ) { num = pow ( 2 , k - 1 ) ; if ( num >= N ) cout << \" A \" ; else { cout << \" B \" ; N -= num ; } k -- ; } cout << endl ; } int main ( ) { int M ; M = 30 ; print_string ( M ) ; M = 55 ; print_string ( M ) ; M = 100 ; print_string ( M ) ; return 0 ; }", "docstring": "Print a number as string of ' A ' and ' B ' in lexicographic order | C ++ program to implement the above approach ; Function to calculate number of characters in corresponding string of ' A ' and ' B ' ; Since the minimum number of characters will be 1 ; Calculating number of characters ; Since k length string can represent at most pow ( 2 , k + 1 ) - 2 that is if k = 4 , it can represent at most pow ( 2 , 4 + 1 ) - 2 = 30 so we have to calculate the length of the corresponding string ; return the length of the corresponding string ; Function to print corresponding string of ' A ' and ' B ' ; Find length of string ; Since the first number that can be represented by k length string will be ( pow ( 2 , k ) - 2 ) + 1 and it will be AAA ... A , k times , therefore , N will store that how much we have to print ; At a particular time , we have to decide whether we have to print ' A ' or ' B ' , this can be check by calculating the value of pow ( 2 , k - 1 ) ; Print new line ; Driver code", "dfg": [["k", 50, "comesFrom", ["k"], [18]], ["k", 91, "comesFrom", ["k"], [67]], ["k", 132, "comesFrom", ["k"], [67]], ["k", 42, "comesFrom", ["k"], [18]], ["k", 83, "comesFrom", ["k"], [67]], ["k", 102, "comesFrom", ["k"], [67]], ["k", 33, "comesFrom", ["k"], [18]], ["M", 76, "comesFrom", ["M"], [57]], ["M", 155, "comesFrom", ["M"], [149]], ["M", 164, "comesFrom", ["M"], [158]], ["M", 173, "comesFrom", ["M"], [167]], ["M", 71, "comesFrom", ["M"], [57]], ["M", 40, "comesFrom", ["M"], [14]], ["num", 109, "comesFrom", ["num"], [96]], ["num", 129, "comesFrom", ["num"], [96]], ["N", 111, "comesFrom", ["N"], [74]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string updateString ( string S , string A , string B ) { int l = A . length ( ) ; for ( int i = 0 ; i + l <= S . length ( ) ; i ++ ) { string curr = S . substr ( i , i + l ) ; if ( curr == A ) { string new_string = \" \" ; new_string += S . substr ( 0 , i ) + B + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else { string new_string = \" \" ; new_string += S . substr ( 0 , i ) + A + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } } return S ; } int main ( ) { string S = \" aab \" ; string A = \" aa \" ; string B = \" bb \" ; cout << ( updateString ( S , A , B ) ) << endl ; }", "docstring": "Replace two substrings ( of a string ) with each other | C ++ implementation of the approach ; Function to return the resultant string ; Iterate through all positions i ; Current sub - string of length = len ( A ) = len ( B ) ; If current sub - string gets equal to A or B ; Update S after replacing A ; Update S after replacing B ; Return the updated string ; Driver code", "dfg": [["S", 167, "comesFrom", ["S"], [154]], ["S", 40, "comesFrom", ["S"], [11]], ["S", 53, "comesFrom", ["S"], [11]], ["S", 201, "comesFrom", ["S"], [176]], ["S", 91, "comesFrom", ["S"], [11]], ["S", 80, "comesFrom", ["S"], [11]], ["S", 139, "comesFrom", ["S"], [106]], ["S", 99, "comesFrom", ["S"], [11]], ["S", 128, "comesFrom", ["S"], [106]], ["S", 147, "comesFrom", ["S"], [106]], ["i", 46, "comesFrom", ["i"], [32]], ["i", 36, "comesFrom", ["i"], [32]], ["i", 57, "comesFrom", ["i"], [32]], ["i", 59, "comesFrom", ["i"], [32]], ["i", 86, "comesFrom", ["i"], [32]], ["i", 95, "comesFrom", ["i"], [32]], ["i", 134, "comesFrom", ["i"], [110]], ["i", 143, "comesFrom", ["i"], [110]], ["l", 38, "comesFrom", ["l"], [21]], ["l", 61, "comesFrom", ["l"], [21]], ["l", 112, "comesFrom", ["l"], [21]], ["l", 160, "comesFrom", ["l"], [21]], ["l", 97, "comesFrom", ["l"], [21]], ["l", 145, "comesFrom", ["l"], [21]], ["A", 23, "comesFrom", ["A"], [14]], ["A", 68, "comesFrom", ["A"], [14]], ["A", 203, "comesFrom", ["A"], [183]], ["A", 137, "comesFrom", ["A"], [14]], ["curr", 66, "comesFrom", ["curr"], [51]], ["new_string", 108, "comesFrom", ["new_string"], [78]], ["new_string", 156, "comesFrom", ["new_string"], [126]], ["B", 205, "comesFrom", ["B"], [190]], ["B", 89, "comesFrom", ["B"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPattern ( int n , int m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { cout << \" - 1\" ; } else if ( abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { cout << \"01\" ; n -- ; m -- ; } if ( n != 0 ) { cout << \"0\" ; } if ( m != 0 ) { cout << \"1\" ; } } else { while ( m - n > 1 && n > 0 ) { cout << \"110\" ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { cout << \"10\" ; n -- ; m -- ; } while ( m > 0 ) { cout << \"1\" ; m -- ; } } } int main ( ) { int n = 4 , m = 8 ; printPattern ( n , m ) ; return 0 ; }", "docstring": "Print n 0 s and m 1 s such that no two 0 s and no three 1 s are together | C ++ implementation of the approach ; Function to print the required pattern ; When condition fails ; When m = n - 1 ; Driver program", "dfg": [["n", 197, "comesFrom", ["n"], [187]], ["n", 30, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 81, "comesFrom", ["n"], [11]], ["n", 47, "comesFrom", ["n"], [11]], ["n", 57, "comesFrom", ["n"], [11]], ["n", 72, "comesFrom", ["n"], [11]], ["n", 144, "comesFrom", ["n"], [135]], ["n", 118, "comesFrom", ["n"], [11]], ["n", 155, "comesFrom", ["n"], [135]], ["n", 114, "comesFrom", ["n"], [11]], ["n", 137, "comesFrom", ["n"], [135]], ["m", 199, "comesFrom", ["m"], [191]], ["m", 19, "comesFrom", ["m"], [14]], ["m", 28, "comesFrom", ["m"], [14]], ["m", 95, "comesFrom", ["m"], [14]], ["m", 49, "comesFrom", ["m"], [14]], ["m", 61, "comesFrom", ["m"], [14]], ["m", 75, "comesFrom", ["m"], [14]], ["m", 164, "comesFrom", ["m"], [129]], ["m", 158, "comesFrom", ["m"], [129]], ["m", 175, "comesFrom", ["m"], [129]], ["m", 112, "comesFrom", ["m"], [14]], ["m", 131, "comesFrom", ["m"], [129]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDecreasing ( int A [ ] , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } int main ( ) { int A [ ] = { 100 , 3 , 1 , 13 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << countDecreasing ( A , n ) ; return 0 ; }", "docstring": "Find the count of Strictly decreasing Subarrays | C ++ program to count number of strictly decreasing subarrays in O ( n ) time . ; Function to count the number of strictly decreasing subarrays ; Initialize length of current decreasing subarray ; Traverse through the array ; If arr [ i + 1 ] is less than arr [ i ] , then increment length ; Else Update count and reset length ; If last length is more than 1 ; Driver program", "dfg": [["cnt", 105, "comesFrom", ["cnt"], [88]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 38, "comesFrom", ["i"], [27]], ["i", 52, "comesFrom", ["i"], [27]], ["i", 45, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 150, "comesFrom", ["n"], [129]], ["len", 84, "comesFrom", ["len"], [76]], ["len", 55, "comesFrom", ["len"], [20]], ["len", 98, "comesFrom", ["len"], [76]], ["len", 93, "comesFrom", ["len"], [76]], ["len", 70, "comesFrom", ["len"], [20]], ["len", 65, "comesFrom", ["len"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumChar ( string S1 , string S2 ) { int n = S1 . size ( ) , m = S2 . size ( ) ; int ans = INT_MAX ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = min ( minRemovedChar , ans ) ; } return ans ; } int main ( ) { string S1 = \" abc \" ; string S2 = \" paxzk \" ; cout << minimumChar ( S1 , S2 ) ; return 0 ; }", "docstring": "Minimum changes required to make first string substring of second string | CPP program to find the minimum number of characters to be replaced in string S2 , such that S1 is a substring of S2 ; Function to find the minimum number of characters to be replaced in string S2 , such that S1 is a substring of S2 ; Get the sizes of both strings ; Traverse the string S2 ; From every index in S2 , check the number of mis - matching characters in substring of length of S1 ; Take minimum of prev and current mis - match ; return answer ; Driver Code", "dfg": [["ans", 109, "comesFrom", ["ans"], [98]], ["ans", 104, "comesFrom", ["ans"], [98]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 54, "comesFrom", ["i"], [42]], ["i", 87, "comesFrom", ["i"], [42]], ["S1", 20, "comesFrom", ["S1"], [11]], ["S1", 135, "comesFrom", ["S1"], [118]], ["S1", 80, "comesFrom", ["S1"], [11]], ["S2", 28, "comesFrom", ["S2"], [14]], ["S2", 137, "comesFrom", ["S2"], [125]], ["S2", 85, "comesFrom", ["S2"], [14]], ["m", 48, "comesFrom", ["m"], [26]], ["n", 50, "comesFrom", ["n"], [18]], ["n", 72, "comesFrom", ["n"], [18]], ["j", 70, "comesFrom", ["j"], [66]], ["j", 74, "comesFrom", ["j"], [66]], ["j", 82, "comesFrom", ["j"], [66]], ["j", 89, "comesFrom", ["j"], [66]], ["minRemovedChar", 102, "comesFrom", ["minRemovedChar"], [59]], ["minRemovedChar", 93, "comesFrom", ["minRemovedChar"], [59]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countFreq ( string & pat , string & txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { res ++ ; j = 0 ; } } return res ; } int main ( ) { string txt = \" dhimanman \" ; string pat = \" man \" ; cout << countFreq ( pat , txt ) ; return 0 ; }", "docstring": "Frequency of a substring in a string | Simple C ++ program to count occurrences of pat in txt . ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Driver program to test above function", "dfg": [["res", 108, "comesFrom", ["res"], [38]], ["res", 98, "comesFrom", ["res"], [38]], ["i", 49, "comesFrom", ["i"], [45]], ["i", 55, "comesFrom", ["i"], [45]], ["i", 79, "comesFrom", ["i"], [45]], ["pat", 134, "comesFrom", ["pat"], [124]], ["txt", 136, "comesFrom", ["txt"], [117]], ["N", 51, "comesFrom", ["N"], [29]], ["M", 53, "comesFrom", ["M"], [20]], ["M", 70, "comesFrom", ["M"], [20]], ["M", 95, "comesFrom", ["M"], [20]], ["j", 68, "comesFrom", ["j"], [64]], ["j", 72, "comesFrom", ["j"], [64]], ["j", 93, "comesFrom", ["j"], [64]], ["j", 86, "comesFrom", ["j"], [64]], ["j", 81, "comesFrom", ["j"], [64]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { cout << \" Pattern ▁ found ▁ at ▁ index ▁ \" << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } int main ( ) { string txt = \" ABCEABCDABCEABCD \" ; string pat = \" ABCD \" ; search ( pat , txt ) ; return 0 ; }", "docstring": "Optimized Naive Algorithm for Pattern Searching | C ++ program for A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; if ( j == M ) if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; slide the pattern by j ; Driver code", "dfg": [["i", 42, "comesFrom", ["i"], [36]], ["i", 109, "comesFrom", ["i"], [107]], ["i", 116, "comesFrom", ["i"], [114]], ["i", 88, "comesFrom", ["i"], [36]], ["i", 94, "comesFrom", ["i"], [92]], ["i", 69, "comesFrom", ["i"], [36]], ["pat", 143, "comesFrom", ["pat"], [135]], ["pat", 20, "comesFrom", ["pat"], [11]], ["pat", 74, "comesFrom", ["pat"], [11]], ["txt", 145, "comesFrom", ["txt"], [128]], ["txt", 29, "comesFrom", ["txt"], [14]], ["txt", 67, "comesFrom", ["txt"], [14]], ["N", 44, "comesFrom", ["N"], [27]], ["M", 46, "comesFrom", ["M"], [18]], ["M", 60, "comesFrom", ["M"], [18]], ["M", 96, "comesFrom", ["M"], [18]], ["j", 58, "comesFrom", ["j"], [54]], ["j", 62, "comesFrom", ["j"], [54]], ["j", 118, "comesFrom", ["j"], [54]], ["j", 102, "comesFrom", ["j"], [54]], ["j", 76, "comesFrom", ["j"], [54]], ["j", 71, "comesFrom", ["j"], [54]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMissingDigit ( string a , string b , string c ) { int w = 1 ; int a_mod_11 = 0 ; for ( int i = a . size ( ) - 1 ; i >= 0 ; i -- ) { a_mod_11 = ( a_mod_11 + w * ( a [ i ] - '0' ) ) % 11 ; w = w * -1 ; } int b_mod_11 = 0 ; w = 1 ; for ( int i = b . size ( ) - 1 ; i >= 0 ; i -- ) { b_mod_11 = ( b_mod_11 + w * ( b [ i ] - '0' ) ) % 11 ; w = w * -1 ; } int c_mod_11 = 0 ; bool xSignIsPositive = true ; w = 1 ; for ( int i = c . size ( ) - 1 ; i >= 0 ; i -- ) { if ( c [ i ] == ' x ' ) { xSignIsPositive = ( w == 1 ) ; } else { c_mod_11 = ( c_mod_11 + w * ( c [ i ] - '0' ) ) % 11 ; } w = w * -1 ; } int x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 ; if ( ! xSignIsPositive ) { x = - x ; } return ( x % 11 + 11 ) % 11 ; } int main ( ) { string A = \"123456789\" ; string B = \"987654321\" ; string C = \"12193263111x635269\" ; cout << findMissingDigit ( A , B , C ) ; return 0 ; }", "docstring": "Find the missing digit in given product of large positive integers | C ++ program for the above approach ; Function to find the replaced digit in the product of a * b ; Keeps track of the sign of the current digit ; Stores the value of a % 11 ; Find the value of a mod 11 for large value of a as per the derived formula ; Stores the value of b % 11 ; Find the value of b mod 11 for large value of a as per the derived formula ; Stores the value of c % 11 ; Keeps track of the sign of x ; If the current digit is the missing digit , then keep the track of its sign ; Find the value of x using the derived equation ; Check if x has a negative sign ; Return positive equivaluent of x mod 11 ; Driver Code", "dfg": [["i", 43, "comesFrom", ["i"], [33]], ["i", 47, "comesFrom", ["i"], [33]], ["i", 101, "comesFrom", ["i"], [91]], ["i", 105, "comesFrom", ["i"], [91]], ["i", 164, "comesFrom", ["i"], [154]], ["i", 168, "comesFrom", ["i"], [154]], ["i", 176, "comesFrom", ["i"], [154]], ["i", 61, "comesFrom", ["i"], [33]], ["i", 119, "comesFrom", ["i"], [91]], ["i", 207, "comesFrom", ["i"], [154]], ["xSignIsPositive", 244, "comesFrom", ["xSignIsPositive"], [186]], ["A", 295, "comesFrom", ["A"], [271]], ["B", 297, "comesFrom", ["B"], [278]], ["C", 299, "comesFrom", ["C"], [285]], ["w", 74, "comesFrom", ["w"], [72]], ["w", 132, "comesFrom", ["w"], [130]], ["w", 221, "comesFrom", ["w"], [219]], ["w", 56, "comesFrom", ["w"], [21]], ["w", 114, "comesFrom", ["w"], [84]], ["w", 189, "comesFrom", ["w"], [147]], ["w", 202, "comesFrom", ["w"], [147]], ["c_mod_11", 236, "comesFrom", ["c_mod_11"], [197]], ["c_mod_11", 200, "comesFrom", ["c_mod_11"], [197]], ["x", 250, "comesFrom", ["x"], [247]], ["x", 255, "comesFrom", ["x"], [247]], ["a", 35, "comesFrom", ["a"], [11]], ["a", 59, "comesFrom", ["a"], [11]], ["b", 93, "comesFrom", ["b"], [14]], ["b", 117, "comesFrom", ["b"], [14]], ["c", 156, "comesFrom", ["c"], [17]], ["c", 174, "comesFrom", ["c"], [17]], ["c", 205, "comesFrom", ["c"], [17]], ["a_mod_11", 54, "comesFrom", ["a_mod_11"], [51]], ["a_mod_11", 231, "comesFrom", ["a_mod_11"], [51]], ["b_mod_11", 112, "comesFrom", ["b_mod_11"], [109]], ["b_mod_11", 233, "comesFrom", ["b_mod_11"], [109]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findIfPossible ( int N , string str ) { int countG = 0 , countF = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' G ' ) countG ++ ; else countF ++ ; } if ( 2 * countF != countG ) { cout << \" NO STRNEWLINE \" ; } else { int id = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' G ' ) { countG -- ; id ++ ; } else { countF -- ; id -- ; } if ( id < 0 ) { flag = false ; break ; } if ( countG < countF ) { flag = false ; break ; } } if ( flag ) { cout << \" YES STRNEWLINE \" ; } else { cout << \" NO STRNEWLINE \" ; } } } int main ( ) { int n = 6 ; string str = \" GFGFGG \" ; findIfPossible ( n , str ) ; return 0 ; }", "docstring": "Check if a string can be made empty by repeatedly removing given subsequence | C ++ program for the above approach ; Function to check if a string can be made empty by removing all subsequences of the form \" GFG \" or not ; Driver Code", "dfg": [["i", 33, "comesFrom", ["i"], [29]], ["i", 37, "comesFrom", ["i"], [29]], ["i", 97, "comesFrom", ["i"], [93]], ["i", 101, "comesFrom", ["i"], [93]], ["i", 45, "comesFrom", ["i"], [29]], ["i", 109, "comesFrom", ["i"], [93]], ["N", 35, "comesFrom", ["N"], [11]], ["N", 99, "comesFrom", ["N"], [11]], ["countG", 68, "comesFrom", ["countG"], [18]], ["countG", 54, "comesFrom", ["countG"], [18]], ["countG", 151, "comesFrom", ["countG"], [18]], ["countG", 119, "comesFrom", ["countG"], [18]], ["n", 206, "comesFrom", ["n"], [193]], ["str", 208, "comesFrom", ["str"], [198]], ["str", 43, "comesFrom", ["str"], [14]], ["str", 107, "comesFrom", ["str"], [14]], ["countF", 66, "comesFrom", ["countF"], [22]], ["countF", 58, "comesFrom", ["countF"], [22]], ["countF", 153, "comesFrom", ["countF"], [22]], ["countF", 128, "comesFrom", ["countF"], [22]], ["flag", 166, "comesFrom", ["flag"], [156]], ["id", 137, "comesFrom", ["id"], [81]], ["id", 122, "comesFrom", ["id"], [81]], ["id", 131, "comesFrom", ["id"], [81]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void isPossible ( string str1 , string str2 ) { int arr [ 256 ] = { 0 } ; int l1 = str1 . size ( ) ; int l2 = str2 . size ( ) ; int i , j ; bool possible = true ; for ( i = 0 ; i < l1 ; i ++ ) { arr [ str1 [ i ] ] = 1 ; } for ( i = 0 ; i < l2 ; i ++ ) { if ( str2 [ i ] != ' ▁ ' ) { if ( arr [ str2 [ i ] ] == 1 ) continue ; else { possible = false ; break ; } } } if ( possible ) { cout << \" Yes \" << endl ; } else { cout << \" No \" << endl ; } } int main ( ) { string str1 = \" we ▁ all ▁ love ▁ geeksforgeeks \" ; string str2 = \" we ▁ all ▁ love ▁ geeks \" ; isPossible ( str1 , str2 ) ; return 0 ; }", "docstring": "Check whether second string can be formed from characters of first string used any number of times | C ++ implementation of the above approach ; Function to check if str2 can be made by characters of str1 or not ; To store the occurrence of every character ; Length of the two strings ; Assume that it is possible to compose the string str2 from str1 ; Iterate over str1 ; Store the presence of every character ; Iterate over str2 ; Ignore the spaces ; Check for the presence of character in str1 ; If it is possible to make str2 from str1 ; Driver Code ; Given strings ; Function Call", "dfg": [["i", 61, "comesFrom", ["i"], [57]], ["i", 65, "comesFrom", ["i"], [57]], ["i", 86, "comesFrom", ["i"], [82]], ["i", 90, "comesFrom", ["i"], [82]], ["i", 98, "comesFrom", ["i"], [82]], ["i", 73, "comesFrom", ["i"], [57]], ["i", 114, "comesFrom", ["i"], [82]], ["l1", 63, "comesFrom", ["l1"], [28]], ["l2", 88, "comesFrom", ["l2"], [37]], ["possible", 135, "comesFrom", ["possible"], [124]], ["str1", 180, "comesFrom", ["str1"], [165]], ["str1", 30, "comesFrom", ["str1"], [11]], ["str1", 71, "comesFrom", ["str1"], [11]], ["str2", 182, "comesFrom", ["str2"], [172]], ["str2", 39, "comesFrom", ["str2"], [14]], ["str2", 96, "comesFrom", ["str2"], [14]], ["str2", 112, "comesFrom", ["str2"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_Min_Inversion ( int n , string s1 , string s2 ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { if ( s1 [ i ] == '1' ) { s1 [ i ] = '0' ; } else { s1 [ i ] = '1' ; } if ( s1 [ i + 1 ] == '1' ) { s1 [ i + 1 ] = '0' ; } else { s1 [ i + 1 ] = '1' ; } count ++ ; } } if ( s1 == s2 ) { return count ; } return -1 ; } int main ( ) { int n = 4 ; string s1 = \"0101\" ; string s2 = \"1111\" ; cout << find_Min_Inversion ( n , s1 , s2 ) << endl ; return 0 ; }", "docstring": "Minimum number of flipping adjacent bits required to make given Binary Strings equal | C ++ program for the above approach ; Function to find the minimum number of inversions required . ; Initializing the answer ; Iterate over the range ; If s1 [ i ] != s2 [ i ] , then inverse the characters at i snd ( i + 1 ) positions in s1 . ; Adding 1 to counter if characters are not same ; Driver Code", "dfg": [["i", 32, "comesFrom", ["i"], [28]], ["i", 38, "comesFrom", ["i"], [28]], ["i", 46, "comesFrom", ["i"], [28]], ["i", 51, "comesFrom", ["i"], [28]], ["i", 59, "comesFrom", ["i"], [28]], ["i", 69, "comesFrom", ["i"], [28]], ["i", 93, "comesFrom", ["i"], [28]], ["i", 81, "comesFrom", ["i"], [28]], ["i", 105, "comesFrom", ["i"], [28]], ["i", 119, "comesFrom", ["i"], [28]], ["n", 34, "comesFrom", ["n"], [11]], ["n", 177, "comesFrom", ["n"], [155]], ["s1", 136, "comesFrom", ["s1"], [14]], ["s1", 179, "comesFrom", ["s1"], [160]], ["s1", 44, "comesFrom", ["s1"], [14]], ["s1", 57, "comesFrom", ["s1"], [14]], ["s1", 91, "comesFrom", ["s1"], [14]], ["s1", 67, "comesFrom", ["s1"], [14]], ["s1", 103, "comesFrom", ["s1"], [14]], ["s1", 79, "comesFrom", ["s1"], [14]], ["s1", 117, "comesFrom", ["s1"], [14]], ["s2", 138, "comesFrom", ["s2"], [17]], ["s2", 181, "comesFrom", ["s2"], [167]], ["s2", 49, "comesFrom", ["s2"], [17]], ["count", 142, "comesFrom", ["count"], [21]], ["count", 129, "comesFrom", ["count"], [21]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubsequence ( string S , char ch ) { int N = S . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ch ) { ans ++ ; ch ++ ; } } return ans ; } int findMaxSubsequence ( string S ) { int ans = 0 ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) { ans = max ( ans , findSubsequence ( S , ch ) ) ; } return ans ; } int main ( ) { string S = \" abcabefghijk \" ; cout << findMaxSubsequence ( S ) ; return 0 ; }", "docstring": "Longest subsequence with consecutive English alphabets | C ++ program for the above approach ; Function to find the length of subsequence starting with character ch ; Length of the string ; Stores the maximum length ; Traverse the given string ; If s [ i ] is required character ch ; Increment ans by 1 ; Increment character ch ; Return the current maximum length with character ch ; Function to find the maximum length of subsequence of consecutive characters ; Stores the maximum length of consecutive characters ; Update ans ; Return the maximum length of subsequence ; Driver Code ; Input ; Function Call", "dfg": [["ans", 65, "comesFrom", ["ans"], [27]], ["ans", 119, "comesFrom", ["ans"], [103]], ["ans", 56, "comesFrom", ["ans"], [27]], ["ans", 107, "comesFrom", ["ans"], [103]], ["i", 38, "comesFrom", ["i"], [34]], ["i", 42, "comesFrom", ["i"], [34]], ["i", 50, "comesFrom", ["i"], [34]], ["N", 40, "comesFrom", ["N"], [18]], ["ch", 91, "comesFrom", ["ch"], [83]], ["ch", 99, "comesFrom", ["ch"], [83]], ["ch", 53, "comesFrom", ["ch"], [14]], ["ch", 59, "comesFrom", ["ch"], [14]], ["ch", 113, "comesFrom", ["ch"], [83]], ["S", 20, "comesFrom", ["S"], [11]], ["S", 138, "comesFrom", ["S"], [128]], ["S", 48, "comesFrom", ["S"], [11]], ["S", 111, "comesFrom", ["S"], [72]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOpsToEmptyString ( string s ) { int ans = INT_MIN ; int cn0 = 0 ; int cn1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = max ( { ans , cn0 , cn1 } ) ; } cout << ans ; } int main ( ) { string S = \"010101\" ; minOpsToEmptyString ( S ) ; return 0 ; }", "docstring": "Minimum number of alternate subsequences required to be removed to empty a Binary String | C ++ program for the above approach ; Function to find the minimum number of operations to empty a binary string ; Stores the resultant number of operations ; Stores the number of 0 s ; Stores the number of 1 s ; Traverse the given string ; To balance 0 with 1 if possible ; Increment the value of cn0 by 1 ; To balance 1 with 0 if possible ; Increment the value of cn1 ; Update the maximum number of unused 0 s and 1 s ; Print the resultant count ; Driver Code", "dfg": [["i", 36, "comesFrom", ["i"], [32]], ["i", 44, "comesFrom", ["i"], [32]], ["i", 52, "comesFrom", ["i"], [32]], ["ans", 104, "comesFrom", ["ans"], [88]], ["ans", 93, "comesFrom", ["ans"], [88]], ["S", 121, "comesFrom", ["S"], [113]], ["s", 38, "comesFrom", ["s"], [11]], ["s", 50, "comesFrom", ["s"], [11]], ["cn0", 69, "comesFrom", ["cn0"], [20]], ["cn0", 95, "comesFrom", ["cn0"], [20]], ["cn0", 77, "comesFrom", ["cn0"], [20]], ["cn0", 81, "comesFrom", ["cn0"], [20]], ["cn1", 62, "comesFrom", ["cn1"], [25]], ["cn1", 66, "comesFrom", ["cn1"], [25]], ["cn1", 84, "comesFrom", ["cn1"], [25]], ["cn1", 97, "comesFrom", ["cn1"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int shortestString ( string S , int N ) { int st = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( st && S [ i ] == '1' ) { st -- ; } else { st ++ ; } } return st ; } int main ( ) { string S = \"1010\" ; int N = S . length ( ) ; cout << shortestString ( S , N ) ; return 0 ; }", "docstring": "Smallest string obtained by removing all occurrences of 01 and 11 from Binary String | Set 2 | C ++ program for the above approach ; Function to find the length of the smallest string possible by removing substrings \"01\" and \"11\" ; Stores the length of the smallest string ; Traverse the string S ; If st is greater than 0 and S [ i ] is '1' ; Delete the last character and decrement st by 1 ; Otherwise ; Increment st by 1 ; Return the answer in st ; Driver Code ; Input ; Function call", "dfg": [["st", 63, "comesFrom", ["st"], [18]], ["st", 39, "comesFrom", ["st"], [18]], ["st", 51, "comesFrom", ["st"], [18]], ["st", 57, "comesFrom", ["st"], [18]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 43, "comesFrom", ["i"], [25]], ["N", 31, "comesFrom", ["N"], [14]], ["N", 93, "comesFrom", ["N"], [79]], ["S", 81, "comesFrom", ["S"], [72]], ["S", 91, "comesFrom", ["S"], [72]], ["S", 41, "comesFrom", ["S"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLength ( string str , int n ) { int pre [ n ] , post [ n ] ; memset ( pre , 0 , sizeof ( pre ) ) ; memset ( post , 0 , sizeof ( post ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 ) { pre [ i ] += pre [ i - 1 ] ; } if ( str [ i ] == '1' ) { pre [ i ] += 1 ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i != n - 1 ) post [ i ] += post [ i + 1 ] ; if ( str [ i ] == '0' ) post [ i ] += 1 ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , pre [ i ] + post [ i ] ) ; } return ans ; } int main ( ) { string S = \"0101110110100001011\" ; cout << findLength ( S , S . length ( ) ) ; return 0 ; }", "docstring": "Longest Non | C ++ program for the above approach ; Function to find the length of the longest non - increasing subsequence ; Stores the prefix and suffix count of 1 s and 0 s respectively ; Initialize the array ; Store the number of '1' s up to current index i in pre ; Find the prefix sum ; If the current element is '1' , update the pre [ i ] ; Store the number of '0' s over the range [ i , N - 1 ] ; Find the suffix sum ; If the current element is '0' , update post [ i ] ; Stores the maximum length ; Find the maximum value of pre [ i ] + post [ i ] ; Return the answer ; Driver Code", "dfg": [["ans", 203, "comesFrom", ["ans"], [184]], ["ans", 188, "comesFrom", ["ans"], [184]], ["n", 20, "comesFrom", ["n"], [14]], ["n", 25, "comesFrom", ["n"], [14]], ["n", 61, "comesFrom", ["n"], [14]], ["n", 178, "comesFrom", ["n"], [14]], ["n", 113, "comesFrom", ["n"], [14]], ["n", 129, "comesFrom", ["n"], [14]], ["i", 59, "comesFrom", ["i"], [55]], ["i", 63, "comesFrom", ["i"], [55]], ["i", 117, "comesFrom", ["i"], [111]], ["i", 121, "comesFrom", ["i"], [111]], ["i", 176, "comesFrom", ["i"], [172]], ["i", 180, "comesFrom", ["i"], [172]], ["i", 69, "comesFrom", ["i"], [55]], ["i", 127, "comesFrom", ["i"], [111]], ["i", 91, "comesFrom", ["i"], [55]], ["i", 135, "comesFrom", ["i"], [111]], ["i", 149, "comesFrom", ["i"], [111]], ["i", 158, "comesFrom", ["i"], [111]], ["i", 76, "comesFrom", ["i"], [55]], ["i", 101, "comesFrom", ["i"], [55]], ["i", 140, "comesFrom", ["i"], [111]], ["i", 81, "comesFrom", ["i"], [55]], ["i", 192, "comesFrom", ["i"], [172]], ["i", 197, "comesFrom", ["i"], [172]], ["S", 222, "comesFrom", ["S"], [212]], ["S", 224, "comesFrom", ["S"], [212]], ["str", 89, "comesFrom", ["str"], [11]], ["str", 147, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstring ( string & S , int N ) { unordered_map < int , int > prevSum ; int res = 0 ; int currentSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] >= ' A ' and S [ i ] <= ' Z ' ) { currentSum ++ ; } else currentSum -- ; if ( currentSum == 0 ) res ++ ; if ( prevSum . find ( currentSum ) != prevSum . end ( ) ) { res += ( prevSum [ currentSum ] ) ; } prevSum [ currentSum ] ++ ; } return res ; } int main ( ) { string S = \" gEEk \" ; cout << countSubstring ( S , S . length ( ) ) ; return 0 ; }", "docstring": "Number of substrings having an equal number of lowercase and uppercase letters | C ++ program for the above approach ; Function to find the count of substrings having an equal number of uppercase and lowercase characters ; Stores the count of prefixes having sum S considering uppercase and lowercase characters as 1 and - 1 ; Stores the count of substrings having equal number of lowercase and uppercase characters ; Stores the sum obtained so far ; If the character is uppercase ; Otherwise ; If currsum is o ; If the current sum exists in the HashMap prevSum ; Increment the resultant count by 1 ; Update the frequency of the current sum by 1 ; Return the resultant count of the subarrays ; Driver Code", "dfg": [["res", 127, "comesFrom", ["res"], [109]], ["res", 90, "comesFrom", ["res"], [27]], ["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["i", 55, "comesFrom", ["i"], [39]], ["i", 66, "comesFrom", ["i"], [39]], ["N", 45, "comesFrom", ["N"], [15]], ["S", 146, "comesFrom", ["S"], [136]], ["S", 148, "comesFrom", ["S"], [136]], ["currentSum", 86, "comesFrom", ["currentSum"], [32]], ["currentSum", 76, "comesFrom", ["currentSum"], [32]], ["currentSum", 81, "comesFrom", ["currentSum"], [32]], ["currentSum", 121, "comesFrom", ["currentSum"], [32]], ["currentSum", 99, "comesFrom", ["currentSum"], [32]], ["currentSum", 114, "comesFrom", ["currentSum"], [32]], ["prevSum", 119, "comesFrom", ["prevSum"], [24]], ["prevSum", 95, "comesFrom", ["prevSum"], [24]], ["prevSum", 102, "comesFrom", ["prevSum"], [24]], ["prevSum", 112, "comesFrom", ["prevSum"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countStringPairs ( string a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { string p = a [ i ] , q = a [ j ] ; if ( p [ 0 ] != q [ 0 ] ) { swap ( p [ 0 ] , q [ 0 ] ) ; int flag1 = 0 ; int flag2 = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] == p ) { flag1 = 1 ; } if ( a [ k ] == q ) { flag2 = 1 ; } } if ( flag1 == 0 && flag2 == 0 ) { ans = ans + 1 ; } } } } cout << ans ; } int main ( ) { string arr [ ] = { \" good \" , \" bad \" , \" food \" } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countStringPairs ( arr , N ) ; return 0 ; }", "docstring": "Count new pairs of strings that can be obtained by swapping first characters of pairs of strings from given array | C ++ program for the above approach ; Function to count new pairs of strings that can be obtained by swapping first characters of any pair of strings ; Stores the count of pairs ; Generate all possible pairs of strings from the array arr [ ] ; Stores the current pair of strings ; Swap the first characters ; Check if they are already present in the array or not ; If both the strings are not present ; Increment the ans by 1 ; Print the resultant count ; Driver Code", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 44, "comesFrom", ["i"], [27]], ["i", 61, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 50, "comesFrom", ["n"], [16]], ["n", 116, "comesFrom", ["n"], [16]], ["ans", 176, "comesFrom", ["ans"], [164]], ["ans", 166, "comesFrom", ["ans"], [164]], ["N", 223, "comesFrom", ["N"], [204]], ["j", 48, "comesFrom", ["j"], [42]], ["j", 52, "comesFrom", ["j"], [42]], ["j", 68, "comesFrom", ["j"], [42]], ["p", 73, "comesFrom", ["p"], [57]], ["p", 86, "comesFrom", ["p"], [57]], ["p", 129, "comesFrom", ["p"], [57]], ["q", 78, "comesFrom", ["q"], [64]], ["q", 91, "comesFrom", ["q"], [64]], ["q", 144, "comesFrom", ["q"], [64]], ["k", 114, "comesFrom", ["k"], [110]], ["k", 118, "comesFrom", ["k"], [110]], ["k", 126, "comesFrom", ["k"], [110]], ["k", 141, "comesFrom", ["k"], [110]], ["flag1", 155, "comesFrom", ["flag1"], [132]], ["flag2", 159, "comesFrom", ["flag2"], [147]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void addFrequencyToCharacter ( string s ) { int frequency [ 26 ] = { 0 } ; int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] - ' a ' ] += 1 ; } for ( int i = 0 ; i < n ; i ++ ) { int add = frequency [ s [ i ] - ' a ' ] % 26 ; if ( int ( s [ i ] ) + add <= int ( ' z ' ) ) s [ i ] = char ( int ( s [ i ] ) + add ) ; else { add = ( int ( s [ i ] ) + add ) - ( int ( ' z ' ) ) ; s [ i ] = char ( int ( ' a ' ) + add - 1 ) ; } } cout << s ; } int main ( ) { string str = \" geeks \" ; addFrequencyToCharacter ( str ) ; return 0 ; }", "docstring": "Modify string by replacing characters by alphabets whose distance from that character is equal to its frequency | C ++ program for the above approach ; Function to modify string by replacing characters by the alphabet present at distance equal to frequency of the string ; Stores frequency of characters ; Stores length of the string ; Traverse the given string S ; Increment frequency of current character by 1 ; Traverse the string ; Store the value to be added to the current character ; Check if after adding the frequency , the character is less than ' z ' or not ; Otherwise , update the value of add so that s [ i ] doesn ' t ▁ exceed ▁ ' z ' ; Print the modified string ; Driver Code", "dfg": [["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 72, "comesFrom", ["i"], [68]], ["i", 76, "comesFrom", ["i"], [68]], ["i", 122, "comesFrom", ["i"], [68]], ["i", 52, "comesFrom", ["i"], [36]], ["i", 167, "comesFrom", ["i"], [68]], ["i", 87, "comesFrom", ["i"], [68]], ["i", 105, "comesFrom", ["i"], [68]], ["i", 131, "comesFrom", ["i"], [68]], ["i", 147, "comesFrom", ["i"], [68]], ["n", 42, "comesFrom", ["n"], [25]], ["n", 74, "comesFrom", ["n"], [25]], ["s", 190, "comesFrom", ["s"], [11]], ["s", 27, "comesFrom", ["s"], [11]], ["s", 120, "comesFrom", ["s"], [11]], ["s", 50, "comesFrom", ["s"], [11]], ["s", 165, "comesFrom", ["s"], [11]], ["s", 85, "comesFrom", ["s"], [11]], ["s", 103, "comesFrom", ["s"], [11]], ["s", 129, "comesFrom", ["s"], [11]], ["s", 145, "comesFrom", ["s"], [11]], ["str", 207, "comesFrom", ["str"], [199]], ["add", 109, "comesFrom", ["add"], [81]], ["add", 135, "comesFrom", ["add"], [81]], ["add", 151, "comesFrom", ["add"], [140]], ["add", 181, "comesFrom", ["add"], [140]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string isPossible ( string S , int R , int N ) { int cntl = 0 , cntr = 0 ; int cntu = 0 , cntd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' L ' ) cntl ++ ; else if ( S [ i ] == ' R ' ) cntr ++ ; else if ( S [ i ] == ' U ' ) cntu ++ ; else cntd ++ ; } if ( max ( max ( cntl , cntr ) , max ( cntu , cntd ) ) >= R ) return \" Yes \" ; unordered_map < int , int > mp ; int r_square = R * R ; for ( int i = 1 ; i * i <= r_square ; i ++ ) { mp [ i * i ] = i ; if ( mp . find ( r_square - i * i ) != mp . end ( ) ) { if ( max ( cntl , cntr ) >= mp [ r_square - i * i ] && max ( cntu , cntd ) >= i ) return \" Yes \" ; if ( max ( cntl , cntr ) >= i && max ( cntu , cntd ) >= mp [ r_square - i * i ] ) return \" Yes \" ; } } return \" No \" ; } int main ( ) { string S = \" RDLLDDLDU \" ; int R = 5 ; int N = S . length ( ) ; cout << isPossible ( S , R , N ) ; return 0 ; }", "docstring": "Check if it is possible to reach any point on the circumference of a given circle from origin | C ++ program for the above approach ; Function to check if it is possible to reach any point on circumference of the given circle from ( 0 , 0 ) ; Stores the count of ' L ' , ' R ' ; Stores the count of ' U ' , ' D ' ; Traverse the string S ; Update the count of L ; Update the count of R ; Update the count of U ; Update the count of D ; Condition 1 for reaching the circumference ; Store the the value of ( i * i ) in the Map ; Check if ( r_square - i * i ) already present in HashMap ; If it is possible to reach the point ( mp [ r_square - i * i ] , i ) ; If it is possible to reach the point ( i , mp [ r_square - i * i ] ) ; If it is impossible to reach ; Driver Code", "dfg": [["i", 45, "comesFrom", ["i"], [41]], ["i", 49, "comesFrom", ["i"], [41]], ["i", 162, "comesFrom", ["i"], [152]], ["i", 156, "comesFrom", ["i"], [152]], ["i", 158, "comesFrom", ["i"], [152]], ["i", 173, "comesFrom", ["i"], [152]], ["i", 57, "comesFrom", ["i"], [41]], ["i", 168, "comesFrom", ["i"], [152]], ["i", 170, "comesFrom", ["i"], [152]], ["i", 220, "comesFrom", ["i"], [152]], ["i", 236, "comesFrom", ["i"], [152]], ["i", 74, "comesFrom", ["i"], [41]], ["i", 183, "comesFrom", ["i"], [152]], ["i", 185, "comesFrom", ["i"], [152]], ["i", 91, "comesFrom", ["i"], [41]], ["i", 208, "comesFrom", ["i"], [152]], ["i", 210, "comesFrom", ["i"], [152]], ["i", 249, "comesFrom", ["i"], [152]], ["i", 251, "comesFrom", ["i"], [152]], ["N", 47, "comesFrom", ["N"], [17]], ["N", 301, "comesFrom", ["N"], [285]], ["r_square", 160, "comesFrom", ["r_square"], [143]], ["r_square", 181, "comesFrom", ["r_square"], [143]], ["r_square", 206, "comesFrom", ["r_square"], [143]], ["r_square", 247, "comesFrom", ["r_square"], [143]], ["R", 127, "comesFrom", ["R"], [14]], ["R", 145, "comesFrom", ["R"], [14]], ["R", 147, "comesFrom", ["R"], [14]], ["R", 299, "comesFrom", ["R"], [280]], ["S", 287, "comesFrom", ["S"], [273]], ["S", 297, "comesFrom", ["S"], [273]], ["S", 55, "comesFrom", ["S"], [11]], ["S", 72, "comesFrom", ["S"], [11]], ["S", 89, "comesFrom", ["S"], [11]], ["cntl", 66, "comesFrom", ["cntl"], [21]], ["cntl", 114, "comesFrom", ["cntl"], [21]], ["cntl", 199, "comesFrom", ["cntl"], [21]], ["cntl", 231, "comesFrom", ["cntl"], [21]], ["mp", 166, "comesFrom", ["mp"], [140]], ["mp", 177, "comesFrom", ["mp"], [140]], ["mp", 188, "comesFrom", ["mp"], [140]], ["mp", 204, "comesFrom", ["mp"], [140]], ["mp", 245, "comesFrom", ["mp"], [140]], ["cntr", 83, "comesFrom", ["cntr"], [25]], ["cntr", 116, "comesFrom", ["cntr"], [25]], ["cntr", 201, "comesFrom", ["cntr"], [25]], ["cntr", 233, "comesFrom", ["cntr"], [25]], ["cntu", 121, "comesFrom", ["cntu"], [30]], ["cntu", 100, "comesFrom", ["cntu"], [30]], ["cntu", 215, "comesFrom", ["cntu"], [30]], ["cntu", 240, "comesFrom", ["cntu"], [30]], ["cntd", 123, "comesFrom", ["cntd"], [34]], ["cntd", 104, "comesFrom", ["cntd"], [34]], ["cntd", 217, "comesFrom", ["cntd"], [34]], ["cntd", 242, "comesFrom", ["cntd"], [34]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void addASCII ( string S , string N ) { for ( int i = 0 ; i < S . size ( ) ; i ++ ) { int a = int ( N [ i ] ) - '0' ; int b = int ( S [ i ] ) + a ; if ( b > 122 ) b -= 26 ; S [ i ] = char ( b ) ; } cout << S ; } int main ( ) { string S = \" sun \" , N = \"966\" ; addASCII ( S , N ) ; return 0 ; }", "docstring": "Modify characters of a string by adding integer values of same | C ++ program for the above approach ; Function to modify a given string by adding ASCII value of characters from a string S to integer values of same indexed characters in string N ; Traverse the string ; Stores integer value of character in string N ; Stores ASCII value of character in string S ; If b exceeds 122 ; Replace the character ; Print resultant string ; Driver Code ; Given strings ; Function call to modify string S by given operations", "dfg": [["i", 24, "comesFrom", ["i"], [20]], ["i", 32, "comesFrom", ["i"], [20]], ["i", 76, "comesFrom", ["i"], [20]], ["i", 43, "comesFrom", ["i"], [20]], ["i", 58, "comesFrom", ["i"], [20]], ["S", 87, "comesFrom", ["S"], [11]], ["S", 110, "comesFrom", ["S"], [96]], ["S", 26, "comesFrom", ["S"], [11]], ["S", 74, "comesFrom", ["S"], [11]], ["S", 56, "comesFrom", ["S"], [11]], ["N", 112, "comesFrom", ["N"], [102]], ["N", 41, "comesFrom", ["N"], [14]], ["a", 62, "comesFrom", ["a"], [37]], ["b", 66, "comesFrom", ["b"], [52]], ["b", 81, "comesFrom", ["b"], [70]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string decHex ( int n ) { char alpha [ ] = { ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' } ; string ans ; while ( n > 0 ) { if ( n % 16 < 10 ) { ans += to_string ( n % 16 ) ; } else { ans += alpha [ n % 16 - 10 ] ; } n /= 16 ; } reverse ( ans . begin ( ) , ans . end ( ) ) ; return ans ; } int hexDec ( string convertedHex ) { char mp [ ] = { 10 , 11 , 12 , 13 , 14 , 15 } ; int ans = 0 ; int pos = 0 ; reverse ( convertedHex . begin ( ) , convertedHex . end ( ) ) ; for ( char ch : convertedHex ) { if ( isdigit ( ch ) ) { ans += ( ( int ) pow ( 16 , pos ) ) * ( ch - '0' ) ; } else { ans += ( ( int ) pow ( 16 , pos ) ) * mp [ ch - ' A ' ] ; } pos += 1 ; } return ans ; } string removeChars ( string hexaVal , string S ) { set < char > setk ; for ( char ch : S ) { setk . insert ( ch ) ; } string ans = \" \" ; for ( char ch : hexaVal ) { if ( setk . find ( ch ) != setk . end ( ) ) { continue ; } ans += ch ; } return ans ; } void convertArr ( int arr [ ] , int N , string S ) { for ( int i = 0 ; i < N ; i ++ ) { string hexaVal = decHex ( arr [ i ] ) ; string convertedHex = removeChars ( hexaVal , S ) ; int decVal = hexDec ( convertedHex ) ; arr [ i ] = decVal ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 74 , 91 , 31 , 122 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; string S = \"1AB \" ; convertArr ( arr , N , S ) ; return 0 ; }", "docstring": "Modify array by removing characters from their Hexadecimal representations which are present in a given string | C ++ program for the above approach ; Function to convert a decimal number to its equivalent hexadecimal number ; Function to convert hexadecimal number to its equavalent decimal number ; Stores characters with their respective hexadecimal values ; Stores answer ; Traverse the string ; If digit ; If character ; Return the answer ; Function to move all the alphabets to front ; Function to modify each array element by removing characters from their hexadecimal representation which are present in a given string ; Traverse the array ; Stores hexadecimal value ; Remove the characters from hexadecimal representation present in string S ; Stores decimal value ; Replace array element ; Print the modified array ; Driven Program ; Given array ; Given string ; Function call to modify array by given operations", "dfg": [["ans", 121, "comesFrom", ["ans"], [88]], ["ans", 248, "comesFrom", ["ans"], [216]], ["ans", 323, "comesFrom", ["ans"], [317]], ["ans", 107, "comesFrom", ["ans"], [88]], ["ans", 113, "comesFrom", ["ans"], [88]], ["convertedHex", 180, "comesFrom", ["convertedHex"], [128]], ["convertedHex", 162, "comesFrom", ["convertedHex"], [128]], ["convertedHex", 168, "comesFrom", ["convertedHex"], [128]], ["convertedHex", 382, "comesFrom", ["convertedHex"], [368]], ["S", 272, "comesFrom", ["S"], [258]], ["S", 470, "comesFrom", ["S"], [458]], ["S", 374, "comesFrom", ["S"], [338]], ["hexaVal", 295, "comesFrom", ["hexaVal"], [255]], ["hexaVal", 372, "comesFrom", ["hexaVal"], [357]], ["i", 348, "comesFrom", ["i"], [344]], ["i", 352, "comesFrom", ["i"], [344]], ["i", 400, "comesFrom", ["i"], [396]], ["i", 404, "comesFrom", ["i"], [396]], ["i", 387, "comesFrom", ["i"], [344]], ["i", 412, "comesFrom", ["i"], [396]], ["i", 363, "comesFrom", ["i"], [344]], ["N", 350, "comesFrom", ["N"], [335]], ["N", 402, "comesFrom", ["N"], [335]], ["N", 468, "comesFrom", ["N"], [442]], ["n", 62, "comesFrom", ["n"], [11]], ["n", 69, "comesFrom", ["n"], [11]], ["n", 80, "comesFrom", ["n"], [11]], ["n", 92, "comesFrom", ["n"], [11]], ["decVal", 390, "comesFrom", ["decVal"], [378]], ["setk", 275, "comesFrom", ["setk"], [265]], ["setk", 300, "comesFrom", ["setk"], [265]], ["setk", 307, "comesFrom", ["setk"], [265]], ["pos", 201, "comesFrom", ["pos"], [156]], ["pos", 226, "comesFrom", ["pos"], [156]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumChairs ( string s ) { int count = 0 ; int i = 0 ; int mini = INT_MIN ; while ( i < s . length ( ) ) { if ( s [ i ] == ' E ' ) count ++ ; else count -- ; mini = max ( count , mini ) ; i ++ ; } return mini ; } int main ( ) { string s = \" EELEE \" ; cout << findMinimumChairs ( s ) ; }", "docstring": "Minimum number of chairs required to ensure that every worker is seated at any instant | C ++ implementation of the above approach ; Function to find the minimum number of chairs required to ensure that every worker is seated at any time ; Stores the number of chairs required ; Pointer to iterate ; Stores minimum number of chairs required ; Iterate over every character ; If character is ' E ' ; Increase the count ; Otherwise ; Update maximum value of count obtained at any given time ; Return mini ; Driver Code ; Given String ; Function call to find the minimum number of chairs", "dfg": [["mini", 74, "comesFrom", ["mini"], [60]], ["mini", 66, "comesFrom", ["mini"], [60]], ["i", 31, "comesFrom", ["i"], [20]], ["i", 69, "comesFrom", ["i"], [20]], ["i", 44, "comesFrom", ["i"], [20]], ["s", 93, "comesFrom", ["s"], [83]], ["s", 33, "comesFrom", ["s"], [11]], ["s", 42, "comesFrom", ["s"], [11]], ["count", 53, "comesFrom", ["count"], [15]], ["count", 57, "comesFrom", ["count"], [15]], ["count", 64, "comesFrom", ["count"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void fillString ( string s , int k ) { unordered_map < int , char > mp ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] != ' ? ' ) { mp [ i % k ] = s [ i ] ; } } for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( mp . find ( i % k ) == mp . end ( ) ) { cout << -1 ; return ; } s [ i ] = mp [ i % k ] ; } cout << s ; } int main ( ) { string S = \" ? ? ? ? abcd \" ; int K = 4 ; fillString ( S , K ) ; return 0 ; }", "docstring": "Modify string by inserting characters such that every K | C ++ program for the above approach ; Function to replace all ' ? ' characters in a string such that the given conditions are satisfied ; Traverse the string to Map the characters with respective positions ; Traverse the string again and replace all unknown characters ; If i % k is not found in the Map M , then return - 1 ; Update S [ i ] ; Print the string S ; Driver Code", "dfg": [["i", 32, "comesFrom", ["i"], [28]], ["i", 40, "comesFrom", ["i"], [28]], ["i", 79, "comesFrom", ["i"], [75]], ["i", 87, "comesFrom", ["i"], [75]], ["i", 118, "comesFrom", ["i"], [75]], ["i", 48, "comesFrom", ["i"], [28]], ["i", 123, "comesFrom", ["i"], [75]], ["i", 67, "comesFrom", ["i"], [28]], ["i", 97, "comesFrom", ["i"], [75]], ["i", 60, "comesFrom", ["i"], [28]], ["s", 131, "comesFrom", ["s"], [11]], ["s", 34, "comesFrom", ["s"], [11]], ["s", 81, "comesFrom", ["s"], [11]], ["s", 116, "comesFrom", ["s"], [11]], ["s", 46, "comesFrom", ["s"], [11]], ["s", 65, "comesFrom", ["s"], [11]], ["S", 153, "comesFrom", ["S"], [140]], ["K", 155, "comesFrom", ["K"], [147]], ["mp", 121, "comesFrom", ["mp"], [23]], ["mp", 58, "comesFrom", ["mp"], [23]], ["mp", 93, "comesFrom", ["mp"], [23]], ["mp", 102, "comesFrom", ["mp"], [23]], ["k", 125, "comesFrom", ["k"], [14]], ["k", 99, "comesFrom", ["k"], [14]], ["k", 62, "comesFrom", ["k"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeString ( string s1 , string s2 ) { int cnt [ 26 ] = { 0 } ; for ( int i = 0 ; i < s2 . size ( ) ; i ++ ) cnt [ s2 [ i ] - ' a ' ] ++ ; int unique = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) if ( cnt [ i ] != 0 ) unique ++ ; if ( unique == 1 ) { int count_in_s2 = s2 . size ( ) ; int count_in_s1 = 0 ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) if ( s1 [ i ] == s2 [ 0 ] ) count_in_s1 ++ ; if ( count_in_s1 < count_in_s2 ) { cout << s1 ; return ; } cout << -1 ; } else { int inc = 1 ; for ( int i = 0 ; i < s2 . size ( ) - 1 ; i ++ ) if ( s2 [ i ] > s2 [ i + 1 ] ) inc = 0 ; if ( inc == 1 ) { sort ( s1 . begin ( ) , s1 . end ( ) , greater < char > ( ) ) ; cout << s1 ; } else { sort ( s1 . begin ( ) , s1 . end ( ) ) ; cout << s1 ; } } } int main ( ) { string s1 = \" abcd \" , s2 = \" ab \" ; rearrangeString ( s1 , s2 ) ; return 0 ; }", "docstring": "Rearrange a string S1 such that another given string S2 is not its subsequence | C ++ program for the above approach ; Function to rearrange characters in string S1 such that S2 is not a subsequence of it ; Store the frequencies of characters of string s2 ; Traverse the string s2 ; Update the frequency ; Find the number of unique characters in s2 ; Increment unique by 1 if the condition satisfies ; Check if the number of unique characters in string s2 is 1 ; Store the unique character frequency ; Store occurence of it in s1 ; Find count of that character in the string s1 ; Increment count by 1 if that unique character is same as current character ; If count count_in_s1 is less than count_in_s2 , then print s1 and return ; Otherwise , there is no possible arrangement ; Checks if any character in s2 is less than its next character ; Iterate the string , s2 ; If s [ i ] is greater than the s [ i + 1 ] ; Set inc to 0 ; If inc = 1 , print s1 in decreasing order ; Otherwise , print s1 in increasing order ; Driver code", "dfg": [["i", 34, "comesFrom", ["i"], [30]], ["i", 42, "comesFrom", ["i"], [30]], ["i", 72, "comesFrom", ["i"], [68]], ["i", 76, "comesFrom", ["i"], [68]], ["i", 119, "comesFrom", ["i"], [115]], ["i", 127, "comesFrom", ["i"], [115]], ["i", 178, "comesFrom", ["i"], [174]], ["i", 188, "comesFrom", ["i"], [174]], ["i", 83, "comesFrom", ["i"], [68]], ["i", 49, "comesFrom", ["i"], [30]], ["i", 134, "comesFrom", ["i"], [115]], ["i", 195, "comesFrom", ["i"], [174]], ["i", 200, "comesFrom", ["i"], [174]], ["unique", 93, "comesFrom", ["unique"], [61]], ["unique", 88, "comesFrom", ["unique"], [61]], ["s1", 287, "comesFrom", ["s1"], [273]], ["s1", 121, "comesFrom", ["s1"], [11]], ["s1", 154, "comesFrom", ["s1"], [11]], ["s1", 132, "comesFrom", ["s1"], [11]], ["s1", 240, "comesFrom", ["s1"], [11]], ["s1", 262, "comesFrom", ["s1"], [11]], ["s1", 218, "comesFrom", ["s1"], [11]], ["s1", 224, "comesFrom", ["s1"], [11]], ["s1", 247, "comesFrom", ["s1"], [11]], ["s1", 253, "comesFrom", ["s1"], [11]], ["s2", 289, "comesFrom", ["s2"], [279]], ["s2", 36, "comesFrom", ["s2"], [14]], ["s2", 101, "comesFrom", ["s2"], [14]], ["s2", 47, "comesFrom", ["s2"], [14]], ["s2", 137, "comesFrom", ["s2"], [14]], ["s2", 180, "comesFrom", ["s2"], [14]], ["s2", 193, "comesFrom", ["s2"], [14]], ["s2", 198, "comesFrom", ["s2"], [14]], ["count_in_s1", 147, "comesFrom", ["count_in_s1"], [108]], ["count_in_s1", 142, "comesFrom", ["count_in_s1"], [108]], ["count_in_s2", 149, "comesFrom", ["count_in_s2"], [99]], ["inc", 211, "comesFrom", ["inc"], [205]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isReducible ( string str ) { int N = str . size ( ) ; stack < char > s ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) s . push ( str [ i ] ) ; else if ( ! s . empty ( ) ) s . pop ( ) ; else return false ; } return s . empty ( ) ; } int main ( ) { string str = \"11011000\" ; if ( isReducible ( str ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if a string can be emptied by removing all subsequences of the form \"10\" | C ++ program for the above approach ; Function to find if string is reducible to NULL ; Length of string ; Stack to store all 1 s ; Iterate over the characters of the string ; If current character is 1 ; Push it into the stack ; Pop from the stack ; If the stack is empty ; Driver Code", "dfg": [["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 48, "comesFrom", ["i"], [32]], ["i", 61, "comesFrom", ["i"], [32]], ["N", 38, "comesFrom", ["N"], [15]], ["s", 87, "comesFrom", ["s"], [27]], ["s", 55, "comesFrom", ["s"], [27]], ["s", 75, "comesFrom", ["s"], [27]], ["s", 69, "comesFrom", ["s"], [27]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 110, "comesFrom", ["str"], [100]], ["str", 46, "comesFrom", ["str"], [11]], ["str", 59, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool cntMinOperation ( string S , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] == '0' && S [ i + 1 ] == '0' ) { S [ i + 1 ] = '1' ; cntOp += 1 ; } } return cntOp ; } int main ( ) { string S = \"10001\" ; int N = S . length ( ) ; cout << cntMinOperation ( S , N ) ; return 0 ; }", "docstring": "Minimize flips required such that string does not any pair of consecutive 0 s | C ++ program for the above approach ; Function to find minimum flips required such that a string does not contain any pair of consecutive 0 s ; Stores minimum count of flips ; Iterate over the characters of the string ; If two consecutive characters are equal to '0' ; Update S [ i + 1 ] ; Update cntOp ; Driver Code", "dfg": [["cntOp", 80, "comesFrom", ["cntOp"], [73]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 35, "comesFrom", ["i"], [25]], ["i", 43, "comesFrom", ["i"], [25]], ["i", 52, "comesFrom", ["i"], [25]], ["i", 64, "comesFrom", ["i"], [25]], ["N", 31, "comesFrom", ["N"], [14]], ["N", 110, "comesFrom", ["N"], [96]], ["S", 98, "comesFrom", ["S"], [89]], ["S", 108, "comesFrom", ["S"], [89]], ["S", 41, "comesFrom", ["S"], [11]], ["S", 50, "comesFrom", ["S"], [11]], ["S", 62, "comesFrom", ["S"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string solution ( string s ) { vector < char > vowel , consonant ; for ( auto i : s ) { if ( i == ' a ' i == ' e ' i == ' i ' i == ' o ' i == ' u ' ) { vowel . push_back ( i ) ; } else { consonant . push_back ( i ) ; } } int Nc , Nv ; Nv = vowel . size ( ) ; Nc = consonant . size ( ) ; int M = Nc / ( Nv - 1 ) ; string ans = \" \" ; int consotnant_till = 0 ; for ( auto i : vowel ) { ans += i ; int temp = 0 ; for ( int j = consotnant_till ; j < min ( Nc , consotnant_till + M ) ; j ++ ) { ans += consonant [ j ] ; temp ++ ; } consotnant_till += temp ; } return ans ; } int main ( ) { string str = \" aaaabbbcc \" ; cout << solution ( str ) ; return 0 ; }", "docstring": "Rearrange a string to maximize the minimum distance between any pair of vowels | C ++ program for the above approach ; Function to rearrange the string such that the minimum distance between any of vowels is maximum . ; Store vowels and consonants ; Iterate over the characters of string ; If current character is a vowel ; If current character is a consonant ; Stores count of vowels and consonants respectively ; Stores the resultant string ; Stores count of consonants appended into ans ; Append vowel to ans ; Append consonants ; Append consonant to ans ; Update temp ; Remove the taken elements of consonant ; Return final ans ; Driver Code ; Function Call", "dfg": [["s", 27, "comesFrom", ["s"], [11]], ["vowel", 137, "comesFrom", ["vowel"], [18]], ["vowel", 95, "comesFrom", ["vowel"], [18]], ["vowel", 69, "comesFrom", ["vowel"], [18]], ["ans", 188, "comesFrom", ["ans"], [171]], ["Nc", 112, "comesFrom", ["Nc"], [101]], ["Nc", 160, "comesFrom", ["Nc"], [101]], ["consonant", 103, "comesFrom", ["consonant"], [20]], ["consonant", 173, "comesFrom", ["consonant"], [20]], ["consonant", 79, "comesFrom", ["consonant"], [20]], ["j", 156, "comesFrom", ["j"], [152]], ["j", 167, "comesFrom", ["j"], [152]], ["j", 175, "comesFrom", ["j"], [152]], ["temp", 184, "comesFrom", ["temp"], [145]], ["temp", 178, "comesFrom", ["temp"], [145]], ["str", 207, "comesFrom", ["str"], [197]], ["Nv", 115, "comesFrom", ["Nv"], [93]], ["consotnant_till", 162, "comesFrom", ["consotnant_till"], [154]], ["M", 164, "comesFrom", ["M"], [110]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestlexicographicstring ( string s , int k ) { int n = s . size ( ) ; if ( k >= n ) { for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = ' a ' ; } cout << s ; return ; } for ( int i = 0 ; i < n ; i ++ ) { if ( k == 0 ) { break ; } if ( s [ i ] == ' a ' ) continue ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] > s [ i ] ) { s [ j ] = s [ i ] ; break ; } else if ( j == n - 1 ) s [ j ] = s [ i ] ; } s [ i ] = ' a ' ; k -- ; } cout << s ; } int main ( ) { string s = \" geeksforgeeks \" ; int k = 6 ; smallestlexicographicstring ( s , k ) ; return 0 ; }", "docstring": "Lexicographically smallest string possible by performing K operations on a given string | C ++ program to implement the above approach ; Function to find the lexicographically smallest possible string by performing K operations on string S ; Store the size of string , s ; Check if k >= n , if true , convert every character to ' a ' ; Iterate in range [ 0 , n - 1 ] using i ; When k reaches 0 , break the loop ; If current character is ' a ' , continue ; Otherwise , iterate in the range [ i + 1 , n - 1 ] using j ; Check if s [ j ] > s [ i ] ; If true , set s [ j ] = s [ i ] and break out of the loop ; Check if j reaches the last index ; Update S [ i ] ; Decrement k by 1 ; Print string ; Driver Code ; Given String , s ; Given k ; Function Call", "dfg": [["i", 74, "comesFrom", ["i"], [70]], ["i", 78, "comesFrom", ["i"], [70]], ["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 112, "comesFrom", ["i"], [70]], ["i", 172, "comesFrom", ["i"], [70]], ["i", 96, "comesFrom", ["i"], [70]], ["i", 50, "comesFrom", ["i"], [36]], ["i", 133, "comesFrom", ["i"], [70]], ["i", 144, "comesFrom", ["i"], [70]], ["i", 166, "comesFrom", ["i"], [70]], ["n", 76, "comesFrom", ["n"], [18]], ["n", 30, "comesFrom", ["n"], [18]], ["n", 42, "comesFrom", ["n"], [18]], ["n", 118, "comesFrom", ["n"], [18]], ["n", 155, "comesFrom", ["n"], [18]], ["s", 187, "comesFrom", ["s"], [11]], ["s", 209, "comesFrom", ["s"], [196]], ["s", 20, "comesFrom", ["s"], [11]], ["s", 62, "comesFrom", ["s"], [11]], ["s", 170, "comesFrom", ["s"], [11]], ["s", 94, "comesFrom", ["s"], [11]], ["s", 48, "comesFrom", ["s"], [11]], ["s", 126, "comesFrom", ["s"], [11]], ["s", 131, "comesFrom", ["s"], [11]], ["s", 137, "comesFrom", ["s"], [11]], ["s", 142, "comesFrom", ["s"], [11]], ["s", 159, "comesFrom", ["s"], [11]], ["s", 164, "comesFrom", ["s"], [11]], ["k", 28, "comesFrom", ["k"], [14]], ["k", 211, "comesFrom", ["k"], [203]], ["k", 181, "comesFrom", ["k"], [14]], ["k", 84, "comesFrom", ["k"], [14]], ["j", 116, "comesFrom", ["j"], [110]], ["j", 120, "comesFrom", ["j"], [110]], ["j", 128, "comesFrom", ["j"], [110]], ["j", 153, "comesFrom", ["j"], [110]], ["j", 139, "comesFrom", ["j"], [110]], ["j", 161, "comesFrom", ["j"], [110]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void canReduceString ( string S , int N ) { int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' ( ' ) { count_1 ++ ; } else { count_2 ++ ; } } if ( count_1 == 0 count_2 == 0 ) { cout << \" - 1\" << endl ; } else if ( count_1 == count_2 ) { cout << \"0\" << endl ; } else if ( N % 2 != 0 ) { cout << \" - 1\" ; } else { cout << abs ( count_1 - count_2 ) / 2 ; } } int main ( ) { string S = \" ) ) ) ( ( ( \" ; int N = S . length ( ) ; canReduceString ( S , N ) ; return 0 ; }", "docstring": "Minimize removal of non | C ++ program for the above approach ; Function to find minimum count of steps required ot make string S an empty string ; Stores count of occurences ' ( ' ; Stores count of occurences ' ) ' ; Traverse the string , str ; If current character is ' ( ' ; Update count_1 ; Update count_2 ; If all the characters are same , then print - 1 ; If the count of occurence of ' ) ' and ' ( ' are same then print 0 ; If length of string is Odd ; Driver Code ; Given string ; Size of the string ; Function Call", "dfg": [["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 46, "comesFrom", ["i"], [30]], ["N", 36, "comesFrom", ["N"], [14]], ["N", 160, "comesFrom", ["N"], [148]], ["N", 106, "comesFrom", ["N"], [14]], ["S", 158, "comesFrom", ["S"], [141]], ["S", 150, "comesFrom", ["S"], [141]], ["S", 44, "comesFrom", ["S"], [11]], ["count_1", 69, "comesFrom", ["count_1"], [18]], ["count_1", 89, "comesFrom", ["count_1"], [18]], ["count_1", 56, "comesFrom", ["count_1"], [18]], ["count_1", 126, "comesFrom", ["count_1"], [18]], ["count_2", 72, "comesFrom", ["count_2"], [23]], ["count_2", 91, "comesFrom", ["count_2"], [23]], ["count_2", 62, "comesFrom", ["count_2"], [23]], ["count_2", 128, "comesFrom", ["count_2"], [23]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void isAcceptedDFA ( string s , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' a ' ) count ++ ; } if ( count == N && count != 0 ) { cout << \" Accepted \" ; } else { cout << \" Not ▁ Accepted \" ; } } int main ( ) { string S = \" aaaaa \" ; isAcceptedDFA ( S , S . size ( ) ) ; return 0 ; }", "docstring": "Program to construct a DFA which accepts the language L = { aN | N â ‰¥ 1 } | C ++ program for the above approach ; Function to check whether the string S satisfy the given DFA or not ; Stores the count of characters ; Iterate over the range [ 0 , N ] ; Count and check every element for ' a ' ; If string matches with DFA ; If not matches ; Driver Code ; Function Call", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 41, "comesFrom", ["i"], [25]], ["N", 31, "comesFrom", ["N"], [14]], ["N", 58, "comesFrom", ["N"], [14]], ["S", 96, "comesFrom", ["S"], [88]], ["S", 98, "comesFrom", ["S"], [88]], ["count", 56, "comesFrom", ["count"], [18]], ["count", 60, "comesFrom", ["count"], [18]], ["count", 50, "comesFrom", ["count"], [18]], ["s", 39, "comesFrom", ["s"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximum_pallindromic ( int arr [ ] ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = arr [ i ] % 3 ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += min ( c1 , c2 ) ; int t = min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * ( c2 / 3 ) ; c2 %= 3 ; res += c2 / 2 ; cout << res ; } int main ( ) { int arr [ ] = { 4 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; maximum_pallindromic ( arr ) ; return 0 ; }", "docstring": "Maximize palindromic strings of length 3 possible from given count of alphabets | C ++ program for the above approach ; Function to count maximum number of palindromic string of length 3 ; Stores the final count of palindromic strings ; Traverse the array ; Increment res by arr [ i ] / 3 , i . e forming string of only i + ' a ' character ; Store remainder ; Increment c1 by one , if current frequency is 1 ; Increment c2 by one , if current frequency is 2 ; Count palindromic strings of length 3 having the character at the ends different from that present in the middle ; Update c1 and c2 ; Increment res by 2 * c2 / 3 ; Finally print the result ; Driver Code ; Given array ; Function Call", "dfg": [["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 56, "comesFrom", ["i"], [33]], ["i", 49, "comesFrom", ["i"], [33]], ["i", 61, "comesFrom", ["i"], [33]], ["i", 70, "comesFrom", ["i"], [33]], ["i", 83, "comesFrom", ["i"], [33]], ["t", 113, "comesFrom", ["t"], [102]], ["t", 117, "comesFrom", ["t"], [102]], ["res", 141, "comesFrom", ["res"], [133]], ["c2", 135, "comesFrom", ["c2"], [129]], ["c2", 98, "comesFrom", ["c2"], [26]], ["c2", 108, "comesFrom", ["c2"], [26]], ["c2", 124, "comesFrom", ["c2"], [115]], ["c2", 88, "comesFrom", ["c2"], [26]], ["c1", 96, "comesFrom", ["c1"], [22]], ["c1", 106, "comesFrom", ["c1"], [22]], ["c1", 75, "comesFrom", ["c1"], [22]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_Winner ( vector < string > & arr , int N ) { vector < queue < char > > Q ( N ) ; int M = arr . size ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int len = arr [ i ] . length ( ) ; for ( int j = 0 ; j < len ; j ++ ) { Q [ i ] . push ( arr [ i ] [ j ] - 1 ) ; } } int player = 0 ; while ( Q [ player ] . size ( ) > 0 ) { int nextPlayer = Q [ player ] . front ( ) - '0' ; Q [ player ] . pop ( ) ; player = nextPlayer ; } cout << \" Player ▁ \" << ( player + 1 ) ; } int main ( ) { int N = 3 ; vector < string > arr = { \"323\" , \"2\" , \"2\" } ; find_Winner ( arr , N ) ; return 0 ; }", "docstring": "Find the winner of game of repeatedly removing the first character to empty given string | C ++ program to implement the above approach ; Function to find the winner of a game of repeatedly removing the first character to empty a string ; Store characters of each string of the array arr [ ] ; Stores count of strings in arr [ ] ; Traverse the array arr [ ] ; Stores length of current string ; Traverse the string ; Insert arr [ i ] [ j ] ; 1 st Player starts the game ; Stores the player number for the next turn ; Remove 1 st character of current string ; Update player number for the next turn ; Driver Code", "dfg": [["i", 49, "comesFrom", ["i"], [45]], ["i", 53, "comesFrom", ["i"], [45]], ["i", 62, "comesFrom", ["i"], [45]], ["i", 86, "comesFrom", ["i"], [45]], ["i", 93, "comesFrom", ["i"], [45]], ["M", 51, "comesFrom", ["M"], [34]], ["arr", 198, "comesFrom", ["arr"], [180]], ["N", 200, "comesFrom", ["N"], [172]], ["j", 76, "comesFrom", ["j"], [72]], ["j", 80, "comesFrom", ["j"], [72]], ["j", 96, "comesFrom", ["j"], [72]], ["len", 78, "comesFrom", ["len"], [58]], ["nextPlayer", 150, "comesFrom", ["nextPlayer"], [124]], ["player", 160, "comesFrom", ["player"], [148]], ["player", 113, "comesFrom", ["player"], [105]], ["player", 141, "comesFrom", ["player"], [105]], ["player", 128, "comesFrom", ["player"], [105]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubstring ( string s ) { int dp [ 1024 ] ; fill ( dp , dp + 1024 , s . size ( ) ) ; int res = 0 , mask = 0 ; dp [ 0 ] = -1 ; for ( int i = 0 ; i < s . size ( ) ; ++ i ) { mask ^= 1 << ( s [ i ] - 48 ) ; res = max ( res , i - dp [ mask ] ) ; for ( int j = 0 ; j <= 9 ; ++ j ) res = max ( res , i - dp [ mask ^ ( 1 << j ) ] ) ; dp [ mask ] = min ( dp [ mask ] , i ) ; } return res ; } int main ( ) { string s = \"3242415\" ; cout << longestSubstring ( s ) ; return 0 ; }", "docstring": "Longest Substring that can be made a palindrome by swapping of characters | C ++ program for the above approach ; Function to find the Longest substring that can be made a palindrome by swapping of characters ; Initialize dp array of size 1024 ; Initializeing dp array with length of s ; Initializing mask and res ; Traverse the string ; Find the mask of the current character ; Finding the length of the longest substring in s which is a palindrome for even count ; Finding the length of the longest substring in s which is a palindrome for one odd count ; Finding maximum length of substring having one odd count ; dp [ mask ] is minimum of current i and dp [ mask ] ; Return longest length of the substring which forms a palindrome with swaps ; Driver Code ; Input String ; Function Call", "dfg": [["res", 148, "comesFrom", ["res"], [111]], ["res", 87, "comesFrom", ["res"], [83]], ["res", 115, "comesFrom", ["res"], [111]], ["i", 58, "comesFrom", ["i"], [54]], ["i", 67, "comesFrom", ["i"], [54]], ["i", 143, "comesFrom", ["i"], [54]], ["i", 89, "comesFrom", ["i"], [54]], ["i", 117, "comesFrom", ["i"], [54]], ["i", 77, "comesFrom", ["i"], [54]], ["s", 60, "comesFrom", ["s"], [11]], ["s", 167, "comesFrom", ["s"], [157]], ["s", 28, "comesFrom", ["s"], [11]], ["s", 75, "comesFrom", ["s"], [11]], ["j", 104, "comesFrom", ["j"], [100]], ["j", 109, "comesFrom", ["j"], [100]], ["j", 126, "comesFrom", ["j"], [100]], ["mask", 133, "comesFrom", ["mask"], [70]], ["mask", 140, "comesFrom", ["mask"], [70]], ["mask", 93, "comesFrom", ["mask"], [70]], ["mask", 121, "comesFrom", ["mask"], [70]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Validate ( string M ) { int len = M . size ( ) ; string temp = \" \" ; for ( int i = 0 ; i < len ; i ++ ) { if ( isdigit ( M [ i ] ) ) temp += M [ i ] ; } int nwlen = temp . size ( ) ; if ( nwlen != 10 ) { cout << \" Invalid STRNEWLINE \" ; return ; } string res = \" \" ; string x = temp . substr ( 0 , 3 ) ; res += \" ( \" + x + \" ) - \" ; x = temp . substr ( 3 , 3 ) ; res += \" ( \" + x + \" ) - \" ; x = temp . substr ( 6 , 3 ) ; res += \" ( \" + x + \" ) - \" ; x = temp . substr ( 9 , 1 ) ; res += \" ( \" + x + \" ) \" ; cout << res << \" STRNEWLINE \" ; } int main ( ) { string M = \"91 ▁ 234rt5%34*0 ▁ 3\" ; Validate ( M ) ; }", "docstring": "Convert given string to a valid mobile number | C ++ program for the above approach ; Function to print the valid and formatted phone number ; Length of given string ; Store digits in temp ; Iterate given M ; If any digit , append it to temp ; Find new length of string ; If length is not equal to 10 ; Store final result ; Make groups of 3 digits and enclose them within ( ) and separate them with \" - \" 0 to 2 index 1 st group ; 3 to 5 index 2 nd group ; 6 to 8 index 3 rd group ; 9 to 9 index last group ; Print final result ; Driver Code ; Given string ; Function Call", "dfg": [["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 59, "comesFrom", ["i"], [33]], ["i", 51, "comesFrom", ["i"], [33]], ["len", 39, "comesFrom", ["len"], [15]], ["nwlen", 74, "comesFrom", ["nwlen"], [64]], ["res", 190, "comesFrom", ["res"], [176]], ["M", 211, "comesFrom", ["M"], [203]], ["M", 17, "comesFrom", ["M"], [11]], ["M", 57, "comesFrom", ["M"], [11]], ["M", 49, "comesFrom", ["M"], [11]], ["temp", 66, "comesFrom", ["temp"], [55]], ["temp", 98, "comesFrom", ["temp"], [55]], ["temp", 121, "comesFrom", ["temp"], [55]], ["temp", 144, "comesFrom", ["temp"], [55]], ["temp", 167, "comesFrom", ["temp"], [55]], ["x", 113, "comesFrom", ["x"], [96]], ["x", 136, "comesFrom", ["x"], [119]], ["x", 159, "comesFrom", ["x"], [142]], ["x", 182, "comesFrom", ["x"], [165]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void hexaModK ( string s , string k ) { map < char , int > mp ; for ( char i = 1 ; i <= 9 ; i ++ ) { mp [ i + '0' ] = i ; } mp [ ' A ' ] = 10 ; mp [ ' B ' ] = 11 ; mp [ ' C ' ] = 12 ; mp [ ' D ' ] = 13 ; mp [ ' E ' ] = 14 ; mp [ ' F ' ] = 15 ; long m = stoi ( k , 0 , 16 ) ; long base = 1 ; long ans = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { long n = mp [ s [ i ] ] % m ; ans = ( ans + ( base % m * n % m ) % m ) % m ; base = ( base % m * 16 % m ) % m ; } stringstream ss ; ss << hex << ans ; string su = ss . str ( ) ; transform ( su . begin ( ) , su . end ( ) , su . begin ( ) , :: toupper ) ; cout << ( su ) ; } int main ( ) { string n = \"3E8\" ; string k = \"13\" ; hexaModK ( n , k ) ; return 0 ; }", "docstring": "Modulus of two Hexadecimal Numbers | C ++ program to implement the above approach ; Function to calculate modulus of two Hexadecimal numbers ; Store all possible hexadecimal digits ; Iterate over the range [ '0' , '9' ] ; Convert given string to long ; Base to get 16 power ; Store N % K ; Iterate over the digits of N ; Stores i - th digit of N ; Update ans ; Update base ; Print the answer converting into hexadecimal ; Driver Code ; Given string N and K ; Function Call", "dfg": [["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 153, "comesFrom", ["i"], [143]], ["i", 157, "comesFrom", ["i"], [143]], ["i", 49, "comesFrom", ["i"], [28]], ["i", 42, "comesFrom", ["i"], [28]], ["i", 168, "comesFrom", ["i"], [143]], ["ans", 216, "comesFrom", ["ans"], [174]], ["ans", 177, "comesFrom", ["ans"], [174]], ["mp", 52, "comesFrom", ["mp"], [23]], ["mp", 63, "comesFrom", ["mp"], [23]], ["mp", 74, "comesFrom", ["mp"], [23]], ["mp", 85, "comesFrom", ["mp"], [23]], ["mp", 96, "comesFrom", ["mp"], [23]], ["mp", 107, "comesFrom", ["mp"], [23]], ["mp", 40, "comesFrom", ["mp"], [23]], ["mp", 164, "comesFrom", ["mp"], [23]], ["ss", 212, "comesFrom", ["ss"], [210]], ["ss", 221, "comesFrom", ["ss"], [210]], ["su", 254, "comesFrom", ["su"], [219]], ["su", 229, "comesFrom", ["su"], [219]], ["su", 235, "comesFrom", ["su"], [219]], ["su", 241, "comesFrom", ["su"], [219]], ["n", 279, "comesFrom", ["n"], [264]], ["n", 184, "comesFrom", ["n"], [162]], ["k", 281, "comesFrom", ["k"], [271]], ["k", 123, "comesFrom", ["k"], [14]], ["m", 172, "comesFrom", ["m"], [119]], ["m", 192, "comesFrom", ["m"], [119]], ["m", 206, "comesFrom", ["m"], [119]], ["m", 203, "comesFrom", ["m"], [119]], ["m", 189, "comesFrom", ["m"], [119]], ["m", 199, "comesFrom", ["m"], [119]], ["m", 186, "comesFrom", ["m"], [119]], ["m", 182, "comesFrom", ["m"], [119]], ["s", 145, "comesFrom", ["s"], [11]], ["s", 166, "comesFrom", ["s"], [11]], ["base", 197, "comesFrom", ["base"], [194]], ["base", 180, "comesFrom", ["base"], [131]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string combination ; set < string > combinations ; void printSequences ( set < string > combinations ) { for ( string s : combinations ) { cout << s << ' ▁ ' ; } } void generateCombinations ( string & s , int n ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { combination . push_back ( s [ i ] ) ; long x = stol ( combination ) ; if ( x <= n ) { combinations . insert ( combination ) ; generateCombinations ( s , n ) ; } combination . pop_back ( ) ; } } int main ( ) { string S = \"124\" ; int N = 100 ; generateCombinations ( S , N ) ; printSequences ( combinations ) ; return 0 ; }", "docstring": "Print all combinations generated by characters of a numeric string which does not exceed N | C ++ program for the above approach ; Store the current sequence of s ; Store the all the required sequences ; Function to print all sequences of S satisfying the required condition ; Print all strings in the set ; Function to generate all sequences of string S that are at most N ; Iterate over string s ; Push ith character to combination ; Convert the string to number ; Check if the condition is true ; Push the current string to the final set of sequences ; Recursively call function ; Backtrack to its previous state ; Driver Code ; Function Call ; Print required sequences", "dfg": [["combinations", 31, "comesFrom", ["combinations"], [23]], ["combinations", 150, "comesFrom", ["combinations"], [23]], ["combinations", 101, "comesFrom", ["combinations"], [23]], ["i", 64, "comesFrom", ["i"], [60]], ["i", 72, "comesFrom", ["i"], [60]], ["i", 82, "comesFrom", ["i"], [60]], ["S", 143, "comesFrom", ["S"], [130]], ["N", 145, "comesFrom", ["N"], [137]], ["combination", 76, "comesFrom", ["combination"], [8]], ["combination", 116, "comesFrom", ["combination"], [8]], ["combination", 91, "comesFrom", ["combination"], [8]], ["combination", 105, "comesFrom", ["combination"], [8]], ["x", 96, "comesFrom", ["x"], [87]], ["n", 98, "comesFrom", ["n"], [54]], ["n", 112, "comesFrom", ["n"], [54]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long compute_hash ( string str ) { int p = 31 ; int MOD = 1e9 + 7 ; long long hash_val = 0 ; long long mul = 1 ; for ( char ch : str ) { hash_val = ( hash_val + ( ch - ' a ' + 1 ) * mul ) % MOD ; mul = ( mul * p ) % MOD ; } return hash_val ; } int distinct_str ( vector < string > & arr , int n ) { vector < long long > hash ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { hash [ i ] = compute_hash ( arr [ i ] ) ; } sort ( hash . begin ( ) , hash . end ( ) ) ; int cntElem = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( hash [ i ] != hash [ i - 1 ] ) { cntElem ++ ; } } return cntElem ; } int main ( ) { vector < string > arr = { \" abcde \" , \" abcce \" , \" abcdf \" , abcde \" } ; int N = arr . size ( ) ; cout << distinct_str ( arr , N ) << endl ; return 0 ; }", "docstring": "Count Distinct Strings present in an array using Polynomial rolling hash function | C ++ program to implement the above approach ; Function to find the hash value of a string ; Traverse the string ; Update hash_val ; Update mul ; Return hash_val of str ; Function to find the count of distinct strings present in the given array ; Store the hash values of the strings ; Traverse the array ; Stores hash value of arr [ i ] ; Sort hash [ ] array ; Stores count of distinct strings in the array ; Traverse hash [ ] array ; Update cntElem ; Driver Code", "dfg": [["str", 44, "comesFrom", ["str"], [12]], ["hash_val", 81, "comesFrom", ["hash_val"], [47]], ["hash_val", 50, "comesFrom", ["hash_val"], [47]], ["cntElem", 193, "comesFrom", ["cntElem"], [153]], ["cntElem", 187, "comesFrom", ["cntElem"], [153]], ["i", 115, "comesFrom", ["i"], [111]], ["i", 119, "comesFrom", ["i"], [111]], ["i", 164, "comesFrom", ["i"], [160]], ["i", 168, "comesFrom", ["i"], [160]], ["i", 125, "comesFrom", ["i"], [111]], ["i", 176, "comesFrom", ["i"], [160]], ["i", 132, "comesFrom", ["i"], [111]], ["i", 181, "comesFrom", ["i"], [160]], ["n", 117, "comesFrom", ["n"], [95]], ["n", 166, "comesFrom", ["n"], [95]], ["MOD", 67, "comesFrom", ["MOD"], [21]], ["MOD", 77, "comesFrom", ["MOD"], [21]], ["mul", 72, "comesFrom", ["mul"], [69]], ["mul", 64, "comesFrom", ["mul"], [35]], ["p", 74, "comesFrom", ["p"], [16]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool * prime , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = 2 ; i * j <= n ; j ++ ) { prime [ i * j ] = false ; } } } } void removePrimeFrequencies ( string s ) { int n = s . length ( ) ; bool prime [ n + 1 ] ; SieveOfEratosthenes ( prime , n ) ; unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( prime [ m [ s [ i ] ] ] ) continue ; new_string += s [ i ] ; } cout << new_string ; } int main ( ) { string str = \" geeksforgeeks \" ; removePrimeFrequencies ( str ) ; return 0 ; }", "docstring": "Remove characters from given string whose frequencies are a Prime Number | C ++ program for the above approach ; Function to perform the seive of eratosthenes algorithm ; Initialize all entries in prime [ ] as true ; Initialize 0 and 1 as non prime ; Traversing the prime array ; If i is prime ; All multiples of i must be marked false as they are non prime ; Function to remove characters which have prime frequency in the string ; Length of the string ; Create a boolean array prime ; Sieve of Eratosthenes ; Stores the frequency of character ; Storing the frequencies ; New string that will be formed ; Removing the characters which have prime frequencies ; If the character has prime frequency then skip ; Else concatenate the character to the new string ; Print the modified string ; Driver Code ; Function Call", "dfg": [["i", 25, "comesFrom", ["i"], [21]], ["i", 29, "comesFrom", ["i"], [21]], ["i", 66, "comesFrom", ["i"], [56]], ["i", 156, "comesFrom", ["i"], [152]], ["i", 164, "comesFrom", ["i"], [152]], ["i", 192, "comesFrom", ["i"], [188]], ["i", 200, "comesFrom", ["i"], [188]], ["i", 60, "comesFrom", ["i"], [56]], ["i", 62, "comesFrom", ["i"], [56]], ["i", 35, "comesFrom", ["i"], [21]], ["i", 223, "comesFrom", ["i"], [188]], ["i", 74, "comesFrom", ["i"], [56]], ["i", 87, "comesFrom", ["i"], [56]], ["i", 172, "comesFrom", ["i"], [152]], ["i", 212, "comesFrom", ["i"], [188]], ["i", 99, "comesFrom", ["i"], [56]], ["n", 27, "comesFrom", ["n"], [15]], ["n", 64, "comesFrom", ["n"], [15]], ["n", 129, "comesFrom", ["n"], [118]], ["n", 138, "comesFrom", ["n"], [118]], ["n", 91, "comesFrom", ["n"], [15]], ["new_string", 229, "comesFrom", ["new_string"], [219]], ["str", 246, "comesFrom", ["str"], [238]], ["s", 120, "comesFrom", ["s"], [114]], ["s", 158, "comesFrom", ["s"], [114]], ["s", 194, "comesFrom", ["s"], [114]], ["s", 221, "comesFrom", ["s"], [114]], ["s", 170, "comesFrom", ["s"], [114]], ["s", 210, "comesFrom", ["s"], [114]], ["m", 168, "comesFrom", ["m"], [147]], ["m", 208, "comesFrom", ["m"], [147]], ["j", 93, "comesFrom", ["j"], [83]], ["j", 89, "comesFrom", ["j"], [83]], ["j", 101, "comesFrom", ["j"], [83]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string rearrange ( string s ) { string s1 = \" \" , s2 = \" \" ; for ( char x : s ) { isalpha ( x ) ? s1 . push_back ( x ) : s2 . push_back ( x ) ; } int n = s1 . size ( ) ; int m = s2 . size ( ) ; if ( abs ( n - m ) > 1 ) return \" - 1\" ; int i = 0 , j = 0 , k = 0 ; int flag = ( n >= m ) ? 1 : 0 ; while ( i < n and j < m ) { if ( flag ) s [ k ++ ] = s1 [ i ++ ] ; else s [ k ++ ] = s2 [ j ++ ] ; flag = ! flag ; } return s ; } int main ( ) { string str = \" geeks2020\" ; cout << rearrange ( str ) << endl ; return 0 ; }", "docstring": "Rearrange string such that no pair of adjacent characters are of the same type | C ++ program to implement the above approach ; Function to rearrange given alphanumeric string such that no two adjacent characters are of the same type ; Stores alphabets and digits ; Store the alphabets and digits separately in the strings ; Stores the count of alphabets and digits ; If respective counts differ by 1 ; Desired arrangement not possible ; Stores the indexes ; Check if first character should be alphabet or digit ; Place alphabets and digits alternatively ; If current character needs to be alphabet ; If current character needs to be a digit ; Flip flag for alternate arrangement ; Return resultant string ; Driver Code ; Given String ; Function Call", "dfg": [["s", 32, "comesFrom", ["s"], [11]], ["s", 162, "comesFrom", ["s"], [11]], ["s", 130, "comesFrom", ["s"], [11]], ["s", 143, "comesFrom", ["s"], [11]], ["s1", 58, "comesFrom", ["s1"], [15]], ["s1", 40, "comesFrom", ["s1"], [15]], ["s1", 136, "comesFrom", ["s1"], [15]], ["s2", 67, "comesFrom", ["s2"], [21]], ["s2", 47, "comesFrom", ["s2"], [21]], ["s2", 149, "comesFrom", ["s2"], [21]], ["i", 117, "comesFrom", ["i"], [90]], ["i", 138, "comesFrom", ["i"], [90]], ["n", 119, "comesFrom", ["n"], [56]], ["n", 106, "comesFrom", ["n"], [56]], ["n", 77, "comesFrom", ["n"], [56]], ["j", 121, "comesFrom", ["j"], [94]], ["j", 151, "comesFrom", ["j"], [94]], ["m", 123, "comesFrom", ["m"], [65]], ["m", 108, "comesFrom", ["m"], [65]], ["m", 79, "comesFrom", ["m"], [65]], ["flag", 128, "comesFrom", ["flag"], [103]], ["flag", 158, "comesFrom", ["flag"], [155]], ["str", 181, "comesFrom", ["str"], [171]], ["k", 132, "comesFrom", ["k"], [98]], ["k", 145, "comesFrom", ["k"], [98]]]}
{"code": "#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; void charactersCount ( string str , int n ) { int count = 0 ; while ( n > 0 ) { char cur = str [ 0 ] ; int ind = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( str [ j ] < cur ) { cur = str [ j ] ; ind = j ; } } str . erase ( str . begin ( ) + ind ) ; n -- ; count += ind + 1 ; } cout << count << endl ; } int main ( ) { string str = \" aabbc \" ; int n = 5 ; charactersCount ( str , n ) ; return 0 ; }", "docstring": "Find value after N operations to remove N characters of string S with given constraints | C ++ program for the above approach ; Function to find the value after N operations to remove all the N characters of string S ; Iterate till N ; Remove character at ind and decrease n ( size of string ) ; Increase count by ind + 1 ; Driver Code ; Given string str ; Function call", "dfg": [["n", 27, "comesFrom", ["n"], [17]], ["n", 134, "comesFrom", ["n"], [126]], ["n", 54, "comesFrom", ["n"], [17]], ["n", 96, "comesFrom", ["n"], [17]], ["count", 108, "comesFrom", ["count"], [99]], ["str", 132, "comesFrom", ["str"], [119]], ["str", 35, "comesFrom", ["str"], [14]], ["str", 83, "comesFrom", ["str"], [14]], ["str", 62, "comesFrom", ["str"], [14]], ["str", 87, "comesFrom", ["str"], [14]], ["str", 72, "comesFrom", ["str"], [14]], ["j", 52, "comesFrom", ["j"], [48]], ["j", 56, "comesFrom", ["j"], [48]], ["j", 79, "comesFrom", ["j"], [48]], ["j", 64, "comesFrom", ["j"], [48]], ["j", 74, "comesFrom", ["j"], [48]], ["ind", 101, "comesFrom", ["ind"], [77]], ["ind", 93, "comesFrom", ["ind"], [77]], ["cur", 67, "comesFrom", ["cur"], [33]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMiddleCharacter ( string str ) { int len = str . size ( ) ; int middle = len / 2 ; cout << str [ middle ] ; } int main ( ) { string str = \" GeeksForGeeks \" ; printMiddleCharacter ( str ) ; return 0 ; }", "docstring": "Print the middle character of a string | C ++ program to implement the above approach ; Function that prints the middle character of a string ; Finding string length ; Finding middle index of string ; Print the middle character of the string ; Driver Code ; Given string str ; Function Call", "dfg": [["len", 26, "comesFrom", ["len"], [15]], ["str", 32, "comesFrom", ["str"], [11]], ["str", 52, "comesFrom", ["str"], [44]], ["str", 17, "comesFrom", ["str"], [11]], ["middle", 34, "comesFrom", ["middle"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s ) { set < char > a ; for ( auto i : s ) { if ( a . count ( i ) ) return false ; a . insert ( i ) ; } return true ; } vector < string > helper ( vector < string > & arr , int ind ) { if ( ind == arr . size ( ) ) return { \" \" } ; vector < string > tmp = helper ( arr , ind + 1 ) ; vector < string > ret ( tmp . begin ( ) , tmp . end ( ) ) ; for ( auto i : tmp ) { string test = i + arr [ ind ] ; if ( check ( test ) ) ret . push_back ( test ) ; } return ret ; } int maxLength ( vector < string > & arr ) { vector < string > tmp = helper ( arr , 0 ) ; int len = 0 ; for ( auto i : tmp ) { len = len > i . size ( ) ? len : i . size ( ) ; } return len ; } int main ( ) { vector < string > s ; s . push_back ( \" abcdefgh \" ) ; cout << maxLength ( s ) ; return 0 ; }", "docstring": "Maximize length of the String by concatenating characters from an Array of Strings | C ++ Program to implement the above approach ; Function to check if all the string characters are unique ; Check for repetition in characters ; Function to generate all possible strings from the given array ; Base case ; Consider every string as a starting substring and store the generated string ; Add current string to result of other strings and check if characters are unique or not ; Function to find the maximum possible length of a string ; Return max length possible ; Return the answer ; Driver Code", "dfg": [["s", 25, "comesFrom", ["s"], [11]], ["s", 228, "comesFrom", ["s"], [226]], ["s", 241, "comesFrom", ["s"], [226]], ["tmp", 125, "comesFrom", ["tmp"], [90]], ["tmp", 191, "comesFrom", ["tmp"], [172]], ["tmp", 107, "comesFrom", ["tmp"], [90]], ["tmp", 113, "comesFrom", ["tmp"], [90]], ["ret", 154, "comesFrom", ["ret"], [105]], ["ret", 145, "comesFrom", ["ret"], [105]], ["len", 214, "comesFrom", ["len"], [194]], ["len", 204, "comesFrom", ["len"], [194]], ["len", 196, "comesFrom", ["len"], [194]], ["ind", 71, "comesFrom", ["ind"], [66]], ["ind", 96, "comesFrom", ["ind"], [66]], ["ind", 135, "comesFrom", ["ind"], [66]], ["a", 40, "comesFrom", ["a"], [18]], ["a", 30, "comesFrom", ["a"], [18]], ["test", 142, "comesFrom", ["test"], [129]], ["test", 149, "comesFrom", ["test"], [129]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Range_sum_query ( string S , vector < pair < int , int > > Query ) { int N = S . length ( ) ; int A [ N ] ; A [ 0 ] = S [ 0 ] - ' a ' + 1 ; for ( int i = 1 ; i < N ; i ++ ) { A [ i ] = S [ i ] - ' a ' + 1 ; A [ i ] = A [ i ] + A [ i - 1 ] ; } for ( int i = 0 ; i < Query . size ( ) ; i ++ ) { if ( Query [ i ] . first == 1 ) { cout << A [ ( Query [ i ] . second ) - 1 ] << endl ; } else { cout << A [ ( Query [ i ] . second ) - 1 ] - A [ ( Query [ i ] . first ) - 2 ] << endl ; } } } int main ( ) { string S = \" abcd \" ; vector < pair < int , int > > Query ; Query . push_back ( make_pair ( 2 , 4 ) ) ; Query . push_back ( make_pair ( 1 , 3 ) ) ; Range_sum_query ( S , Query ) ; return 0 ; }", "docstring": "Perform range sum queries on string as per given condition | C ++ program for the above approach ; Function to perform range sum queries on string as per the given condition ; Initialize N by string size ; Create array A [ ] for prefix sum ; Iterate till N ; Traverse the queries ; Check if if L == 1 range sum will be A [ R - 1 ] ; Condition if L > 1 range sum will be A [ R - 1 ] - A [ L - 2 ] ; Driver Code ; Given string ; Given Queries ; Function call", "dfg": [["N", 37, "comesFrom", ["N"], [26]], ["N", 67, "comesFrom", ["N"], [26]], ["i", 65, "comesFrom", ["i"], [61]], ["i", 69, "comesFrom", ["i"], [61]], ["i", 116, "comesFrom", ["i"], [112]], ["i", 124, "comesFrom", ["i"], [112]], ["i", 75, "comesFrom", ["i"], [61]], ["i", 93, "comesFrom", ["i"], [61]], ["i", 98, "comesFrom", ["i"], [61]], ["i", 80, "comesFrom", ["i"], [61]], ["i", 103, "comesFrom", ["i"], [61]], ["i", 132, "comesFrom", ["i"], [112]], ["i", 147, "comesFrom", ["i"], [112]], ["i", 168, "comesFrom", ["i"], [112]], ["i", 182, "comesFrom", ["i"], [112]], ["Query", 219, "comesFrom", ["Query"], [217]], ["Query", 231, "comesFrom", ["Query"], [217]], ["Query", 247, "comesFrom", ["Query"], [217]], ["Query", 118, "comesFrom", ["Query"], [22]], ["Query", 130, "comesFrom", ["Query"], [22]], ["Query", 145, "comesFrom", ["Query"], [22]], ["Query", 166, "comesFrom", ["Query"], [22]], ["Query", 180, "comesFrom", ["Query"], [22]], ["S", 245, "comesFrom", ["S"], [202]], ["S", 28, "comesFrom", ["S"], [11]], ["S", 45, "comesFrom", ["S"], [11]], ["S", 78, "comesFrom", ["S"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap_ ( char & a , char & b ) { char temp ; temp = a ; a = b ; b = temp ; } void permute ( char * str , int l , int r , int n ) { int i ; if ( l == r ) { int j = atoi ( str ) ; if ( j % n == 0 ) cout << str << endl ; return ; } for ( i = l ; i < r ; i ++ ) { swap_ ( str [ l ] , str [ i ] ) ; permute ( str , l + 1 , r , n ) ; swap_ ( str [ l ] , str [ i ] ) ; } } int main ( ) { char str [ 100 ] = \"125\" ; int n = 5 ; int len = strlen ( str ) ; if ( len > 0 ) permute ( str , 0 , len , n ) ; return 0 ; }", "docstring": "Generate all possible permutations of a Number divisible by N | C ++ Program to implement the above approach ; Function to Swap two characters ; Function to generate all permutations and print the ones that are divisible by the N ; Convert string to integer ; Check for divisibility and print it ; Print all the permutations ; Swap characters ; Permute remaining characters ; Revoke the swaps ; Driver Code", "dfg": [["temp", 32, "comesFrom", ["temp"], [22]], ["l", 91, "comesFrom", ["l"], [43]], ["l", 57, "comesFrom", ["l"], [43]], ["l", 118, "comesFrom", ["l"], [43]], ["l", 105, "comesFrom", ["l"], [43]], ["l", 131, "comesFrom", ["l"], [43]], ["i", 93, "comesFrom", ["i"], [89]], ["i", 97, "comesFrom", ["i"], [89]], ["i", 110, "comesFrom", ["i"], [89]], ["i", 136, "comesFrom", ["i"], [89]], ["r", 95, "comesFrom", ["r"], [46]], ["r", 59, "comesFrom", ["r"], [46]], ["r", 122, "comesFrom", ["r"], [46]], ["len", 172, "comesFrom", ["len"], [163]], ["len", 182, "comesFrom", ["len"], [163]], ["n", 184, "comesFrom", ["n"], [158]], ["n", 124, "comesFrom", ["n"], [49]], ["n", 74, "comesFrom", ["n"], [49]], ["j", 72, "comesFrom", ["j"], [63]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string decimalToBinary ( int N ) { string ans = \" \" ; while ( N > 0 ) { if ( N & 1 ) { ans = '1' + ans ; } else { ans = '0' + ans ; } N /= 2 ; } return ans ; } string checkBinaryString ( string & str , int N ) { int map [ N + 10 ] , cnt = 0 ; memset ( map , 0 , sizeof ( map ) ) ; for ( int i = N ; i > 0 ; i -- ) { if ( ! map [ i ] ) { int t = i ; string s = decimalToBinary ( t ) ; if ( str . find ( s ) != str . npos ) { while ( t && ! map [ t ] ) { map [ t ] = 1 ; cnt ++ ; t >>= 1 ; } } } } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '0' ) { cnt ++ ; break ; } } if ( cnt == N + 1 ) return \" True \" ; else return \" False \" ; } int main ( ) { string str = \"0110\" ; int N = 3 ; cout << checkBinaryString ( str , N ) ; return 0 ; }", "docstring": "Check if binary representations of 0 to N are present as substrings in given binary string | C ++ program for the above approach ; Function to convert decimal to binary representation ; Iterate over all bits of N ; If bit is 1 ; Return binary representation ; Function to check if binary conversion of numbers from N to 1 exists in the string as a substring or not ; To store the count of number exists as a substring ; Traverse from N to 1 ; If current number is not present in map ; Store current number ; Find binary of t ; If the string s is a substring of str ; Mark t as true ; Increment the count ; Update for t / 2 ; Special judgment '0' ; If the count is N + 1 , return \" yes \" ; Driver Code ; Given String ; Given Number ; Function Call", "dfg": [["ans", 61, "comesFrom", ["ans"], [46]], ["ans", 41, "comesFrom", ["ans"], [35]], ["ans", 52, "comesFrom", ["ans"], [46]], ["i", 106, "comesFrom", ["i"], [102]], ["i", 110, "comesFrom", ["i"], [102]], ["i", 186, "comesFrom", ["i"], [182]], ["i", 194, "comesFrom", ["i"], [182]], ["i", 119, "comesFrom", ["i"], [102]], ["i", 202, "comesFrom", ["i"], [182]], ["N", 23, "comesFrom", ["N"], [11]], ["N", 78, "comesFrom", ["N"], [72]], ["N", 221, "comesFrom", ["N"], [104]], ["N", 260, "comesFrom", ["N"], [250]], ["N", 30, "comesFrom", ["N"], [11]], ["str", 258, "comesFrom", ["str"], [243]], ["cnt", 219, "comesFrom", ["cnt"], [83]], ["cnt", 210, "comesFrom", ["cnt"], [83]], ["cnt", 168, "comesFrom", ["cnt"], [83]], ["t", 133, "comesFrom", ["t"], [124]], ["t", 152, "comesFrom", ["t"], [124]], ["t", 157, "comesFrom", ["t"], [124]], ["t", 163, "comesFrom", ["t"], [124]], ["s", 142, "comesFrom", ["s"], [129]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestAnagramGrp ( vector < string > arr ) { int prime [ ] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 } ; int max = -1 ; long maxpdt = -1 ; unordered_map < long long , string > W ; unordered_map < long long , long > P ; for ( string temp : arr ) { long pdt = 1 ; for ( char t : temp ) { pdt *= prime [ t - ' a ' ] ; } if ( P . find ( pdt ) != P . end ( ) ) { P [ pdt ] ++ ; } else { W [ pdt ] = temp ; P [ pdt ] = 1 ; } } for ( auto e : P ) { if ( max < e . second ) { max = e . second ; maxpdt = e . first ; } } return W [ maxpdt ] ; } int main ( ) { char S [ ] = \" please ▁ be ▁ silent ▁ and ▁ listen ▁ to ▁ what ▁ the ▁ professor ▁ says ▁ \" ; vector < string > arr ; char * token = strtok ( S , \" ▁ \" ) ; while ( token != NULL ) { arr . push_back ( token ) ; token = strtok ( NULL , \" ▁ \" ) ; } cout << largestAnagramGrp ( arr ) << endl ; return 0 ; }", "docstring": "Find the word with most anagrams in a given sentence | C ++ Program to find the word with most anagrams in a sentence ; Function to find the word with maximum number of anagrams ; Primes assigned to 26 alphabets ; Stores the product and word mappings ; Stores the frequencies of products ; Calculate the product of primes assigned ; If product already exists ; Otherwise ; Fetch the most frequent product ; Return a string with that product ; Driver Code", "dfg": [["arr", 109, "comesFrom", ["arr"], [14]], ["arr", 258, "comesFrom", ["arr"], [236]], ["arr", 281, "comesFrom", ["arr"], [236]], ["P", 185, "comesFrom", ["P"], [102]], ["P", 141, "comesFrom", ["P"], [102]], ["P", 148, "comesFrom", ["P"], [102]], ["P", 155, "comesFrom", ["P"], [102]], ["P", 171, "comesFrom", ["P"], [102]], ["W", 212, "comesFrom", ["W"], [93]], ["W", 164, "comesFrom", ["W"], [93]], ["maxpdt", 214, "comesFrom", ["maxpdt"], [203]], ["max", 190, "comesFrom", ["max"], [77]], ["pdt", 145, "comesFrom", ["pdt"], [125]], ["pdt", 157, "comesFrom", ["pdt"], [125]], ["pdt", 166, "comesFrom", ["pdt"], [125]], ["pdt", 173, "comesFrom", ["pdt"], [125]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string print_next_vovel_string ( string str ) { map < char , int > m ; m [ ' a ' ] = 0 ; m [ ' e ' ] = 1 ; m [ ' i ' ] = 2 ; m [ ' o ' ] = 3 ; m [ ' u ' ] = 4 ; char arr [ 5 ] = { ' a ' , ' e ' , ' i ' , ' o ' , ' u ' } ; int N = str . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { char c = str [ i ] ; if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) { int index = m + 1 ; int newindex = index % 5 ; str [ i ] = arr [ newindex ] ; } } return str ; } int main ( ) { string str = \" geeksforgeeks \" ; cout << print_next_vovel_string ( str ) ; return 0 ; }", "docstring": "Replace every vowels with lexicographically next vowel in a String | C ++ program to convert all the vowels in in the string to the next vowel ; Function to replace every vowel with next vowel lexicographically ; Storing the vowels in the map with custom numbers showing their index ; Iterate over the string ; If the current character is a vowel Find the index in Hash and Replace it with next vowel from Hash ; Driver function", "dfg": [["str", 213, "comesFrom", ["str"], [11]], ["str", 118, "comesFrom", ["str"], [11]], ["str", 232, "comesFrom", ["str"], [222]], ["str", 142, "comesFrom", ["str"], [11]], ["str", 200, "comesFrom", ["str"], [11]], ["i", 131, "comesFrom", ["i"], [127]], ["i", 135, "comesFrom", ["i"], [127]], ["i", 144, "comesFrom", ["i"], [127]], ["i", 202, "comesFrom", ["i"], [127]], ["N", 133, "comesFrom", ["N"], [116]], ["m", 22, "comesFrom", ["m"], [20]], ["m", 33, "comesFrom", ["m"], [20]], ["m", 44, "comesFrom", ["m"], [20]], ["m", 55, "comesFrom", ["m"], [20]], ["m", 66, "comesFrom", ["m"], [20]], ["m", 189, "comesFrom", ["m"], [20]], ["c", 177, "comesFrom", ["c"], [140]], ["c", 170, "comesFrom", ["c"], [140]], ["c", 163, "comesFrom", ["c"], [140]], ["c", 149, "comesFrom", ["c"], [140]], ["c", 156, "comesFrom", ["c"], [140]], ["index", 196, "comesFrom", ["index"], [187]], ["newindex", 207, "comesFrom", ["newindex"], [194]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ len - i - 1 ] ) return false ; } return true ; } bool isCompressablePalindrome ( string str ) { int len = str . length ( ) ; string compressed = \" \" ; compressed . push_back ( str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] != str [ i - 1 ] ) compressed . push_back ( str [ i ] ) ; } return isPalindrome ( compressed ) ; } int main ( ) { string str = \" abbcbbbaaa \" ; if ( isCompressablePalindrome ( str ) ) cout << \" Yes STRNEWLINE \" ; else cout << \" No STRNEWLINE \" ; return 0 ; }", "docstring": "Check if string is palindrome after removing all consecutive duplicates | C ++ program for the above approach ; Function to check if a string is palindrome or not ; Length of the string ; Check if its a palindrome ; If the palindromic condition is not met ; Return true as str is palindromic ; Function to check if string str is palindromic after removing every consecutive characters from the str ; Length of the string str ; Create an empty compressed string ; The first character will always be included in the final string ; Check all the characters of the string ; If the current character is not same as its previous one , then insert it in the final string ; Check if the compressed string is a palindrome ; Driver Code ; Given string ; Function call", "dfg": [["i", 30, "comesFrom", ["i"], [26]], ["i", 34, "comesFrom", ["i"], [26]], ["i", 102, "comesFrom", ["i"], [98]], ["i", 106, "comesFrom", ["i"], [98]], ["i", 42, "comesFrom", ["i"], [26]], ["i", 114, "comesFrom", ["i"], [98]], ["i", 119, "comesFrom", ["i"], [98]], ["i", 130, "comesFrom", ["i"], [98]], ["i", 49, "comesFrom", ["i"], [26]], ["len", 32, "comesFrom", ["len"], [15]], ["len", 104, "comesFrom", ["len"], [70]], ["len", 47, "comesFrom", ["len"], [15]], ["compressed", 85, "comesFrom", ["compressed"], [79]], ["compressed", 138, "comesFrom", ["compressed"], [79]], ["compressed", 124, "comesFrom", ["compressed"], [79]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 72, "comesFrom", ["str"], [66]], ["str", 89, "comesFrom", ["str"], [66]], ["str", 158, "comesFrom", ["str"], [148]], ["str", 40, "comesFrom", ["str"], [11]], ["str", 45, "comesFrom", ["str"], [11]], ["str", 112, "comesFrom", ["str"], [66]], ["str", 117, "comesFrom", ["str"], [66]], ["str", 128, "comesFrom", ["str"], [66]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; bool isvowel ( char ch ) { return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) ; } int CountTotal ( string & s ) { int ans = 0 ; int n = s . length ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isvowel ( s [ i ] ) ) cnt += 1 ; else { ans += ( cnt * ( cnt + 1 ) / 2 ) ; cnt = 0 ; } } if ( cnt != 0 ) { ans += ( cnt * ( cnt + 1 ) / 2 ) ; } return ans ; } int main ( ) { string s = \" geeksforgeeks \" ; cout << ( CountTotal ( s ) ) << endl ; return 0 ; }", "docstring": "Count of substrings consisting only of vowels | C ++ program to Count all substrings in a string which contains only vowels ; Function to check vowel or not ; Function to Count all substrings in a string which contains only vowels ; Check if current character is vowel ; Increment length of substring ; Calculate possible substrings of calculated length ; Reset the length ; Add remaining possible substrings consisting of vowels occupying last indices of the string ; Driver Program", "dfg": [["ans", 159, "comesFrom", ["ans"], [143]], ["i", 92, "comesFrom", ["i"], [88]], ["i", 96, "comesFrom", ["i"], [88]], ["i", 106, "comesFrom", ["i"], [88]], ["n", 94, "comesFrom", ["n"], [72]], ["s", 179, "comesFrom", ["s"], [168]], ["cnt", 138, "comesFrom", ["cnt"], [130]], ["cnt", 146, "comesFrom", ["cnt"], [130]], ["cnt", 149, "comesFrom", ["cnt"], [130]], ["cnt", 119, "comesFrom", ["cnt"], [110]], ["cnt", 122, "comesFrom", ["cnt"], [110]], ["ch", 48, "comesFrom", ["ch"], [11]], ["ch", 40, "comesFrom", ["ch"], [11]], ["ch", 32, "comesFrom", ["ch"], [11]], ["ch", 16, "comesFrom", ["ch"], [11]], ["ch", 24, "comesFrom", ["ch"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int totCount ; int firstCount ; void getTotCount ( int num ) { totCount = 1 ; firstCount = 1 ; int temp = 1 ; while ( ( num & temp ) == 0 ) { temp = temp << 1 ; totCount += 1 ; } firstCount = totCount ; temp = num >> totCount ; while ( temp != 0 ) { totCount += 1 ; temp = temp >> 1 ; } } int flipBitsFromRightMostSetBit ( int num ) { getTotCount ( num ) ; int num1 = num ^ ( ( 1 << totCount ) - 1 ) ; num1 = num1 ^ ( ( 1 << firstCount ) - 1 ) ; return num1 ; } int main ( ) { int n = 120 ; cout << flipBitsFromRightMostSetBit ( n ) << endl ; return 0 ; }", "docstring": "Number formed by flipping all bits to the left of rightmost set bit | C ++ program to find the integer formed after flipping all bits to the left of the rightmost set bit ; Function to get the total count ; Moving until we get the rightmost set bit ; To get total number of bits in a number ; Function to find the integer formed after flipping all bits to the left of the rightmost set bit ; Find the total count of bits and the rightmost set bit ; XOR given number with the number which has is made up of only totbits set ; To avoid flipping the bits to the right of the set bit , take XOR with the number made up of only set firstbits ; Driver Code", "dfg": [["num1", 126, "comesFrom", ["num1"], [111]], ["num1", 113, "comesFrom", ["num1"], [111]], ["totCount", 57, "comesFrom", ["totCount"], [50]], ["totCount", 63, "comesFrom", ["totCount"], [50]], ["totCount", 105, "comesFrom", ["totCount"], [72]], ["num", 61, "comesFrom", ["num"], [17]], ["num", 93, "comesFrom", ["num"], [88]], ["num", 99, "comesFrom", ["num"], [88]], ["num", 36, "comesFrom", ["num"], [17]], ["temp", 67, "comesFrom", ["temp"], [59]], ["temp", 38, "comesFrom", ["temp"], [29]], ["temp", 46, "comesFrom", ["temp"], [44]], ["temp", 78, "comesFrom", ["temp"], [76]], ["n", 143, "comesFrom", ["n"], [135]], ["firstCount", 119, "comesFrom", ["firstCount"], [55]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isvowel ( char c ) { return c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ; } int findMaxLen ( string & s ) { int maxLen = 0 ; int cur = 0 ; if ( isvowel ( s [ 0 ] ) ) cur = maxLen = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( isvowel ( s [ i ] ) ) { if ( s [ i ] != s [ i - 1 ] ) cur += 1 ; else cur = 1 ; } else { cur = 0 ; } maxLen = max ( cur , maxLen ) ; } return maxLen ; } int main ( ) { string Str = \" aeoibsddaeiouudb \" ; cout << findMaxLen ( Str ) << endl ; return 0 ; }", "docstring": "Longest substring of vowels with no two adjacent alphabets same | C ++ implementation of the above approach ; Function to check a character is vowel or not ; Function to find length of longest substring consisting only of vowels and no similar adjacent alphabets ; Stores max length of valid subString ; Stores length of current valid subString ; If curr and prev character are not same , include it ; If same as prev one , start new subString from here ; Store max in maxLen ; Driver code", "dfg": [["maxLen", 162, "comesFrom", ["maxLen"], [151]], ["maxLen", 157, "comesFrom", ["maxLen"], [151]], ["i", 97, "comesFrom", ["i"], [93]], ["i", 105, "comesFrom", ["i"], [93]], ["i", 115, "comesFrom", ["i"], [93]], ["i", 124, "comesFrom", ["i"], [93]], ["i", 129, "comesFrom", ["i"], [93]], ["c", 47, "comesFrom", ["c"], [11]], ["c", 39, "comesFrom", ["c"], [11]], ["c", 31, "comesFrom", ["c"], [11]], ["c", 15, "comesFrom", ["c"], [11]], ["c", 23, "comesFrom", ["c"], [11]], ["Str", 181, "comesFrom", ["Str"], [171]], ["cur", 155, "comesFrom", ["cur"], [146]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long power ( unsigned long long base , unsigned long long pow ) { unsigned long long res = 1 ; while ( pow > 0 ) { if ( pow & 1 ) res = ( res * base ) ; base = ( base * base ) ; pow >>= 1 ; } return res ; } unsigned long long countNonPalindromicString ( unsigned long long n , unsigned long long m ) { unsigned long long total = power ( n , m ) ; unsigned long long palindrome = power ( n , m / 2 + m % 2 ) ; unsigned long long count = total - palindrome ; return count ; } int main ( ) { int n = 3 , m = 5 ; cout << countNonPalindromicString ( n , m ) ; return 0 ; }", "docstring": "Count of non | C ++ Program to count non - palindromic strings of length M using N distinct characters ; Iterative Function to calculate base ^ pow in O ( log y ) ; Function to return the count of non palindromic strings ; Count of strings using n characters with repetitions allowed ; Count of palindromic strings ; Count of non - palindromic strings ; Driver code", "dfg": [["res", 65, "comesFrom", ["res"], [43]], ["res", 46, "comesFrom", ["res"], [43]], ["count", 124, "comesFrom", ["count"], [117]], ["pow", 32, "comesFrom", ["pow"], [20]], ["pow", 39, "comesFrom", ["pow"], [20]], ["total", 119, "comesFrom", ["total"], [87]], ["palindrome", 121, "comesFrom", ["palindrome"], [99]], ["n", 91, "comesFrom", ["n"], [76]], ["n", 103, "comesFrom", ["n"], [76]], ["n", 145, "comesFrom", ["n"], [133]], ["m", 93, "comesFrom", ["m"], [81]], ["m", 147, "comesFrom", ["m"], [137]], ["m", 105, "comesFrom", ["m"], [81]], ["m", 109, "comesFrom", ["m"], [81]], ["base", 54, "comesFrom", ["base"], [51]], ["base", 56, "comesFrom", ["base"], [51]], ["base", 48, "comesFrom", ["base"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > freq ( 26 ) ; bool checkPalindrome ( ) { int oddCnt = 0 ; for ( auto x : freq ) { if ( x % 2 == 1 ) oddCnt ++ ; } return oddCnt <= 1 ; } int countPalindromePermutation ( string s , int k ) { for ( int i = 0 ; i < k ; i ++ ) { freq [ s [ i ] - 97 ] ++ ; } int ans = 0 ; if ( checkPalindrome ( ) ) { ans ++ ; } int i = 0 , j = k ; while ( j < s . size ( ) ) { freq [ s [ i ++ ] - 97 ] -- ; freq [ s [ j ++ ] - 97 ] ++ ; if ( checkPalindrome ( ) ) { ans ++ ; } } return ans ; } int main ( ) { string str = \" abbaca \" ; int K = 3 ; cout << countPalindromePermutation ( str , K ) << endl ; return 0 ; }", "docstring": "Count of K | C ++ program for the above approach ; To store the frequency array ; Function to check palindromic of of any substring using frequency array ; Initialise the odd count ; Traversing frequency array to compute the count of characters having odd frequency ; Returns true if odd count is atmost 1 ; Function to count the total number substring whose any permutations are palindromic ; Computing the frequency of first K character of the string ; To store the count of palindromic permutations ; Checking for the current window if it has any palindromic permutation ; Start and end point of window ; Decrementing count of first element of the window ; Incrementing count of next element of the window ; Checking current window character frequency count ; Return the final count ; Driver Code ; Given string str ; Window of size K ; Function Call", "dfg": [["freq", 31, "comesFrom", ["freq"], [11]], ["freq", 77, "comesFrom", ["freq"], [11]], ["freq", 125, "comesFrom", ["freq"], [11]], ["freq", 137, "comesFrom", ["freq"], [11]], ["ans", 162, "comesFrom", ["ans"], [90]], ["ans", 101, "comesFrom", ["ans"], [90]], ["ans", 156, "comesFrom", ["ans"], [90]], ["oddCnt", 47, "comesFrom", ["oddCnt"], [22]], ["oddCnt", 42, "comesFrom", ["oddCnt"], [22]], ["i", 69, "comesFrom", ["i"], [65]], ["i", 73, "comesFrom", ["i"], [65]], ["i", 81, "comesFrom", ["i"], [65]], ["i", 129, "comesFrom", ["i"], [106]], ["k", 71, "comesFrom", ["k"], [59]], ["j", 116, "comesFrom", ["j"], [110]], ["j", 141, "comesFrom", ["j"], [110]], ["s", 118, "comesFrom", ["s"], [56]], ["s", 79, "comesFrom", ["s"], [56]], ["s", 127, "comesFrom", ["s"], [56]], ["s", 139, "comesFrom", ["s"], [56]], ["str", 186, "comesFrom", ["str"], [171]], ["K", 188, "comesFrom", ["K"], [178]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minFlips ( string target ) { char curr = '1' ; int count = 0 ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { if ( target [ i ] == curr ) { count ++ ; curr = ( char ) ( 48 + ( curr + 1 ) % 2 ) ; } } return count ; } int main ( ) { string S = \"011000\" ; cout << ( minFlips ( S ) ) ; }", "docstring": "Minimum flips required to form given binary string where every flip changes all bits to its right as well | C ++ program for the above approach ; Function to return the count of minimum flips required ; If curr occurs in the final string ; Switch curr to '0' if '1' or vice - versa ; Driver Code", "dfg": [["count", 78, "comesFrom", ["count"], [22]], ["count", 55, "comesFrom", ["count"], [22]], ["i", 33, "comesFrom", ["i"], [29]], ["i", 41, "comesFrom", ["i"], [29]], ["i", 49, "comesFrom", ["i"], [29]], ["target", 35, "comesFrom", ["target"], [11]], ["target", 47, "comesFrom", ["target"], [11]], ["curr", 52, "comesFrom", ["curr"], [15]], ["curr", 67, "comesFrom", ["curr"], [58]], ["S", 98, "comesFrom", ["S"], [87]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #include <boost/algorithm/string.hpp> NEW_LINE using namespace std ; bool checkSuffix ( int A , int B ) { int digit_B = log10 ( B ) + 1 ; A -= B ; return ( A % int ( pow ( 10 , digit_B ) ) ) ; } int main ( ) { int A = 12345 , B = 45 ; bool result = checkSuffix ( A , B ) ; if ( ! result ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "docstring": "Check if a number ends with another number or not | C ++ program for the above approach ; Function to check if B is a suffix of A or not ; Find the number of digit in B ; Subtract B from A ; Returns true , if B is a suffix of A ; Driver Code ; Given numbers ; Function Call ; If B is a suffix of A , then print \" Yes \"", "dfg": [["B", 32, "comesFrom", ["B"], [17]], ["B", 71, "comesFrom", ["B"], [60]], ["B", 25, "comesFrom", ["B"], [17]], ["A", 36, "comesFrom", ["A"], [30]], ["A", 69, "comesFrom", ["A"], [56]], ["result", 77, "comesFrom", ["result"], [65]], ["digit_B", 44, "comesFrom", ["digit_B"], [21]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_min_length ( string s ) { int hash [ 26 ] ; int ans = INT_MAX ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = -1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( hash [ s [ i ] - ' a ' ] == -1 ) hash [ s [ i ] - ' a ' ] = i ; else { if ( hash [ s [ i ] - ' a ' ] == i - 1 hash [ s [ i ] - ' a ' ] == i - 2 ) return 0 ; ans = min ( ans , i - hash [ s [ i ] - ' a ' ] - 1 ) ; hash [ s [ i ] - ' a ' ] = i ; } } if ( ans == INT_MAX ) return -1 ; return ans ; } int main ( ) { string str = \" abcdeba \" ; cout << count_min_length ( str ) ; }", "docstring": "Minimum length of substring whose rotation generates a palindromic substring | C ++ Program to find the minimum length of substring whose rotation generates a palindromic substring ; Function to return the minimum length of substring ; Store the index of previous occurrence of the character ; Variable to store the maximum length of substring ; If the current character hasn 't appeared yet ; If the character has occured within one or two previous index , a palindromic substring already exists ; Update the maximum ; Replace the previous index of the character by the current index ; If character appeared at least twice ; Driver Code", "dfg": [["ans", 194, "comesFrom", ["ans"], [141]], ["ans", 186, "comesFrom", ["ans"], [141]], ["ans", 145, "comesFrom", ["ans"], [141]], ["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 53, "comesFrom", ["i"], [49]], ["i", 61, "comesFrom", ["i"], [49]], ["i", 41, "comesFrom", ["i"], [28]], ["i", 97, "comesFrom", ["i"], [49]], ["i", 180, "comesFrom", ["i"], [49]], ["i", 134, "comesFrom", ["i"], [49]], ["i", 71, "comesFrom", ["i"], [49]], ["i", 87, "comesFrom", ["i"], [49]], ["i", 117, "comesFrom", ["i"], [49]], ["i", 147, "comesFrom", ["i"], [49]], ["i", 170, "comesFrom", ["i"], [49]], ["i", 107, "comesFrom", ["i"], [49]], ["i", 124, "comesFrom", ["i"], [49]], ["i", 153, "comesFrom", ["i"], [49]], ["INT_MAX", 188, "comesFrom", ["INT_MAX"], [23]], ["s", 55, "comesFrom", ["s"], [11]], ["s", 69, "comesFrom", ["s"], [11]], ["s", 85, "comesFrom", ["s"], [11]], ["s", 168, "comesFrom", ["s"], [11]], ["s", 105, "comesFrom", ["s"], [11]], ["s", 122, "comesFrom", ["s"], [11]], ["s", 151, "comesFrom", ["s"], [11]], ["str", 213, "comesFrom", ["str"], [203]]]}
{"code": "#include <iostream> NEW_LINE #include <regex> NEW_LINE using namespace std ; void RemoveHTMLTags ( string s ) { const regex pattern ( \" \\\\ < . * ? \\\\ > \" ) ; s = regex_replace ( s , pattern , \" \" ) ; cout << s ; return ; } int main ( ) { string str = \" < div > < b > Geeks ▁ for ▁ Geeks < / b > < / div > \" ; RemoveHTMLTags ( str ) ; return 0 ; }", "docstring": "Program to remove HTML tags from a given String | C ++ program for the above approach ; Function to remove the HTML tags from the given string ; Use regex_replace function in regex to erase every tags enclosed in < > ; Print string after removing tags ; Driver Code ; Given String ; Function call to print the HTML string after removing tags", "dfg": [["s", 45, "comesFrom", ["s"], [30]], ["s", 34, "comesFrom", ["s"], [30]], ["str", 64, "comesFrom", ["str"], [56]], ["pattern", 36, "comesFrom", ["pattern"], [19]]]}
{"code": "#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; class TreeNode { TreeNode * parent = NULL ; vector < TreeNode * > children ; public : void addChild ( TreeNode * node ) { children . push_back ( node ) ; } void setParent ( TreeNode * node ) { parent = node ; } TreeNode * getParent ( ) { return parent ; } int computeScore ( ) { if ( children . size ( ) == 0 ) return 1 ; int res = 0 ; for ( TreeNode * curr : children ) res += curr -> computeScore ( ) ; if ( parent == NULL ) return res ; else return 2 * res ; } } ; TreeNode * computeTree ( string s ) { TreeNode * current = new TreeNode ( ) ; TreeNode * root = current ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) { TreeNode * child = new TreeNode ( ) ; child -> setParent ( current ) ; current -> addChild ( child ) ; current = child ; } else { current = current -> getParent ( ) ; } } return root ; } int main ( ) { string s = \" ( ( ) ( ( ) ) ) \" ; TreeNode * root = computeTree ( s ) ; cout << root -> computeScore ( ) ; return 0 ; }", "docstring": "Score of Parentheses using Tree | C ++ program to find the score of parentheses using Tree ; Customized tree class or struct , contains all required methods . ; Function to add a child into the list of children ; Function to change the parent pointer to the node passed ; Function to return the parent of the current node ; Function to compute the score recursively . ; Base case ; Adds scores of all children ; Function to create the tree structure ; Creating a node for every \" ( ) \" ; If we find \" ( \" we add a node as a child ; On finding \" ) \" which confirms that a pair is closed , we go back to the parent ; Driver code ; Generating the tree ; Computing the score", "dfg": [["parent", 64, "comesFrom", ["parent"], [52]], ["parent", 108, "comesFrom", ["parent"], [52]], ["i", 154, "comesFrom", ["i"], [150]], ["i", 162, "comesFrom", ["i"], [150]], ["i", 170, "comesFrom", ["i"], [150]], ["current", 193, "comesFrom", ["current"], [145]], ["current", 196, "comesFrom", ["current"], [145]], ["current", 212, "comesFrom", ["current"], [210]], ["res", 113, "comesFrom", ["res"], [98]], ["res", 119, "comesFrom", ["res"], [98]], ["s", 156, "comesFrom", ["s"], [129]], ["s", 242, "comesFrom", ["s"], [230]], ["s", 168, "comesFrom", ["s"], [129]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rec ( char * a , int i ) { if ( i == 0 ) { cout << a << endl ; return ; } if ( a [ i ] == ' x ' ) { int j = i ; while ( a [ j ] != ' \\0' && a [ j + 1 ] != ' \\0' ) { swap ( a [ j ] , a [ j + 1 ] ) ; j ++ ; } } rec ( a , i - 1 ) ; } int main ( ) { char a [ ] = { ' g ' , ' e ' , ' e ' , ' k ' , ' x ' , ' s ' , ' x ' , ' x ' , ' k ' , ' s ' , ' \\0' } ; int n = 10 ; rec ( a , n - 1 ) ; }", "docstring": "Move all occurrence of letter ' x ' from the string s to the end using Recursion | C ++ program for above approach ; Recursive program to bring ' x ' to the end ; When the string is completed from reverse direction end of recursion ; If the character x is found ; Transverse the whole string ; Swap the x so that it moves to the last ; call to the smaller problem now ; Driver Code ; Size of a ; Call to rec", "dfg": [["i", 20, "comesFrom", ["i"], [15]], ["i", 100, "comesFrom", ["i"], [51]], ["i", 38, "comesFrom", ["i"], [15]], ["n", 191, "comesFrom", ["n"], [183]], ["j", 91, "comesFrom", ["j"], [49]], ["j", 57, "comesFrom", ["j"], [49]], ["j", 66, "comesFrom", ["j"], [49]], ["j", 80, "comesFrom", ["j"], [49]], ["j", 85, "comesFrom", ["j"], [49]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string generateString ( int N , int M , int K ) { string s = \" \" ; int cnt1 = 0 ; int cnt2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cnt1 ++ ; cnt2 ++ ; if ( cnt1 <= M ) { if ( cnt2 <= K ) { s = s + char ( 96 + cnt1 ) ; } else { s = s + ' a ' ; } } else { cnt1 = 1 ; cnt2 = 1 ; s = s + ' a ' ; } } return s ; } int main ( ) { int N = 7 , M = 5 , K = 3 ; cout << generateString ( N , M , K ) << endl ; return 0 ; }", "docstring": "Generate a string of size N whose each substring of size M has exactly K distinct characters | C ++ program to generate a string of size N whose each substring of size M has exactly K distinct characters ; Function to generate the string ; Declare empty string ; counter for M ; counter for K ; Loop to generate string size of N ; Generating K distinct letters one by one ; After generating b distinct letters , append rest a - b letters as ' a ' ; Reset the counter value and repeat the process ; return final result string ; Driver code", "dfg": [["s", 121, "comesFrom", ["s"], [108]], ["s", 110, "comesFrom", ["s"], [108]], ["s", 74, "comesFrom", ["s"], [72]], ["s", 88, "comesFrom", ["s"], [86]], ["i", 44, "comesFrom", ["i"], [40]], ["i", 48, "comesFrom", ["i"], [40]], ["N", 46, "comesFrom", ["N"], [11]], ["N", 146, "comesFrom", ["N"], [130]], ["cnt1", 52, "comesFrom", ["cnt1"], [28]], ["cnt1", 60, "comesFrom", ["cnt1"], [28]], ["cnt1", 80, "comesFrom", ["cnt1"], [28]], ["cnt2", 55, "comesFrom", ["cnt2"], [33]], ["cnt2", 67, "comesFrom", ["cnt2"], [33]], ["M", 62, "comesFrom", ["M"], [14]], ["M", 148, "comesFrom", ["M"], [134]], ["K", 150, "comesFrom", ["K"], [138]], ["K", 69, "comesFrom", ["K"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void finalString ( string str ) { int x = 0 , y = 0 ; int left ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) x ++ ; else y ++ ; } if ( x > y ) left = 1 ; else left = 0 ; int length = n - 2 * min ( x , y ) ; for ( int i = 0 ; i < length ; i ++ ) { cout << left ; } } int main ( ) { string str = \"010110100100000\" ; finalString ( str ) ; return 0 ; }", "docstring": "Print string after removing all ( “ 10 ” or “ 01 ” ) from the binary string | C ++ program to print the final string after removing all the occurrences of \"10\" and \"01\" from the given binary string ; Function to print the final string after removing all the occurrences of \"10\" and \"01\" from the given binary string ; Variables to store the count of 1 ' s ▁ and ▁ 0' s ; Variable left will store whether 0 ' s ▁ or ▁ 1' s is left in the final string ; Length of the string ; For loop to count the occurrences of 1 ' s ▁ and ▁ 0' s in the string ; To check if the count of 1 ' s ▁ is ▁ ▁ greater ▁ than ▁ the ▁ count ▁ of ▁ 0' s or not . If x is greater , then those many 1 's  are printed. ; Length of the final remaining string after removing all the occurrences ; Printing the final string ; Driver Code", "dfg": [["i", 42, "comesFrom", ["i"], [38]], ["i", 46, "comesFrom", ["i"], [38]], ["i", 105, "comesFrom", ["i"], [101]], ["i", 109, "comesFrom", ["i"], [101]], ["i", 54, "comesFrom", ["i"], [38]], ["n", 44, "comesFrom", ["n"], [27]], ["n", 87, "comesFrom", ["n"], [27]], ["length", 107, "comesFrom", ["length"], [85]], ["x", 71, "comesFrom", ["x"], [15]], ["x", 61, "comesFrom", ["x"], [15]], ["x", 93, "comesFrom", ["x"], [15]], ["y", 73, "comesFrom", ["y"], [19]], ["y", 65, "comesFrom", ["y"], [19]], ["y", 95, "comesFrom", ["y"], [19]], ["str", 133, "comesFrom", ["str"], [125]], ["str", 29, "comesFrom", ["str"], [11]], ["str", 52, "comesFrom", ["str"], [11]], ["left", 115, "comesFrom", ["left"], [80]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPalindrome ( vector < string > left , string mid , vector < string > right ) { for ( string x : left ) cout << x ; cout << mid ; reverse ( right . begin ( ) , right . end ( ) ) ; for ( string x : right ) cout << x ; cout << endl ; } void findPalindrome ( vector < string > & S , int N , int M ) { set < string > dict ; for ( int i = 0 ; i < M ; i ++ ) { cin >> S [ i ] ; dict . insert ( S [ i ] ) ; } vector < string > left , right ; string mid ; for ( int i = 0 ; i < N ; i ++ ) { string t = S [ i ] ; reverse ( t . begin ( ) , t . end ( ) ) ; if ( t == S [ i ] ) mid = t ; else if ( dict . find ( t ) != dict . end ( ) ) { left . push_back ( S [ i ] ) ; right . push_back ( t ) ; dict . erase ( S [ i ] ) ; dict . erase ( t ) ; } } printPalindrome ( left , mid , right ) ; } int main ( ) { vector < string > S { \" tab \" , \" one \" , \" bat \" } ; int M = 3 ; int N = S . size ( ) ; findPalindrome ( S , N , M ) ; }", "docstring": "Longest palindrome formed by concatenating and reordering strings of equal length | C ++ program to find the Longest palindrome that can be formed by concatenating and reordering given N strings of equal length ; Function to print the longest palindrome ; Printing every string in left vector ; Printing the palindromic string in the middle ; Printing the reverse of the right vector to make the final output palindromic ; Function to find and print the longest palindrome that can be formed ; Inserting each string in the set ; Vectors to add the strings in the left and right side ; To add the already present palindrome string in the middle of the solution ; Iterating through all the given strings ; If the string is a palindrome it is added in the middle ; Checking if the reverse of the string is already present in the set ; Driver code", "dfg": [["left", 31, "comesFrom", ["left"], [14]], ["left", 245, "comesFrom", ["left"], [132]], ["left", 207, "comesFrom", ["left"], [132]], ["right", 61, "comesFrom", ["right"], [23]], ["right", 249, "comesFrom", ["right"], [134]], ["right", 43, "comesFrom", ["right"], [23]], ["right", 49, "comesFrom", ["right"], [23]], ["right", 217, "comesFrom", ["right"], [134]], ["mid", 39, "comesFrom", ["mid"], [17]], ["mid", 247, "comesFrom", ["mid"], [186]], ["i", 102, "comesFrom", ["i"], [98]], ["i", 106, "comesFrom", ["i"], [98]], ["i", 146, "comesFrom", ["i"], [142]], ["i", 150, "comesFrom", ["i"], [142]], ["i", 114, "comesFrom", ["i"], [98]], ["i", 159, "comesFrom", ["i"], [142]], ["i", 123, "comesFrom", ["i"], [98]], ["i", 183, "comesFrom", ["i"], [142]], ["i", 213, "comesFrom", ["i"], [142]], ["i", 230, "comesFrom", ["i"], [142]], ["M", 104, "comesFrom", ["M"], [86]], ["M", 297, "comesFrom", ["M"], [278]], ["N", 148, "comesFrom", ["N"], [83]], ["N", 295, "comesFrom", ["N"], [283]], ["S", 293, "comesFrom", ["S"], [262]], ["S", 285, "comesFrom", ["S"], [262]], ["dict", 117, "comesFrom", ["dict"], [93]], ["dict", 193, "comesFrom", ["dict"], [93]], ["dict", 200, "comesFrom", ["dict"], [93]], ["dict", 224, "comesFrom", ["dict"], [93]], ["dict", 234, "comesFrom", ["dict"], [93]], ["t", 179, "comesFrom", ["t"], [155]], ["t", 188, "comesFrom", ["t"], [155]], ["t", 164, "comesFrom", ["t"], [155]], ["t", 170, "comesFrom", ["t"], [155]], ["t", 197, "comesFrom", ["t"], [155]], ["t", 221, "comesFrom", ["t"], [155]], ["t", 238, "comesFrom", ["t"], [155]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( char & x , char & y ) { char temp = x ; x = y ; y = temp ; } bool IsLexicographicallySmaller ( string A , string B ) { if ( A < B ) { return true ; } string temp = A ; sort ( temp . begin ( ) , temp . end ( ) ) ; int index = -1 ; for ( int i = 0 ; i < A . length ( ) ; i ++ ) { if ( A [ i ] != temp [ i ] ) { index = i ; break ; } } if ( index == -1 ) { return false ; } int j ; for ( int i = 0 ; i < A . length ( ) ; i ++ ) { if ( A [ i ] == temp [ index ] ) j = i ; } swap ( A [ index ] , A [ j ] ) ; if ( A < B ) { return true ; } else { return false ; } } int main ( ) { string A = \" AGAIN \" ; string B = \" ACTION \" ; if ( IsLexicographicallySmaller ( A , B ) ) { cout << \" Yes \" << \" STRNEWLINE \" ; } else { cout << \" No \" << \" STRNEWLINE \" ; } return 0 ; }", "docstring": "Lexicographically smaller string by swapping at most one character pair | C ++ program check whether is it possible to make string A lexicographically smaller than string B ; Swap function ; Function that finds whether is it possible to make string A lexicographically smaller than string B ; Condition if string A is already smaller than B ; Sorting temp string ; Condition for first changed character of string A and temp ; Condition if string A is already sorted ; Finding first changed character from last of string A ; Swap the two characters ; Condition if string A is smaller than B ; Driver Code", "dfg": [["temp", 30, "comesFrom", ["temp"], [20]], ["temp", 61, "comesFrom", ["temp"], [55]], ["temp", 67, "comesFrom", ["temp"], [55]], ["temp", 105, "comesFrom", ["temp"], [55]], ["temp", 159, "comesFrom", ["temp"], [55]], ["i", 86, "comesFrom", ["i"], [82]], ["i", 94, "comesFrom", ["i"], [82]], ["i", 140, "comesFrom", ["i"], [136]], ["i", 148, "comesFrom", ["i"], [136]], ["i", 166, "comesFrom", ["i"], [136]], ["i", 113, "comesFrom", ["i"], [82]], ["i", 102, "comesFrom", ["i"], [82]], ["i", 107, "comesFrom", ["i"], [82]], ["i", 156, "comesFrom", ["i"], [136]], ["A", 45, "comesFrom", ["A"], [37]], ["A", 184, "comesFrom", ["A"], [57]], ["A", 88, "comesFrom", ["A"], [57]], ["A", 142, "comesFrom", ["A"], [57]], ["A", 171, "comesFrom", ["A"], [57]], ["A", 176, "comesFrom", ["A"], [57]], ["A", 223, "comesFrom", ["A"], [206]], ["A", 100, "comesFrom", ["A"], [57]], ["A", 154, "comesFrom", ["A"], [57]], ["B", 47, "comesFrom", ["B"], [40]], ["B", 186, "comesFrom", ["B"], [40]], ["B", 225, "comesFrom", ["B"], [213]], ["index", 121, "comesFrom", ["index"], [111]], ["index", 173, "comesFrom", ["index"], [111]], ["index", 161, "comesFrom", ["index"], [111]], ["j", 178, "comesFrom", ["j"], [164]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ) ? x : y ; } int longestPalindromic ( string str , int i , int j , int count ) { if ( i > j ) return count ; if ( i == j ) return ( count + 1 ) ; if ( str [ i ] == str [ j ] ) { count = longestPalindromic ( str , i + 1 , j - 1 , count + 2 ) ; return max ( count , max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ) ; } return max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ; } int longest_palindromic_substr ( string str ) { return longestPalindromic ( str , 0 , str . length ( ) - 1 , 0 ) ; } int main ( ) { string str = \" aaaabbaa \" ; cout << longest_palindromic_substr ( str ) ; return 0 ; }", "docstring": "Length of longest palindromic sub | C ++ implementation to find the length of longest palindromic sub - string using Recursion ; Function to find maximum of the two variables ; Function to find the longest palindromic substring : Recursion ; Base condition when the start index is greater than end index ; Base condition when both the start and end index are equal ; Condition when corner characters are equal in the string ; Recursive call to find the longest Palindromic string by excluding the corner characters ; Recursive call to find the longest Palindromic string by including one corner character at a time ; Function to find the longest palindromic sub - string ; Utility function call ; Driver Code ; Function Call", "dfg": [["x", 24, "comesFrom", ["x"], [11]], ["x", 19, "comesFrom", ["x"], [11]], ["y", 26, "comesFrom", ["y"], [14]], ["y", 21, "comesFrom", ["y"], [14]], ["count", 52, "comesFrom", ["count"], [42]], ["count", 62, "comesFrom", ["count"], [42]], ["count", 102, "comesFrom", ["count"], [80]], ["count", 94, "comesFrom", ["count"], [80]], ["i", 47, "comesFrom", ["i"], [36]], ["i", 56, "comesFrom", ["i"], [36]], ["i", 71, "comesFrom", ["i"], [36]], ["i", 155, "comesFrom", ["i"], [36]], ["i", 142, "comesFrom", ["i"], [36]], ["i", 86, "comesFrom", ["i"], [36]], ["i", 123, "comesFrom", ["i"], [36]], ["i", 110, "comesFrom", ["i"], [36]], ["j", 49, "comesFrom", ["j"], [39]], ["j", 58, "comesFrom", ["j"], [39]], ["j", 76, "comesFrom", ["j"], [39]], ["j", 146, "comesFrom", ["j"], [39]], ["j", 157, "comesFrom", ["j"], [39]], ["j", 90, "comesFrom", ["j"], [39]], ["j", 114, "comesFrom", ["j"], [39]], ["j", 125, "comesFrom", ["j"], [39]], ["str", 176, "comesFrom", ["str"], [170]], ["str", 69, "comesFrom", ["str"], [33]], ["str", 74, "comesFrom", ["str"], [33]], ["str", 208, "comesFrom", ["str"], [198]], ["str", 140, "comesFrom", ["str"], [33]], ["str", 153, "comesFrom", ["str"], [33]], ["str", 84, "comesFrom", ["str"], [33]], ["str", 180, "comesFrom", ["str"], [170]], ["str", 108, "comesFrom", ["str"], [33]], ["str", 121, "comesFrom", ["str"], [33]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void MaxPrefix ( string s ) { map < char , int > Dict ; for ( char i : s ) { Dict [ i ] ++ ; } int minfrequency = INT_MAX ; for ( auto x : Dict ) { minfrequency = min ( minfrequency , x . second ) ; } int countminFrequency = 0 ; for ( auto x : Dict ) { if ( x . second == minfrequency ) countminFrequency += 1 ; } map < char , int > mapper ; int indi = 0 ; for ( char i : s ) { mapper [ i ] += 1 ; if ( mapper [ i ] > countminFrequency ) break ; indi += 1 ; } cout << ( s . substr ( 0 , indi ) ) ; } int main ( ) { string str = \" aabcdaab \" ; MaxPrefix ( str ) ; }", "docstring": "Maximum length prefix such that frequency of each character is atmost number of characters with minimum frequency | C ++ implementation to find the prefix of the s such that occurrence of each character is atmost the count of minimum frequency in the s ; Function to find the maximum possible prefix of the s ; Hash map to store the frequency of the characters in the s ; Iterate over the s to find the occurence of each Character ; Minimum frequency of the Characters ; Loop to find the count of minimum frequency in the hash - map ; Loop to find the maximum possible length of the prefix in the s ; Condition to check if the frequency is greater than minimum possible freq ; maxprefix s and its length . ; Driver code ; s is initialize . ; str is passed in MaxPrefix function .", "dfg": [["s", 27, "comesFrom", ["s"], [11]], ["s", 106, "comesFrom", ["s"], [11]], ["s", 135, "comesFrom", ["s"], [11]], ["Dict", 47, "comesFrom", ["Dict"], [20]], ["Dict", 72, "comesFrom", ["Dict"], [20]], ["Dict", 30, "comesFrom", ["Dict"], [20]], ["str", 160, "comesFrom", ["str"], [152]], ["minfrequency", 81, "comesFrom", ["minfrequency"], [50]], ["minfrequency", 54, "comesFrom", ["minfrequency"], [50]], ["mapper", 109, "comesFrom", ["mapper"], [94]], ["mapper", 118, "comesFrom", ["mapper"], [94]], ["countminFrequency", 123, "comesFrom", ["countminFrequency"], [83]], ["indi", 141, "comesFrom", ["indi"], [127]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstring ( string & S , char L [ ] , int & n ) { int freq [ 26 ] = { 0 } , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ ( int ) ( L [ i ] - ' a ' ) ] = 1 ; } int count = 0 ; for ( auto x : S ) { if ( freq [ ( int ) ( x - ' a ' ) ] ) { ans += ( count * count + count ) / 2 ; count = 0 ; } else count ++ ; } ans += ( count * count + count ) / 2 ; return ans ; } int main ( ) { string S = \" abcpxyz \" ; char L [ ] = { ' a ' , ' p ' , ' q ' } ; int n = sizeof ( L ) / sizeof ( L [ 0 ] ) ; cout << countSubstring ( S , L , n ) ; return 0 ; }", "docstring": "Count of Substrings that can be formed without using the given list of Characters | C ++ implementation of the above approach ; Function to find the Number of sub - strings without using given character ; Mark the given characters in the freq array ; Count variable to store the count of the characters until a character from given L is encountered ; If a character from L is encountered , then the answer variable is incremented by the value obtained by using the mentioned formula and count is set to 0 ; For last remaining characters ; Driver code", "dfg": [["S", 202, "comesFrom", ["S"], [151]], ["ans", 142, "comesFrom", ["ans"], [129]], ["i", 45, "comesFrom", ["i"], [41]], ["i", 49, "comesFrom", ["i"], [41]], ["i", 61, "comesFrom", ["i"], [41]], ["n", 206, "comesFrom", ["n"], [183]], ["count", 136, "comesFrom", ["count"], [119]], ["count", 125, "comesFrom", ["count"], [119]], ["count", 132, "comesFrom", ["count"], [119]], ["count", 134, "comesFrom", ["count"], [119]], ["count", 114, "comesFrom", ["count"], [76]], ["count", 110, "comesFrom", ["count"], [76]], ["count", 112, "comesFrom", ["count"], [76]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int checkIfStartsWithVowels ( string str ) { if ( ! ( str [ 0 ] == ' A ' str [ 0 ] == ' a ' str [ 0 ] == ' E ' str [ 0 ] == ' e ' str [ 0 ] == ' I ' str [ 0 ] == ' i ' str [ 0 ] == ' O ' str [ 0 ] == ' o ' str [ 0 ] == ' U ' str [ 0 ] == ' u ' ) ) return 1 ; else return 0 ; } void check ( string str ) { if ( checkIfStartsWithVowels ( str ) ) cout << \" Not ▁ Accepted STRNEWLINE \" ; else cout << \" Accepted STRNEWLINE \" ; } int main ( ) { string str = \" animal \" ; check ( str ) ; str = \" zebra \" ; check ( str ) ; return 0 ; }", "docstring": "Program to accept Strings starting with a Vowel | C ++ program to accept String starting with Vowel ; Function to check if first character is vowel ; Function to check ; Driver function", "dfg": [["str", 170, "comesFrom", ["str"], [162]], ["str", 181, "comesFrom", ["str"], [173]], ["str", 139, "comesFrom", ["str"], [132]], ["str", 108, "comesFrom", ["str"], [11]], ["str", 98, "comesFrom", ["str"], [11]], ["str", 88, "comesFrom", ["str"], [11]], ["str", 78, "comesFrom", ["str"], [11]], ["str", 68, "comesFrom", ["str"], [11]], ["str", 58, "comesFrom", ["str"], [11]], ["str", 48, "comesFrom", ["str"], [11]], ["str", 18, "comesFrom", ["str"], [11]], ["str", 38, "comesFrom", ["str"], [11]], ["str", 28, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNthOccur ( string str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return -1 ; } int main ( ) { string str = \" geeks \" ; char ch = ' e ' ; int N = 2 ; cout << findNthOccur ( str , ch , N ) ; }", "docstring": "Find the Nth occurrence of a character in the given String | C ++ implementation to find the Nth occurrence of a character ; Function to find the Nth occurrence of a character ; Loop to find the Nth occurrence of the character ; Driver Code", "dfg": [["i", 32, "comesFrom", ["i"], [28]], ["i", 40, "comesFrom", ["i"], [28]], ["i", 66, "comesFrom", ["i"], [28]], ["i", 48, "comesFrom", ["i"], [28]], ["str", 34, "comesFrom", ["str"], [11]], ["str", 103, "comesFrom", ["str"], [79]], ["str", 46, "comesFrom", ["str"], [11]], ["ch", 105, "comesFrom", ["ch"], [86]], ["ch", 51, "comesFrom", ["ch"], [14]], ["N", 107, "comesFrom", ["N"], [95]], ["N", 63, "comesFrom", ["N"], [17]], ["occur", 61, "comesFrom", ["occur"], [54]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( string X , string Y , int N , int K ) { int count [ N + 1 ] = { 0 } ; int sol = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) ; } int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) { j ++ ; } sol = max ( sol , i - j ) ; } return sol ; } int main ( ) { int N = 4 ; string X = \" abcd \" , Y = \" bcde \" ; int K = 3 ; cout << solve ( X , Y , N , K ) << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Longest equal substring with cost less than K | C ++ program to find the maximum length of equal substring within a given cost ; Function to find the maximum length ; Fill the prefix array with the difference of letters ; Update the maximum length ; Driver code", "dfg": [["sol", 146, "comesFrom", ["sol"], [133]], ["sol", 137, "comesFrom", ["sol"], [133]], ["i", 54, "comesFrom", ["i"], [50]], ["i", 58, "comesFrom", ["i"], [50]], ["i", 104, "comesFrom", ["i"], [100]], ["i", 108, "comesFrom", ["i"], [100]], ["i", 64, "comesFrom", ["i"], [50]], ["i", 139, "comesFrom", ["i"], [100]], ["i", 69, "comesFrom", ["i"], [50]], ["i", 117, "comesFrom", ["i"], [100]], ["i", 78, "comesFrom", ["i"], [50]], ["i", 85, "comesFrom", ["i"], [50]], ["N", 56, "comesFrom", ["N"], [17]], ["N", 106, "comesFrom", ["N"], [17]], ["N", 26, "comesFrom", ["N"], [17]], ["N", 185, "comesFrom", ["N"], [155]], ["K", 126, "comesFrom", ["K"], [20]], ["K", 187, "comesFrom", ["K"], [173]], ["X", 181, "comesFrom", ["X"], [160]], ["X", 76, "comesFrom", ["X"], [11]], ["Y", 183, "comesFrom", ["Y"], [166]], ["Y", 83, "comesFrom", ["Y"], [14]], ["j", 129, "comesFrom", ["j"], [93]], ["j", 141, "comesFrom", ["j"], [93]], ["j", 122, "comesFrom", ["j"], [93]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double jaro_distance ( string s1 , string s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; if ( len1 == 0 len2 == 0 ) return 0.0 ; int max_dist = floor ( max ( len1 , len2 ) / 2 ) - 1 ; int match = 0 ; int hash_s1 [ s1 . length ( ) ] = { 0 } , hash_s2 [ s2 . length ( ) ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = max ( 0 , i - max_dist ) ; j < min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; } double jaro_Winkler ( string s1 , string s2 ) { double jaro_dist = jaro_distance ( s1 , s2 ) ; if ( jaro_dist > 0.7 ) { int prefix = 0 ; for ( int i = 0 ; i < min ( s1 . length ( ) , s2 . length ( ) ) ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) prefix ++ ; else break ; } prefix = min ( 4 , prefix ) ; jaro_dist += 0.1 * prefix * ( 1 - jaro_dist ) ; } return jaro_dist ; } int main ( ) { string s1 = \" TRATE \" , s2 = \" TRACE \" ; cout << \" Jaro - Winkler ▁ Similarity ▁ = \" << jaro_Winkler ( s1 , s2 ) << endl ; return 0 ; }", "docstring": "Jaro and Jaro | C ++ implementation of above approach ; Function to calculate the Jaro Similarity of two strings ; If the strings are equal ; Length of two strings ; Maximum distance upto which matching is allowed ; Count of matches ; Hash for matches ; Traverse through the first string ; Check if there is any matches ; If there is a match ; If there is no match ; Number of transpositions ; Count number of occurrences where two characters match but there is a third matched character in between the indices ; Find the next matched character in second string ; Return the Jaro Similarity ; Jaro Winkler Similarity ; If the jaro Similarity is above a threshold ; Find the length of common prefix ; If the characters match ; Else break ; Maximum of 4 characters are allowed in prefix ; Calculate jaro winkler Similarity ; Driver code ; Print Jaro - Winkler Similarity of two strings", "dfg": [["jaro_dist", 416, "comesFrom", ["jaro_dist"], [402]], ["jaro_dist", 336, "comesFrom", ["jaro_dist"], [325]], ["jaro_dist", 411, "comesFrom", ["jaro_dist"], [402]], ["i", 111, "comesFrom", ["i"], [107]], ["i", 115, "comesFrom", ["i"], [107]], ["i", 216, "comesFrom", ["i"], [212]], ["i", 220, "comesFrom", ["i"], [212]], ["i", 353, "comesFrom", ["i"], [349]], ["i", 370, "comesFrom", ["i"], [349]], ["i", 227, "comesFrom", ["i"], [212]], ["i", 128, "comesFrom", ["i"], [107]], ["i", 139, "comesFrom", ["i"], [107]], ["i", 247, "comesFrom", ["i"], [212]], ["i", 153, "comesFrom", ["i"], [107]], ["i", 171, "comesFrom", ["i"], [107]], ["i", 378, "comesFrom", ["i"], [349]], ["i", 383, "comesFrom", ["i"], [349]], ["len1", 113, "comesFrom", ["len1"], [27]], ["len1", 218, "comesFrom", ["len1"], [27]], ["len1", 45, "comesFrom", ["len1"], [27]], ["len1", 62, "comesFrom", ["len1"], [27]], ["len1", 277, "comesFrom", ["len1"], [27]], ["s1", 19, "comesFrom", ["s1"], [11]], ["s1", 29, "comesFrom", ["s1"], [11]], ["s1", 329, "comesFrom", ["s1"], [318]], ["s1", 80, "comesFrom", ["s1"], [11]], ["s1", 445, "comesFrom", ["s1"], [425]], ["s1", 245, "comesFrom", ["s1"], [11]], ["s1", 151, "comesFrom", ["s1"], [11]], ["s1", 357, "comesFrom", ["s1"], [318]], ["s1", 376, "comesFrom", ["s1"], [318]], ["s2", 21, "comesFrom", ["s2"], [14]], ["s2", 37, "comesFrom", ["s2"], [14]], ["s2", 331, "comesFrom", ["s2"], [321]], ["s2", 93, "comesFrom", ["s2"], [14]], ["s2", 447, "comesFrom", ["s2"], [431]], ["s2", 250, "comesFrom", ["s2"], [14]], ["s2", 156, "comesFrom", ["s2"], [14]], ["s2", 363, "comesFrom", ["s2"], [321]], ["s2", 381, "comesFrom", ["s2"], [321]], ["match", 192, "comesFrom", ["match"], [73]], ["match", 183, "comesFrom", ["match"], [73]], ["match", 307, "comesFrom", ["match"], [73]], ["match", 270, "comesFrom", ["match"], [73]], ["match", 284, "comesFrom", ["match"], [73]], ["match", 298, "comesFrom", ["match"], [73]], ["len2", 48, "comesFrom", ["len2"], [35]], ["len2", 137, "comesFrom", ["len2"], [35]], ["len2", 64, "comesFrom", ["len2"], [35]], ["len2", 291, "comesFrom", ["len2"], [35]], ["j", 133, "comesFrom", ["j"], [122]], ["j", 146, "comesFrom", ["j"], [122]], ["j", 158, "comesFrom", ["j"], [122]], ["j", 163, "comesFrom", ["j"], [122]], ["j", 178, "comesFrom", ["j"], [122]], ["point", 240, "comesFrom", ["point"], [205]], ["point", 235, "comesFrom", ["point"], [205]], ["point", 252, "comesFrom", ["point"], [205]], ["t", 256, "comesFrom", ["t"], [200]], ["t", 300, "comesFrom", ["t"], [260]], ["prefix", 399, "comesFrom", ["prefix"], [393]], ["prefix", 406, "comesFrom", ["prefix"], [393]], ["prefix", 386, "comesFrom", ["prefix"], [342]], ["max_dist", 130, "comesFrom", ["max_dist"], [56]], ["max_dist", 141, "comesFrom", ["max_dist"], [56]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isWordPresent ( string sentence , string word ) { stringstream s ( sentence ) ; string temp ; while ( s >> temp ) { if ( temp . compare ( word ) == 0 ) { return true ; } } return false ; } int main ( ) { string s = \" Geeks ▁ for ▁ Geeks \" ; string word = \" Geeks \" ; if ( isWordPresent ( s , word ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if a word is present in a sentence | C ++ implementation of the approach ; Function that returns true if the word is found ; To break the sentence in words ; To temporarily store each individual word ; Comparing the current word with the word to be searched ; Driver code", "dfg": [["s", 77, "comesFrom", ["s"], [60]], ["temp", 30, "comesFrom", ["temp"], [24]], ["temp", 35, "comesFrom", ["temp"], [24]], ["word", 79, "comesFrom", ["word"], [67]], ["word", 39, "comesFrom", ["word"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isWordPresent ( string sentence , string word ) { transform ( word . begin ( ) , word . end ( ) , word . begin ( ) , :: toupper ) ; transform ( sentence . begin ( ) , sentence . end ( ) , sentence . begin ( ) , :: toupper ) ; stringstream s ( sentence ) ; string temp ; while ( s >> temp ) { if ( temp . compare ( word ) == 0 ) { return true ; } } return false ; } int main ( ) { string s = \" Geeks ▁ for ▁ Geeks \" ; string word = \" geeks \" ; if ( isWordPresent ( s , word ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if a word is present in a sentence | C ++ implementation of the approach ; Function that returns true if the word is found ; To convert the word in uppercase ; To convert the complete sentence in uppercase ; To break the sentence in words ; To store the individual words of the sentence ; Compare the current word with the word to be searched ; Driver code", "dfg": [["s", 125, "comesFrom", ["s"], [108]], ["temp", 78, "comesFrom", ["temp"], [72]], ["temp", 83, "comesFrom", ["temp"], [72]], ["word", 127, "comesFrom", ["word"], [115]], ["word", 19, "comesFrom", ["word"], [14]], ["word", 25, "comesFrom", ["word"], [14]], ["word", 31, "comesFrom", ["word"], [14]], ["word", 87, "comesFrom", ["word"], [14]], ["sentence", 43, "comesFrom", ["sentence"], [11]], ["sentence", 49, "comesFrom", ["sentence"], [11]], ["sentence", 55, "comesFrom", ["sentence"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countChars ( string str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == '0' ) i ++ ; else i += 2 ; cnt ++ ; } return cnt ; } int main ( ) { string str = \"11010\" ; int n = str . length ( ) ; cout << countChars ( str , n ) ; return 0 ; }", "docstring": "Count of 1 | C ++ implementation of the approach ; Function to return the count of required characters ; While there are characters left ; Single bit character ; Two - bit character ; Update the count ; Driver code", "dfg": [["cnt", 57, "comesFrom", ["cnt"], [22]], ["cnt", 52, "comesFrom", ["cnt"], [22]], ["i", 28, "comesFrom", ["i"], [18]], ["i", 44, "comesFrom", ["i"], [18]], ["i", 37, "comesFrom", ["i"], [18]], ["n", 30, "comesFrom", ["n"], [14]], ["n", 87, "comesFrom", ["n"], [73]], ["str", 75, "comesFrom", ["str"], [66]], ["str", 85, "comesFrom", ["str"], [66]], ["str", 35, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; void compressString ( string s , int n ) { int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == 0 ) continue ; cout << ( char ) ( i + ' a ' ) << freq [ i ] ; } } int main ( ) { string s = \" geeksforgeeks \" ; int n = s . length ( ) ; compressString ( s , n ) ; return 0 ; }", "docstring": "Print the frequency of each character in Alphabetical order | C ++ implementation of the approach ; Function to print the frequency of each of the characters of s in alphabetical order ; To store the frequency of the characters ; Update the frequency array ; Print the frequency in alphatecial order ; If the current alphabet doesn 't  appear in the string ; Driver code", "dfg": [["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 71, "comesFrom", ["i"], [67]], ["i", 75, "comesFrom", ["i"], [67]], ["i", 107, "comesFrom", ["i"], [67]], ["i", 83, "comesFrom", ["i"], [67]], ["i", 96, "comesFrom", ["i"], [67]], ["i", 52, "comesFrom", ["i"], [36]], ["n", 42, "comesFrom", ["n"], [20]], ["n", 137, "comesFrom", ["n"], [125]], ["MAX", 73, "comesFrom", ["MAX"], [9]], ["MAX", 26, "comesFrom", ["MAX"], [9]], ["s", 135, "comesFrom", ["s"], [118]], ["s", 127, "comesFrom", ["s"], [118]], ["s", 50, "comesFrom", ["s"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } int concat ( int m , int n ) { int k = log2 ( m ) + 1 ; int l = log2 ( n ) + 1 ; int a [ k ] = { 0 } , b [ l ] = { 0 } ; int c [ k + l ] = { 0 } ; decBinary ( a , m ) ; decBinary ( b , n ) ; int in = 0 ; for ( int i = 0 ; i < k ; i ++ ) c [ in ++ ] = a [ i ] ; for ( int i = 0 ; i < l ; i ++ ) c [ in ++ ] = b [ i ] ; return ( binaryDec ( c , k + l ) ) ; } int main ( ) { int m = 4 , n = 5 ; cout << concat ( m , n ) ; return 0 ; }", "docstring": "Find the number obtained after concatenation of binary representation of M and N | C ++ implementation of the approach ; Function to convert decimal number n to its binary representation stored as an array arr [ ] ; Funtion to convert the number represented as a binary array arr [ ] into its decimal equivalent ; Function to concatenate the binary numbers and return the decimal result ; Number of bits in both the numbers ; Convert the bits in both the integers to the arrays a [ ] and b [ ] ; c [ ] will be the binary array for the result ; Update the c [ ] array ; Return the decimal equivalent of the result ; Driver code", "dfg": [["ans", 97, "comesFrom", ["ans"], [81]], ["i", 74, "comesFrom", ["i"], [70]], ["i", 78, "comesFrom", ["i"], [70]], ["i", 187, "comesFrom", ["i"], [183]], ["i", 191, "comesFrom", ["i"], [183]], ["i", 212, "comesFrom", ["i"], [208]], ["i", 216, "comesFrom", ["i"], [208]], ["i", 202, "comesFrom", ["i"], [183]], ["i", 227, "comesFrom", ["i"], [208]], ["i", 85, "comesFrom", ["i"], [70]], ["i", 91, "comesFrom", ["i"], [70]], ["n", 76, "comesFrom", ["n"], [59]], ["n", 29, "comesFrom", ["n"], [16]], ["n", 172, "comesFrom", ["n"], [107]], ["n", 24, "comesFrom", ["n"], [16]], ["n", 263, "comesFrom", ["n"], [253]], ["n", 40, "comesFrom", ["n"], [16]], ["n", 125, "comesFrom", ["n"], [107]], ["n", 89, "comesFrom", ["n"], [59]], ["k", 189, "comesFrom", ["k"], [111]], ["k", 133, "comesFrom", ["k"], [111]], ["k", 152, "comesFrom", ["k"], [111]], ["k", 236, "comesFrom", ["k"], [111]], ["k", 36, "comesFrom", ["k"], [20]], ["l", 214, "comesFrom", ["l"], [121]], ["l", 142, "comesFrom", ["l"], [121]], ["l", 154, "comesFrom", ["l"], [121]], ["l", 238, "comesFrom", ["l"], [121]], ["m", 165, "comesFrom", ["m"], [104]], ["m", 261, "comesFrom", ["m"], [249]], ["m", 115, "comesFrom", ["m"], [104]], ["in", 196, "comesFrom", ["in"], [176]], ["in", 221, "comesFrom", ["in"], [176]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getBinaryLength ( int n ) { int length = 0 ; while ( n > 0 ) { length += 1 ; n /= 2 ; } return length ; } int concat ( int m , int n ) { int length = getBinaryLength ( n ) ; return ( m << length ) + n ; } int main ( ) { int m = 4 , n = 5 ; cout << concat ( m , n ) ; return 0 ; }", "docstring": "Find the number obtained after concatenation of binary representation of M and N | C ++ implementation of the approach ; Utility function to calculate binary length of a number . ; Function to concatenate the binary numbers and return the decimal result ; find binary length of n ; left binary shift m and then add n ; Driver code", "dfg": [["length", 36, "comesFrom", ["length"], [26]], ["length", 61, "comesFrom", ["length"], [50]], ["n", 64, "comesFrom", ["n"], [46]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 54, "comesFrom", ["n"], [46]], ["n", 87, "comesFrom", ["n"], [77]], ["m", 59, "comesFrom", ["m"], [43]], ["m", 85, "comesFrom", ["m"], [73]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void addZeros ( string & str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { str = \"0\" + str ; } } string getXOR ( string a , string b ) { int aLen = a . length ( ) ; int bLen = b . length ( ) ; if ( aLen > bLen ) { addZeros ( b , aLen - bLen ) ; } else if ( bLen > aLen ) { addZeros ( a , bLen - aLen ) ; } int len = max ( aLen , bLen ) ; string res = \" \" ; for ( int i = 0 ; i < len ; i ++ ) { if ( a [ i ] == b [ i ] ) res += \"0\" ; else res += \"1\" ; } return res ; } int main ( ) { string a = \"11001\" , b = \"111111\" ; cout << getXOR ( a , b ) ; return 0 ; }", "docstring": "XOR two binary strings of unequal lengths | C ++ implementation of the approach ; Function to insert n 0 s in the beginning of the given string ; Function to return the XOR of the given strings ; Lengths of the given strings ; Make both the strings of equal lengths by inserting 0 s in the beginning ; Updated length ; To store the resultant XOR ; Driver code", "dfg": [["res", 165, "comesFrom", ["res"], [157]], ["i", 25, "comesFrom", ["i"], [21]], ["i", 29, "comesFrom", ["i"], [21]], ["i", 130, "comesFrom", ["i"], [126]], ["i", 134, "comesFrom", ["i"], [126]], ["i", 142, "comesFrom", ["i"], [126]], ["i", 147, "comesFrom", ["i"], [126]], ["n", 27, "comesFrom", ["n"], [15]], ["len", 132, "comesFrom", ["len"], [107]], ["str", 39, "comesFrom", ["str"], [33]], ["aLen", 73, "comesFrom", ["aLen"], [54]], ["aLen", 111, "comesFrom", ["aLen"], [54]], ["aLen", 93, "comesFrom", ["aLen"], [54]], ["aLen", 82, "comesFrom", ["aLen"], [54]], ["aLen", 102, "comesFrom", ["aLen"], [54]], ["bLen", 75, "comesFrom", ["bLen"], [63]], ["bLen", 113, "comesFrom", ["bLen"], [63]], ["bLen", 91, "comesFrom", ["bLen"], [63]], ["bLen", 84, "comesFrom", ["bLen"], [63]], ["bLen", 100, "comesFrom", ["bLen"], [63]], ["a", 56, "comesFrom", ["a"], [47]], ["a", 190, "comesFrom", ["a"], [174]], ["a", 140, "comesFrom", ["a"], [47]], ["a", 98, "comesFrom", ["a"], [47]], ["b", 65, "comesFrom", ["b"], [50]], ["b", 192, "comesFrom", ["b"], [180]], ["b", 80, "comesFrom", ["b"], [50]], ["b", 145, "comesFrom", ["b"], [50]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int * soln ; int level ; vector < Node * > child ; Node * parent ; Node ( Node * parent , int level , int N ) { this -> parent = parent ; this -> level = level ; this -> soln = new int [ N ] ; } } ; queue < Node * > Q ; void generate ( Node * n , int & N , queue < Node * > & Q ) { if ( n -> level == N ) { for ( int i = 0 ; i < N ; i ++ ) cout << n -> soln [ i ] ; cout << endl ; } else { int l = n -> level ; for ( int i = 0 ; i <= 1 ; i ++ ) { Node * x = new Node ( n , l + 1 , N ) ; for ( int k = 0 ; k < l ; k ++ ) x -> soln [ k ] = n -> soln [ k ] ; x -> soln [ l ] = i ; n -> child . push_back ( x ) ; Q . push ( x ) ; } } } int main ( ) { int N = 3 ; Node * root ; root = new Node ( NULL , 0 , N ) ; Q . push ( root ) ; while ( ! Q . empty ( ) ) { Node * E = Q . front ( ) ; Q . pop ( ) ; generate ( E , N , Q ) ; } return 0 ; }", "docstring": "Generate Binary Strings of length N using Branch and Bound | CPP Program to generate Binary Strings using Branch and Bound ; Creating a Node class ; Queue that maintains the list of live Nodes ; Utility function to generate binary strings of length n ; If list is full print combination ; Create a new vector for new combination ; iterate while length is not equal to n ; Driver Code ; Initiate Generation Create a root Node ; Instantiate the Queue", "dfg": [["level", 53, "comesFrom", ["level"], [37]], ["level", 99, "comesFrom", ["level"], [37]], ["level", 51, "comesFrom", ["level"], [37]], ["level", 139, "comesFrom", ["level"], [37]], ["root", 258, "comesFrom", ["root"], [242]], ["N", 84, "comesFrom", ["N"], [40]], ["N", 101, "comesFrom", ["N"], [40]], ["N", 113, "comesFrom", ["N"], [40]], ["N", 251, "comesFrom", ["N"], [234]], ["N", 291, "comesFrom", ["N"], [234]], ["N", 62, "comesFrom", ["N"], [40]], ["N", 169, "comesFrom", ["N"], [40]], ["Q", 92, "comesFrom", ["Q"], [73]], ["Q", 254, "comesFrom", ["Q"], [73]], ["Q", 264, "comesFrom", ["Q"], [73]], ["Q", 281, "comesFrom", ["Q"], [73]], ["Q", 293, "comesFrom", ["Q"], [73]], ["Q", 275, "comesFrom", ["Q"], [73]], ["Q", 218, "comesFrom", ["Q"], [73]], ["i", 111, "comesFrom", ["i"], [107]], ["i", 115, "comesFrom", ["i"], [107]], ["i", 148, "comesFrom", ["i"], [144]], ["i", 152, "comesFrom", ["i"], [144]], ["i", 124, "comesFrom", ["i"], [107]], ["i", 207, "comesFrom", ["i"], [144]], ["k", 179, "comesFrom", ["k"], [175]], ["k", 183, "comesFrom", ["k"], [175]], ["k", 190, "comesFrom", ["k"], [175]], ["k", 197, "comesFrom", ["k"], [175]], ["l", 181, "comesFrom", ["l"], [135]], ["l", 204, "comesFrom", ["l"], [135]], ["l", 165, "comesFrom", ["l"], [135]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; int minOperation ( string str , int len ) { int first [ MAX ] , last [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - ' a ' ) ; if ( first [ index ] == -1 ) first [ index ] = i ; last [ index ] = i ; } int minOp = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == -1 first [ i ] == last [ i ] ) continue ; int cnt = len - ( last [ i ] - first [ i ] + 1 ) ; if ( minOp == -1 cnt < minOp ) minOp = cnt ; } return minOp ; } int main ( ) { string str = \" abcda \" ; int len = str . length ( ) ; cout << minOperation ( str , len ) ; return 0 ; }", "docstring": "Minimum operations required to make the string satisfy the given condition | C ++ implementation of the approach ; Function to return the minimum operations required ; To store the first and the last occurrence of all the characters ; Set the first and the last occurrence of all the characters to - 1 ; Update the occurrences of the characters ; Only set the first occurrence if it hasn 't already been set ; To store the minimum operations ; If the frequency of the current character in the string is less than 2 ; Count of characters to be removed so that the string starts and ends at the current character ; Driver code", "dfg": [["minOp", 193, "comesFrom", ["minOp"], [187]], ["minOp", 180, "comesFrom", ["minOp"], [120]], ["minOp", 185, "comesFrom", ["minOp"], [120]], ["MAX", 26, "comesFrom", ["MAX"], [9]], ["MAX", 31, "comesFrom", ["MAX"], [9]], ["MAX", 43, "comesFrom", ["MAX"], [9]], ["MAX", 133, "comesFrom", ["MAX"], [9]], ["i", 41, "comesFrom", ["i"], [37]], ["i", 45, "comesFrom", ["i"], [37]], ["i", 71, "comesFrom", ["i"], [67]], ["i", 75, "comesFrom", ["i"], [67]], ["i", 131, "comesFrom", ["i"], [127]], ["i", 135, "comesFrom", ["i"], [127]], ["i", 116, "comesFrom", ["i"], [67]], ["i", 109, "comesFrom", ["i"], [67]], ["i", 51, "comesFrom", ["i"], [37]], ["i", 58, "comesFrom", ["i"], [37]], ["i", 154, "comesFrom", ["i"], [127]], ["i", 85, "comesFrom", ["i"], [67]], ["i", 143, "comesFrom", ["i"], [127]], ["i", 149, "comesFrom", ["i"], [127]], ["i", 167, "comesFrom", ["i"], [127]], ["i", 172, "comesFrom", ["i"], [127]], ["len", 73, "comesFrom", ["len"], [20]], ["len", 223, "comesFrom", ["len"], [209]], ["len", 162, "comesFrom", ["len"], [20]], ["str", 211, "comesFrom", ["str"], [202]], ["str", 221, "comesFrom", ["str"], [202]], ["str", 83, "comesFrom", ["str"], [17]], ["cnt", 189, "comesFrom", ["cnt"], [160]], ["cnt", 183, "comesFrom", ["cnt"], [160]], ["index", 113, "comesFrom", ["index"], [80]], ["index", 99, "comesFrom", ["index"], [80]], ["index", 106, "comesFrom", ["index"], [80]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  2 NEW_LINE bool isVowel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } int countVowels ( string str , int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( isVowel ( str [ i ] ) ) cnt ++ ; } return cnt ; } void performQueries ( string str , int queries [ ] [ N ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { cout << countVowels ( str , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) << \" STRNEWLINE \" ; } } int main ( ) { string str = \" geeksforgeeks \" ; int queries [ ] [ N ] = { { 1 , 3 } , { 2 , 4 } , { 1 , 9 } } ; int q = ( sizeof ( queries ) / sizeof ( queries [ 0 ] ) ) ; performQueries ( str , queries , q ) ; return 0 ; }", "docstring": "Queries to find the count of vowels in the substrings of the given string | C ++ implementation of the approach ; Function that returns true if ch is a vowel ; Function to return the count of vowels in the substring str [ l ... r ] ; To store the count of vowels ; For every character in the index range [ l , r ] ; If the current character is a vowel ; For every query ; Find the count of vowels for the current query ; Driver code", "dfg": []}
{"code": "#include <iostream> NEW_LINE using namespace std ; struct node { char data ; node * next ; } ; node * add ( char data ) { node * newnode = new node ; newnode -> data = data ; newnode -> next = NULL ; return newnode ; } node * string_to_SLL ( string text , node * head ) { head = add ( text [ 0 ] ) ; node * curr = head ; for ( int i = 1 ; i < text . size ( ) ; i ++ ) { curr -> next = add ( text [ i ] ) ; curr = curr -> next ; } return head ; } void print ( node * head ) { node * curr = head ; while ( curr != NULL ) { cout << curr -> data << \" ▁ - > ▁ \" ; curr = curr -> next ; } } int main ( ) { string text = \" GEEKS \" ; node * head = NULL ; head = string_to_SLL ( text , head ) ; print ( head ) ; return 0 ; }", "docstring": "Convert a String to a Singly Linked List | C ++ program to Convert a String to a Singly Linked List ; Structure for a Singly Linked List ; Function to add a new node to the Linked List ; Function to convert the string to Linked List . ; curr pointer points to the current node where the insertion should take place ; Function to print the data present in all the nodes ; Driver code", "dfg": [["data", 38, "comesFrom", ["data"], [24]], ["data", 36, "comesFrom", ["data"], [24]], ["data", 145, "comesFrom", ["data"], [24]], ["head", 117, "comesFrom", ["head"], [76]], ["head", 125, "comesFrom", ["head"], [76]], ["head", 173, "comesFrom", ["head"], [132]], ["head", 188, "comesFrom", ["head"], [177]], ["head", 183, "comesFrom", ["head"], [177]], ["i", 85, "comesFrom", ["i"], [81]], ["i", 93, "comesFrom", ["i"], [81]], ["i", 105, "comesFrom", ["i"], [81]], ["curr", 130, "comesFrom", ["curr"], [109]], ["curr", 136, "comesFrom", ["curr"], [109]], ["curr", 111, "comesFrom", ["curr"], [109]], ["curr", 153, "comesFrom", ["curr"], [151]], ["curr", 143, "comesFrom", ["curr"], [109]], ["text", 87, "comesFrom", ["text"], [55]], ["text", 181, "comesFrom", ["text"], [165]], ["text", 66, "comesFrom", ["text"], [55]], ["text", 103, "comesFrom", ["text"], [55]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLength ( string str , int len ) { stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( s . empty ( ) ) { s . push ( str [ i ] ) ; } else { char c = s . top ( ) ; if ( c != str [ i ] && toupper ( c ) == toupper ( str [ i ] ) ) { s . pop ( ) ; } else { s . push ( str [ i ] ) ; } } } return s . size ( ) ; } int main ( ) { string str = \" ASbBsd \" ; int len = str . length ( ) ; cout << minLength ( str , len ) ; return 0 ; }", "docstring": "Reduce the string to minimum length with the given operation | C ++ implementation of the approach ; Function to return the minimum possible length str can be reduced to with the given operation ; Stack to store the characters of the given string ; For every character of the string ; If the stack is empty then push the current character in the stack ; Get the top character ; If the top element is not equal to the current element and it only differs in the case ; Pop the top element from stack ; Else push the current element ; Driver code", "dfg": [["i", 30, "comesFrom", ["i"], [26]], ["i", 34, "comesFrom", ["i"], [26]], ["i", 53, "comesFrom", ["i"], [26]], ["i", 75, "comesFrom", ["i"], [26]], ["i", 87, "comesFrom", ["i"], [26]], ["i", 107, "comesFrom", ["i"], [26]], ["len", 32, "comesFrom", ["len"], [14]], ["len", 149, "comesFrom", ["len"], [135]], ["s", 115, "comesFrom", ["s"], [21]], ["s", 40, "comesFrom", ["s"], [21]], ["s", 47, "comesFrom", ["s"], [21]], ["s", 63, "comesFrom", ["s"], [21]], ["s", 92, "comesFrom", ["s"], [21]], ["s", 101, "comesFrom", ["s"], [21]], ["str", 137, "comesFrom", ["str"], [128]], ["str", 147, "comesFrom", ["str"], [128]], ["str", 51, "comesFrom", ["str"], [11]], ["str", 73, "comesFrom", ["str"], [11]], ["str", 85, "comesFrom", ["str"], [11]], ["str", 105, "comesFrom", ["str"], [11]], ["c", 71, "comesFrom", ["c"], [61]], ["c", 80, "comesFrom", ["c"], [61]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE bool canBeMadeEqual ( string str1 , string str2 ) { int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; if ( len1 == len2 ) { int freq [ MAX ] ; for ( int i = 0 ; i < len1 ; i ++ ) { freq [ str1 [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < len2 ; i ++ ) { if ( freq [ str2 [ i ] - ' a ' ] > 0 ) return true ; } } return false ; } int main ( ) { string str1 = \" abc \" , str2 = \" defa \" ; if ( canBeMadeEqual ( str1 , str2 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check whether two strings can be made equal by copying their characters with the adjacent ones | C ++ implementation of the approach ; Function that returns true if both the strings can be made equal with the given operation ; Lengths of both the strings have to be equal ; To store the frequency of the characters of str1 ; For every character of str2 ; If current character of str2 also appears in str1 ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( string str , int n ) { int cnt = 0 ; int i = 0 ; while ( i < n - 2 ) { if ( str [ i ] == str [ i + 1 ] && str [ i ] == str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else i ++ ; } return cnt ; } int main ( ) { string str = \" aabbbcc \" ; int n = str . length ( ) ; cout << getCount ( str , n ) ; return 0 ; }", "docstring": "Minimum characters that are to be inserted such that no three consecutive characters are same | C ++ implementation of the approach ; Function to return the count of characters that are to be inserted in str such that no three consecutive characters are same ; To store the count of operations required ; A character needs to be inserted after str [ i + 1 ] ; Current three consecutive characters are not same ; Driver code", "dfg": [["cnt", 79, "comesFrom", ["cnt"], [18]], ["cnt", 63, "comesFrom", ["cnt"], [18]], ["i", 29, "comesFrom", ["i"], [23]], ["i", 74, "comesFrom", ["i"], [66]], ["i", 68, "comesFrom", ["i"], [66]], ["i", 40, "comesFrom", ["i"], [23]], ["i", 52, "comesFrom", ["i"], [23]], ["i", 45, "comesFrom", ["i"], [23]], ["i", 57, "comesFrom", ["i"], [23]], ["n", 31, "comesFrom", ["n"], [14]], ["n", 109, "comesFrom", ["n"], [95]], ["str", 97, "comesFrom", ["str"], [88]], ["str", 107, "comesFrom", ["str"], [88]], ["str", 38, "comesFrom", ["str"], [11]], ["str", 43, "comesFrom", ["str"], [11]], ["str", 50, "comesFrom", ["str"], [11]], ["str", 55, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact *= i ; return fact ; } int countStrings ( string str , int n ) { set < char > distinct_char ; for ( int i = 0 ; i < n ; i ++ ) { distinct_char . insert ( str [ i ] ) ; } return fact ( distinct_char . size ( ) ) ; } int main ( ) { string str = \" geeksforgeeks \" ; int n = str . length ( ) ; cout << countStrings ( str , n ) ; return 0 ; }", "docstring": "Find the number of strings formed using distinct characters of a given string | C ++ implementation of the approach ; Function to return the factorial of n ; Function to return the count of all possible strings that can be formed with the characters of the given string without repeating characters ; To store the distinct characters of the string str ; Driver code", "dfg": [["fact", 38, "comesFrom", ["fact"], [33]], ["fact", 84, "comesFrom", ["fact"], [33]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 64, "comesFrom", ["i"], [60]], ["i", 68, "comesFrom", ["i"], [60]], ["i", 35, "comesFrom", ["i"], [22]], ["i", 78, "comesFrom", ["i"], [60]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 66, "comesFrom", ["n"], [48]], ["n", 121, "comesFrom", ["n"], [107]], ["str", 109, "comesFrom", ["str"], [100]], ["str", 119, "comesFrom", ["str"], [100]], ["str", 76, "comesFrom", ["str"], [45]], ["distinct_char", 72, "comesFrom", ["distinct_char"], [55]], ["distinct_char", 86, "comesFrom", ["distinct_char"], [55]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; char getChar ( string str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str [ i ] - ' a ' + 1 ) ; } if ( sum % 26 == 0 ) return ' z ' ; else { sum = sum % 26 ; return ( char ) ( ' a ' + sum - 1 ) ; } } int main ( ) { string str = \" gfg \" ; cout << getChar ( str ) ; return 0 ; }", "docstring": "Find the character made by adding all the characters of the given string | C ++ implementation of the approach ; Function to return the required character ; To store the sum of the characters of the given string ; Add the current character to the sum ; Return the required character ; Driver code", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 34, "comesFrom", ["i"], [22]], ["i", 43, "comesFrom", ["i"], [22]], ["str", 28, "comesFrom", ["str"], [11]], ["str", 113, "comesFrom", ["str"], [103]], ["str", 41, "comesFrom", ["str"], [11]], ["sum", 58, "comesFrom", ["sum"], [38]], ["sum", 75, "comesFrom", ["sum"], [73]], ["sum", 90, "comesFrom", ["sum"], [73]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string reverse ( string str , int len , int l , int r ) { if ( l < 0 r > = len l > r ) return str ; while ( l < r ) { char c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return str ; } int main ( ) { string str = \" geeksforgeeks \" ; int len = str . length ( ) ; int l = 5 , r = 7 ; cout << reverse ( str , len , l , r ) ; return 0 ; }", "docstring": "Reverse the given string in the range [ L , R ] | C ++ implementation of the approach ; Function to return the string after reversing characters in the range [ L , R ] ; Invalid range ; While there are characters to swap ; Swap ( str [ l ] , str [ r ] ) ; Driver code", "dfg": [["str", 80, "comesFrom", ["str"], [37]], ["str", 98, "comesFrom", ["str"], [89]], ["str", 117, "comesFrom", ["str"], [89]], ["str", 50, "comesFrom", ["str"], [37]], ["str", 55, "comesFrom", ["str"], [37]], ["str", 60, "comesFrom", ["str"], [37]], ["str", 65, "comesFrom", ["str"], [37]], ["c", 70, "comesFrom", ["c"], [48]], ["l", 72, "comesFrom", ["l"], [17]], ["l", 121, "comesFrom", ["l"], [105]], ["l", 32, "comesFrom", ["l"], [17]], ["l", 41, "comesFrom", ["l"], [17]], ["l", 52, "comesFrom", ["l"], [17]], ["l", 57, "comesFrom", ["l"], [17]], ["r", 75, "comesFrom", ["r"], [20]], ["r", 123, "comesFrom", ["r"], [109]], ["r", 34, "comesFrom", ["r"], [20]], ["r", 43, "comesFrom", ["r"], [20]], ["r", 62, "comesFrom", ["r"], [20]], ["r", 67, "comesFrom", ["r"], [20]], ["len", 119, "comesFrom", ["len"], [96]], ["len", 31, "comesFrom", ["len"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void encrypt ( char input [ 100 ] ) { char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i <= strlen ( input ) ; i ++ ) { ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) cout << oddPos ; else cout << evenPos ; } } } int main ( ) { char input [ 100 ] = { ' A ' , ' b ' , ' C ' , ' d ' } ; encrypt ( input ) ; return 0 ; }", "docstring": "Program to Encrypt a String using ! and @ | C ++ program to Encrypt the String using ! and @ ; Function to encrypt the string ; evenPos is for storing encrypting char at evenPosition oddPos is for storing encrypting char at oddPosition ; Get the number of times the character is to be repeated ; if i is odd , print ' ! ' else print ' @ ' ; Driver code ; Encrypt the String", "dfg": [["i", 46, "comesFrom", ["i"], [42]], ["i", 53, "comesFrom", ["i"], [42]], ["i", 61, "comesFrom", ["i"], [42]], ["i", 95, "comesFrom", ["i"], [42]], ["j", 85, "comesFrom", ["j"], [81]], ["j", 89, "comesFrom", ["j"], [81]], ["repeat", 87, "comesFrom", ["repeat"], [64]], ["ascii", 66, "comesFrom", ["ascii"], [57]], ["ascii", 70, "comesFrom", ["ascii"], [57]], ["ascii", 74, "comesFrom", ["ascii"], [57]], ["oddPos", 103, "comesFrom", ["oddPos"], [26]], ["evenPos", 108, "comesFrom", ["evenPos"], [18]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; bool IsRedundantBraces ( string A ) { int a = 0 , b = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( A [ i ] == ' ( ' && A [ i + 2 ] == ' ) ' ) return 1 ; if ( A [ i ] == ' * ' A [ i ] == ' + ' A [ i ] == ' - ' A [ i ] == ' / ' ) a ++ ; if ( A [ i ] == ' ( ' ) b ++ ; } if ( b > a ) return 1 ; return 0 ; } int main ( ) { string A = \" ( ( ( a + b ) ▁ + ▁ c ) ▁ + ▁ d ) \" ; if ( IsRedundantBraces ( A ) ) { cout << \" YES STRNEWLINE \" ; } else { cout << \" NO \" ; } }", "docstring": "Check if expression contains redundant bracket or not | Set 2 | C ++ program to check for / redundant braces in the string ; Function to check for redundant braces ; count of no of signs ; Driver function", "dfg": [["i", 30, "comesFrom", ["i"], [26]], ["i", 38, "comesFrom", ["i"], [26]], ["i", 121, "comesFrom", ["i"], [26]], ["i", 46, "comesFrom", ["i"], [26]], ["i", 105, "comesFrom", ["i"], [26]], ["i", 57, "comesFrom", ["i"], [26]], ["i", 95, "comesFrom", ["i"], [26]], ["i", 75, "comesFrom", ["i"], [26]], ["i", 85, "comesFrom", ["i"], [26]], ["b", 136, "comesFrom", ["b"], [19]], ["b", 130, "comesFrom", ["b"], [19]], ["a", 138, "comesFrom", ["a"], [15]], ["a", 114, "comesFrom", ["a"], [15]], ["A", 32, "comesFrom", ["A"], [11]], ["A", 163, "comesFrom", ["A"], [153]], ["A", 119, "comesFrom", ["A"], [11]], ["A", 44, "comesFrom", ["A"], [11]], ["A", 55, "comesFrom", ["A"], [11]], ["A", 103, "comesFrom", ["A"], [11]], ["A", 73, "comesFrom", ["A"], [11]], ["A", 93, "comesFrom", ["A"], [11]], ["A", 83, "comesFrom", ["A"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string balancedBrackets ( string str ) { int dep = 0 ; int minDep = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ( ' ) dep ++ ; else dep -- ; if ( minDep > dep ) minDep = dep ; } if ( minDep < 0 ) { for ( int i = 0 ; i < abs ( minDep ) ; i ++ ) str = ' ( ' + str ; } dep = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ( ' ) dep ++ ; else dep -- ; } if ( dep != 0 ) { for ( int i = 0 ; i < dep ; i ++ ) str = str + ' ) ' ; } return str ; } int main ( ) { string str = \" ) ) ) ( ) \" ; cout << balancedBrackets ( str ) ; }", "docstring": "Convert an unbalanced bracket sequence to a balanced sequence | C ++ implementation of the approach ; Function to return balancedBrackets string ; Initializing dep to 0 ; Stores maximum negative depth ; if dep is less than minDep ; if minDep is less than 0 then there is need to add ' ( ' at the front ; Reinitializing to check the updated string ; if dep is not 0 then there is need to add ' ) ' at the back ; Driver code", "dfg": [["str", 186, "comesFrom", ["str"], [174]], ["str", 33, "comesFrom", ["str"], [11]], ["str", 122, "comesFrom", ["str"], [98]], ["str", 205, "comesFrom", ["str"], [195]], ["str", 45, "comesFrom", ["str"], [11]], ["str", 106, "comesFrom", ["str"], [98]], ["str", 134, "comesFrom", ["str"], [98]], ["str", 176, "comesFrom", ["str"], [174]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 39, "comesFrom", ["i"], [27]], ["i", 120, "comesFrom", ["i"], [116]], ["i", 128, "comesFrom", ["i"], [116]], ["i", 88, "comesFrom", ["i"], [84]], ["i", 95, "comesFrom", ["i"], [84]], ["i", 167, "comesFrom", ["i"], [163]], ["i", 171, "comesFrom", ["i"], [163]], ["i", 47, "comesFrom", ["i"], [27]], ["i", 136, "comesFrom", ["i"], [116]], ["minDep", 76, "comesFrom", ["minDep"], [69]], ["minDep", 65, "comesFrom", ["minDep"], [20]], ["minDep", 92, "comesFrom", ["minDep"], [69]], ["dep", 155, "comesFrom", ["dep"], [109]], ["dep", 169, "comesFrom", ["dep"], [109]], ["dep", 56, "comesFrom", ["dep"], [15]], ["dep", 67, "comesFrom", ["dep"], [15]], ["dep", 71, "comesFrom", ["dep"], [15]], ["dep", 145, "comesFrom", ["dep"], [109]], ["dep", 60, "comesFrom", ["dep"], [15]], ["dep", 149, "comesFrom", ["dep"], [109]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; } int main ( ) { string str = \"000111\" ; int n = str . length ( ) ; cout << minOperations ( str , n ) ; return 0 ; }", "docstring": "Minimum operations required to convert a binary string to all 0 s or all 1 s | C ++ implementation of the approach ; Function to return the count of minimum operations required ; Increment count when consecutive characters are different ; Answer is rounding off the ( count / 2 ) to lower ; Driver code", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 35, "comesFrom", ["i"], [25]], ["i", 43, "comesFrom", ["i"], [25]], ["i", 48, "comesFrom", ["i"], [25]], ["n", 31, "comesFrom", ["n"], [14]], ["n", 94, "comesFrom", ["n"], [80]], ["count", 59, "comesFrom", ["count"], [18]], ["count", 53, "comesFrom", ["count"], [18]], ["str", 82, "comesFrom", ["str"], [73]], ["str", 92, "comesFrom", ["str"], [73]], ["str", 41, "comesFrom", ["str"], [11]], ["str", 46, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_digit ( string s , int n ) { int first_digit = -1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] < '0' s [ i ] > '9' ) { first_digit = i ; break ; } } first_digit ++ ; int s_len = first_digit ; int num = 0 , pw = 1 ; int i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] >= '0' && s [ i ] <= '9' ) { int digit = s [ i ] - '0' ; num = num + ( pw * digit ) ; if ( num >= s_len ) return -1 ; pw = pw * 10 ; } i -- ; } num = num * 10 ; int req = s_len - num ; if ( req > 9 req < 0 ) return -1 ; return req ; } int main ( ) { string s = \" abcd0\" ; int n = s . length ( ) ; cout << find_digit ( s , n ) ; return 0 ; }", "docstring": "Append a digit in the end to make the number equal to the length of the remaining string | C ++ implementation of the approach ; Function to return the required digit ; To store the position of the first numeric digit in the string ; To store the length of the string without the numeric digits in the end ; pw stores the current power of 10 and num is to store the number which is appended in the end ; If current character is a numeric digit ; Get the current digit ; Build the number ; If number exceeds the length ; Next power of 10 ; Append 0 in the end ; Required number that must be added ; If number is not a single digit ; Driver code", "dfg": [["req", 187, "comesFrom", ["req"], [168]], ["req", 176, "comesFrom", ["req"], [168]], ["req", 179, "comesFrom", ["req"], [168]], ["i", 31, "comesFrom", ["i"], [25]], ["i", 35, "comesFrom", ["i"], [25]], ["i", 93, "comesFrom", ["i"], [85]], ["i", 157, "comesFrom", ["i"], [85]], ["i", 61, "comesFrom", ["i"], [25]], ["i", 43, "comesFrom", ["i"], [25]], ["i", 51, "comesFrom", ["i"], [25]], ["i", 102, "comesFrom", ["i"], [85]], ["i", 111, "comesFrom", ["i"], [85]], ["i", 124, "comesFrom", ["i"], [85]], ["first_digit", 67, "comesFrom", ["first_digit"], [59]], ["n", 87, "comesFrom", ["n"], [14]], ["n", 27, "comesFrom", ["n"], [14]], ["n", 217, "comesFrom", ["n"], [203]], ["num", 163, "comesFrom", ["num"], [161]], ["num", 172, "comesFrom", ["num"], [161]], ["num", 133, "comesFrom", ["num"], [131]], ["num", 143, "comesFrom", ["num"], [131]], ["s_len", 170, "comesFrom", ["s_len"], [71]], ["s_len", 145, "comesFrom", ["s_len"], [71]], ["s", 205, "comesFrom", ["s"], [196]], ["s", 215, "comesFrom", ["s"], [196]], ["s", 41, "comesFrom", ["s"], [11]], ["s", 100, "comesFrom", ["s"], [11]], ["s", 109, "comesFrom", ["s"], [11]], ["s", 49, "comesFrom", ["s"], [11]], ["s", 122, "comesFrom", ["s"], [11]], ["pw", 152, "comesFrom", ["pw"], [150]], ["pw", 136, "comesFrom", ["pw"], [80]], ["digit", 138, "comesFrom", ["digit"], [120]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canConvert ( string str1 , string str2 ) { int i = 0 , j = 0 ; while ( i < str1 . size ( ) && j < str2 . size ( ) ) { if ( str1 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == '0' && str2 [ j ] == '1' && i + 1 < str1 . size ( ) && str1 [ i + 1 ] == '0' ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i == str1 . size ( ) && j == str2 . size ( ) ) return true ; return false ; } int main ( ) { string str1 = \"00100\" , str2 = \"111\" ; if ( canConvert ( str1 , str2 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check whether str1 can be converted to str2 with the given operations | C ++ implementation of the approach ; Function that returns true if str1 can be converted to str2 with the given operations ; Traverse from left to right ; If the two characters do not match ; If possible to combine ; If not possible to combine ; If the two characters match ; If possible to convert one string to another ; Driver code", "dfg": [["i", 28, "comesFrom", ["i"], [18]], ["i", 127, "comesFrom", ["i"], [100]], ["i", 49, "comesFrom", ["i"], [18]], ["i", 117, "comesFrom", ["i"], [100]], ["i", 78, "comesFrom", ["i"], [18]], ["i", 90, "comesFrom", ["i"], [18]], ["i", 62, "comesFrom", ["i"], [18]], ["j", 36, "comesFrom", ["j"], [22]], ["j", 135, "comesFrom", ["j"], [22]], ["j", 54, "comesFrom", ["j"], [22]], ["j", 120, "comesFrom", ["j"], [22]], ["j", 104, "comesFrom", ["j"], [22]], ["j", 71, "comesFrom", ["j"], [22]], ["str1", 172, "comesFrom", ["str1"], [156]], ["str1", 30, "comesFrom", ["str1"], [11]], ["str1", 47, "comesFrom", ["str1"], [11]], ["str1", 129, "comesFrom", ["str1"], [11]], ["str1", 88, "comesFrom", ["str1"], [11]], ["str1", 60, "comesFrom", ["str1"], [11]], ["str1", 82, "comesFrom", ["str1"], [11]], ["str2", 174, "comesFrom", ["str2"], [162]], ["str2", 38, "comesFrom", ["str2"], [14]], ["str2", 52, "comesFrom", ["str2"], [14]], ["str2", 137, "comesFrom", ["str2"], [14]], ["str2", 69, "comesFrom", ["str2"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverse ( string s ) { stack < string > stc ; string temp = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ▁ ' ) { stc . push ( temp ) ; temp = \" \" ; } else { temp = temp + s [ i ] ; } } stc . push ( temp ) ; while ( ! stc . empty ( ) ) { temp = stc . top ( ) ; cout << temp << \" ▁ \" ; stc . pop ( ) ; } cout << endl ; } int main ( ) { string s = \" I ▁ Love ▁ To ▁ Code \" ; reverse ( s ) ; return 0 ; }", "docstring": "Reverse the Words of a String using Stack | C ++ implementation of the above approach ; function to reverse the words of the given string without using strtok ( ) . ; create an empty string stack ; create an empty temporary string ; traversing the entire string ; push the temporary variable into the stack ; assigning temporary variable as empty ; for the last word of the string ; Get the words in reverse order ; Driver code", "dfg": [["i", 34, "comesFrom", ["i"], [30]], ["i", 42, "comesFrom", ["i"], [30]], ["i", 50, "comesFrom", ["i"], [30]], ["i", 82, "comesFrom", ["i"], [30]], ["stc", 87, "comesFrom", ["stc"], [18]], ["stc", 97, "comesFrom", ["stc"], [18]], ["stc", 120, "comesFrom", ["stc"], [18]], ["stc", 106, "comesFrom", ["stc"], [18]], ["stc", 60, "comesFrom", ["stc"], [18]], ["temp", 91, "comesFrom", ["temp"], [76]], ["temp", 114, "comesFrom", ["temp"], [104]], ["temp", 64, "comesFrom", ["temp"], [21]], ["temp", 78, "comesFrom", ["temp"], [76]], ["s", 146, "comesFrom", ["s"], [138]], ["s", 36, "comesFrom", ["s"], [11]], ["s", 48, "comesFrom", ["s"], [11]], ["s", 80, "comesFrom", ["s"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMatrix ( int n , int m ) { if ( n < 5 m < 5 ) { cout << -1 ; return ; } string s = \" aeiou \" ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { cout << s [ j % 5 ] << \" ▁ \" ; } cout << endl ; char c = s [ 0 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { s [ i ] = s [ i + 1 ] ; } s [ 4 ] = c ; } } int main ( ) { int n = 5 , m = 5 ; printMatrix ( n , m ) ; return 0 ; }", "docstring": "Print an N x M matrix such that each row and column has all the vowels in it | C ++ implementation of the approach ; Function to print the required matrix ; Impossible to generate the required matrix ; Store all the vowels ; Print the matrix ; Print vowels for every index ; Shift the vowels by one ; Driver code", "dfg": [["i", 49, "comesFrom", ["i"], [45]], ["i", 53, "comesFrom", ["i"], [45]], ["i", 105, "comesFrom", ["i"], [101]], ["i", 109, "comesFrom", ["i"], [101]], ["i", 115, "comesFrom", ["i"], [101]], ["i", 120, "comesFrom", ["i"], [101]], ["n", 51, "comesFrom", ["n"], [11]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 151, "comesFrom", ["n"], [141]], ["m", 153, "comesFrom", ["m"], [145]], ["m", 66, "comesFrom", ["m"], [14]], ["m", 22, "comesFrom", ["m"], [14]], ["j", 64, "comesFrom", ["j"], [60]], ["j", 68, "comesFrom", ["j"], [60]], ["j", 76, "comesFrom", ["j"], [60]], ["c", 131, "comesFrom", ["c"], [91]], ["s", 93, "comesFrom", ["s"], [36]], ["s", 126, "comesFrom", ["s"], [36]], ["s", 113, "comesFrom", ["s"], [36]], ["s", 118, "comesFrom", ["s"], [36]], ["s", 74, "comesFrom", ["s"], [36]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isTwoAlter ( string s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; } int main ( ) { string str = \" ABAB \" ; if ( isTwoAlter ( str ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if a given string is made up of two alternating characters | C ++ implementation of the approach ; Function that returns true if the string is made up of two alternating characters ; Check if ith character matches with the character at index ( i + 2 ) ; If string consists of a single character repeating itself ; Driver code", "dfg": [["i", 21, "comesFrom", ["i"], [17]], ["i", 31, "comesFrom", ["i"], [17]], ["i", 39, "comesFrom", ["i"], [17]], ["i", 44, "comesFrom", ["i"], [17]], ["s", 57, "comesFrom", ["s"], [11]], ["s", 62, "comesFrom", ["s"], [11]], ["s", 23, "comesFrom", ["s"], [11]], ["s", 37, "comesFrom", ["s"], [11]], ["s", 42, "comesFrom", ["s"], [11]], ["str", 90, "comesFrom", ["str"], [80]]]}
{"code": "#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; const int minOperations ( int n , string a , string b , string c ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a [ i ] ; char y = b [ i ] ; char z = c [ i ] ; if ( x == y && y == z ) ; else if ( x == y y == z x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; } int main ( ) { string a = \" place \" ; string b = \" abcde \" ; string c = \" plybe \" ; int n = a . size ( ) ; cout << minOperations ( n , a , b , c ) ; return 0 ; }", "docstring": "Number of character corrections in the given strings to make them equal | C ++ implementation of the approach ; Function to return the count of operations required ; To store the count of operations ; No operation required ; One operation is required when any two characters are equal ; Two operations are required when none of the characters are equal ; Return the minimum count of operations required ; Driver code", "dfg": [["ans", 109, "comesFrom", ["ans"], [102]], ["ans", 96, "comesFrom", ["ans"], [28]], ["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 52, "comesFrom", ["i"], [35]], ["i", 60, "comesFrom", ["i"], [35]], ["i", 68, "comesFrom", ["i"], [35]], ["n", 41, "comesFrom", ["n"], [15]], ["n", 151, "comesFrom", ["n"], [139]], ["a", 141, "comesFrom", ["a"], [118]], ["a", 153, "comesFrom", ["a"], [118]], ["a", 50, "comesFrom", ["a"], [18]], ["b", 155, "comesFrom", ["b"], [125]], ["b", 58, "comesFrom", ["b"], [21]], ["c", 157, "comesFrom", ["c"], [132]], ["c", 66, "comesFrom", ["c"], [24]], ["x", 73, "comesFrom", ["x"], [48]], ["x", 91, "comesFrom", ["x"], [48]], ["x", 85, "comesFrom", ["x"], [48]], ["y", 75, "comesFrom", ["y"], [56]], ["y", 77, "comesFrom", ["y"], [56]], ["y", 87, "comesFrom", ["y"], [56]], ["y", 88, "comesFrom", ["y"], [56]], ["z", 79, "comesFrom", ["z"], [64]], ["z", 93, "comesFrom", ["z"], [64]], ["z", 90, "comesFrom", ["z"], [64]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; } int main ( ) { string s = \" geeksforgeeks \" ; if ( check ( s ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if string can be made lexicographically smaller by reversing any substring | C ++ implementation of the approach ; Function that returns true if s can be made lexicographically smaller by reversing a sub - string in s ; Traverse in the string ; Check if s [ i + 1 ] < s [ i ] ; Not possible ; Driver code", "dfg": [["i", 30, "comesFrom", ["i"], [26]], ["i", 36, "comesFrom", ["i"], [26]], ["i", 44, "comesFrom", ["i"], [26]], ["i", 49, "comesFrom", ["i"], [26]], ["n", 32, "comesFrom", ["n"], [15]], ["s", 17, "comesFrom", ["s"], [11]], ["s", 78, "comesFrom", ["s"], [68]], ["s", 42, "comesFrom", ["s"], [11]], ["s", 47, "comesFrom", ["s"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubStr ( string str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; } int main ( ) { string str = \" abcabc \" ; int n = str . length ( ) ; char x = ' c ' ; cout << countSubStr ( str , n , x ) ; return 0 ; }", "docstring": "Count of sub | C ++ implementation of the approach ; Function to return the count of required sub - strings ; Number of sub - strings from position of current x to the end of str ; To store the number of characters before x ; Driver code", "dfg": [["res", 81, "comesFrom", ["res"], [54]], ["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 48, "comesFrom", ["i"], [32]], ["i", 66, "comesFrom", ["i"], [32]], ["n", 38, "comesFrom", ["n"], [14]], ["n", 120, "comesFrom", ["n"], [97]], ["n", 64, "comesFrom", ["n"], [14]], ["str", 99, "comesFrom", ["str"], [90]], ["str", 118, "comesFrom", ["str"], [90]], ["str", 46, "comesFrom", ["str"], [11]], ["x", 122, "comesFrom", ["x"], [106]], ["x", 51, "comesFrom", ["x"], [17]], ["count", 76, "comesFrom", ["count"], [70]], ["count", 58, "comesFrom", ["count"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubStr ( string str , int n ) { int len = str . length ( ) ; return ( len - n + 1 ) ; } int main ( ) { string str = \" geeksforgeeks \" ; int n = 5 ; cout << countSubStr ( str , n ) ; return 0 ; }", "docstring": "Count of sub | C ++ implementation of the approach ; Function to return the count of possible sub - strings of length n ; Driver code", "dfg": [["str", 20, "comesFrom", ["str"], [11]], ["str", 57, "comesFrom", ["str"], [42]], ["len", 28, "comesFrom", ["len"], [18]], ["n", 30, "comesFrom", ["n"], [14]], ["n", 59, "comesFrom", ["n"], [49]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstrings ( string s , char c ) { int n = s . length ( ) ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; } int main ( ) { string s = \" baa \" ; char c = ' b ' ; cout << countSubstrings ( s , c ) ; return 0 ; }", "docstring": "Count of sub | C ++ implementation of the approach ; Function to return the number of sub - strings that do not contain the given character c ; Length of the string ; Traverse in the string ; If current character is different from the given character ; Update the number of sub - strings ; Reset count to 0 ; For the characters appearing after the last occurrence of c ; Driver code", "dfg": [["sum", 100, "comesFrom", ["sum"], [85]], ["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["i", 55, "comesFrom", ["i"], [39]], ["n", 45, "comesFrom", ["n"], [18]], ["s", 20, "comesFrom", ["s"], [11]], ["s", 128, "comesFrom", ["s"], [109]], ["s", 53, "comesFrom", ["s"], [11]], ["c", 130, "comesFrom", ["c"], [116]], ["c", 58, "comesFrom", ["c"], [14]], ["cnt", 60, "comesFrom", ["cnt"], [27]], ["cnt", 88, "comesFrom", ["cnt"], [79]], ["cnt", 91, "comesFrom", ["cnt"], [79]], ["cnt", 68, "comesFrom", ["cnt"], [27]], ["cnt", 71, "comesFrom", ["cnt"], [27]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinimizedSum ( string str , int len ) { int i , maxVal = INT_MIN , sum = 0 ; int occurrences [ 26 ] = { 0 } ; for ( i = 0 ; i < len ; i ++ ) { occurrences [ str [ i ] - ' a ' ] ++ ; sum += ( int ) str [ i ] ; } for ( i = 0 ; i < 26 ; i ++ ) maxVal = max ( maxVal , occurrences [ i ] * ( i + ' a ' ) ) ; return ( sum - maxVal ) ; } int main ( ) { string str = \" geeksforgeeks \" ; int len = str . length ( ) ; cout << getMinimizedSum ( str , len ) ; return 0 ; }", "docstring": "Minimize ASCII values sum after removing all occurrences of one character | C ++ implementation of the approach ; Function to return the minimized sum ; To store the occurrences of each character of the string ; Update the occurrence ; Calculate the sum ; Get the character which is contributing the maximum value to the sum ; Count of occurrence of the character multiplied by its ASCII value ; Return the minimized sum ; Driver code", "dfg": [["i", 44, "comesFrom", ["i"], [40]], ["i", 48, "comesFrom", ["i"], [40]], ["i", 84, "comesFrom", ["i"], [80]], ["i", 88, "comesFrom", ["i"], [80]], ["i", 74, "comesFrom", ["i"], [40]], ["i", 99, "comesFrom", ["i"], [80]], ["i", 103, "comesFrom", ["i"], [80]], ["i", 56, "comesFrom", ["i"], [40]], ["len", 46, "comesFrom", ["len"], [14]], ["len", 148, "comesFrom", ["len"], [134]], ["sum", 115, "comesFrom", ["sum"], [67]], ["maxVal", 117, "comesFrom", ["maxVal"], [91]], ["maxVal", 95, "comesFrom", ["maxVal"], [91]], ["str", 136, "comesFrom", ["str"], [127]], ["str", 146, "comesFrom", ["str"], [127]], ["str", 72, "comesFrom", ["str"], [11]], ["str", 54, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string s ) { int i = 0 ; int j = s . length ( ) - 1 ; while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; } int getIndex ( string S1 , string S2 , int n ) { string S = \" \" ; for ( int i = 0 ; i < n ; i ++ ) { S = S + S1 [ i ] ; string Temp = \" \" ; for ( int j = i + 1 ; j < n ; j ++ ) Temp += S2 [ j ] ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return -1 ; } int main ( ) { string S1 = \" abcdf \" , S2 = \" sfgba \" ; int n = S1 . length ( ) ; cout << getIndex ( S1 , S2 , n ) ; return 0 ; }", "docstring": "Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | C ++ implementation of the approach ; Function that returns true if s is palindrome ; Function to return the required index ; Copy the ith character in S ; Copy all the character of string s2 in Temp ; Check whether the string is palindrome ; Driver code", "dfg": [["i", 90, "comesFrom", ["i"], [86]], ["i", 94, "comesFrom", ["i"], [86]], ["i", 32, "comesFrom", ["i"], [15]], ["i", 52, "comesFrom", ["i"], [15]], ["i", 148, "comesFrom", ["i"], [86]], ["i", 119, "comesFrom", ["i"], [86]], ["i", 41, "comesFrom", ["i"], [15]], ["i", 104, "comesFrom", ["i"], [86]], ["n", 92, "comesFrom", ["n"], [73]], ["n", 125, "comesFrom", ["n"], [73]], ["n", 191, "comesFrom", ["n"], [175]], ["j", 34, "comesFrom", ["j"], [20]], ["j", 55, "comesFrom", ["j"], [20]], ["j", 123, "comesFrom", ["j"], [117]], ["j", 127, "comesFrom", ["j"], [117]], ["j", 46, "comesFrom", ["j"], [20]], ["j", 134, "comesFrom", ["j"], [117]], ["S1", 177, "comesFrom", ["S1"], [162]], ["S1", 187, "comesFrom", ["S1"], [162]], ["S1", 102, "comesFrom", ["S1"], [67]], ["S2", 189, "comesFrom", ["S2"], [168]], ["S2", 132, "comesFrom", ["S2"], [70]], ["s", 22, "comesFrom", ["s"], [11]], ["s", 39, "comesFrom", ["s"], [11]], ["s", 44, "comesFrom", ["s"], [11]], ["S", 100, "comesFrom", ["S"], [98]], ["S", 141, "comesFrom", ["S"], [98]], ["Temp", 143, "comesFrom", ["Temp"], [130]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string s , int i , int j ) { while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; } int getIndex ( string s1 , string s2 , int len ) { int i = 0 , j = len - 1 ; while ( i < j ) { if ( s1 [ i ] != s2 [ j ] ) { break ; } i ++ ; j -- ; } if ( i == j ) { return i - 1 ; } else if ( isPalindrome ( s2 , i , j ) ) return i - 1 ; else if ( isPalindrome ( s1 , i , j ) ) return j ; return -1 ; } int main ( ) { string s1 = \" abcdf \" , s2 = \" sfgba \" ; int len = s1 . length ( ) ; cout << getIndex ( s1 , s2 , len ) ; return 0 ; }", "docstring": "Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | C ++ program to implement the above approach ; Function that returns true if the sub - string starting from index i and ending at index j is a palindrome ; Function to get the required index ; Start comparing the two strings from both ends . ; Break from the loop at first mismatch ; If it is possible to concatenate the strings to form palindrome , return index ; If remaining part for s2 is palindrome ; If remaining part for s1 is palindrome ; If not possible , return - 1 ; Driver Code", "dfg": [["i", 22, "comesFrom", ["i"], [14]], ["i", 79, "comesFrom", ["i"], [67]], ["i", 109, "comesFrom", ["i"], [67]], ["i", 42, "comesFrom", ["i"], [14]], ["i", 100, "comesFrom", ["i"], [67]], ["i", 115, "comesFrom", ["i"], [67]], ["i", 133, "comesFrom", ["i"], [67]], ["i", 127, "comesFrom", ["i"], [67]], ["i", 31, "comesFrom", ["i"], [14]], ["i", 88, "comesFrom", ["i"], [67]], ["i", 144, "comesFrom", ["i"], [67]], ["j", 24, "comesFrom", ["j"], [17]], ["j", 81, "comesFrom", ["j"], [71]], ["j", 111, "comesFrom", ["j"], [71]], ["j", 45, "comesFrom", ["j"], [17]], ["j", 103, "comesFrom", ["j"], [71]], ["j", 129, "comesFrom", ["j"], [71]], ["j", 150, "comesFrom", ["j"], [71]], ["j", 36, "comesFrom", ["j"], [17]], ["j", 93, "comesFrom", ["j"], [71]], ["j", 146, "comesFrom", ["j"], [71]], ["len", 73, "comesFrom", ["len"], [63]], ["len", 191, "comesFrom", ["len"], [175]], ["s1", 177, "comesFrom", ["s1"], [162]], ["s1", 187, "comesFrom", ["s1"], [162]], ["s1", 86, "comesFrom", ["s1"], [57]], ["s1", 142, "comesFrom", ["s1"], [57]], ["s2", 189, "comesFrom", ["s2"], [168]], ["s2", 91, "comesFrom", ["s2"], [60]], ["s2", 125, "comesFrom", ["s2"], [60]], ["s", 29, "comesFrom", ["s"], [11]], ["s", 34, "comesFrom", ["s"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_acronym ( int n , string arr [ ] ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] [ 0 ] - ' a ' ] ++ ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string st = arr [ i ] ; int num [ 26 ] = { 0 } ; for ( int j = 0 ; j < st . length ( ) ; j ++ ) num [ st [ j ] - ' a ' ] ++ ; bool flag = true ; for ( int j = 1 ; j < 26 ; j ++ ) { if ( num [ j ] > freq [ j ] ) { flag = false ; break ; } } int x = st [ 0 ] - ' a ' ; if ( freq [ x ] - 1 < num [ x ] ) flag = false ; if ( flag ) cnt ++ ; } return cnt ; } int main ( ) { string arr [ ] = { \" abc \" , \" bcad \" , \" cabd \" , \" cba \" , \" dzzz \" } ; int n = 5 ; cout << count_acronym ( n , arr ) ; }", "docstring": "Acronym words | C ++ implementation of the approach ; Function to return the number of strings that can be an acronym for other strings ; Frequency array to store the frequency of the first character of every string in the array ; To store the count of required strings ; Current word ; Frequency array to store the frequency of each of the character of the current string ; Check if the frequency of every character in the current string is <= its value in freq [ ] ; First character of the current string ; Driver code", "dfg": [["cnt", 214, "comesFrom", ["cnt"], [62]], ["cnt", 209, "comesFrom", ["cnt"], [62]], ["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 73, "comesFrom", ["i"], [69]], ["i", 77, "comesFrom", ["i"], [69]], ["i", 86, "comesFrom", ["i"], [69]], ["i", 47, "comesFrom", ["i"], [32]], ["n", 38, "comesFrom", ["n"], [11]], ["n", 75, "comesFrom", ["n"], [11]], ["n", 258, "comesFrom", ["n"], [250]], ["j", 106, "comesFrom", ["j"], [102]], ["j", 114, "comesFrom", ["j"], [102]], ["j", 144, "comesFrom", ["j"], [140]], ["j", 148, "comesFrom", ["j"], [140]], ["j", 156, "comesFrom", ["j"], [140]], ["j", 161, "comesFrom", ["j"], [140]], ["j", 121, "comesFrom", ["j"], [102]], ["flag", 207, "comesFrom", ["flag"], [201]], ["st", 108, "comesFrom", ["st"], [82]], ["st", 176, "comesFrom", ["st"], [82]], ["st", 119, "comesFrom", ["st"], [82]], ["x", 198, "comesFrom", ["x"], [174]], ["x", 191, "comesFrom", ["x"], [174]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool valid ( int cnt [ ] ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; } string getGoodString ( string s , int n ) { if ( n < 26 ) return \" - 1\" ; for ( int i = 25 ; i < n ; i ++ ) { int cnt [ 26 ] = { 0 } ; for ( int j = i ; j >= i - 25 ; j -- ) { cnt [ s [ j ] - ' a ' ] ++ ; } if ( valid ( cnt ) ) { int cur = 0 ; while ( cnt [ cur ] > 0 ) cur ++ ; for ( int j = i - 25 ; j <= i ; j ++ ) { if ( s [ j ] == ' ? ' ) { s [ j ] = cur + ' a ' ; cur ++ ; while ( cnt [ cur ] > 0 ) cur ++ ; } } return s ; } } return \" - 1\" ; } int main ( ) { string s = \" abcdefghijkl ? nopqrstuvwxy ? \" ; int n = s . length ( ) ; cout << getGoodString ( s , n ) ; return 0 ; }", "docstring": "Sub | C ++ implementation of the approach ; Function that returns true if every lowercase character appears atmost once ; every character frequency must be not greater than one ; Function that returns the modified good string if possible ; If the length of the string is less than n ; Sub - strings of length 26 ; To store frequency of each character ; Get the frequency of each character in the current sub - string ; Check if we can get sub - string containing all the 26 characters ; Find which character is missing ; Fill with missing characters ; Find the next missing character ; Return the modified good string ; Driver code", "dfg": [["i", 23, "comesFrom", ["i"], [19]], ["i", 27, "comesFrom", ["i"], [19]], ["i", 76, "comesFrom", ["i"], [72]], ["i", 80, "comesFrom", ["i"], [72]], ["i", 103, "comesFrom", ["i"], [99]], ["i", 163, "comesFrom", ["i"], [99]], ["i", 35, "comesFrom", ["i"], [19]], ["i", 157, "comesFrom", ["i"], [99]], ["n", 78, "comesFrom", ["n"], [55]], ["n", 60, "comesFrom", ["n"], [55]], ["n", 251, "comesFrom", ["n"], [237]], ["j", 101, "comesFrom", ["j"], [97]], ["j", 107, "comesFrom", ["j"], [97]], ["j", 161, "comesFrom", ["j"], [155]], ["j", 165, "comesFrom", ["j"], [155]], ["j", 115, "comesFrom", ["j"], [97]], ["j", 173, "comesFrom", ["j"], [155]], ["j", 185, "comesFrom", ["j"], [155]], ["s", 239, "comesFrom", ["s"], [230]], ["s", 249, "comesFrom", ["s"], [230]], ["s", 214, "comesFrom", ["s"], [52]], ["s", 113, "comesFrom", ["s"], [52]], ["s", 171, "comesFrom", ["s"], [52]], ["s", 183, "comesFrom", ["s"], [52]], ["cur", 149, "comesFrom", ["cur"], [136]], ["cur", 144, "comesFrom", ["cur"], [136]], ["cur", 196, "comesFrom", ["cur"], [136]], ["cur", 188, "comesFrom", ["cur"], [136]], ["cur", 208, "comesFrom", ["cur"], [136]], ["cur", 203, "comesFrom", ["cur"], [136]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { c = tolower ( c ) ; if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; } string swapRepeated ( string str ) { for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) { if ( ( isVowel ( str [ i ] ) && isVowel ( str [ i + 1 ] ) ) || ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i + 1 ] ) ) ) swap ( str [ i ] , str [ i + 1 ] ) ; } return str ; } int main ( ) { string str = \" geeksforgeeks \" ; cout << swapRepeated ( str ) ; return 0 ; }", "docstring": "Modify the string by swapping continuous vowels or consonants | C ++ implementation of the above approach ; Function to check if a character is a vowel ; Function to swap two consecutively repeated vowels or consonants ; Traverse through the length of the string ; Check if the two consecutive characters are vowels or consonants ; swap the two characters ; Driver code", "dfg": [["str", 155, "comesFrom", ["str"], [70]], ["str", 174, "comesFrom", ["str"], [164]], ["str", 82, "comesFrom", ["str"], [70]], ["str", 140, "comesFrom", ["str"], [70]], ["str", 145, "comesFrom", ["str"], [70]], ["str", 99, "comesFrom", ["str"], [70]], ["str", 107, "comesFrom", ["str"], [70]], ["str", 120, "comesFrom", ["str"], [70]], ["str", 129, "comesFrom", ["str"], [70]], ["i", 80, "comesFrom", ["i"], [76]], ["i", 90, "comesFrom", ["i"], [76]], ["i", 142, "comesFrom", ["i"], [76]], ["i", 147, "comesFrom", ["i"], [76]], ["i", 101, "comesFrom", ["i"], [76]], ["i", 109, "comesFrom", ["i"], [76]], ["i", 122, "comesFrom", ["i"], [76]], ["i", 131, "comesFrom", ["i"], [76]], ["c", 18, "comesFrom", ["c"], [14]], ["c", 51, "comesFrom", ["c"], [14]], ["c", 44, "comesFrom", ["c"], [14]], ["c", 37, "comesFrom", ["c"], [14]], ["c", 23, "comesFrom", ["c"], [14]], ["c", 30, "comesFrom", ["c"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestPalinSub ( string s ) { string res ; char mx = s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = max ( mx , s [ i ] ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; } int main ( ) { string s = \" geeksforgeeks \" ; cout << largestPalinSub ( s ) ; }", "docstring": "Find the lexicographically largest palindromic Subsequence of a String | CPP program to find the largest palindromic subsequence ; Function to find the largest palindromic subsequence ; Find the largest character ; Append all occurrences of largest character to the resultant string ; Driver Code", "dfg": [["res", 90, "comesFrom", ["res"], [82]], ["i", 32, "comesFrom", ["i"], [28]], ["i", 40, "comesFrom", ["i"], [28]], ["i", 62, "comesFrom", ["i"], [58]], ["i", 70, "comesFrom", ["i"], [58]], ["i", 77, "comesFrom", ["i"], [58]], ["i", 86, "comesFrom", ["i"], [58]], ["i", 51, "comesFrom", ["i"], [28]], ["s", 20, "comesFrom", ["s"], [11]], ["s", 34, "comesFrom", ["s"], [11]], ["s", 64, "comesFrom", ["s"], [11]], ["s", 109, "comesFrom", ["s"], [99]], ["s", 75, "comesFrom", ["s"], [11]], ["s", 84, "comesFrom", ["s"], [11]], ["s", 49, "comesFrom", ["s"], [11]], ["mx", 80, "comesFrom", ["mx"], [43]], ["mx", 47, "comesFrom", ["mx"], [43]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printString ( string str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = 1 ; for ( int j = 0 ; j < ones ; j ++ ) cout << \"1\" ; } if ( str [ i ] != '1' ) cout << str [ i ] ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) cout << \"1\" ; } int main ( ) { string str = \"100210\" ; int n = str . length ( ) ; printString ( str , n ) ; return 0 ; }", "docstring": "Generate lexicographically smallest string of 0 , 1 and 2 with adjacent swaps allowed | C ++ implementation of the approach ; Function to print the required string ; count number of 1 s ; To check if the all the 1 s have been used or not ; Print all the 1 s if any 2 is encountered ; If str [ i ] = 0 or str [ i ] = 2 ; If 1 s are not printed yet ; Driver code", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 62, "comesFrom", ["i"], [58]], ["i", 66, "comesFrom", ["i"], [58]], ["i", 40, "comesFrom", ["i"], [25]], ["i", 114, "comesFrom", ["i"], [58]], ["i", 125, "comesFrom", ["i"], [58]], ["i", 74, "comesFrom", ["i"], [58]], ["n", 31, "comesFrom", ["n"], [14]], ["n", 64, "comesFrom", ["n"], [14]], ["n", 180, "comesFrom", ["n"], [168]], ["used", 132, "comesFrom", ["used"], [85]], ["used", 82, "comesFrom", ["used"], [51]], ["j", 141, "comesFrom", ["j"], [137]], ["j", 145, "comesFrom", ["j"], [137]], ["j", 96, "comesFrom", ["j"], [92]], ["j", 100, "comesFrom", ["j"], [92]], ["ones", 143, "comesFrom", ["ones"], [18]], ["ones", 47, "comesFrom", ["ones"], [18]], ["ones", 98, "comesFrom", ["ones"], [18]], ["str", 178, "comesFrom", ["str"], [161]], ["str", 170, "comesFrom", ["str"], [161]], ["str", 38, "comesFrom", ["str"], [11]], ["str", 112, "comesFrom", ["str"], [11]], ["str", 123, "comesFrom", ["str"], [11]], ["str", 72, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPermutation ( string str , int k ) { bool has [ 26 ] = { false } ; int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! has [ str [ i ] - ' a ' ] ) { cnt ++ ; has [ str [ i ] - ' a ' ] = true ; } } long long int ans = 1 ; for ( int i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( int i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; } int main ( ) { string str = \" geeksforgeeks \" ; int k = 4 ; cout << findPermutation ( str , k ) ; return 0 ; }", "docstring": "K length words that can be formed from given characters without repetition | C ++ implementation of the approach ; Function to return the required count ; To store the count of distinct characters in str ; Traverse str character by character ; If current character is appearing for the first time in str ; Increment the distinct character count ; Update the appearance of the current character ; Since P ( n , r ) = n ! / ( n - r ) ! ; Return the answer ; Driver code", "dfg": [["ans", 136, "comesFrom", ["ans"], [131]], ["i", 39, "comesFrom", ["i"], [35]], ["i", 47, "comesFrom", ["i"], [35]], ["i", 104, "comesFrom", ["i"], [100]], ["i", 108, "comesFrom", ["i"], [100]], ["i", 124, "comesFrom", ["i"], [118]], ["i", 128, "comesFrom", ["i"], [118]], ["i", 113, "comesFrom", ["i"], [100]], ["i", 133, "comesFrom", ["i"], [118]], ["i", 58, "comesFrom", ["i"], [35]], ["i", 76, "comesFrom", ["i"], [35]], ["cnt", 106, "comesFrom", ["cnt"], [28]], ["cnt", 120, "comesFrom", ["cnt"], [28]], ["cnt", 69, "comesFrom", ["cnt"], [28]], ["str", 41, "comesFrom", ["str"], [11]], ["str", 160, "comesFrom", ["str"], [145]], ["str", 56, "comesFrom", ["str"], [11]], ["str", 74, "comesFrom", ["str"], [11]], ["k", 122, "comesFrom", ["k"], [14]], ["k", 162, "comesFrom", ["k"], [152]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int product ( int x ) { int prod = 1 ; while ( x ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; } int findNumber ( int l , int r ) { string a = to_string ( l ) ; string b = to_string ( r ) ; int ans = r ; for ( int i = 0 ; i < b . size ( ) ; i ++ ) { if ( b [ i ] == '0' ) continue ; string curr = b ; curr [ i ] = ( ( curr [ i ] - '0' ) - 1 ) + '0' ; for ( int j = i + 1 ; j < curr . size ( ) ; j ++ ) curr [ j ] = '9' ; int num = 0 ; for ( auto c : curr ) num = num * 10 + ( c - '0' ) ; if ( num >= l && product ( ans ) < product ( num ) ) ans = num ; } return ans ; } int main ( ) { int l = 1 , r = 10 ; cout << findNumber ( l , r ) << endl ; l = 51 , r = 62 ; cout << findNumber ( l , r ) << endl ; return 0 ; }", "docstring": "Find the number in a range having maximum product of the digits | CPP Program to find the number in a range having maximum product of the digits ; Returns the product of digits of number x ; This function returns the number having maximum product of the digits ; Converting both integers to strings ; Let the current answer be r ; Stores the current number having current digit one less than current digit in b ; Replace all following digits with 9 to maximise the product ; Convert string to number ; Check if it lies in range and its product is greater than max product ; Driver Code", "dfg": [["prod", 38, "comesFrom", ["prod"], [24]], ["ans", 210, "comesFrom", ["ans"], [204]], ["ans", 196, "comesFrom", ["ans"], [68]], ["x", 21, "comesFrom", ["x"], [11]], ["x", 27, "comesFrom", ["x"], [11]], ["i", 79, "comesFrom", ["i"], [75]], ["i", 87, "comesFrom", ["i"], [75]], ["i", 111, "comesFrom", ["i"], [75]], ["i", 138, "comesFrom", ["i"], [75]], ["i", 95, "comesFrom", ["i"], [75]], ["i", 118, "comesFrom", ["i"], [75]], ["curr", 172, "comesFrom", ["curr"], [105]], ["curr", 109, "comesFrom", ["curr"], [105]], ["curr", 144, "comesFrom", ["curr"], [105]], ["curr", 153, "comesFrom", ["curr"], [105]], ["curr", 116, "comesFrom", ["curr"], [105]], ["l", 56, "comesFrom", ["l"], [45]], ["l", 231, "comesFrom", ["l"], [219]], ["l", 250, "comesFrom", ["l"], [238]], ["l", 192, "comesFrom", ["l"], [45]], ["r", 64, "comesFrom", ["r"], [48]], ["r", 233, "comesFrom", ["r"], [223]], ["r", 252, "comesFrom", ["r"], [242]], ["b", 81, "comesFrom", ["b"], [60]], ["b", 93, "comesFrom", ["b"], [60]], ["j", 142, "comesFrom", ["j"], [136]], ["j", 150, "comesFrom", ["j"], [136]], ["j", 155, "comesFrom", ["j"], [136]], ["num", 206, "comesFrom", ["num"], [174]], ["num", 190, "comesFrom", ["num"], [174]], ["num", 176, "comesFrom", ["num"], [174]], ["num", 201, "comesFrom", ["num"], [174]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < char > vowels = { ' a ' , ' e ' , ' i ' , ' o ' , ' u ' } ; map < char , int > mapping = { { ' a ' , 0 } , { ' e ' , 1 } , { ' i ' , 2 } , { ' o ' , 3 } , { ' u ' , 4 } } ; bool isValidSequence ( string subList ) { for ( char c : vowels ) { if ( subList . find ( c ) == std :: string :: npos ) return 0 ; } return 1 ; } string longestSubsequence ( string str , string subList , int index ) { int len = str . length ( ) ; if ( index >= len ) { if ( isValidSequence ( subList ) ) return subList ; else return \" \" ; } else if ( subList . size ( ) == 0 ) { if ( str [ index ] != ' a ' ) return longestSubsequence ( str , \" \" , index + 1 ) ; else return longestSubsequence ( str , subList + str [ index ] , index + 1 ) ; } else if ( mapping [ subList [ subList . size ( ) - 1 ] ] == mapping [ str [ index ] ] ) return longestSubsequence ( str , subList + str [ index ] , index + 1 ) ; else if ( mapping [ subList [ subList . size ( ) - 1 ] ] + 1 == mapping [ str [ index ] ] ) { string sub1 = longestSubsequence ( str , subList + str [ index ] , index + 1 ) ; string sub2 = longestSubsequence ( str , subList , index + 1 ) ; if ( sub1 . length ( ) > sub2 . length ( ) ) return sub1 ; else return sub2 ; } else return longestSubsequence ( str , subList , index + 1 ) ; } int main ( ) { string str = \" aeiaaioooauuaeiou \" ; string subsequence = longestSubsequence ( str , \" \" , 0 ) ; if ( subsequence . length ( ) == 0 ) cout << \" No ▁ subsequence ▁ possible STRNEWLINE \" ; else cout << subsequence << \" STRNEWLINE \" ; }", "docstring": "Longest Ordered Subsequence of Vowels | C ++ program to find the longest subsequence of vowels in the specified order ; Mapping values for vowels ; Function to check if given subsequence contains all the vowels or not ; not contain vowel ; Function to find the longest subsequence of vowels in the given string in specified order ; If we have reached the end of the string , return the subsequence if it is valid , else return an empty list ; If there is no vowel in the subsequence yet , add vowel at current index if it is ' a ' , else move on to the next character in the string ; If the last vowel in the subsequence until now is same as the vowel at current index , add it to the subsequence ; If the vowel at the current index comes right after the last vowel in the subsequence , we have two options : either to add the vowel in the subsequence , or move on to next character . We choose the one which gives the longest subsequence . ; Driver Code", "dfg": [["vowels", 117, "comesFrom", ["vowels"], [11]], ["index", 167, "comesFrom", ["index"], [153]], ["index", 205, "comesFrom", ["index"], [153]], ["index", 223, "comesFrom", ["index"], [153]], ["index", 284, "comesFrom", ["index"], [153]], ["index", 241, "comesFrom", ["index"], [153]], ["index", 268, "comesFrom", ["index"], [153]], ["index", 281, "comesFrom", ["index"], [153]], ["index", 238, "comesFrom", ["index"], [153]], ["index", 380, "comesFrom", ["index"], [153]], ["index", 312, "comesFrom", ["index"], [153]], ["index", 331, "comesFrom", ["index"], [153]], ["index", 345, "comesFrom", ["index"], [153]], ["index", 328, "comesFrom", ["index"], [153]], ["len", 169, "comesFrom", ["len"], [157]], ["str", 159, "comesFrom", ["str"], [147]], ["str", 403, "comesFrom", ["str"], [392]], ["str", 203, "comesFrom", ["str"], [147]], ["str", 217, "comesFrom", ["str"], [147]], ["str", 275, "comesFrom", ["str"], [147]], ["str", 232, "comesFrom", ["str"], [147]], ["str", 266, "comesFrom", ["str"], [147]], ["str", 279, "comesFrom", ["str"], [147]], ["str", 236, "comesFrom", ["str"], [147]], ["str", 376, "comesFrom", ["str"], [147]], ["str", 310, "comesFrom", ["str"], [147]], ["str", 322, "comesFrom", ["str"], [147]], ["str", 341, "comesFrom", ["str"], [147]], ["str", 326, "comesFrom", ["str"], [147]], ["subList", 180, "comesFrom", ["subList"], [150]], ["subList", 176, "comesFrom", ["subList"], [150]], ["subList", 122, "comesFrom", ["subList"], [109]], ["subList", 192, "comesFrom", ["subList"], [150]], ["subList", 277, "comesFrom", ["subList"], [150]], ["subList", 234, "comesFrom", ["subList"], [150]], ["subList", 252, "comesFrom", ["subList"], [150]], ["subList", 378, "comesFrom", ["subList"], [150]], ["subList", 343, "comesFrom", ["subList"], [150]], ["subList", 294, "comesFrom", ["subList"], [150]], ["subList", 324, "comesFrom", ["subList"], [150]], ["subList", 254, "comesFrom", ["subList"], [150]], ["subList", 296, "comesFrom", ["subList"], [150]], ["subsequence", 414, "comesFrom", ["subsequence"], [399]], ["subsequence", 431, "comesFrom", ["subsequence"], [399]], ["mapping", 250, "comesFrom", ["mapping"], [51]], ["mapping", 264, "comesFrom", ["mapping"], [51]], ["mapping", 308, "comesFrom", ["mapping"], [51]], ["mapping", 292, "comesFrom", ["mapping"], [51]], ["sub1", 365, "comesFrom", ["sub1"], [318]], ["sub1", 352, "comesFrom", ["sub1"], [318]], ["sub2", 369, "comesFrom", ["sub2"], [337]], ["sub2", 358, "comesFrom", ["sub2"], [337]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printExpansion ( string str ) { int size = 0 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { string subStr = str . substr ( i , ++ size ) ; cout << subStr ; } } int main ( ) { string str = \" geeks \" ; printExpansion ( str ) ; return 0 ; }", "docstring": "Concatenate suffixes of a String | C ++ implementation of the approach ; Function to print the expansion of the string ; Take sub - string from i to n - 1 ; Print the sub - string ; Driver code", "dfg": [["i", 32, "comesFrom", ["i"], [22]], ["i", 36, "comesFrom", ["i"], [22]], ["i", 47, "comesFrom", ["i"], [22]], ["str", 73, "comesFrom", ["str"], [65]], ["str", 24, "comesFrom", ["str"], [11]], ["str", 43, "comesFrom", ["str"], [11]], ["subStr", 55, "comesFrom", ["subStr"], [41]], ["size", 50, "comesFrom", ["size"], [15]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int constructBinString ( int a , int b , int x ) { int d , i ; d = x / 2 ; if ( x % 2 == 0 && x / 2 != a ) { d -- ; cout << 0 ; a -- ; } for ( i = 0 ; i < d ; i ++ ) cout << \"10\" ; a = a - d ; b = b - d ; for ( i = 0 ; i < b ; i ++ ) { cout << \"1\" ; } for ( i = 0 ; i < a ; i ++ ) { cout << \"0\" ; } } int main ( ) { int a = 4 , b = 3 , x = 2 ; constructBinString ( a , b , x ) ; return 0 ; }", "docstring": "Construct a binary string following the given constraints | C ++ implementation of the approach ; Function to print a binary string which has ' a ' number of 0 ' s , ▁ ' b ' ▁ number ▁ of ▁ 1' s and there are at least ' x ' indices such that s [ i ] != s [ i + 1 ] ; Divide index value by 2 and store it into d ; If index value x is even and x / 2 is not equal to a ; Loop for d for each d print 10 ; subtract d from a and b ; Loop for b to print remaining 1 's ; Loop for a to print remaining 0 's ; Driver code", "dfg": [["i", 63, "comesFrom", ["i"], [59]], ["i", 67, "comesFrom", ["i"], [59]], ["i", 94, "comesFrom", ["i"], [90]], ["i", 98, "comesFrom", ["i"], [90]], ["i", 115, "comesFrom", ["i"], [111]], ["i", 119, "comesFrom", ["i"], [111]], ["d", 65, "comesFrom", ["d"], [25]], ["d", 80, "comesFrom", ["d"], [25]], ["d", 86, "comesFrom", ["d"], [25]], ["d", 46, "comesFrom", ["d"], [25]], ["b", 96, "comesFrom", ["b"], [82]], ["b", 84, "comesFrom", ["b"], [82]], ["b", 153, "comesFrom", ["b"], [141]], ["a", 117, "comesFrom", ["a"], [76]], ["a", 78, "comesFrom", ["a"], [76]], ["a", 151, "comesFrom", ["a"], [137]], ["a", 43, "comesFrom", ["a"], [11]], ["a", 53, "comesFrom", ["a"], [11]], ["x", 27, "comesFrom", ["x"], [17]], ["x", 155, "comesFrom", ["x"], [145]], ["x", 33, "comesFrom", ["x"], [17]], ["x", 39, "comesFrom", ["x"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int matchPattern ( string s ) { int count = 0 ; int n = s . length ( ) ; int i = 0 ; while ( i < n ) { while ( i < n && s [ i ] == ' a ' ) { count ++ ; i ++ ; } while ( i < n && s [ i ] == ' b ' ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; } int main ( ) { string s = \" bb \" ; if ( matchPattern ( s ) == true ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check If every group of a ' s ▁ is ▁ followed ▁ by ▁ a ▁ group ▁ of ▁ b ' s of same length | C ++ implementation of the approach ; Function to match whether there are always n consecutive b ' s ▁ followed ▁ by ▁ n ▁ consecutive ▁ a ' s throughout the string ; Traverse through the string ; Count a 's in current segment ; Count b 's in current segment ; If both counts are not same . ; Driver code", "dfg": [["i", 35, "comesFrom", ["i"], [29]], ["i", 42, "comesFrom", ["i"], [29]], ["i", 61, "comesFrom", ["i"], [29]], ["i", 67, "comesFrom", ["i"], [29]], ["i", 86, "comesFrom", ["i"], [29]], ["i", 48, "comesFrom", ["i"], [29]], ["i", 73, "comesFrom", ["i"], [29]], ["n", 37, "comesFrom", ["n"], [20]], ["n", 44, "comesFrom", ["n"], [20]], ["n", 69, "comesFrom", ["n"], [20]], ["s", 22, "comesFrom", ["s"], [11]], ["s", 120, "comesFrom", ["s"], [110]], ["s", 46, "comesFrom", ["s"], [11]], ["s", 71, "comesFrom", ["s"], [11]], ["count", 92, "comesFrom", ["count"], [15]], ["count", 58, "comesFrom", ["count"], [15]], ["count", 83, "comesFrom", ["count"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum_one ( string s , int n ) { int cnt_one = 0 ; int max_cnt = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { cnt_one ++ ; temp ++ ; } else { max_cnt = max ( temp , max_cnt ) ; temp = 0 ; } } max_cnt = max ( max_cnt , temp ) ; int left [ n ] , right [ n ] ; if ( s [ 0 ] == '1' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s [ n - 1 ] == '1' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == '0' ) { int sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) max_cnt = max ( max_cnt , sum + 1 ) ; else max_cnt = max ( max_cnt , sum ) ; } } return max_cnt ; } int main ( ) { string s = \"111011101\" ; cout << maximum_one ( s , s . length ( ) ) ; return 0 ; }", "docstring": "Length of longest consecutive ones by at most one swap in a Binary String | C ++ program to find length of longest consecutive ones by at most one swap in a Binary String ; Function to calculate the length of the longest consecutive 1 's ; To count all 1 's in the string ; To store cumulative 1 's ; Counting cumulative 1 's from left ; If 0 then start new cumulative one from that i ; perform step 3 of the approach ; step 3 ; Driver Code ; string", "dfg": [["max_cnt", 336, "comesFrom", ["max_cnt"], [324]], ["max_cnt", 86, "comesFrom", ["max_cnt"], [82]], ["max_cnt", 73, "comesFrom", ["max_cnt"], [67]], ["max_cnt", 316, "comesFrom", ["max_cnt"], [312]], ["max_cnt", 328, "comesFrom", ["max_cnt"], [324]], ["i", 38, "comesFrom", ["i"], [34]], ["i", 42, "comesFrom", ["i"], [34]], ["i", 167, "comesFrom", ["i"], [163]], ["i", 171, "comesFrom", ["i"], [163]], ["i", 218, "comesFrom", ["i"], [212]], ["i", 222, "comesFrom", ["i"], [212]], ["i", 267, "comesFrom", ["i"], [263]], ["i", 273, "comesFrom", ["i"], [263]], ["i", 50, "comesFrom", ["i"], [34]], ["i", 179, "comesFrom", ["i"], [163]], ["i", 188, "comesFrom", ["i"], [163]], ["i", 230, "comesFrom", ["i"], [212]], ["i", 239, "comesFrom", ["i"], [212]], ["i", 281, "comesFrom", ["i"], [263]], ["i", 203, "comesFrom", ["i"], [163]], ["i", 254, "comesFrom", ["i"], [212]], ["i", 193, "comesFrom", ["i"], [163]], ["i", 244, "comesFrom", ["i"], [212]], ["i", 294, "comesFrom", ["i"], [263]], ["i", 301, "comesFrom", ["i"], [263]], ["n", 40, "comesFrom", ["n"], [14]], ["n", 94, "comesFrom", ["n"], [14]], ["n", 99, "comesFrom", ["n"], [14]], ["n", 169, "comesFrom", ["n"], [14]], ["n", 269, "comesFrom", ["n"], [14]], ["n", 214, "comesFrom", ["n"], [14]], ["n", 132, "comesFrom", ["n"], [14]], ["n", 143, "comesFrom", ["n"], [14]], ["n", 153, "comesFrom", ["n"], [14]], ["temp", 88, "comesFrom", ["temp"], [76]], ["temp", 61, "comesFrom", ["temp"], [27]], ["temp", 71, "comesFrom", ["temp"], [27]], ["s", 104, "comesFrom", ["s"], [11]], ["s", 130, "comesFrom", ["s"], [11]], ["s", 355, "comesFrom", ["s"], [345]], ["s", 48, "comesFrom", ["s"], [11]], ["s", 177, "comesFrom", ["s"], [11]], ["s", 228, "comesFrom", ["s"], [11]], ["s", 279, "comesFrom", ["s"], [11]], ["s", 357, "comesFrom", ["s"], [345]], ["cnt_one", 58, "comesFrom", ["cnt_one"], [18]], ["cnt_one", 310, "comesFrom", ["cnt_one"], [18]], ["sum", 308, "comesFrom", ["sum"], [290]], ["sum", 318, "comesFrom", ["sum"], [290]], ["sum", 330, "comesFrom", ["sum"], [290]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string MaxFreq ( string str ) { int n = str . size ( ) ; unordered_map < string , int > m ; for ( int i = 0 ; i < n ; i ++ ) { string s = \" \" ; for ( int j = i ; j < n ; j ++ ) { s += str [ j ] ; m [ s ] ++ ; } } int maxi = 0 ; string s ; for ( auto i = m . begin ( ) ; i != m . end ( ) ; i ++ ) { if ( i -> second > maxi ) { maxi = i -> second ; s = i -> first ; } else if ( i -> second == maxi ) { string ss = i -> first ; if ( ss . size ( ) > s . size ( ) ) s = ss ; } } return s ; } int main ( ) { string str = \" ababecdecd \" ; cout << MaxFreq ( str ) ; return 0 ; }", "docstring": "Maximum length substring with highest frequency in a string | C ++ program to find maximum occurred substring of a string ; function to return maximum occurred substring of a string ; size of the string ; to store maximum frequency ; to store string which has maximum frequency ; return substring which has maximum frequency ; Driver program ; function call", "dfg": [["s", 174, "comesFrom", ["s"], [167]], ["s", 77, "comesFrom", ["s"], [68]], ["s", 161, "comesFrom", ["s"], [129]], ["i", 38, "comesFrom", ["i"], [34]], ["i", 42, "comesFrom", ["i"], [34]], ["i", 102, "comesFrom", ["i"], [94]], ["i", 110, "comesFrom", ["i"], [94]], ["i", 116, "comesFrom", ["i"], [94]], ["i", 125, "comesFrom", ["i"], [94]], ["i", 131, "comesFrom", ["i"], [94]], ["i", 139, "comesFrom", ["i"], [94]], ["i", 149, "comesFrom", ["i"], [94]], ["n", 40, "comesFrom", ["n"], [15]], ["n", 62, "comesFrom", ["n"], [15]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 193, "comesFrom", ["str"], [183]], ["str", 70, "comesFrom", ["str"], [11]], ["j", 60, "comesFrom", ["j"], [56]], ["j", 64, "comesFrom", ["j"], [56]], ["j", 72, "comesFrom", ["j"], [56]], ["m", 104, "comesFrom", ["m"], [29]], ["m", 96, "comesFrom", ["m"], [29]], ["m", 75, "comesFrom", ["m"], [29]], ["maxi", 120, "comesFrom", ["maxi"], [84]], ["maxi", 143, "comesFrom", ["maxi"], [123]], ["ss", 169, "comesFrom", ["ss"], [147]], ["ss", 155, "comesFrom", ["ss"], [147]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxFreq ( string s , int a , int b ) { int fre [ 10 ] = { 0 } ; int n = s . size ( ) ; if ( a > b ) swap ( a , b ) ; for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - '0' ] ++ ; if ( fre [ a ] == 0 and fre [ b ] == 0 ) return -1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; } int main ( ) { int a = 4 , b = 7 ; string s = \"47744\" ; cout << maxFreq ( s , a , b ) ; return 0 ; }", "docstring": "Lexicographically smallest substring with maximum occurrences containing a ' s ▁ and ▁ b ' s only | CPP program to Find the lexicographically smallest substring in a given string with maximum frequency and contains a ' s ▁ and ▁ b ' s only ; Function to Find the lexicographically smallest substring in a given string with maximum frequency and contains a ' s ▁ and ▁ b ' s only . ; To store frequency of digits ; size of string ; Take lexicographically larger digit in b ; get frequency of each character ; If no such string exits ; Maximum frequency ; Driver program", "dfg": [["i", 59, "comesFrom", ["i"], [55]], ["i", 63, "comesFrom", ["i"], [55]], ["i", 70, "comesFrom", ["i"], [55]], ["n", 61, "comesFrom", ["n"], [31]], ["a", 41, "comesFrom", ["a"], [14]], ["a", 47, "comesFrom", ["a"], [14]], ["a", 112, "comesFrom", ["a"], [14]], ["a", 146, "comesFrom", ["a"], [125]], ["a", 83, "comesFrom", ["a"], [14]], ["a", 103, "comesFrom", ["a"], [14]], ["b", 43, "comesFrom", ["b"], [17]], ["b", 49, "comesFrom", ["b"], [17]], ["b", 148, "comesFrom", ["b"], [129]], ["b", 116, "comesFrom", ["b"], [17]], ["b", 90, "comesFrom", ["b"], [17]], ["b", 108, "comesFrom", ["b"], [17]], ["s", 33, "comesFrom", ["s"], [11]], ["s", 144, "comesFrom", ["s"], [134]], ["s", 68, "comesFrom", ["s"], [11]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void convert ( int n , string a , string b ) { int l [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) l [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) l [ i ] = 1 ; } int cc = 0 ; int vl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( l [ i ] == 0 ) { if ( vl != 0 ) cc += 1 ; vl = 0 ; } else vl += 1 ; } if ( vl != 0 ) cc += 1 ; cout << cc << endl ; } int main ( ) { string a = \"101010\" ; string b = \"110011\" ; int n = a . length ( ) ; convert ( n , a , b ) ; return 0 ; }", "docstring": "Minimum steps to convert one binary string to other only using negation | C ++ implementation of the above approach ; Function to find the minimum steps to convert string a to string b ; array to mark the positions needed to be negated ; If two character are not same then they need to be negated ; To count the blocks of 1 ; To count the number of 1 ' s ▁ in ▁ ▁ each ▁ block ▁ of ▁ 1' s ; For the last block of 1 's ; Driver code", "dfg": [["n", 23, "comesFrom", ["n"], [11]], ["n", 37, "comesFrom", ["n"], [11]], ["n", 57, "comesFrom", ["n"], [11]], ["n", 101, "comesFrom", ["n"], [11]], ["n", 185, "comesFrom", ["n"], [175]], ["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 55, "comesFrom", ["i"], [51]], ["i", 59, "comesFrom", ["i"], [51]], ["i", 99, "comesFrom", ["i"], [95]], ["i", 103, "comesFrom", ["i"], [95]], ["i", 44, "comesFrom", ["i"], [31]], ["i", 67, "comesFrom", ["i"], [51]], ["i", 72, "comesFrom", ["i"], [51]], ["i", 77, "comesFrom", ["i"], [51]], ["i", 111, "comesFrom", ["i"], [95]], ["vl", 140, "comesFrom", ["vl"], [133]], ["vl", 119, "comesFrom", ["vl"], [89]], ["cc", 150, "comesFrom", ["cc"], [144]], ["a", 187, "comesFrom", ["a"], [161]], ["a", 177, "comesFrom", ["a"], [161]], ["a", 65, "comesFrom", ["a"], [14]], ["b", 189, "comesFrom", ["b"], [168]], ["b", 70, "comesFrom", ["b"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void StringMatch ( string s ) { int lo = 0 , hi = s . length ( ) , len = s . length ( ) ; vector < int > ans ; for ( int x = 0 ; x < len ; x ++ ) { if ( s [ x ] == ' I ' ) { ans . push_back ( lo ) ; lo += 1 ; } else { ans . push_back ( hi ) ; hi -= 1 ; } } ans . push_back ( lo ) ; cout << \" [ \" ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] ; if ( i != ans . size ( ) - 1 ) cout << \" , \" ; } cout << \" ] \" ; } int main ( ) { string S = \" IDID \" ; StringMatch ( S ) ; return 0 ; }", "docstring": "Generate a sequence with the given operations | C ++ Implementation of above approach ; function to find minimum required permutation ; Driver code", "dfg": [["x", 48, "comesFrom", ["x"], [44]], ["x", 52, "comesFrom", ["x"], [44]], ["x", 60, "comesFrom", ["x"], [44]], ["len", 50, "comesFrom", ["len"], [27]], ["i", 117, "comesFrom", ["i"], [113]], ["i", 125, "comesFrom", ["i"], [113]], ["i", 138, "comesFrom", ["i"], [113]], ["i", 133, "comesFrom", ["i"], [113]], ["ans", 97, "comesFrom", ["ans"], [39]], ["ans", 119, "comesFrom", ["ans"], [39]], ["ans", 131, "comesFrom", ["ans"], [39]], ["ans", 70, "comesFrom", ["ans"], [39]], ["ans", 84, "comesFrom", ["ans"], [39]], ["ans", 140, "comesFrom", ["ans"], [39]], ["lo", 101, "comesFrom", ["lo"], [77]], ["lo", 74, "comesFrom", ["lo"], [15]], ["S", 176, "comesFrom", ["S"], [168]], ["s", 21, "comesFrom", ["s"], [11]], ["s", 29, "comesFrom", ["s"], [11]], ["s", 58, "comesFrom", ["s"], [11]], ["hi", 88, "comesFrom", ["hi"], [19]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int countWays ( string s1 , string s2 , int n ) { int a , b , c , d ; a = b = c = d = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s2 [ i ] == '0' ) { if ( s1 [ i ] == '0' ) { c ++ ; } else { d ++ ; } } else { if ( s1 [ i ] == '0' ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; } int main ( ) { int n = 5 ; string s1 = \"01011\" ; string s2 = \"11001\" ; cout << countWays ( s1 , s2 , n ) ; return 0 ; }", "docstring": "Number of ways to swap two bit of s1 so that bitwise OR of s1 and s2 changes | C ++ program to find no of ways to swap bits of s1 so that bitwise OR of s1 and s2 changes ; Function to find number of ways ; initialise result that store No . of swaps required ; Traverse both strings and check the bits as explained ; calculate result ; Driver code", "dfg": [["result", 135, "comesFrom", ["result"], [120]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 55, "comesFrom", ["i"], [47]], ["i", 63, "comesFrom", ["i"], [47]], ["i", 75, "comesFrom", ["i"], [47]], ["i", 100, "comesFrom", ["i"], [47]], ["n", 53, "comesFrom", ["n"], [17]], ["n", 170, "comesFrom", ["n"], [144]], ["c", 130, "comesFrom", ["c"], [33]], ["c", 128, "comesFrom", ["c"], [33]], ["c", 83, "comesFrom", ["c"], [33]], ["d", 132, "comesFrom", ["d"], [35]], ["d", 124, "comesFrom", ["d"], [35]], ["d", 89, "comesFrom", ["d"], [35]], ["s1", 166, "comesFrom", ["s1"], [149]], ["s1", 73, "comesFrom", ["s1"], [11]], ["s1", 98, "comesFrom", ["s1"], [11]], ["s2", 168, "comesFrom", ["s2"], [156]], ["s2", 61, "comesFrom", ["s2"], [14]], ["a", 122, "comesFrom", ["a"], [29]], ["a", 108, "comesFrom", ["a"], [29]], ["b", 126, "comesFrom", ["b"], [31]], ["b", 114, "comesFrom", ["b"], [31]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int returnWinner ( string s , int l ) { int freq [ 26 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] & 1 ) cnt ++ ; } if ( cnt == 0 cnt & 1 ) return 1 ; else return 2 ; } int main ( ) { string s = \" abaaab \" ; int l = s . length ( ) ; int winner = returnWinner ( s , l ) ; cout << \" Player - \" << winner ; return 0 ; }", "docstring": "Find the player who rearranges the characters to get a palindrome string first | C ++ program to print the winner of the game ; Function that returns the winner of the game ; Initialize the freq array to 0 ; Iterate and count the frequencies of each character in the string ; Count the odd occurring character ; If odd occurrence ; Check condition for Player - 1 winning the game ; Driver code ; Function call that returns the winner", "dfg": [["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 76, "comesFrom", ["i"], [72]], ["i", 80, "comesFrom", ["i"], [72]], ["i", 88, "comesFrom", ["i"], [72]], ["i", 52, "comesFrom", ["i"], [36]], ["l", 42, "comesFrom", ["l"], [14]], ["l", 142, "comesFrom", ["l"], [127]], ["winner", 151, "comesFrom", ["winner"], [136]], ["cnt", 99, "comesFrom", ["cnt"], [65]], ["cnt", 102, "comesFrom", ["cnt"], [65]], ["cnt", 93, "comesFrom", ["cnt"], [65]], ["s", 129, "comesFrom", ["s"], [120]], ["s", 140, "comesFrom", ["s"], [120]], ["s", 50, "comesFrom", ["s"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxProductSum ( string str , int m ) { int n = str . length ( ) ; int maxProd = INT_MIN , maxSum = INT_MIN ; for ( int i = 0 ; i <= n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - '0' ) ; sum = sum + ( str [ j ] - '0' ) ; } maxProd = max ( maxProd , product ) ; maxSum = max ( maxSum , sum ) ; } cout << \" Maximum ▁ Product ▁ = ▁ \" << maxProd ; cout << \" Maximum Sum = \" } int main ( ) { string str = \"3605356297\" ; int m = 3 ; maxProductSum ( str , m ) ; }", "docstring": "Maximum sum and product of the M consecutive digits in a number | C ++ implementation of the above approach ; Function to find the maximum product ; Driver code", "dfg": [["i", 42, "comesFrom", ["i"], [38]], ["i", 48, "comesFrom", ["i"], [38]], ["i", 72, "comesFrom", ["i"], [66]], ["maxProd", 134, "comesFrom", ["maxProd"], [109]], ["maxProd", 113, "comesFrom", ["maxProd"], [109]], ["n", 44, "comesFrom", ["n"], [18]], ["m", 46, "comesFrom", ["m"], [14]], ["m", 164, "comesFrom", ["m"], [156]], ["m", 70, "comesFrom", ["m"], [14]], ["str", 162, "comesFrom", ["str"], [149]], ["str", 20, "comesFrom", ["str"], [11]], ["str", 83, "comesFrom", ["str"], [11]], ["str", 98, "comesFrom", ["str"], [11]], ["j", 68, "comesFrom", ["j"], [64]], ["j", 74, "comesFrom", ["j"], [64]], ["j", 85, "comesFrom", ["j"], [64]], ["j", 100, "comesFrom", ["j"], [64]], ["product", 115, "comesFrom", ["product"], [78]], ["product", 80, "comesFrom", ["product"], [78]], ["maxSum", 122, "comesFrom", ["maxSum"], [118]], ["sum", 124, "comesFrom", ["sum"], [93]], ["sum", 95, "comesFrom", ["sum"], [93]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' ) return false ; return true ; } string replacingConsonants ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s [ i ] ) ) continue ; else { if ( s [ i ] > ' a ' && s [ i ] < ' e ' ) { if ( abs ( s [ i ] - ' a ' ) > abs ( s [ i ] - ' e ' ) ) s [ i ] = ' e ' ; else s [ i ] = ' a ' ; } else if ( s [ i ] > ' e ' && s [ i ] < ' i ' ) { if ( abs ( s [ i ] - ' e ' ) > abs ( s [ i ] - ' i ' ) ) s [ i ] = ' i ' ; else s [ i ] = ' e ' ; } else if ( s [ i ] > ' i ' && s [ i ] < ' o ' ) { if ( abs ( s [ i ] - ' i ' ) > abs ( s [ i ] - ' o ' ) ) s [ i ] = ' o ' ; else s [ i ] = ' i ' ; } else if ( s [ i ] > ' o ' && s [ i ] < ' u ' ) { if ( abs ( s [ i ] - ' o ' ) > abs ( s [ i ] - ' u ' ) ) s [ i ] = ' u ' ; else s [ i ] = ' o ' ; } else if ( s [ i ] > ' u ' ) s [ i ] = ' u ' ; } } return s ; } int main ( ) { string s = \" geeksforgeeks \" ; cout << replacingConsonants ( s ) ; return 0 ; }", "docstring": "Replace all consonants with nearest vowels in a string | C ++ program to replace all consonants with nearest vowels in a string ; Function to check if a character is vowel or not ; Function to replace consonant with nearest vowels ; if , string element is vowel , jump to next element ; check if consonant lies between two vowels , if it lies , than replace it with nearest vowel ; here the absolute difference of ascii value is considered ; when s [ i ] is equal to either ' v ' , ' w ' , ' x ' , ' y ' , ' z ' ; Driver code", "dfg": [["s", 450, "comesFrom", ["s"], [67]], ["s", 79, "comesFrom", ["s"], [67]], ["s", 469, "comesFrom", ["s"], [459]], ["s", 93, "comesFrom", ["s"], [67]], ["s", 105, "comesFrom", ["s"], [67]], ["s", 116, "comesFrom", ["s"], [67]], ["s", 158, "comesFrom", ["s"], [67]], ["s", 170, "comesFrom", ["s"], [67]], ["s", 185, "comesFrom", ["s"], [67]], ["s", 196, "comesFrom", ["s"], [67]], ["s", 238, "comesFrom", ["s"], [67]], ["s", 132, "comesFrom", ["s"], [67]], ["s", 146, "comesFrom", ["s"], [67]], ["s", 250, "comesFrom", ["s"], [67]], ["s", 265, "comesFrom", ["s"], [67]], ["s", 276, "comesFrom", ["s"], [67]], ["s", 318, "comesFrom", ["s"], [67]], ["s", 212, "comesFrom", ["s"], [67]], ["s", 226, "comesFrom", ["s"], [67]], ["s", 330, "comesFrom", ["s"], [67]], ["s", 345, "comesFrom", ["s"], [67]], ["s", 356, "comesFrom", ["s"], [67]], ["s", 398, "comesFrom", ["s"], [67]], ["s", 425, "comesFrom", ["s"], [67]], ["s", 436, "comesFrom", ["s"], [67]], ["s", 292, "comesFrom", ["s"], [67]], ["s", 306, "comesFrom", ["s"], [67]], ["s", 410, "comesFrom", ["s"], [67]], ["s", 372, "comesFrom", ["s"], [67]], ["s", 386, "comesFrom", ["s"], [67]], ["i", 77, "comesFrom", ["i"], [73]], ["i", 85, "comesFrom", ["i"], [73]], ["i", 95, "comesFrom", ["i"], [73]], ["i", 107, "comesFrom", ["i"], [73]], ["i", 118, "comesFrom", ["i"], [73]], ["i", 160, "comesFrom", ["i"], [73]], ["i", 172, "comesFrom", ["i"], [73]], ["i", 187, "comesFrom", ["i"], [73]], ["i", 198, "comesFrom", ["i"], [73]], ["i", 240, "comesFrom", ["i"], [73]], ["i", 134, "comesFrom", ["i"], [73]], ["i", 148, "comesFrom", ["i"], [73]], ["i", 252, "comesFrom", ["i"], [73]], ["i", 267, "comesFrom", ["i"], [73]], ["i", 278, "comesFrom", ["i"], [73]], ["i", 320, "comesFrom", ["i"], [73]], ["i", 214, "comesFrom", ["i"], [73]], ["i", 228, "comesFrom", ["i"], [73]], ["i", 332, "comesFrom", ["i"], [73]], ["i", 347, "comesFrom", ["i"], [73]], ["i", 358, "comesFrom", ["i"], [73]], ["i", 400, "comesFrom", ["i"], [73]], ["i", 427, "comesFrom", ["i"], [73]], ["i", 438, "comesFrom", ["i"], [73]], ["i", 294, "comesFrom", ["i"], [73]], ["i", 308, "comesFrom", ["i"], [73]], ["i", 412, "comesFrom", ["i"], [73]], ["i", 374, "comesFrom", ["i"], [73]], ["i", 388, "comesFrom", ["i"], [73]], ["ch", 48, "comesFrom", ["ch"], [11]], ["ch", 40, "comesFrom", ["ch"], [11]], ["ch", 32, "comesFrom", ["ch"], [11]], ["ch", 16, "comesFrom", ["ch"], [11]], ["ch", 24, "comesFrom", ["ch"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( string s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = INT_MIN ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' o ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == ' x ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' x ' ) ) left = 1 ; coun = ceil ( ( double ) coun / ( right + left ) ) ; max_length = max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; } int main ( ) { string s = \" oooxoooooooooxooo \" ; int n = s . size ( ) ; cout << maxLength ( s , n ) ; return 0 ; }", "docstring": "Find time taken for signal to reach all positions in a string | C ++ program to Find time taken for signal to reach all positions in a string ; Returns time needed for signal to traverse through complete string . ; for the calculation of last index ; for strings like oxoooo , xoxxoooo . . ; if coun is greater than max_length ; if ' x ' is present at the right side of max_length ; if ' x ' is present at left side of max_length ; We use ceiling function to handle odd number ' o ' s ; Driver code", "dfg": [["max_length", 174, "comesFrom", ["max_length"], [157]], ["max_length", 80, "comesFrom", ["max_length"], [31]], ["max_length", 161, "comesFrom", ["max_length"], [157]], ["i", 50, "comesFrom", ["i"], [46]], ["i", 54, "comesFrom", ["i"], [46]], ["i", 62, "comesFrom", ["i"], [46]], ["i", 95, "comesFrom", ["i"], [46]], ["i", 112, "comesFrom", ["i"], [46]], ["i", 123, "comesFrom", ["i"], [46]], ["n", 52, "comesFrom", ["n"], [14]], ["n", 204, "comesFrom", ["n"], [190]], ["s", 37, "comesFrom", ["s"], [35]], ["s", 192, "comesFrom", ["s"], [183]], ["s", 202, "comesFrom", ["s"], [183]], ["s", 60, "comesFrom", ["s"], [35]], ["s", 93, "comesFrom", ["s"], [35]], ["s", 121, "comesFrom", ["s"], [35]], ["coun", 71, "comesFrom", ["coun"], [27]], ["coun", 78, "comesFrom", ["coun"], [27]], ["coun", 163, "comesFrom", ["coun"], [141]], ["coun", 148, "comesFrom", ["coun"], [141]], ["coun", 114, "comesFrom", ["coun"], [27]], ["coun", 125, "comesFrom", ["coun"], [27]], ["right", 151, "comesFrom", ["right"], [104]], ["left", 153, "comesFrom", ["left"], [137]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string printLargestString ( string s , int l , int r ) { int freq [ 26 ] = { 0 } ; l -- ; r -- ; for ( int i = min ( l , r ) ; i <= max ( l , r ) ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } string ans = \" \" ; for ( int i = 25 ; i >= 0 ; i -- ) { while ( freq [ i ] ) { ans += char ( ' a ' + i ) ; freq [ i ] -- ; } } return ans ; } int main ( ) { string s = \" striver \" ; int l = 3 , r = 5 ; cout << printLargestString ( s , l , r ) ; return 0 ; }", "docstring": "Lexicographically largest string formed from the characters in range L and R | C ++ program to print the lexicographically largest string that can be formed from the characters in range L and R ; Function to return the lexicographically largest string ; hash array ; make 0 - based indexing ; iterate and count frequencies of character ; ans string ; iterate in frequency array ; add til all characters are added ; Driver Code", "dfg": [["ans", 129, "comesFrom", ["ans"], [107]], ["l", 30, "comesFrom", ["l"], [14]], ["l", 52, "comesFrom", ["l"], [14]], ["l", 159, "comesFrom", ["l"], [145]], ["l", 43, "comesFrom", ["l"], [14]], ["r", 33, "comesFrom", ["r"], [17]], ["r", 54, "comesFrom", ["r"], [17]], ["r", 161, "comesFrom", ["r"], [149]], ["r", 45, "comesFrom", ["r"], [17]], ["i", 48, "comesFrom", ["i"], [39]], ["i", 57, "comesFrom", ["i"], [39]], ["i", 91, "comesFrom", ["i"], [87]], ["i", 95, "comesFrom", ["i"], [87]], ["i", 103, "comesFrom", ["i"], [87]], ["i", 122, "comesFrom", ["i"], [87]], ["i", 65, "comesFrom", ["i"], [39]], ["i", 117, "comesFrom", ["i"], [87]], ["s", 157, "comesFrom", ["s"], [138]], ["s", 63, "comesFrom", ["s"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrange ( string s ) { int cc = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) cc ++ ; } int a [ s . length ( ) + 1 ] = { 0 } ; int qq [ ] [ 2 ] = { { 2 , 3 } , { 5 , 5 } } ; int n = sizeof ( qq ) / sizeof ( qq [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) { int l = qq [ i ] [ 0 ] , r = qq [ i ] [ 1 ] ; l -- , r -- ; a [ l ] ++ ; a [ r + 1 ] -- ; } int len_a = sizeof ( a ) / sizeof ( a [ 0 ] ) ; for ( int i = 1 ; i < len_a ; i ++ ) { a [ i ] += a [ i - 1 ] ; } int zz [ s . length ( ) ] = { 0 } ; for ( int i = 0 ; i < len_a - 1 ; i ++ ) { if ( a [ i ] > 0 ) { if ( cc > 0 ) { zz [ i ] = 1 ; cc -- ; } else break ; } if ( cc == 0 ) break ; } if ( cc > 0 ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( zz [ i ] == 0 ) { zz [ i ] = 1 ; cc -- ; } if ( cc == 0 ) break ; } } for ( int i = 0 ; i < s . length ( ) ; i ++ ) cout << zz [ i ] ; cout << endl ; } int main ( ) { string str = \"11100\" ; arrange ( str ) ; return 0 ; }", "docstring": "Arrange a binary string to get maximum value within a range of indices | C ++ implementation of the approach ; Storing the count of 1 's in the string ; Query of l and r ; Applying range update technique . ; Taking prefix sum to get the range update values ; Final array which will store the arranged string ; if after maximizing the ranges any 1 is left then we maximize the string lexicographically . ; Driver Code", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 34, "comesFrom", ["i"], [22]], ["i", 114, "comesFrom", ["i"], [110]], ["i", 118, "comesFrom", ["i"], [110]], ["i", 187, "comesFrom", ["i"], [183]], ["i", 191, "comesFrom", ["i"], [183]], ["i", 229, "comesFrom", ["i"], [225]], ["i", 235, "comesFrom", ["i"], [225]], ["i", 344, "comesFrom", ["i"], [340]], ["i", 352, "comesFrom", ["i"], [340]], ["i", 294, "comesFrom", ["i"], [290]], ["i", 302, "comesFrom", ["i"], [290]], ["i", 359, "comesFrom", ["i"], [340]], ["i", 197, "comesFrom", ["i"], [183]], ["i", 42, "comesFrom", ["i"], [22]], ["i", 127, "comesFrom", ["i"], [110]], ["i", 137, "comesFrom", ["i"], [110]], ["i", 202, "comesFrom", ["i"], [183]], ["i", 243, "comesFrom", ["i"], [225]], ["i", 310, "comesFrom", ["i"], [290]], ["i", 258, "comesFrom", ["i"], [225]], ["i", 318, "comesFrom", ["i"], [290]], ["n", 116, "comesFrom", ["n"], [92]], ["len_a", 189, "comesFrom", ["len_a"], [165]], ["len_a", 231, "comesFrom", ["len_a"], [165]], ["cc", 282, "comesFrom", ["cc"], [15]], ["cc", 49, "comesFrom", ["cc"], [15]], ["cc", 273, "comesFrom", ["cc"], [15]], ["cc", 251, "comesFrom", ["cc"], [15]], ["cc", 329, "comesFrom", ["cc"], [15]], ["cc", 263, "comesFrom", ["cc"], [15]], ["cc", 323, "comesFrom", ["cc"], [15]], ["str", 381, "comesFrom", ["str"], [373]], ["s", 28, "comesFrom", ["s"], [11]], ["s", 346, "comesFrom", ["s"], [11]], ["s", 211, "comesFrom", ["s"], [11]], ["s", 40, "comesFrom", ["s"], [11]], ["s", 56, "comesFrom", ["s"], [11]], ["s", 296, "comesFrom", ["s"], [11]], ["l", 143, "comesFrom", ["l"], [123]], ["l", 151, "comesFrom", ["l"], [123]], ["r", 146, "comesFrom", ["r"], [133]], ["r", 157, "comesFrom", ["r"], [133]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areVowelsInOrder ( string s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; } int main ( ) { string s = \" aabbbddeecc \" ; if ( areVowelsInOrder ( s ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check whether the vowels in a string are in alphabetical order or not | C ++ implementation of above approach ; Function that checks whether the vowel characters in a string are in alphabetical order or not ; ASCII Value 64 is less than all the alphabets so using it as a default value ; check if the vowels in the string are sorted or not ; if the vowel is smaller than the previous vowel ; store the vowel ; Driver code ; check whether the vowel characters in a string are in alphabetical order or not", "dfg": [["i", 38, "comesFrom", ["i"], [34]], ["i", 42, "comesFrom", ["i"], [34]], ["i", 90, "comesFrom", ["i"], [34]], ["i", 80, "comesFrom", ["i"], [34]], ["i", 104, "comesFrom", ["i"], [34]], ["i", 70, "comesFrom", ["i"], [34]], ["i", 50, "comesFrom", ["i"], [34]], ["i", 60, "comesFrom", ["i"], [34]], ["i", 118, "comesFrom", ["i"], [34]], ["n", 40, "comesFrom", ["n"], [15]], ["s", 17, "comesFrom", ["s"], [11]], ["s", 144, "comesFrom", ["s"], [134]], ["s", 88, "comesFrom", ["s"], [11]], ["s", 102, "comesFrom", ["s"], [11]], ["s", 78, "comesFrom", ["s"], [11]], ["s", 48, "comesFrom", ["s"], [11]], ["s", 68, "comesFrom", ["s"], [11]], ["s", 116, "comesFrom", ["s"], [11]], ["s", 58, "comesFrom", ["s"], [11]], ["c", 107, "comesFrom", ["c"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string newString ( string s ) { int l = s . length ( ) ; int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s [ i ] - ' a ' ] += 1 ; } string ans = \" \" ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < freq [ i ] ; j ++ ) { ans += ( char ) ( 97 + i ) ; } } return ans ; } int main ( ) { string s = \" aabab \" ; cout << newString ( s ) ; return 0 ; }", "docstring": "Rearrange the string to maximize the number of palindromic substrings | C ++ program to rearrange the string such to maximize the number of palindromic substrings ; Function to return the newString ; length of string ; hashing array ; iterate and count ; resulting string ; form the resulting string ; number of times character appears ; append to resulting string ; Driver Code", "dfg": [["ans", 119, "comesFrom", ["ans"], [105]], ["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 79, "comesFrom", ["i"], [75]], ["i", 83, "comesFrom", ["i"], [75]], ["i", 98, "comesFrom", ["i"], [75]], ["i", 52, "comesFrom", ["i"], [36]], ["i", 113, "comesFrom", ["i"], [75]], ["l", 42, "comesFrom", ["l"], [15]], ["s", 17, "comesFrom", ["s"], [11]], ["s", 138, "comesFrom", ["s"], [128]], ["s", 50, "comesFrom", ["s"], [11]], ["j", 94, "comesFrom", ["j"], [90]], ["j", 101, "comesFrom", ["j"], [90]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Remainder ( string str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - '0' ) ; Rem = Num % R ; } return Rem ; } int main ( ) { string str = \"13589234356546756\" ; int R = 13 ; cout << Remainder ( str , R ) ; return 0 ; }", "docstring": "Program to find remainder when large number is divided by r | CPP implementation to find Remainder when a large Number is divided by R ; Function to Return Remainder ; len is variable to store the length of Number string . ; loop that find Remainder ; Return the remainder ; Driver code ; Get the large number as string ; Get the divisor R ; Find and print the remainder", "dfg": [["Rem", 73, "comesFrom", ["Rem"], [65]], ["Rem", 50, "comesFrom", ["Rem"], [29]], ["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 57, "comesFrom", ["i"], [36]], ["len", 42, "comesFrom", ["len"], [18]], ["str", 20, "comesFrom", ["str"], [11]], ["str", 97, "comesFrom", ["str"], [82]], ["str", 55, "comesFrom", ["str"], [11]], ["R", 99, "comesFrom", ["R"], [89]], ["R", 69, "comesFrom", ["R"], [14]], ["Num", 67, "comesFrom", ["Num"], [48]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countWays ( int a [ ] , int n ) { int i , j ; long suff [ n ] ; if ( a [ n - 1 ] == 2 ) suff [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] == 2 ) suff [ i ] = suff [ i + 1 ] + 1 ; else suff [ i ] = suff [ i + 1 ] ; } long ss = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ss += suff [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && suff [ j ] >= 2 ) { ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) / 2 ; } } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && ( suff [ i ] - suff [ j ] ) >= 1 && suff [ j ] >= 1 ) { ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] ; } } } cout << ( ss ) ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 1 , 2 , 2 } ; int n = 6 ; countWays ( a , n ) ; return 0 ; }", "docstring": "Number of balanced bracket subsequence of length 2 and 4 | C ++ implementation of above approach ; Taking the frequency suffix sum of the number of 2 's present after every index ; Storing the count of subsequence ; Subsequence of length 2 ; Subsequence of length 4 of type 1 1 2 2 ; Subsequence of length 4 of type 1 2 1 2 ; Driver code", "dfg": [["n", 27, "comesFrom", ["n"], [16]], ["n", 116, "comesFrom", ["n"], [16]], ["n", 147, "comesFrom", ["n"], [16]], ["n", 224, "comesFrom", ["n"], [16]], ["n", 54, "comesFrom", ["n"], [16]], ["n", 346, "comesFrom", ["n"], [338]], ["n", 163, "comesFrom", ["n"], [16]], ["n", 240, "comesFrom", ["n"], [16]], ["n", 34, "comesFrom", ["n"], [16]], ["n", 43, "comesFrom", ["n"], [16]], ["i", 58, "comesFrom", ["i"], [52]], ["i", 62, "comesFrom", ["i"], [52]], ["i", 114, "comesFrom", ["i"], [110]], ["i", 118, "comesFrom", ["i"], [110]], ["i", 145, "comesFrom", ["i"], [141]], ["i", 149, "comesFrom", ["i"], [141]], ["i", 222, "comesFrom", ["i"], [218]], ["i", 226, "comesFrom", ["i"], [218]], ["i", 157, "comesFrom", ["i"], [141]], ["i", 234, "comesFrom", ["i"], [218]], ["i", 70, "comesFrom", ["i"], [52]], ["i", 77, "comesFrom", ["i"], [52]], ["i", 126, "comesFrom", ["i"], [110]], ["i", 135, "comesFrom", ["i"], [110]], ["i", 92, "comesFrom", ["i"], [52]], ["i", 82, "comesFrom", ["i"], [52]], ["i", 97, "comesFrom", ["i"], [52]], ["i", 173, "comesFrom", ["i"], [141]], ["i", 250, "comesFrom", ["i"], [218]], ["i", 265, "comesFrom", ["i"], [218]], ["i", 289, "comesFrom", ["i"], [218]], ["ss", 309, "comesFrom", ["ss"], [284]], ["j", 161, "comesFrom", ["j"], [155]], ["j", 165, "comesFrom", ["j"], [155]], ["j", 238, "comesFrom", ["j"], [232]], ["j", 242, "comesFrom", ["j"], [232]], ["j", 187, "comesFrom", ["j"], [155]], ["j", 278, "comesFrom", ["j"], [232]], ["j", 180, "comesFrom", ["j"], [155]], ["j", 300, "comesFrom", ["j"], [232]], ["j", 257, "comesFrom", ["j"], [232]], ["j", 198, "comesFrom", ["j"], [155]], ["j", 270, "comesFrom", ["j"], [232]], ["j", 294, "comesFrom", ["j"], [232]], ["j", 205, "comesFrom", ["j"], [155]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_carry ( string a , string b ) { int carry = 0 ; int count = 0 ; int len_a = a . length ( ) , len_b = b . length ( ) ; while ( len_a != 0 len_b != 0 ) { int x = 0 , y = 0 ; if ( len_a > 0 ) { x = a [ len_a - 1 ] - '0' ; len_a -- ; } if ( len_b > 0 ) { y = b [ len_b - 1 ] - '0' ; len_b -- ; } int sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; } int main ( ) { string a = \"9555\" , b = \"555\" ; int count = count_carry ( a , b ) ; if ( count == 0 ) cout << \"0 STRNEWLINE \" ; else if ( count == 1 ) cout << \"1 STRNEWLINE \" ; else cout << count << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Count the number of carry operations required to add two numbers | C ++ implementation of above approach ; Function to count the number of carry operations ; Initialize the value of carry to 0 ; Counts the number of carry operations ; Initialize len_a and len_b with the sizes of strings ; Assigning the ascii value of the character ; Add both numbers / digits ; If sum > 0 , increment count and set carry to 1 ; Else , set carry to 0 ; Driver code", "dfg": [["count", 142, "comesFrom", ["count"], [23]], ["count", 175, "comesFrom", ["count"], [164]], ["count", 188, "comesFrom", ["count"], [164]], ["count", 131, "comesFrom", ["count"], [23]], ["count", 201, "comesFrom", ["count"], [164]], ["a", 30, "comesFrom", ["a"], [11]], ["a", 168, "comesFrom", ["a"], [151]], ["a", 72, "comesFrom", ["a"], [11]], ["b", 38, "comesFrom", ["b"], [14]], ["b", 170, "comesFrom", ["b"], [157]], ["b", 96, "comesFrom", ["b"], [14]], ["len_a", 46, "comesFrom", ["len_a"], [28]], ["len_a", 65, "comesFrom", ["len_a"], [28]], ["len_a", 83, "comesFrom", ["len_a"], [28]], ["len_a", 74, "comesFrom", ["len_a"], [28]], ["len_b", 49, "comesFrom", ["len_b"], [36]], ["len_b", 89, "comesFrom", ["len_b"], [36]], ["len_b", 107, "comesFrom", ["len_b"], [36]], ["len_b", 98, "comesFrom", ["len_b"], [36]], ["carry", 118, "comesFrom", ["carry"], [18]], ["sum", 122, "comesFrom", ["sum"], [112]], ["x", 114, "comesFrom", ["x"], [70]], ["y", 116, "comesFrom", ["y"], [94]]]}
{"code": "#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool isInGivenBase ( string str , int base ) { if ( base > 16 ) return false ; else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str [ i ] >= '0' and str [ i ] < ( '0' + base ) ) ) return false ; } else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + base ) ) || ( str [ i ] >= ' A ' && str [ i ] < ( ' A ' + base - 10 ) ) ) ) return false ; } return true ; } int main ( ) { string str = \" AF87\" ; if ( isInGivenBase ( str , 16 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if a number is in given base or not | CPP program to check if given number is in given base or not . ; Allowed bases are till 16 ( Hexadecimal ) ; If base is below or equal to 10 , then all digits should be from 0 to 9. ; If base is below or equal to 16 , then all digits should be from 0 to 9 or from ' A ' ; Driver code", "dfg": [["base", 22, "comesFrom", ["base"], [17]], ["base", 32, "comesFrom", ["base"], [17]], ["base", 78, "comesFrom", ["base"], [17]], ["base", 130, "comesFrom", ["base"], [17]], ["base", 158, "comesFrom", ["base"], [17]], ["str", 189, "comesFrom", ["str"], [179]], ["str", 46, "comesFrom", ["str"], [14]], ["str", 97, "comesFrom", ["str"], [14]], ["str", 59, "comesFrom", ["str"], [14]], ["str", 68, "comesFrom", ["str"], [14]], ["str", 111, "comesFrom", ["str"], [14]], ["str", 120, "comesFrom", ["str"], [14]], ["str", 135, "comesFrom", ["str"], [14]], ["str", 146, "comesFrom", ["str"], [14]], ["i", 44, "comesFrom", ["i"], [40]], ["i", 52, "comesFrom", ["i"], [40]], ["i", 95, "comesFrom", ["i"], [91]], ["i", 103, "comesFrom", ["i"], [91]], ["i", 61, "comesFrom", ["i"], [40]], ["i", 70, "comesFrom", ["i"], [40]], ["i", 113, "comesFrom", ["i"], [91]], ["i", 122, "comesFrom", ["i"], [91]], ["i", 137, "comesFrom", ["i"], [91]], ["i", 148, "comesFrom", ["i"], [91]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void printIndex ( string str , string s ) { bool flag = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . substr ( i , s . length ( ) ) == s ) { cout << i << \" ▁ \" ; flag = true ; } } if ( flag == false ) cout << \" NONE \" ; } int main ( ) { string str1 = \" GeeksforGeeks \" ; string str2 = \" Geeks \" ; printIndex ( str1 , str2 ) ; return 0 ; }", "docstring": "Find indices of all occurrence of one string in other | C ++ program to find indices of all occurrences of one string in other . ; Driver code", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 37, "comesFrom", ["i"], [25]], ["i", 47, "comesFrom", ["i"], [25]], ["i", 61, "comesFrom", ["i"], [25]], ["flag", 75, "comesFrom", ["flag"], [67]], ["str1", 107, "comesFrom", ["str1"], [92]], ["str2", 109, "comesFrom", ["str2"], [99]], ["str", 31, "comesFrom", ["str"], [11]], ["str", 43, "comesFrom", ["str"], [11]], ["s", 56, "comesFrom", ["s"], [14]], ["s", 49, "comesFrom", ["s"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string merge ( string s1 , string s2 ) { string result = \" \" ; for ( int i = 0 ; i < s1 . length ( ) || i < s2 . length ( ) ; i ++ ) { if ( i < s1 . length ( ) ) result += s1 [ i ] ; if ( i < s2 . length ( ) ) result += s2 [ i ] ; } return result ; } int main ( ) { string s1 = \" geeks \" ; string s2 = \" forgeeks \" ; cout << merge ( s1 , s2 ) ; return 0 ; }", "docstring": "Alternatively Merge two Strings in Java | C ++ code to alternatively merge two strings ; Function for alternatively merging two strings ; To store the final string ; For every index in the strings ; First choose the ith character of the first string if it exists ; Then choose the ith character of the second string if it exists ; Driver code", "dfg": [["result", 87, "comesFrom", ["result"], [78]], ["i", 47, "comesFrom", ["i"], [27]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 39, "comesFrom", ["i"], [27]], ["i", 53, "comesFrom", ["i"], [27]], ["i", 70, "comesFrom", ["i"], [27]], ["i", 65, "comesFrom", ["i"], [27]], ["i", 82, "comesFrom", ["i"], [27]], ["s1", 113, "comesFrom", ["s1"], [96]], ["s1", 33, "comesFrom", ["s1"], [11]], ["s1", 63, "comesFrom", ["s1"], [11]], ["s1", 55, "comesFrom", ["s1"], [11]], ["s2", 115, "comesFrom", ["s2"], [103]], ["s2", 41, "comesFrom", ["s2"], [14]], ["s2", 80, "comesFrom", ["s2"], [14]], ["s2", 72, "comesFrom", ["s2"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; char getMaxOccurringChar ( char str [ ] ) { int freq [ 26 ] = { 0 } ; int max = -1 ; char result ; int len = strlen ( str ) ; for ( int i = 0 ; i < len ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( max < freq [ i ] ) { max = freq [ i ] ; result = ( char ) ( i + ' a ' ) ; } return result ; } int main ( ) { char str [ ] = \" sample ▁ program \" ; cout << \" Maximum ▁ occurring ▁ character ▁ = ▁ \" << getMaxOccurringChar ( str ) ; return 0 ; }", "docstring": "Maximum occurring character in an input string | Set | C ++ implementation to find the maximum occurring character in an input string which is lexicographically first ; function to find the maximum occurring character in an input string which is lexicographically first ; freq [ ] used as hash table ; to store maximum frequency ; to store the maximum occurring character ; length of ' str ' ; get frequency of each character of ' str ' ; for each character , where character is obtained by ( i + ' a ' ) check whether it is the maximum character so far and accodingly update ' result ' ; maximum occurring character ; Driver Code", "dfg": [["result", 119, "comesFrom", ["result"], [102]], ["i", 49, "comesFrom", ["i"], [45]], ["i", 53, "comesFrom", ["i"], [45]], ["i", 78, "comesFrom", ["i"], [74]], ["i", 82, "comesFrom", ["i"], [74]], ["i", 91, "comesFrom", ["i"], [74]], ["i", 99, "comesFrom", ["i"], [74]], ["i", 60, "comesFrom", ["i"], [45]], ["i", 108, "comesFrom", ["i"], [74]], ["len", 51, "comesFrom", ["len"], [35]], ["max", 87, "comesFrom", ["max"], [27]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int ALPHABET_SIZE = 26 ; struct trieNode { trieNode * t [ ALPHABET_SIZE ] ; int isEnd ; } ; trieNode * getNode ( ) { trieNode * temp = new ( trieNode ) ; for ( int i = 0 ; i < ALPHABET_SIZE ; i ++ ) temp -> t [ i ] = NULL ; temp -> isEnd = 0 ; return temp ; } void insert ( trieNode * root , string key ) { trieNode * trail ; trail = root ; for ( int i = 0 ; i < key . length ( ) ; i ++ ) { if ( trail -> t [ key [ i ] - ' a ' ] == NULL ) { trieNode * temp ; temp = getNode ( ) ; trail -> t [ key [ i ] - ' a ' ] = temp ; } trail = trail -> t [ key [ i ] - ' a ' ] ; } ( trail -> isEnd ) ++ ; } bool search_mod ( trieNode * root , string word ) { trieNode * trail ; trail = root ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { if ( trail -> t [ word [ i ] - ' a ' ] == NULL ) return false ; trail = trail -> t [ word [ i ] - ' a ' ] ; } if ( ( trail -> isEnd ) > 0 && trail != NULL ) { ( trail -> isEnd ) -- ; return true ; } else return false ; } void checkPossibility ( string sentence [ ] , int m , trieNode * root ) { int flag = 1 ; for ( int i = 0 ; i < m ; i ++ ) { if ( search_mod ( root , sentence [ i ] ) == false ) { cout << \" NO \" ; return ; } } cout << \" YES \" ; } void insertToTrie ( string dictionary [ ] , int n , trieNode * root ) { for ( int i = 0 ; i < n ; i ++ ) insert ( root , dictionary [ i ] ) ; } int main ( ) { trieNode * root ; root = getNode ( ) ; string dictionary [ ] = { \" find \" , \" a \" , \" geeks \" , \" all \" , \" for \" , \" on \" , \" geeks \" , \" answers \" , \" inter \" } ; int N = sizeof ( dictionary ) / sizeof ( dictionary [ 0 ] ) ; insertToTrie ( dictionary , N , root ) ; string sentence [ ] = { \" find \" , \" all \" , \" answers \" , \" on \" , \" geeks \" , \" for \" , \" geeks \" } ; int M = sizeof ( sentence ) / sizeof ( sentence [ 0 ] ) ; checkPossibility ( sentence , M , root ) ; return 0 ; }", "docstring": "Check if the given string of words can be formed from words present in the dictionary | C ++ program to check if a sentence can be formed from a given set of words . ; here isEnd is an integer that will store count of words ending at that node ; utility function to create a new node ; Initialize new node with null ; Function to insert new words in trie ; Iterate for the length of a word ; If the next key does not contains the character ; isEnd is increment so not only the word but its count is also stored ; Search function to find a word of a sentence ; Iterate for the complete length of the word ; If the character is not present then word is also not present ; If present move to next character in Trie ; If word foundthen decrement count of the word ; if the word is found decrement isEnd showing one occurrence of this word is already taken so ; Function to check if string can be formed from the sentence ; Iterate for all words in the string ; if a word is not found in a string then the sentence cannot be made from this dictionary of words ; If possible ; Function to insert all the words of dictionary in the Trie ; Driver Code ; Dictionary of words ; Calling Function to insert words of dictionary to tree ; String to be checked ; Function call to check possibility", "dfg": [["temp", 162, "comesFrom", ["temp"], [140]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 55, "comesFrom", ["i"], [47]], ["i", 103, "comesFrom", ["i"], [99]], ["i", 111, "comesFrom", ["i"], [99]], ["i", 218, "comesFrom", ["i"], [214]], ["i", 226, "comesFrom", ["i"], [214]], ["i", 331, "comesFrom", ["i"], [327]], ["i", 335, "comesFrom", ["i"], [327]], ["i", 394, "comesFrom", ["i"], [390]], ["i", 398, "comesFrom", ["i"], [390]], ["i", 62, "comesFrom", ["i"], [47]], ["i", 407, "comesFrom", ["i"], [390]], ["i", 173, "comesFrom", ["i"], [99]], ["i", 261, "comesFrom", ["i"], [214]], ["i", 347, "comesFrom", ["i"], [327]], ["i", 123, "comesFrom", ["i"], [99]], ["i", 238, "comesFrom", ["i"], [214]], ["i", 152, "comesFrom", ["i"], [99]], ["ALPHABET_SIZE", 53, "comesFrom", ["ALPHABET_SIZE"], [9]], ["ALPHABET_SIZE", 20, "comesFrom", ["ALPHABET_SIZE"], [9]], ["trail", 205, "comesFrom", ["trail"], [165]], ["trail", 185, "comesFrom", ["trail"], [165]], ["trail", 282, "comesFrom", ["trail"], [253]], ["trail", 167, "comesFrom", ["trail"], [165]], ["trail", 255, "comesFrom", ["trail"], [253]], ["trail", 275, "comesFrom", ["trail"], [253]], ["trail", 288, "comesFrom", ["trail"], [253]], ["trail", 117, "comesFrom", ["trail"], [92]], ["trail", 232, "comesFrom", ["trail"], [207]], ["trail", 146, "comesFrom", ["trail"], [92]], ["root", 492, "comesFrom", ["root"], [421]], ["root", 552, "comesFrom", ["root"], [421]], ["m", 333, "comesFrom", ["m"], [312]], ["n", 396, "comesFrom", ["n"], [380]], ["N", 490, "comesFrom", ["N"], [471]], ["M", 550, "comesFrom", ["M"], [531]], ["key", 105, "comesFrom", ["key"], [85]], ["key", 171, "comesFrom", ["key"], [85]], ["key", 121, "comesFrom", ["key"], [85]], ["key", 150, "comesFrom", ["key"], [85]], ["word", 220, "comesFrom", ["word"], [200]], ["word", 259, "comesFrom", ["word"], [200]], ["word", 236, "comesFrom", ["word"], [200]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isGreaterThanEqualTo ( string s1 , string s2 ) { if ( s1 . size ( ) > s2 . size ( ) ) return true ; return ( s1 == s2 ) ; } string multiply ( string s1 , string s2 ) { int n = s1 . size ( ) ; int m = s2 . size ( ) ; vector < int > result ( n + m , 0 ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) for ( int j = m - 1 ; j >= 0 ; j -- ) result [ i + j + 1 ] += ( s1 [ i ] - '0' ) * ( s2 [ j ] - '0' ) ; int size = result . size ( ) ; for ( int i = size - 1 ; i > 0 ; i -- ) { if ( result [ i ] >= 10 ) { result [ i - 1 ] += result [ i ] / 10 ; result [ i ] = result [ i ] % 10 ; } } int i = 0 ; while ( i < size && result [ i ] == 0 ) i ++ ; if ( i == size ) return \"0\" ; string temp ; while ( i < size ) { temp += ( result [ i ] + '0' ) ; i ++ ; } return temp ; } string removeLeadingZeores ( string s ) { int n = s . size ( ) ; int i = 0 ; while ( i < n && s [ i ] == '0' ) i ++ ; if ( i == n ) return \"0\" ; string temp ; while ( i < n ) temp += s [ i ++ ] ; return temp ; } bool isPower ( string s1 , string s2 ) { s1 = removeLeadingZeores ( s1 ) ; s2 = removeLeadingZeores ( s2 ) ; if ( s1 == \"0\" s2 == \"0\" ) return false ; if ( s1 == \"1\" && s2 == \"1\" ) return true ; if ( s1 == \"1\" s2 == \"1\" ) return true ; if ( s1 . size ( ) > s2 . size ( ) ) return isPower ( s2 , s1 ) ; string temp = s1 ; while ( ! isGreaterThanEqualTo ( s1 , s2 ) ) s1 = multiply ( s1 , temp ) ; return s1 == s2 ; } int main ( ) { string s1 = \"374747\" , s2 = \"52627712618930723\" ; cout << ( isPower ( s1 , s2 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ) ; s1 = \"4099\" , s2 = \"2\" ; cout << ( isPower ( s1 , s2 ) ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ) ; return 0 ; }", "docstring": "Given two numbers as strings , find if one is a power of other | CPP program to check if one number is power of other ; Multiply the numbers . It multiplies each digit of second string to each digit of first and stores the result . ; If the digit exceeds 9 , add the cumulative carry to previous digit . ; if all zeroes , return \"0\" . ; Remove starting zeroes . ; Removes Extra zeroes from front of a string . ; Make sure there are no leading zeroes in the string . ; Making sure that s1 is smaller . If it is greater , we recur we reversed parameters . ; Driver Code", "dfg": [["temp", 270, "comesFrom", ["temp"], [252]], ["temp", 341, "comesFrom", ["temp"], [332]], ["temp", 460, "comesFrom", ["temp"], [440]], ["i", 92, "comesFrom", ["i"], [86]], ["i", 96, "comesFrom", ["i"], [86]], ["i", 164, "comesFrom", ["i"], [158]], ["i", 168, "comesFrom", ["i"], [158]], ["i", 228, "comesFrom", ["i"], [211]], ["i", 233, "comesFrom", ["i"], [211]], ["i", 247, "comesFrom", ["i"], [211]], ["i", 309, "comesFrom", ["i"], [290]], ["i", 314, "comesFrom", ["i"], [290]], ["i", 328, "comesFrom", ["i"], [290]], ["i", 217, "comesFrom", ["i"], [211]], ["i", 265, "comesFrom", ["i"], [211]], ["i", 296, "comesFrom", ["i"], [290]], ["i", 223, "comesFrom", ["i"], [211]], ["i", 302, "comesFrom", ["i"], [290]], ["i", 336, "comesFrom", ["i"], [290]], ["i", 176, "comesFrom", ["i"], [158]], ["i", 117, "comesFrom", ["i"], [86]], ["i", 198, "comesFrom", ["i"], [158]], ["i", 257, "comesFrom", ["i"], [211]], ["i", 127, "comesFrom", ["i"], [86]], ["i", 184, "comesFrom", ["i"], [158]], ["i", 191, "comesFrom", ["i"], [158]], ["i", 203, "comesFrom", ["i"], [158]], ["s1", 464, "comesFrom", ["s1"], [454]], ["s1", 36, "comesFrom", ["s1"], [11]], ["s1", 55, "comesFrom", ["s1"], [46]], ["s1", 358, "comesFrom", ["s1"], [354]], ["s1", 370, "comesFrom", ["s1"], [354]], ["s1", 386, "comesFrom", ["s1"], [354]], ["s1", 403, "comesFrom", ["s1"], [354]], ["s1", 436, "comesFrom", ["s1"], [354]], ["s1", 19, "comesFrom", ["s1"], [11]], ["s1", 419, "comesFrom", ["s1"], [354]], ["s1", 449, "comesFrom", ["s1"], [442]], ["s1", 458, "comesFrom", ["s1"], [454]], ["s1", 492, "comesFrom", ["s1"], [475]], ["s1", 523, "comesFrom", ["s1"], [506]], ["s1", 125, "comesFrom", ["s1"], [46]], ["s2", 466, "comesFrom", ["s2"], [361]], ["s2", 38, "comesFrom", ["s2"], [14]], ["s2", 64, "comesFrom", ["s2"], [49]], ["s2", 365, "comesFrom", ["s2"], [361]], ["s2", 375, "comesFrom", ["s2"], [361]], ["s2", 392, "comesFrom", ["s2"], [361]], ["s2", 408, "comesFrom", ["s2"], [361]], ["s2", 434, "comesFrom", ["s2"], [361]], ["s2", 25, "comesFrom", ["s2"], [14]], ["s2", 425, "comesFrom", ["s2"], [361]], ["s2", 451, "comesFrom", ["s2"], [361]], ["s2", 494, "comesFrom", ["s2"], [481]], ["s2", 525, "comesFrom", ["s2"], [512]], ["s2", 136, "comesFrom", ["s2"], [49]], ["j", 108, "comesFrom", ["j"], [102]], ["j", 112, "comesFrom", ["j"], [102]], ["j", 119, "comesFrom", ["j"], [102]], ["j", 138, "comesFrom", ["j"], [102]], ["size", 235, "comesFrom", ["size"], [147]], ["size", 249, "comesFrom", ["size"], [147]], ["size", 151, "comesFrom", ["size"], [147]], ["size", 160, "comesFrom", ["size"], [147]], ["size", 219, "comesFrom", ["size"], [147]], ["size", 285, "comesFrom", ["size"], [147]], ["size", 421, "comesFrom", ["size"], [147]], ["size", 427, "comesFrom", ["size"], [147]], ["n", 316, "comesFrom", ["n"], [281]], ["n", 330, "comesFrom", ["n"], [281]], ["n", 76, "comesFrom", ["n"], [53]], ["n", 88, "comesFrom", ["n"], [53]], ["n", 298, "comesFrom", ["n"], [281]], ["m", 78, "comesFrom", ["m"], [62]], ["m", 104, "comesFrom", ["m"], [62]], ["result", 149, "comesFrom", ["result"], [74]], ["result", 115, "comesFrom", ["result"], [74]], ["result", 221, "comesFrom", ["result"], [74]], ["result", 174, "comesFrom", ["result"], [74]], ["result", 182, "comesFrom", ["result"], [74]], ["result", 196, "comesFrom", ["result"], [74]], ["result", 255, "comesFrom", ["result"], [74]], ["result", 189, "comesFrom", ["result"], [74]], ["result", 201, "comesFrom", ["result"], [74]], ["s", 283, "comesFrom", ["s"], [277]], ["s", 334, "comesFrom", ["s"], [277]], ["s", 300, "comesFrom", ["s"], [277]]]}
{"code": "#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int matchClosing ( char X [ ] , int start , int end , char open , char close ) { int c = 1 ; int i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) c ++ ; else if ( X [ i ] == close ) c -- ; if ( c == 0 ) return i ; i ++ ; } return i ; } int matchingOpening ( char X [ ] , int start , int end , char open , char close ) { int c = -1 ; int i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) c ++ ; else if ( X [ i ] == close ) c -- ; if ( c == 0 ) return i ; i -- ; } return -1 ; } bool isBalanced ( char X [ ] , int n ) { int i , j , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == ' ( ' ) j = matchClosing ( X , i , n - 1 , ' ( ' , ' ) ' ) ; else if ( X [ i ] == ' { ' ) j = matchClosing ( X , i , n - 1 , ' { ' , ' } ' ) ; else if ( X [ i ] == ' [ ' ) j = matchClosing ( X , i , n - 1 , ' [ ' , ' ] ' ) ; else { if ( X [ i ] == ' ) ' ) j = matchingOpening ( X , 0 , i , ' ( ' , ' ) ' ) ; else if ( X [ i ] == ' } ' ) j = matchingOpening ( X , 0 , i , ' { ' , ' } ' ) ; else if ( X [ i ] == ' ] ' ) j = matchingOpening ( X , 0 , i , ' [ ' , ' ] ' ) ; if ( j < 0 j > = i ) return false ; continue ; } if ( j >= n j < 0 ) return false ; start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == ' ( ' ) { x = matchClosing ( X , k , end , ' ( ' , ' ) ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ) ' ) { x = matchingOpening ( X , start , k , ' ( ' , ' ) ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' { ' ) { x = matchClosing ( X , k , end , ' { ' , ' } ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' } ' ) { x = matchingOpening ( X , start , k , ' { ' , ' } ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' [ ' ) { x = matchClosing ( X , k , end , ' [ ' , ' ] ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ] ' ) { x = matchingOpening ( X , start , k , ' [ ' , ' ] ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; } int main ( ) { char X [ ] = \" [ ( ) ] ( ) \" ; int n = 6 ; if ( isBalanced ( X , n ) ) printf ( \" Yes STRNEWLINE \" ) ; else printf ( \" No STRNEWLINE \" ) ; char Y [ ] = \" [ [ ( ) ] ] ) \" ; n = 7 ; if ( isBalanced ( Y , n ) ) printf ( \" Yes STRNEWLINE \" ) ; else printf ( \" No STRNEWLINE \" ) ; return 0 ; }", "docstring": "Check for balanced parentheses in an expression | O ( 1 ) space | C ++ code to check balanced parentheses with O ( 1 ) space . ; Function1 to match closing bracket ; Function1 to match opening bracket ; Function to check balanced parentheses ; helper variables ; Handling case of opening parentheses ; Handling case of closing parentheses ; If corresponding matching opening parentheses doesn 't  lie in given interval return 0 ; else continue ; If corresponding closing parentheses doesn 't lie in given interval  return 0 ; if found , now check for each opening and closing parentheses in this interval ; Driver Code", "dfg": [["i", 85, "comesFrom", ["i"], [33]], ["i", 201, "comesFrom", ["i"], [197]], ["i", 205, "comesFrom", ["i"], [197]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 123, "comesFrom", ["i"], [115]], ["i", 78, "comesFrom", ["i"], [33]], ["i", 80, "comesFrom", ["i"], [33]], ["i", 160, "comesFrom", ["i"], [115]], ["i", 162, "comesFrom", ["i"], [115]], ["i", 468, "comesFrom", ["i"], [445]], ["i", 50, "comesFrom", ["i"], [33]], ["i", 132, "comesFrom", ["i"], [115]], ["i", 213, "comesFrom", ["i"], [197]], ["i", 228, "comesFrom", ["i"], [197]], ["i", 63, "comesFrom", ["i"], [33]], ["i", 145, "comesFrom", ["i"], [115]], ["i", 252, "comesFrom", ["i"], [197]], ["i", 267, "comesFrom", ["i"], [197]], ["i", 291, "comesFrom", ["i"], [197]], ["i", 306, "comesFrom", ["i"], [197]], ["i", 331, "comesFrom", ["i"], [197]], ["i", 348, "comesFrom", ["i"], [197]], ["i", 368, "comesFrom", ["i"], [197]], ["i", 385, "comesFrom", ["i"], [197]], ["i", 405, "comesFrom", ["i"], [197]], ["i", 422, "comesFrom", ["i"], [197]], ["n", 203, "comesFrom", ["n"], [179]], ["n", 860, "comesFrom", ["n"], [850]], ["n", 897, "comesFrom", ["n"], [887]], ["n", 458, "comesFrom", ["n"], [179]], ["n", 230, "comesFrom", ["n"], [179]], ["n", 269, "comesFrom", ["n"], [179]], ["n", 308, "comesFrom", ["n"], [179]], ["start", 35, "comesFrom", ["start"], [15]], ["start", 125, "comesFrom", ["start"], [97]], ["start", 478, "comesFrom", ["start"], [466]], ["start", 567, "comesFrom", ["start"], [466]], ["start", 680, "comesFrom", ["start"], [466]], ["start", 793, "comesFrom", ["start"], [466]], ["start", 588, "comesFrom", ["start"], [466]], ["start", 701, "comesFrom", ["start"], [466]], ["start", 814, "comesFrom", ["start"], [466]], ["end", 43, "comesFrom", ["end"], [18]], ["end", 117, "comesFrom", ["end"], [100]], ["end", 484, "comesFrom", ["end"], [470]], ["end", 512, "comesFrom", ["end"], [470]], ["end", 625, "comesFrom", ["end"], [470]], ["end", 738, "comesFrom", ["end"], [470]], ["end", 537, "comesFrom", ["end"], [470]], ["end", 650, "comesFrom", ["end"], [470]], ["end", 763, "comesFrom", ["end"], [470]], ["j", 472, "comesFrom", ["j"], [414]], ["j", 456, "comesFrom", ["j"], [414]], ["j", 459, "comesFrom", ["j"], [414]], ["k", 482, "comesFrom", ["k"], [476]], ["k", 486, "comesFrom", ["k"], [476]], ["k", 494, "comesFrom", ["k"], [476]], ["k", 607, "comesFrom", ["k"], [476]], ["k", 720, "comesFrom", ["k"], [476]], ["k", 510, "comesFrom", ["k"], [476]], ["k", 623, "comesFrom", ["k"], [476]], ["k", 736, "comesFrom", ["k"], [476]], ["k", 551, "comesFrom", ["k"], [476]], ["k", 664, "comesFrom", ["k"], [476]], ["k", 777, "comesFrom", ["k"], [476]], ["k", 531, "comesFrom", ["k"], [476]], ["k", 569, "comesFrom", ["k"], [476]], ["k", 644, "comesFrom", ["k"], [476]], ["k", 682, "comesFrom", ["k"], [476]], ["k", 757, "comesFrom", ["k"], [476]], ["k", 795, "comesFrom", ["k"], [476]], ["k", 594, "comesFrom", ["k"], [476]], ["k", 707, "comesFrom", ["k"], [476]], ["k", 820, "comesFrom", ["k"], [476]], ["open", 53, "comesFrom", ["open"], [21]], ["open", 135, "comesFrom", ["open"], [103]], ["c", 55, "comesFrom", ["c"], [28]], ["c", 73, "comesFrom", ["c"], [28]], ["c", 137, "comesFrom", ["c"], [110]], ["c", 155, "comesFrom", ["c"], [110]], ["c", 68, "comesFrom", ["c"], [28]], ["c", 150, "comesFrom", ["c"], [110]], ["close", 66, "comesFrom", ["close"], [24]], ["close", 148, "comesFrom", ["close"], [106]], ["x", 533, "comesFrom", ["x"], [504]], ["x", 535, "comesFrom", ["x"], [504]], ["x", 646, "comesFrom", ["x"], [617]], ["x", 648, "comesFrom", ["x"], [617]], ["x", 759, "comesFrom", ["x"], [730]], ["x", 761, "comesFrom", ["x"], [730]], ["x", 590, "comesFrom", ["x"], [561]], ["x", 592, "comesFrom", ["x"], [561]], ["x", 703, "comesFrom", ["x"], [674]], ["x", 705, "comesFrom", ["x"], [674]], ["x", 816, "comesFrom", ["x"], [787]], ["x", 818, "comesFrom", ["x"], [787]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string possibleToSort ( int * arr , int n , string str ) { int max_element = -1 ; for ( long i = 0 ; i < str . size ( ) ; i ++ ) { max_element = max ( max_element , arr [ i ] ) ; if ( str [ i ] == '0' ) { if ( max_element > i + 1 ) return \" No \" ; } } return \" Yes \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; string str = \"01110\" ; cout << possibleToSort ( arr , n , str ) ; return 0 ; }", "docstring": "Sorting array with conditional swapping | CPP program to Check if it is possible to sort the array in ascending order . ; Function to check if it is possible to sort the array ; Calculating max_element at each iteration . ; if we can not swap the i - th element . ; if it is impossible to swap the max_element then we can not sort the array . ; Otherwise , we can sort the array . ; Driver function", "dfg": [["i", 33, "comesFrom", ["i"], [29]], ["i", 41, "comesFrom", ["i"], [29]], ["i", 61, "comesFrom", ["i"], [29]], ["i", 53, "comesFrom", ["i"], [29]], ["i", 73, "comesFrom", ["i"], [29]], ["str", 35, "comesFrom", ["str"], [18]], ["str", 145, "comesFrom", ["str"], [131]], ["str", 59, "comesFrom", ["str"], [18]], ["n", 143, "comesFrom", ["n"], [115]], ["max_element", 49, "comesFrom", ["max_element"], [45]], ["max_element", 71, "comesFrom", ["max_element"], [45]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; void findSubstring ( string str , ll power ) { ll i ; unordered_map < ll , ll > map ; int curr_power = 0 ; int len = str . length ( ) ; for ( i = 0 ; i < len ; i ++ ) { curr_power = curr_power + ( str [ i ] - ' a ' + 1 ) ; if ( curr_power == power ) { cout << \" Substring ▁ from ▁ index ▁ \" << 0 << \" ▁ to ▁ \" << i << \" ▁ has ▁ power ▁ \" << power << endl ; return ; } if ( map . find ( curr_power - power ) != map . end ( ) ) { cout << \" Substring ▁ from ▁ index ▁ \" << map [ curr_power - power ] + 1 << \" ▁ to ▁ \" << i << \" ▁ has ▁ power ▁ \" << power << endl ; return ; } map [ curr_power ] = i ; } cout << \" No ▁ substring ▁ with ▁ given ▁ power ▁ exists . \" ; } int main ( ) { string str = \" geeksforgeeks \" ; ll power = 36 ; findSubstring ( str , power ) ; return 0 ; }", "docstring": "Find sub | C ++ program to find substring with given power ; Function to print indexes of substring with power as given power . ; Create an empty map ; Maintains sum of powers of characters so far . ; Add current character power to curr_power . ; If curr_power is equal to target power we found a substring starting from index 0 and ending at index i . ; If curr_power - power already exists in map then we have found a subarray with target power . ; If we reach here , then no substring exists . ; Drivers code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrimeString ( string str ) { int len = str . length ( ) , n = 0 ; for ( int i = 0 ; i < len ; i ++ ) n += ( int ) str [ i ] ; if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int main ( ) { string str = \" geekRam \" ; if ( isPrimeString ( str ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; }", "docstring": "Prime String | C ++ program to find if string is a Prime or not . ; Function that checks if sum is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver code", "dfg": [["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 92, "comesFrom", ["i"], [88]], ["i", 94, "comesFrom", ["i"], [88]], ["i", 100, "comesFrom", ["i"], [98]], ["i", 48, "comesFrom", ["i"], [30]], ["i", 108, "comesFrom", ["i"], [98]], ["i", 115, "comesFrom", ["i"], [98]], ["len", 36, "comesFrom", ["len"], [15]], ["n", 96, "comesFrom", ["n"], [41]], ["n", 53, "comesFrom", ["n"], [41]], ["n", 62, "comesFrom", ["n"], [41]], ["n", 71, "comesFrom", ["n"], [41]], ["n", 76, "comesFrom", ["n"], [41]], ["n", 106, "comesFrom", ["n"], [41]], ["n", 112, "comesFrom", ["n"], [41]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 145, "comesFrom", ["str"], [135]], ["str", 46, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( string s ) { int count [ 26 ] = { 0 } ; for ( char x : s ) count [ x - ' a ' ] ++ ; count [ s [ 0 ] - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; } int main ( ) { string s = \" acbbcc \" ; cout << countWays ( s ) << endl ; return 0 ; }", "docstring": "Ways to split string such that each partition starts with distinct character | CPP Program to find number of way to split string such that each partition starts with distinct character with maximum number of partitions . ; Returns the number of we can split the string ; Finding the frequency of each character . ; making frequency of first character of string equal to 1. ; Finding the product of frequency of occurrence of each character . ; Driven Program", "dfg": [["s", 29, "comesFrom", ["s"], [11]], ["s", 114, "comesFrom", ["s"], [104]], ["s", 45, "comesFrom", ["s"], [11]], ["ans", 95, "comesFrom", ["ans"], [87]], ["i", 71, "comesFrom", ["i"], [67]], ["i", 76, "comesFrom", ["i"], [67]], ["i", 82, "comesFrom", ["i"], [67]], ["i", 91, "comesFrom", ["i"], [67]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexoString ( string s , int k ) { int n = s . size ( ) ; vector < char > v ; map < char , int > mp ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( mp [ s [ i ] ] == 0 ) { mp [ s [ i ] ] = 1 ; v . push_back ( s [ i ] ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; if ( k > n ) { cout << s ; for ( int i = n ; i < k ; i ++ ) { cout << v [ 0 ] ; } } for ( int i = k - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != v [ v . size ( ) - 1 ] ) { for ( int j = 0 ; j < i ; j ++ ) { cout << s [ j ] ; } for ( int j = 0 ; j < v . size ( ) ; j ++ ) { if ( v [ j ] > s [ i ] ) { cout << v [ j ] ; break ; } } for ( int j = i + 1 ; j < k ; j ++ ) cout << v [ 0 ] ; return ; } } cout << \" No ▁ lexicographically ▁ greater ▁ string ▁ of ▁ length ▁ \" << k << \" ▁ possible ▁ here . \" ; } int main ( ) { string s = \" gi \" ; int k = 3 ; lexoString ( s , k ) ; return 0 ; }", "docstring": "Lexicographically next greater string using same character set | C ++ implementation of above algorithm . ; function to print output ; to store unique characters of the string ; to check uniqueness ; if mp [ s [ i ] ] = 0 then it is first time ; sort the unique characters ; simply add n - k smallest characters ; return ; end the program ; searching the first character left of index k and not equal to greatest character of the string ; finding the just next greater character than s [ i ] ; suffix with smallest character ; if we reach here then all indices to the left of k had the greatest character ; Driver code ; Function call", "dfg": [["i", 47, "comesFrom", ["i"], [43]], ["i", 55, "comesFrom", ["i"], [43]], ["i", 153, "comesFrom", ["i"], [147]], ["i", 157, "comesFrom", ["i"], [147]], ["i", 127, "comesFrom", ["i"], [123]], ["i", 131, "comesFrom", ["i"], [123]], ["i", 189, "comesFrom", ["i"], [147]], ["i", 165, "comesFrom", ["i"], [147]], ["i", 251, "comesFrom", ["i"], [147]], ["i", 65, "comesFrom", ["i"], [43]], ["i", 88, "comesFrom", ["i"], [43]], ["i", 76, "comesFrom", ["i"], [43]], ["i", 231, "comesFrom", ["i"], [147]], ["k", 111, "comesFrom", ["k"], [14]], ["k", 279, "comesFrom", ["k"], [14]], ["k", 307, "comesFrom", ["k"], [299]], ["k", 129, "comesFrom", ["k"], [14]], ["k", 149, "comesFrom", ["k"], [14]], ["k", 257, "comesFrom", ["k"], [14]], ["n", 113, "comesFrom", ["n"], [18]], ["s", 305, "comesFrom", ["s"], [292]], ["s", 20, "comesFrom", ["s"], [11]], ["s", 49, "comesFrom", ["s"], [11]], ["s", 118, "comesFrom", ["s"], [11]], ["s", 163, "comesFrom", ["s"], [11]], ["s", 63, "comesFrom", ["s"], [11]], ["s", 86, "comesFrom", ["s"], [11]], ["s", 74, "comesFrom", ["s"], [11]], ["s", 197, "comesFrom", ["s"], [11]], ["s", 229, "comesFrom", ["s"], [11]], ["v", 96, "comesFrom", ["v"], [30]], ["v", 102, "comesFrom", ["v"], [30]], ["v", 168, "comesFrom", ["v"], [30]], ["v", 82, "comesFrom", ["v"], [30]], ["v", 137, "comesFrom", ["v"], [30]], ["v", 212, "comesFrom", ["v"], [30]], ["v", 264, "comesFrom", ["v"], [30]], ["v", 170, "comesFrom", ["v"], [30]], ["v", 224, "comesFrom", ["v"], [30]], ["v", 237, "comesFrom", ["v"], [30]], ["mp", 61, "comesFrom", ["mp"], [38]], ["mp", 72, "comesFrom", ["mp"], [38]], ["j", 187, "comesFrom", ["j"], [183]], ["j", 191, "comesFrom", ["j"], [183]], ["j", 210, "comesFrom", ["j"], [206]], ["j", 218, "comesFrom", ["j"], [206]], ["j", 255, "comesFrom", ["j"], [249]], ["j", 259, "comesFrom", ["j"], [249]], ["j", 199, "comesFrom", ["j"], [183]], ["j", 226, "comesFrom", ["j"], [206]], ["j", 239, "comesFrom", ["j"], [206]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 256 ; long long int fact ( int n ) { long long int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int countPalinPermutations ( string & str ) { int n = str . length ( ) ; int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] ] ++ ; long long int res = fact ( n / 2 ) ; bool oddFreq = false ; for ( int i = 0 ; i < MAX ; i ++ ) { int half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return res ; } int main ( ) { string str = \" gffg \" ; cout << countPalinPermutations ( str ) ; return 0 ; }", "docstring": "Number of palindromic permutations | Set 1 | CPP program to find number of palindromic permutations of a given string ; Returns factorial of n ; Returns count of palindromic permutations of str . ; Count frequencies of all characters ; Since half of the characters decide count of palindromic permutations , we take ( n / 2 ) ! ; To make sure that there is at most one odd occurring char ; Traverse through all counts ; To make sure that the string can permute to form a palindrome ; If there are more than one odd occurring chars ; Divide all permutations with repeated characters ; Driver code", "dfg": [["res", 50, "comesFrom", ["res"], [43]], ["res", 182, "comesFrom", ["res"], [171]], ["res", 45, "comesFrom", ["res"], [43]], ["res", 173, "comesFrom", ["res"], [171]], ["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 87, "comesFrom", ["i"], [83]], ["i", 91, "comesFrom", ["i"], [83]], ["i", 127, "comesFrom", ["i"], [123]], ["i", 131, "comesFrom", ["i"], [123]], ["i", 47, "comesFrom", ["i"], [32]], ["i", 98, "comesFrom", ["i"], [83]], ["i", 140, "comesFrom", ["i"], [123]], ["i", 149, "comesFrom", ["i"], [123]], ["n", 38, "comesFrom", ["n"], [19]], ["n", 89, "comesFrom", ["n"], [62]], ["n", 110, "comesFrom", ["n"], [62]], ["MAX", 129, "comesFrom", ["MAX"], [9]], ["MAX", 73, "comesFrom", ["MAX"], [9]], ["str", 201, "comesFrom", ["str"], [191]], ["oddFreq", 159, "comesFrom", ["oddFreq"], [116]], ["half", 177, "comesFrom", ["half"], [136]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string getPalindrome ( string str ) { unordered_map < char , int > hmap ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) hmap [ str [ i ] ] ++ ; int oddCount = 0 ; char oddChar ; for ( auto x : hmap ) { if ( x . second % 2 != 0 ) { oddCount ++ ; oddChar = x . first ; } } if ( oddCount > 1 || oddCount == 1 && str . length ( ) % 2 == 0 ) return \" NO ▁ PALINDROME \" ; string firstHalf = \" \" , secondHalf = \" \" ; for ( auto x : hmap ) { string s ( x . second / 2 , x . first ) ; firstHalf = firstHalf + s ; secondHalf = s + secondHalf ; } return ( oddCount == 1 ) ? ( firstHalf + oddChar + secondHalf ) : ( firstHalf + secondHalf ) ; } int main ( ) { string s = \" mdaam \" ; cout << getPalindrome ( s ) ; return 0 ; }", "docstring": "Rearrange characters to form palindrome if possible | C ++ program to rearrange a string to make palindrome . ; Store counts of characters ; find the number of odd elements . Takes O ( n ) ; odd_cnt = 1 only if the length of str is odd ; Generate first halh of palindrome ; Build a string of floor ( count / 2 ) occurrences of current character ; Attach the built string to end of and begin of second half ; Insert odd character if there is any ; Driver code", "dfg": [["hmap", 62, "comesFrom", ["hmap"], [20]], ["hmap", 130, "comesFrom", ["hmap"], [20]], ["hmap", 40, "comesFrom", ["hmap"], [20]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 37, "comesFrom", ["i"], [25]], ["i", 44, "comesFrom", ["i"], [25]], ["str", 31, "comesFrom", ["str"], [11]], ["str", 42, "comesFrom", ["str"], [11]], ["str", 97, "comesFrom", ["str"], [11]], ["oddCount", 89, "comesFrom", ["oddCount"], [50]], ["oddCount", 162, "comesFrom", ["oddCount"], [50]], ["oddCount", 93, "comesFrom", ["oddCount"], [50]], ["oddCount", 76, "comesFrom", ["oddCount"], [50]], ["secondHalf", 172, "comesFrom", ["secondHalf"], [153]], ["secondHalf", 178, "comesFrom", ["secondHalf"], [153]], ["secondHalf", 157, "comesFrom", ["secondHalf"], [153]], ["firstHalf", 176, "comesFrom", ["firstHalf"], [147]], ["firstHalf", 149, "comesFrom", ["firstHalf"], [147]], ["firstHalf", 168, "comesFrom", ["firstHalf"], [147]], ["s", 198, "comesFrom", ["s"], [188]], ["s", 151, "comesFrom", ["s"], [134]], ["s", 155, "comesFrom", ["s"], [134]], ["oddChar", 170, "comesFrom", ["oddChar"], [79]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } bool isCons ( char ch ) { return ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' ) ; } int countSpecial ( string & str ) { int len = str . length ( ) ; if ( len == 0 ) return 0 ; int co [ len + 1 ] ; int vo [ len + 1 ] ; memset ( co , 0 , sizeof ( co ) ) ; memset ( vo , 0 , sizeof ( vo ) ) ; if ( isCons ( str [ len - 1 ] ) == 1 ) co [ len - 1 ] = 1 ; else vo [ len - 1 ] = 1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( isCons ( str [ i ] ) == 1 ) { co [ i ] = co [ i + 1 ] + 1 ; vo [ i ] = vo [ i + 1 ] ; } else { co [ i ] = co [ i + 1 ] ; vo [ i ] = vo [ i + 1 ] + 1 ; } } long long ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( str [ i ] ) ) ans = ans + co [ i + 1 ] ; else ans = ans + vo [ i + 1 ] ; } return ans ; } int main ( ) { string str = \" adceba \" ; cout << countSpecial ( str ) ; return 0 ; }", "docstring": "Substrings starting with vowel and ending with consonants and vice versa | CPP program to count special strings ; Returns true if ch is vowel ; function to check consonant ; in case of empty string , we can 't fullfill the  required condition, hence we return ans as 0. ; co [ i ] is going to store counts of consonants from str [ len - 1 ] to str [ i ] . vo [ i ] is going to store counts of vowels from str [ len - 1 ] to str [ i ] . ; Counting consonants and vowels from end of string . ; Now we traverse string from beginning ; If vowel , then count of substrings starting with str [ i ] is equal to count of consonants after it . ; If consonant , then count of substrings starting with str [ i ] is equal to count of vowels after it . ; driver program", "dfg": [["ans", 347, "comesFrom", ["ans"], [334]], ["ans", 324, "comesFrom", ["ans"], [322]], ["ans", 336, "comesFrom", ["ans"], [334]], ["i", 213, "comesFrom", ["i"], [207]], ["i", 217, "comesFrom", ["i"], [207]], ["i", 304, "comesFrom", ["i"], [300]], ["i", 308, "comesFrom", ["i"], [300]], ["i", 236, "comesFrom", ["i"], [207]], ["i", 250, "comesFrom", ["i"], [207]], ["i", 318, "comesFrom", ["i"], [300]], ["i", 227, "comesFrom", ["i"], [207]], ["i", 255, "comesFrom", ["i"], [207]], ["i", 265, "comesFrom", ["i"], [207]], ["i", 277, "comesFrom", ["i"], [207]], ["i", 328, "comesFrom", ["i"], [300]], ["i", 241, "comesFrom", ["i"], [207]], ["i", 270, "comesFrom", ["i"], [207]], ["i", 340, "comesFrom", ["i"], [300]], ["i", 282, "comesFrom", ["i"], [207]], ["len", 306, "comesFrom", ["len"], [114]], ["len", 124, "comesFrom", ["len"], [114]], ["len", 134, "comesFrom", ["len"], [114]], ["len", 142, "comesFrom", ["len"], [114]], ["len", 209, "comesFrom", ["len"], [114]], ["len", 187, "comesFrom", ["len"], [114]], ["len", 197, "comesFrom", ["len"], [114]], ["len", 177, "comesFrom", ["len"], [114]], ["str", 366, "comesFrom", ["str"], [356]], ["ch", 44, "comesFrom", ["ch"], [11]], ["ch", 95, "comesFrom", ["ch"], [58]], ["ch", 37, "comesFrom", ["ch"], [11]], ["ch", 87, "comesFrom", ["ch"], [58]], ["ch", 30, "comesFrom", ["ch"], [11]], ["ch", 79, "comesFrom", ["ch"], [58]], ["ch", 16, "comesFrom", ["ch"], [11]], ["ch", 23, "comesFrom", ["ch"], [11]], ["ch", 63, "comesFrom", ["ch"], [58]], ["ch", 71, "comesFrom", ["ch"], [58]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPalindrome ( string str ) { int n = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; } int main ( ) { string str = \" abccaa \" ; if ( checkPalindrome ( str ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }", "docstring": "Convert the string into palindrome string by changing only one character | CPP program to Check if it is possible to convert the string into palindrome string by changing only one character . ; Function to check if it is possible to convert the string into palindrome ; Counting number of characters that should be changed . ; If count of changes is less than or equal to 1 ; Driver function .", "dfg": [["i", 35, "comesFrom", ["i"], [31]], ["i", 42, "comesFrom", ["i"], [31]], ["i", 48, "comesFrom", ["i"], [31]], ["i", 55, "comesFrom", ["i"], [31]], ["n", 37, "comesFrom", ["n"], [15]], ["n", 53, "comesFrom", ["n"], [15]], ["count", 65, "comesFrom", ["count"], [24]], ["count", 61, "comesFrom", ["count"], [24]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 87, "comesFrom", ["str"], [77]], ["str", 46, "comesFrom", ["str"], [11]], ["str", 51, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { result += ( n - i ) ; } } return result ; } int main ( ) { string str = \"10010\" ; int n = 5 ; cout << evenDecimalValue ( str , n ) << endl ; return 0 ; }", "docstring": "Counting even decimal value substrings in a binary string | Program to count all even decimal value substring . ; function return count of even decimal value substring ; store the count of even decimal value substring ; substring started with '0' ; increment result by ( n - i ) because all substring which are generate by this character produce even decimal value . ; Driver program", "dfg": [["result", 60, "comesFrom", ["result"], [49]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 41, "comesFrom", ["i"], [25]], ["i", 54, "comesFrom", ["i"], [25]], ["n", 31, "comesFrom", ["n"], [14]], ["n", 86, "comesFrom", ["n"], [76]], ["n", 52, "comesFrom", ["n"], [14]], ["str", 84, "comesFrom", ["str"], [69]], ["str", 39, "comesFrom", ["str"], [11]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int countSubstr ( string s ) { int n = s . length ( ) ; int auxArr [ n ] = { 0 } ; if ( s [ 0 ] == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == '1' ) count += auxArr [ i ] ; return count ; } int main ( ) { string s = \"1101\" ; cout << countSubstr ( s ) ; return 0 ; }", "docstring": "Number of substrings with odd decimal value in a binary string | CPP program to count substrings with odd decimal value ; function to count number of substrings with odd decimal representation ; auxiliary array to store count of 1 's before ith index ; store count of 1 's before  i-th index ; variable to store answer ; traverse the string reversely to calculate number of odd substrings before i - th index ; Driver code", "dfg": [["count", 145, "comesFrom", ["count"], [137]], ["i", 58, "comesFrom", ["i"], [54]], ["i", 62, "comesFrom", ["i"], [54]], ["i", 119, "comesFrom", ["i"], [113]], ["i", 123, "comesFrom", ["i"], [113]], ["i", 130, "comesFrom", ["i"], [113]], ["i", 141, "comesFrom", ["i"], [113]], ["i", 70, "comesFrom", ["i"], [54]], ["i", 79, "comesFrom", ["i"], [54]], ["i", 94, "comesFrom", ["i"], [54]], ["i", 84, "comesFrom", ["i"], [54]], ["i", 99, "comesFrom", ["i"], [54]], ["n", 60, "comesFrom", ["n"], [15]], ["n", 26, "comesFrom", ["n"], [15]], ["n", 115, "comesFrom", ["n"], [15]], ["s", 17, "comesFrom", ["s"], [11]], ["s", 35, "comesFrom", ["s"], [11]], ["s", 164, "comesFrom", ["s"], [154]], ["s", 128, "comesFrom", ["s"], [11]], ["s", 68, "comesFrom", ["s"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findSubstringIndices ( string S , const vector < string > & L ) { int size_word = L [ 0 ] . size ( ) ; int word_count = L . size ( ) ; int size_L = size_word * word_count ; vector < int > res ; if ( size_L > S . size ( ) ) return res ; unordered_map < string , int > hash_map ; for ( int i = 0 ; i < word_count ; i ++ ) hash_map [ L [ i ] ] ++ ; for ( int i = 0 ; i <= S . size ( ) - size_L ; i ++ ) { unordered_map < string , int > temp_hash_map ( hash_map ) ; int j = i , count = word_count ; while ( j < i + size_L ) { string word = S . substr ( j , size_word ) ; if ( hash_map . find ( word ) == hash_map . end ( ) temp_hash_map [ word ] == 0 ) break ; else { temp_hash_map [ word ] -- ; count -- ; } j += size_word ; } if ( count == 0 ) res . push_back ( i ) ; } return res ; } int main ( ) { string S = \" barfoothefoobarman \" ; vector < string > L = { \" foo \" , \" bar \" } ; vector < int > indices = findSubstringIndices ( S , L ) ; for ( int i = 0 ; i < indices . size ( ) ; i ++ ) cout << indices [ i ] << \" ▁ \" ; return 0 ; }", "docstring": "Find the starting indices of the substrings in string ( S ) which is made by concatenating all words from a list ( L ) | CPP program to calculate the starting indices of substrings inside S which contains all the words present in List L . ; Returns an integer vector consisting of starting indices of substrings present inside the string S ; Number of a characters of a word in list L . ; Number of words present inside list L . ; Total characters present in list L . ; Resultant vector which stores indices . ; If the total number of characters in list L is more than length of string S itself . ; Map stores the words present in list L against it 's occurrences inside list L ; Traverse the substring ; Extract the word ; If word not found or if frequency of current word is more than required simply break . ; Else decrement the count of word from hash_map ; Store the starting index of that substring when all the words in the list are in substring ; Driver Code", "dfg": [["res", 220, "comesFrom", ["res"], [57]], ["res", 70, "comesFrom", ["res"], [57]], ["res", 211, "comesFrom", ["res"], [57]], ["i", 87, "comesFrom", ["i"], [83]], ["i", 91, "comesFrom", ["i"], [83]], ["i", 110, "comesFrom", ["i"], [106]], ["i", 120, "comesFrom", ["i"], [106]], ["i", 271, "comesFrom", ["i"], [267]], ["i", 279, "comesFrom", ["i"], [267]], ["i", 148, "comesFrom", ["i"], [138]], ["i", 215, "comesFrom", ["i"], [138]], ["i", 286, "comesFrom", ["i"], [267]], ["i", 98, "comesFrom", ["i"], [83]], ["word_count", 89, "comesFrom", ["word_count"], [38]], ["word_count", 51, "comesFrom", ["word_count"], [38]], ["L", 261, "comesFrom", ["L"], [239]], ["size_word", 49, "comesFrom", ["size_word"], [26]], ["size_word", 202, "comesFrom", ["size_word"], [26]], ["size_word", 162, "comesFrom", ["size_word"], [26]], ["size_L", 61, "comesFrom", ["size_L"], [47]], ["size_L", 118, "comesFrom", ["size_L"], [47]], ["size_L", 150, "comesFrom", ["size_L"], [47]], ["hash_map", 94, "comesFrom", ["hash_map"], [78]], ["hash_map", 167, "comesFrom", ["hash_map"], [78]], ["hash_map", 174, "comesFrom", ["hash_map"], [78]], ["S", 259, "comesFrom", ["S"], [229]], ["S", 63, "comesFrom", ["S"], [14]], ["S", 112, "comesFrom", ["S"], [14]], ["S", 156, "comesFrom", ["S"], [14]], ["indices", 273, "comesFrom", ["indices"], [255]], ["indices", 284, "comesFrom", ["indices"], [255]], ["j", 146, "comesFrom", ["j"], [136]], ["j", 160, "comesFrom", ["j"], [136]], ["count", 207, "comesFrom", ["count"], [140]], ["count", 196, "comesFrom", ["count"], [140]], ["word", 171, "comesFrom", ["word"], [154]], ["word", 181, "comesFrom", ["word"], [154]], ["word", 192, "comesFrom", ["word"], [154]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 256 ; bool canMakeStr2 ( string str1 , string str2 ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count [ str1 [ i ] ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; } int main ( ) { string str1 = \" geekforgeeks \" ; string str2 = \" for \" ; if ( canMakeStr2 ( str1 , str2 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check whether second string can be formed from characters of first string | CPP program to check whether second string can be formed from first string ; Create a count array and count frequencies characters in str1 . ; Now traverse through str2 to check if every character has enough counts ; Driver Code", "dfg": [["i", 40, "comesFrom", ["i"], [36]], ["i", 48, "comesFrom", ["i"], [36]], ["i", 67, "comesFrom", ["i"], [63]], ["i", 75, "comesFrom", ["i"], [63]], ["i", 55, "comesFrom", ["i"], [36]], ["i", 98, "comesFrom", ["i"], [63]], ["i", 85, "comesFrom", ["i"], [63]], ["MAX", 26, "comesFrom", ["MAX"], [9]], ["str1", 42, "comesFrom", ["str1"], [17]], ["str1", 131, "comesFrom", ["str1"], [114]], ["str1", 53, "comesFrom", ["str1"], [17]], ["str2", 69, "comesFrom", ["str2"], [20]], ["str2", 133, "comesFrom", ["str2"], [121]], ["str2", 96, "comesFrom", ["str2"], [20]], ["str2", 83, "comesFrom", ["str2"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void finalPosition ( string move ) { int l = move . size ( ) ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move [ i ] == ' U ' ) countUp ++ ; else if ( move [ i ] == ' D ' ) countDown ++ ; else if ( move [ i ] == ' L ' ) countLeft ++ ; else if ( move [ i ] == ' R ' ) countRight ++ ; } cout << \" Final ▁ Position : ▁ ( \" << ( countRight - countLeft ) << \" , ▁ \" << ( countUp - countDown ) << \" ) \" << endl ; } int main ( ) { string move = \" UDDLLRUUUDUURUDDUULLDRRRR \" ; finalPosition ( move ) ; return 0 ; }", "docstring": "Position of robot after given movements | C ++ implementation to find final position of robot after the complete movement ; Function to find final position of robot after the complete movement ; Traverse the instruction string ' move ' ; For each movement increment its respective counter ; Required final position of robot ; Driver code", "dfg": [["i", 48, "comesFrom", ["i"], [44]], ["i", 52, "comesFrom", ["i"], [44]], ["i", 60, "comesFrom", ["i"], [44]], ["i", 77, "comesFrom", ["i"], [44]], ["i", 94, "comesFrom", ["i"], [44]], ["i", 111, "comesFrom", ["i"], [44]], ["l", 50, "comesFrom", ["l"], [15]], ["move", 167, "comesFrom", ["move"], [159]], ["move", 17, "comesFrom", ["move"], [11]], ["move", 58, "comesFrom", ["move"], [11]], ["move", 75, "comesFrom", ["move"], [11]], ["move", 92, "comesFrom", ["move"], [11]], ["move", 109, "comesFrom", ["move"], [11]], ["countUp", 69, "comesFrom", ["countUp"], [24]], ["countUp", 141, "comesFrom", ["countUp"], [24]], ["countDown", 143, "comesFrom", ["countDown"], [28]], ["countDown", 86, "comesFrom", ["countDown"], [28]], ["countRight", 131, "comesFrom", ["countRight"], [37]], ["countRight", 120, "comesFrom", ["countRight"], [37]], ["countLeft", 133, "comesFrom", ["countLeft"], [33]], ["countLeft", 103, "comesFrom", ["countLeft"], [33]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxbalancedprefix ( char str [ ] , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; } int main ( ) { char str [ ] = \" ( ( ( ) ( ) ) ( ) ) ( ( \" ; int n = strlen ( str ) ; cout << maxbalancedprefix ( str , n ) << endl ; return 0 ; }", "docstring": "Length of longest balanced parentheses prefix | CPP Program to find length of longest balanced parentheses prefix . ; Return the length of longest balanced parentheses prefix . ; Traversing the string . ; If open bracket add 1 to sum . ; If closed bracket subtract 1 from sum ; if first bracket is closing bracket then this condition would help ; If sum is 0 , store the index value . ; Driven Program", "dfg": [["maxi", 88, "comesFrom", ["maxi"], [80]], ["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 82, "comesFrom", ["i"], [32]], ["i", 48, "comesFrom", ["i"], [32]], ["n", 38, "comesFrom", ["n"], [16]], ["n", 119, "comesFrom", ["n"], [106]], ["sum", 68, "comesFrom", ["sum"], [62]], ["sum", 76, "comesFrom", ["sum"], [62]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cost ( string str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += min ( str [ i ] , str [ j ] ) - ' a ' + 1 ; return res ; } int main ( ) { string str = \" abcdef \" ; cout << cost ( str ) << endl ; return 0 ; }", "docstring": "Minimum cost to convert string into palindrome | CPP program to find minimum cost to make a palindrome . ; Function to return cost ; length of string ; Iterate from both sides of string . If not equal , a cost will be there ; Driver code", "dfg": [["res", 87, "comesFrom", ["res"], [63]], ["i", 41, "comesFrom", ["i"], [31]], ["i", 45, "comesFrom", ["i"], [31]], ["i", 55, "comesFrom", ["i"], [31]], ["i", 69, "comesFrom", ["i"], [31]], ["j", 43, "comesFrom", ["j"], [35]], ["j", 48, "comesFrom", ["j"], [35]], ["j", 60, "comesFrom", ["j"], [35]], ["j", 74, "comesFrom", ["j"], [35]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 53, "comesFrom", ["str"], [11]], ["str", 58, "comesFrom", ["str"], [11]], ["str", 106, "comesFrom", ["str"], [96]], ["str", 67, "comesFrom", ["str"], [11]], ["str", 72, "comesFrom", ["str"], [11]], ["len", 37, "comesFrom", ["len"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' A ' c == ' E ' c == ' I ' c == ' O ' c == ' U ' c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } string pigLatin ( string s ) { int len = s . length ( ) ; int index = -1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( s [ i ] ) ) { index = i ; break ; } } if ( index == -1 ) return \" - 1\" ; return s . substr ( index ) + s . substr ( 0 , index ) + \" ay \" ; } int main ( ) { string str = pigLatin ( \" graphic \" ) ; if ( str == \" - 1\" ) cout << \" No ▁ vowels ▁ found . ▁ Pig ▁ Latin ▁ not ▁ possible \" ; else cout << str ; }", "docstring": "Encoding a word into Pig Latin | C ++ program to encode a word to a Pig Latin . ; the index of the first vowel is stored . ; Pig Latin is possible only if vowels is present ; Take all characters after index ( including index ) . Append all characters which are before index . Finally append \" ay \" ; Driver code", "dfg": [["i", 117, "comesFrom", ["i"], [113]], ["i", 121, "comesFrom", ["i"], [113]], ["i", 138, "comesFrom", ["i"], [113]], ["i", 131, "comesFrom", ["i"], [113]], ["len", 119, "comesFrom", ["len"], [97]], ["index", 146, "comesFrom", ["index"], [136]], ["index", 160, "comesFrom", ["index"], [136]], ["index", 169, "comesFrom", ["index"], [136]], ["str", 194, "comesFrom", ["str"], [183]], ["str", 209, "comesFrom", ["str"], [183]], ["c", 79, "comesFrom", ["c"], [11]], ["c", 72, "comesFrom", ["c"], [11]], ["c", 65, "comesFrom", ["c"], [11]], ["c", 58, "comesFrom", ["c"], [11]], ["c", 51, "comesFrom", ["c"], [11]], ["c", 44, "comesFrom", ["c"], [11]], ["c", 37, "comesFrom", ["c"], [11]], ["c", 30, "comesFrom", ["c"], [11]], ["c", 16, "comesFrom", ["c"], [11]], ["c", 23, "comesFrom", ["c"], [11]], ["s", 99, "comesFrom", ["s"], [93]], ["s", 156, "comesFrom", ["s"], [93]], ["s", 163, "comesFrom", ["s"], [93]], ["s", 129, "comesFrom", ["s"], [93]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 256 ; bool isPresent ( string s , string q ) { int freq [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s [ i ] ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; } int main ( ) { string s = \" abctd \" ; string q = \" cat \" ; if ( isPresent ( s , q ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Possibility of a word from a given set of characters | CPP program to check if a query string is present is given set . ; Count occurrences of all characters in s . ; Check if number of occurrences of every character in q is less than or equal to that in s . ; driver program", "dfg": [["i", 40, "comesFrom", ["i"], [36]], ["i", 48, "comesFrom", ["i"], [36]], ["i", 67, "comesFrom", ["i"], [63]], ["i", 75, "comesFrom", ["i"], [63]], ["i", 55, "comesFrom", ["i"], [36]], ["i", 83, "comesFrom", ["i"], [63]], ["i", 94, "comesFrom", ["i"], [63]], ["MAX_CHAR", 26, "comesFrom", ["MAX_CHAR"], [9]], ["s", 42, "comesFrom", ["s"], [17]], ["s", 131, "comesFrom", ["s"], [114]], ["s", 53, "comesFrom", ["s"], [17]], ["q", 69, "comesFrom", ["q"], [20]], ["q", 133, "comesFrom", ["q"], [121]], ["q", 81, "comesFrom", ["q"], [20]], ["q", 92, "comesFrom", ["q"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countReduce ( string & str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; } int main ( ) { string str = \" abcd \" ; cout << countReduce ( str ) ; return 0 ; }", "docstring": "Minimum reduce operations to convert a given string into a palindrome | CPP program to count minimum reduce operations to make a palindrome ; Returns count of minimum character reduce operations to make palindrome . ; Compare every character of first half with the corresponding character of second half and add difference to result . ; Driver code", "dfg": [["res", 65, "comesFrom", ["res"], [45]], ["i", 36, "comesFrom", ["i"], [32]], ["i", 42, "comesFrom", ["i"], [32]], ["i", 51, "comesFrom", ["i"], [32]], ["i", 58, "comesFrom", ["i"], [32]], ["str", 84, "comesFrom", ["str"], [74]], ["n", 38, "comesFrom", ["n"], [16]], ["n", 56, "comesFrom", ["n"], [16]]]}
{"code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; int calculate ( string s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - '0' ) c ++ ; if ( j != s [ 1 ] - '0' ) c ++ ; if ( k != s [ 2 ] - '0' ) c ++ ; if ( l != s [ 3 ] - '0' ) c ++ ; if ( m != s [ 4 ] - '0' ) c ++ ; if ( n != s [ 5 ] - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; } int main ( ) { string s = \"123456\" ; cout << calculate ( s ) ; }", "docstring": "Minimal operations to make a number magical | CPP program to make a number magical ; function to calculate the minimal changes ; maximum digits that can be changed ; nested loops to generate all 6 digit numbers ; counter to count the number of change required ; if first digit is equal ; if 2 nd digit is equal ; if 3 rd digit is equal ; if 4 th digit is equal ; if 5 th digit is equal ; if 6 th digit is equal ; checks if less then the previous calculate changes ; returns the answer ; driver program to test the above function ; number stored in string ; prints the minimum operations", "dfg": [["ans", 245, "comesFrom", ["ans"], [233]], ["ans", 231, "comesFrom", ["ans"], [17]], ["i", 28, "comesFrom", ["i"], [24]], ["i", 33, "comesFrom", ["i"], [24]], ["i", 113, "comesFrom", ["i"], [24]], ["i", 133, "comesFrom", ["i"], [24]], ["j", 43, "comesFrom", ["j"], [39]], ["j", 48, "comesFrom", ["j"], [39]], ["j", 115, "comesFrom", ["j"], [39]], ["j", 149, "comesFrom", ["j"], [39]], ["s", 264, "comesFrom", ["s"], [254]], ["s", 135, "comesFrom", ["s"], [13]], ["s", 151, "comesFrom", ["s"], [13]], ["s", 167, "comesFrom", ["s"], [13]], ["s", 183, "comesFrom", ["s"], [13]], ["s", 199, "comesFrom", ["s"], [13]], ["s", 215, "comesFrom", ["s"], [13]], ["k", 58, "comesFrom", ["k"], [54]], ["k", 63, "comesFrom", ["k"], [54]], ["k", 117, "comesFrom", ["k"], [54]], ["k", 165, "comesFrom", ["k"], [54]], ["l", 73, "comesFrom", ["l"], [69]], ["l", 78, "comesFrom", ["l"], [69]], ["l", 119, "comesFrom", ["l"], [69]], ["l", 181, "comesFrom", ["l"], [69]], ["m", 88, "comesFrom", ["m"], [84]], ["m", 93, "comesFrom", ["m"], [84]], ["m", 121, "comesFrom", ["m"], [84]], ["m", 197, "comesFrom", ["m"], [84]], ["n", 103, "comesFrom", ["n"], [99]], ["n", 108, "comesFrom", ["n"], [99]], ["n", 123, "comesFrom", ["n"], [99]], ["n", 213, "comesFrom", ["n"], [99]], ["c", 144, "comesFrom", ["c"], [127]], ["c", 160, "comesFrom", ["c"], [127]], ["c", 176, "comesFrom", ["c"], [127]], ["c", 192, "comesFrom", ["c"], [127]], ["c", 208, "comesFrom", ["c"], [127]], ["c", 224, "comesFrom", ["c"], [127]], ["c", 229, "comesFrom", ["c"], [127]], ["c", 235, "comesFrom", ["c"], [127]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool makeAndCheckString ( vector < string > words , string str ) { int n = words . size ( ) ; bool first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; } int main ( ) { string str = \" ya \" ; vector < string > words = { \" ah \" , \" oy \" , \" to \" , \" ha \" } ; if ( makeAndCheckString ( words , str ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if a two character string can be made using given words | CPP code to check if a two character string can be made using given strings ; Function to check if str can be made using given words ; If str itself is present ; Match first character of str with second of word and vice versa ; If both characters found . ; Driver Code", "dfg": [["i", 45, "comesFrom", ["i"], [41]], ["i", 49, "comesFrom", ["i"], [41]], ["i", 57, "comesFrom", ["i"], [41]], ["i", 74, "comesFrom", ["i"], [41]], ["i", 93, "comesFrom", ["i"], [41]], ["n", 47, "comesFrom", ["n"], [21]], ["words", 23, "comesFrom", ["words"], [14]], ["words", 157, "comesFrom", ["words"], [133]], ["words", 55, "comesFrom", ["words"], [14]], ["words", 72, "comesFrom", ["words"], [14]], ["words", 91, "comesFrom", ["words"], [14]], ["str", 159, "comesFrom", ["str"], [123]], ["str", 60, "comesFrom", ["str"], [17]], ["str", 67, "comesFrom", ["str"], [17]], ["str", 86, "comesFrom", ["str"], [17]], ["first", 105, "comesFrom", ["first"], [80]], ["second", 107, "comesFrom", ["second"], [99]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; string getBinaryRep ( int N , int num_of_bits ) { string r = \" \" ; num_of_bits -- ; while ( num_of_bits >= 0 ) { if ( N & ( 1 << num_of_bits ) ) r . append ( \"1\" ) ; else r . append ( \"0\" ) ; num_of_bits -- ; } return r ; } vector < string > NBitBinary ( int N ) { vector < string > r ; int first = 1 << ( N - 1 ) ; int last = first * 2 ; for ( int i = last - 1 ; i >= first ; -- i ) { int zero_cnt = 0 ; int one_cnt = 0 ; int t = i ; int num_of_bits = 0 ; while ( t ) { if ( t & 1 ) one_cnt ++ ; else zero_cnt ++ ; num_of_bits ++ ; t = t >> 1 ; } if ( one_cnt >= zero_cnt ) { bool all_prefix_match = true ; int msk = ( 1 << num_of_bits ) - 2 ; int prefix_shift = 1 ; while ( msk ) { int prefix = ( msk & i ) >> prefix_shift ; int prefix_one_cnt = 0 ; int prefix_zero_cnt = 0 ; while ( prefix ) { if ( prefix & 1 ) prefix_one_cnt ++ ; else prefix_zero_cnt ++ ; prefix = prefix >> 1 ; } if ( prefix_zero_cnt > prefix_one_cnt ) { all_prefix_match = false ; break ; } prefix_shift ++ ; msk = msk & ( msk << 1 ) ; } if ( all_prefix_match ) { r . push_back ( getBinaryRep ( i , num_of_bits ) ) ; } } } return r ; } int main ( ) { int n = 4 ; vector < string > results = NBitBinary ( n ) ; for ( int i = 0 ; i < results . size ( ) ; ++ i ) cout << results [ i ] << \" ▁ \" ; cout << endl ; return 0 ; }", "docstring": "Print N | C ++ program to print all N - bit binary ; Function to get the binary representation of the number N ; loop for each bit ; generate numbers in the range of ( 2 ^ N ) - 1 to 2 ^ ( N - 1 ) inclusive ; longest prefix check ; if counts of 1 is greater than counts of zero ; do sub - prefixes check ; Driver code ; Function call", "dfg": [["r", 71, "comesFrom", ["r"], [21]], ["r", 301, "comesFrom", ["r"], [88]], ["r", 47, "comesFrom", ["r"], [21]], ["r", 57, "comesFrom", ["r"], [21]], ["r", 285, "comesFrom", ["r"], [88]], ["num_of_bits", 27, "comesFrom", ["num_of_bits"], [17]], ["num_of_bits", 32, "comesFrom", ["num_of_bits"], [17]], ["num_of_bits", 66, "comesFrom", ["num_of_bits"], [17]], ["num_of_bits", 163, "comesFrom", ["num_of_bits"], [141]], ["num_of_bits", 44, "comesFrom", ["num_of_bits"], [17]], ["num_of_bits", 191, "comesFrom", ["num_of_bits"], [141]], ["num_of_bits", 293, "comesFrom", ["num_of_bits"], [141]], ["i", 117, "comesFrom", ["i"], [111]], ["i", 122, "comesFrom", ["i"], [111]], ["i", 332, "comesFrom", ["i"], [328]], ["i", 341, "comesFrom", ["i"], [328]], ["i", 347, "comesFrom", ["i"], [328]], ["i", 212, "comesFrom", ["i"], [138]], ["i", 291, "comesFrom", ["i"], [138]], ["first", 119, "comesFrom", ["first"], [91]], ["first", 104, "comesFrom", ["first"], [91]], ["last", 113, "comesFrom", ["last"], [102]], ["t", 147, "comesFrom", ["t"], [136]], ["t", 152, "comesFrom", ["t"], [136]], ["t", 168, "comesFrom", ["t"], [166]], ["n", 322, "comesFrom", ["n"], [310]], ["results", 334, "comesFrom", ["results"], [318]], ["results", 345, "comesFrom", ["results"], [318]], ["N", 39, "comesFrom", ["N"], [14]], ["N", 96, "comesFrom", ["N"], [81]], ["one_cnt", 175, "comesFrom", ["one_cnt"], [131]], ["one_cnt", 156, "comesFrom", ["one_cnt"], [131]], ["zero_cnt", 177, "comesFrom", ["zero_cnt"], [126]], ["zero_cnt", 160, "comesFrom", ["zero_cnt"], [126]], ["msk", 203, "comesFrom", ["msk"], [186]], ["msk", 271, "comesFrom", ["msk"], [269]], ["msk", 210, "comesFrom", ["msk"], [186]], ["msk", 274, "comesFrom", ["msk"], [269]], ["all_prefix_match", 282, "comesFrom", ["all_prefix_match"], [259]], ["prefix", 229, "comesFrom", ["prefix"], [207]], ["prefix", 234, "comesFrom", ["prefix"], [207]], ["prefix", 247, "comesFrom", ["prefix"], [245]], ["prefix_shift", 266, "comesFrom", ["prefix_shift"], [197]], ["prefix_shift", 215, "comesFrom", ["prefix_shift"], [197]], ["prefix_zero_cnt", 254, "comesFrom", ["prefix_zero_cnt"], [223]], ["prefix_zero_cnt", 242, "comesFrom", ["prefix_zero_cnt"], [223]], ["prefix_one_cnt", 256, "comesFrom", ["prefix_one_cnt"], [218]], ["prefix_one_cnt", 238, "comesFrom", ["prefix_one_cnt"], [218]]]}
{"code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; void findWinner ( vector < string > & votes ) { unordered_map < string , int > mapObj ; for ( auto & str : votes ) { mapObj [ str ] ++ ; } int maxValueInMap = 0 ; string winner ; for ( auto & entry : mapObj ) { string key = entry . first ; int val = entry . second ; if ( val > maxValueInMap ) { maxValueInMap = val ; winner = key ; } else if ( val == maxValueInMap && winner > key ) winner = key ; } cout << winner << endl ; } int main ( ) { vector < string > votes = { \" john \" , \" johnny \" , \" jackie \" , \" johnny \" , \" john \" , \" jackie \" , \" jamie \" , \" jamie \" , \" john \" , \" johnny \" , \" jamie \" , \" johnny \" , \" john \" } ; findWinner ( votes ) ; return 0 ; }", "docstring": "Find winner of an election where votes are represented as candidate names | C ++ ++ program to find winner in an election . ; We have four Candidates with name as ' John ' , ' Johnny ' , ' jamie ' , ' jackie ' . The votes in String array are as per the votes casted . Print the name of candidates received Max vote . ; Insert all votes in a hashmap ; Traverse through map to find the candidate with maximum votes . ; If there is a tie , pick lexicographically smaller . ; Driver code", "dfg": [["votes", 181, "comesFrom", ["votes"], [123]], ["mapObj", 58, "comesFrom", ["mapObj"], [26]], ["mapObj", 37, "comesFrom", ["mapObj"], [26]], ["winner", 109, "comesFrom", ["winner"], [102]], ["winner", 98, "comesFrom", ["winner"], [86]], ["val", 77, "comesFrom", ["val"], [69]], ["val", 84, "comesFrom", ["val"], [69]], ["val", 94, "comesFrom", ["val"], [69]], ["maxValueInMap", 79, "comesFrom", ["maxValueInMap"], [45]], ["maxValueInMap", 96, "comesFrom", ["maxValueInMap"], [82]], ["key", 88, "comesFrom", ["key"], [62]], ["key", 104, "comesFrom", ["key"], [62]], ["key", 100, "comesFrom", ["key"], [62]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkLuhn ( const string & cardNo ) { int nDigits = cardNo . length ( ) ; int nSum = 0 , isSecond = false ; for ( int i = nDigits - 1 ; i >= 0 ; i -- ) { int d = cardNo [ i ] - '0' ; if ( isSecond == true ) d = d * 2 ; nSum += d / 10 ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; } int main ( ) { string cardNo = \"79927398713\" ; if ( checkLuhn ( cardNo ) ) printf ( \" This ▁ is ▁ a ▁ valid ▁ card \" ) ; else printf ( \" This ▁ is ▁ not ▁ a ▁ valid ▁ card \" ) ; return 0 ; }", "docstring": "Luhn algorithm | C ++ program to implement Luhn algorithm ; Returns true if given card number is valid ; We add two digits to handle cases that make two digits after doubling ; Driver code", "dfg": [["i", 43, "comesFrom", ["i"], [37]], ["i", 47, "comesFrom", ["i"], [37]], ["i", 56, "comesFrom", ["i"], [37]], ["cardNo", 119, "comesFrom", ["cardNo"], [109]], ["nDigits", 39, "comesFrom", ["nDigits"], [17]], ["nSum", 95, "comesFrom", ["nSum"], [81]], ["isSecond", 65, "comesFrom", ["isSecond"], [30]], ["isSecond", 90, "comesFrom", ["isSecond"], [87]], ["d", 77, "comesFrom", ["d"], [69]], ["d", 83, "comesFrom", ["d"], [69]], ["d", 71, "comesFrom", ["d"], [69]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; bool distributingBalls ( int k , int n , string str ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { a [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; } int main ( ) { long long int n = 6 , k = 3 ; string str = \" aacaab \" ; if ( distributingBalls ( k , n , str ) ) cout << \" YES \" ; else cout << \" NO \" ; return 0 ; }", "docstring": "Distributing all balls without repetition | CPP program to find if its possible to distribute balls without repitiion ; function to find if its possible to distribute balls or not ; count array to count how many times each color has occurred ; increasing count of each color every time it appears ; to check if any color appears more than K times if it does we will print NO ; Driver code", "dfg": [["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["i", 74, "comesFrom", ["i"], [70]], ["i", 78, "comesFrom", ["i"], [70]], ["i", 85, "comesFrom", ["i"], [70]], ["i", 55, "comesFrom", ["i"], [39]], ["n", 45, "comesFrom", ["n"], [20]], ["n", 126, "comesFrom", ["n"], [105]], ["MAX_CHAR", 76, "comesFrom", ["MAX_CHAR"], [9]], ["MAX_CHAR", 29, "comesFrom", ["MAX_CHAR"], [9]], ["k", 88, "comesFrom", ["k"], [17]], ["k", 124, "comesFrom", ["k"], [109]], ["str", 128, "comesFrom", ["str"], [114]], ["str", 53, "comesFrom", ["str"], [23]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } void FindSubstring ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( isVowel ( str [ j ] ) == false ) break ; hash . insert ( str [ j ] ) ; if ( hash . size ( ) == 5 ) cout << str . substr ( i , j - i + 1 ) << \" ▁ \" ; } hash . clear ( ) ; } } int main ( ) { string str = \" aeoibsddaeiouudb \" ; FindSubstring ( str ) ; return 0 ; }", "docstring": "Find substrings that contain all vowels | CPP program to find all substring that contain all vowels ; Returns true if x is vowel . ; Function to check whether a character is vowel or not ; Outer loop picks starting character and inner loop picks ending character . ; If current character is not vowel , then no more result substrings possible starting from str [ i ] . ; If vowel , then we insert it in hash ; If all vowels are present in current substring ; Driver code", "dfg": [["i", 77, "comesFrom", ["i"], [73]], ["i", 81, "comesFrom", ["i"], [73]], ["i", 140, "comesFrom", ["i"], [90]], ["i", 144, "comesFrom", ["i"], [90]], ["n", 79, "comesFrom", ["n"], [62]], ["n", 94, "comesFrom", ["n"], [62]], ["str", 176, "comesFrom", ["str"], [168]], ["str", 64, "comesFrom", ["str"], [58]], ["str", 118, "comesFrom", ["str"], [58]], ["str", 104, "comesFrom", ["str"], [58]], ["str", 136, "comesFrom", ["str"], [58]], ["x", 44, "comesFrom", ["x"], [11]], ["x", 37, "comesFrom", ["x"], [11]], ["x", 30, "comesFrom", ["x"], [11]], ["x", 16, "comesFrom", ["x"], [11]], ["x", 23, "comesFrom", ["x"], [11]], ["j", 92, "comesFrom", ["j"], [88]], ["j", 96, "comesFrom", ["j"], [88]], ["j", 120, "comesFrom", ["j"], [88]], ["j", 106, "comesFrom", ["j"], [88]], ["j", 142, "comesFrom", ["j"], [88]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( vector < string > list , string s ) { int n = ( int ) list . size ( ) ; if ( n == 0 ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( list [ i ] . size ( ) != s . size ( ) ) continue ; bool diff = false ; for ( int j = 0 ; j < ( int ) list [ i ] . size ( ) ; j ++ ) { if ( list [ i ] [ j ] != s [ j ] ) { if ( ! diff ) diff = true ; else { diff = false ; break ; } } } if ( diff ) return true ; } return false ; } int main ( ) { vector < string > s ; s . push_back ( \" bana \" ) ; s . push_back ( \" apple \" ) ; s . push_back ( \" banacb \" ) ; s . push_back ( \" bonanza \" ) ; s . push_back ( \" banamf \" ) ; cout << check ( s , \" banana \" ) ; return 0 ; }", "docstring": "Find if an array contains a string with one mismatch | C ++ program to find if given string is present with one mismatch . ; If the array is empty ; If sizes are same ; If first mismatch ; Second mismatch ; Driver code", "dfg": [["i", 48, "comesFrom", ["i"], [44]], ["i", 52, "comesFrom", ["i"], [44]], ["i", 60, "comesFrom", ["i"], [44]], ["i", 94, "comesFrom", ["i"], [44]], ["i", 109, "comesFrom", ["i"], [44]], ["n", 50, "comesFrom", ["n"], [21]], ["n", 34, "comesFrom", ["n"], [21]], ["s", 164, "comesFrom", ["s"], [162]], ["s", 173, "comesFrom", ["s"], [162]], ["s", 182, "comesFrom", ["s"], [162]], ["s", 191, "comesFrom", ["s"], [162]], ["s", 200, "comesFrom", ["s"], [162]], ["s", 213, "comesFrom", ["s"], [162]], ["s", 67, "comesFrom", ["s"], [17]], ["s", 115, "comesFrom", ["s"], [17]], ["j", 87, "comesFrom", ["j"], [83]], ["j", 101, "comesFrom", ["j"], [83]], ["j", 112, "comesFrom", ["j"], [83]], ["j", 117, "comesFrom", ["j"], [83]], ["diff", 143, "comesFrom", ["diff"], [132]], ["diff", 124, "comesFrom", ["diff"], [76]], ["list", 26, "comesFrom", ["list"], [14]], ["list", 58, "comesFrom", ["list"], [14]], ["list", 92, "comesFrom", ["list"], [14]], ["list", 107, "comesFrom", ["list"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sentencePalindrome ( string str ) { int l = 0 , h = str . length ( ) - 1 ; for ( int i = 0 ; i <= h ; i ++ ) str [ i ] = tolower ( str [ i ] ) ; while ( l <= h ) { if ( ! ( str [ l ] >= ' a ' && str [ l ] <= ' z ' ) ) l ++ ; else if ( ! ( str [ h ] >= ' a ' && str [ h ] <= ' z ' ) ) h -- ; else if ( str [ l ] == str [ h ] ) l ++ , h -- ; else return false ; } return true ; } int main ( ) { string str = \" Too ▁ hot ▁ to ▁ hoot . \" ; if ( sentencePalindrome ( str ) ) cout << \" Sentence ▁ is ▁ palindrome . \" ; else cout << \" Sentence ▁ is ▁ not ▁ palindrome . \" ; return 0 ; }", "docstring": "Sentence Palindrome ( Palindrome after removing spaces , dots , . . etc ) | CPP program to find if a sentence is palindrome ; To check sentence is palindrome or not ; Lowercase string ; Compares character until they are equal ; If there is another symbol in left of sentence ; If there is another symbol in right of sentence ; If characters are equal ; If characters are not equal then sentence is not palindrome ; Returns true if sentence is palindrome ; Driver program to test sentencePalindrome ( )", "dfg": [["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 45, "comesFrom", ["i"], [32]], ["i", 52, "comesFrom", ["i"], [32]], ["h", 38, "comesFrom", ["h"], [19]], ["h", 60, "comesFrom", ["h"], [19]], ["h", 121, "comesFrom", ["h"], [19]], ["h", 140, "comesFrom", ["h"], [19]], ["h", 134, "comesFrom", ["h"], [19]], ["h", 100, "comesFrom", ["h"], [19]], ["h", 111, "comesFrom", ["h"], [19]], ["l", 58, "comesFrom", ["l"], [15]], ["l", 90, "comesFrom", ["l"], [15]], ["l", 69, "comesFrom", ["l"], [15]], ["l", 80, "comesFrom", ["l"], [15]], ["l", 137, "comesFrom", ["l"], [15]], ["l", 129, "comesFrom", ["l"], [15]], ["str", 43, "comesFrom", ["str"], [11]], ["str", 168, "comesFrom", ["str"], [158]], ["str", 21, "comesFrom", ["str"], [11]], ["str", 50, "comesFrom", ["str"], [11]], ["str", 67, "comesFrom", ["str"], [11]], ["str", 78, "comesFrom", ["str"], [11]], ["str", 127, "comesFrom", ["str"], [11]], ["str", 132, "comesFrom", ["str"], [11]], ["str", 98, "comesFrom", ["str"], [11]], ["str", 109, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorZero ( string str ) { int one_count = 0 , zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; } int main ( ) { string str = \"11111\" ; cout << xorZero ( str ) << endl ; return 0 ; }", "docstring": "Ways to remove one element from a binary string so that XOR becomes zero | C ++ program to count number of ways to remove an element so that XOR of remaining string becomes 0. ; Return number of ways in which XOR become ZERO by remove 1 element ; Counting number of 0 and 1 ; If count of ones is even then return count of zero else count of one ; Driver Code", "dfg": [["one_count", 76, "comesFrom", ["one_count"], [15]], ["one_count", 57, "comesFrom", ["one_count"], [15]], ["one_count", 66, "comesFrom", ["one_count"], [15]], ["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 50, "comesFrom", ["i"], [35]], ["n", 41, "comesFrom", ["n"], [24]], ["zero_count", 73, "comesFrom", ["zero_count"], [19]], ["zero_count", 61, "comesFrom", ["zero_count"], [19]], ["str", 26, "comesFrom", ["str"], [11]], ["str", 48, "comesFrom", ["str"], [11]], ["str", 95, "comesFrom", ["str"], [85]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string encoder ( string key ) { string encoded = \" \" ; bool arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < key . size ( ) ; i ++ ) { if ( key [ i ] >= ' A ' && key [ i ] <= ' Z ' ) { if ( arr [ key [ i ] - 65 ] == 0 ) { encoded += key [ i ] ; arr [ key [ i ] - 65 ] = 1 ; } } else if ( key [ i ] >= ' a ' && key [ i ] <= ' z ' ) { if ( arr [ key [ i ] - 97 ] == 0 ) { encoded += key [ i ] - 32 ; arr [ key [ i ] - 97 ] = 1 ; } } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( arr [ i ] == 0 ) { arr [ i ] = 1 ; encoded += char ( i + 65 ) ; } } return encoded ; } string cipheredIt ( string msg , string encoded ) { string cipher = \" \" ; for ( int i = 0 ; i < msg . size ( ) ; i ++ ) { if ( msg [ i ] >= ' a ' && msg [ i ] <= ' z ' ) { int pos = msg [ i ] - 97 ; cipher += encoded [ pos ] ; } else if ( msg [ i ] >= ' A ' && msg [ i ] <= ' Z ' ) { int pos = msg [ i ] - 65 ; cipher += encoded [ pos ] ; } else { cipher += msg [ i ] ; } } return cipher ; } int main ( ) { string key ; key = \" Computer \" ; cout << \" Keyword ▁ : ▁ \" << key << endl ; string encoded = encoder ( key ) ; string message = \" GeeksforGeeks \" ; cout << \" Message ▁ before ▁ Ciphering ▁ : ▁ \" << message << endl ; cout << \" Ciphered ▁ Text ▁ : ▁ \" << cipheredIt ( message , encoded ) << endl ; return 0 ; }", "docstring": "Keyword Cipher | CPP program for encoding the string using classical cipher ; Function generates the encoded text ; This array represents the 26 letters of alphabets ; This loop inserts the keyword at the start of the encoded string ; To check whether the character is inserted earlier in the encoded string or not ; This loop inserts the remaining characters in the encoded string . ; Function that generates encodes ( cipher ) the message ; This loop ciphered the message . Spaces , special characters and numbers remain same . ; Driver code ; Hold the Keyword ; Function call to generate encoded text ; Message that need to encode ; Function call to print ciphered text", "dfg": [["encoded", 220, "comesFrom", ["encoded"], [208]], ["encoded", 420, "comesFrom", ["encoded"], [386]], ["encoded", 296, "comesFrom", ["encoded"], [230]], ["encoded", 340, "comesFrom", ["encoded"], [230]], ["cipher", 358, "comesFrom", ["cipher"], [348]], ["i", 38, "comesFrom", ["i"], [34]], ["i", 46, "comesFrom", ["i"], [34]], ["i", 183, "comesFrom", ["i"], [179]], ["i", 187, "comesFrom", ["i"], [179]], ["i", 247, "comesFrom", ["i"], [243]], ["i", 255, "comesFrom", ["i"], [243]], ["i", 195, "comesFrom", ["i"], [179]], ["i", 54, "comesFrom", ["i"], [34]], ["i", 65, "comesFrom", ["i"], [34]], ["i", 203, "comesFrom", ["i"], [179]], ["i", 263, "comesFrom", ["i"], [243]], ["i", 274, "comesFrom", ["i"], [243]], ["i", 212, "comesFrom", ["i"], [179]], ["i", 289, "comesFrom", ["i"], [243]], ["i", 94, "comesFrom", ["i"], [34]], ["i", 116, "comesFrom", ["i"], [34]], ["i", 127, "comesFrom", ["i"], [34]], ["i", 307, "comesFrom", ["i"], [243]], ["i", 318, "comesFrom", ["i"], [243]], ["i", 333, "comesFrom", ["i"], [243]], ["i", 352, "comesFrom", ["i"], [243]], ["i", 81, "comesFrom", ["i"], [34]], ["i", 101, "comesFrom", ["i"], [34]], ["i", 156, "comesFrom", ["i"], [34]], ["i", 143, "comesFrom", ["i"], [34]], ["i", 165, "comesFrom", ["i"], [34]], ["key", 381, "comesFrom", ["key"], [369]], ["key", 40, "comesFrom", ["key"], [11]], ["key", 390, "comesFrom", ["key"], [369]], ["key", 52, "comesFrom", ["key"], [11]], ["key", 63, "comesFrom", ["key"], [11]], ["key", 92, "comesFrom", ["key"], [11]], ["key", 114, "comesFrom", ["key"], [11]], ["key", 125, "comesFrom", ["key"], [11]], ["key", 79, "comesFrom", ["key"], [11]], ["key", 99, "comesFrom", ["key"], [11]], ["key", 154, "comesFrom", ["key"], [11]], ["key", 141, "comesFrom", ["key"], [11]], ["key", 163, "comesFrom", ["key"], [11]], ["message", 406, "comesFrom", ["message"], [394]], ["message", 418, "comesFrom", ["message"], [394]], ["msg", 249, "comesFrom", ["msg"], [227]], ["msg", 261, "comesFrom", ["msg"], [227]], ["msg", 272, "comesFrom", ["msg"], [227]], ["msg", 287, "comesFrom", ["msg"], [227]], ["msg", 305, "comesFrom", ["msg"], [227]], ["msg", 316, "comesFrom", ["msg"], [227]], ["msg", 331, "comesFrom", ["msg"], [227]], ["msg", 350, "comesFrom", ["msg"], [227]], ["pos", 298, "comesFrom", ["pos"], [285]], ["pos", 342, "comesFrom", ["pos"], [329]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; bool checkCorrectOrNot ( string s ) { int count [ MAX_CHAR ] = { 0 } ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - ' a ' ] ++ ; count [ s [ j ] - ' a ' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; } int main ( ) { string s = \" abab \" ; if ( checkCorrectOrNot ( s ) ) cout << \" Yes STRNEWLINE \" ; else cout << \" No STRNEWLINE \" ; return 0 ; }", "docstring": "Check if both halves of the string have same set of characters | C ++ program to check if it is possible to split string or not ; function to check if we can split string or not ; Counter array initialized with 0 ; Length of the string ; traverse till the middle element is reached ; First half ; Second half ; Checking if values are different set flag to 1 ; Driver program to test above function ; String to be checked", "dfg": [["i", 61, "comesFrom", ["i"], [51]], ["i", 110, "comesFrom", ["i"], [106]], ["i", 114, "comesFrom", ["i"], [106]], ["i", 65, "comesFrom", ["i"], [51]], ["i", 121, "comesFrom", ["i"], [106]], ["i", 76, "comesFrom", ["i"], [51]], ["j", 63, "comesFrom", ["j"], [55]], ["j", 68, "comesFrom", ["j"], [55]], ["j", 91, "comesFrom", ["j"], [55]], ["MAX_CHAR", 112, "comesFrom", ["MAX_CHAR"], [9]], ["MAX_CHAR", 23, "comesFrom", ["MAX_CHAR"], [9]], ["n", 41, "comesFrom", ["n"], [31]], ["n", 57, "comesFrom", ["n"], [31]], ["s", 33, "comesFrom", ["s"], [17]], ["s", 149, "comesFrom", ["s"], [139]], ["s", 74, "comesFrom", ["s"], [17]], ["s", 89, "comesFrom", ["s"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check_isogram ( string str ) { int length = str . length ( ) ; int mapHash [ 26 ] = { 0 } ; for ( int i = 0 ; i < length ; i ++ ) { mapHash [ str [ i ] - ' a ' ] ++ ; if ( mapHash [ str [ i ] - ' a ' ] > 1 ) { return false ; } } return true ; } int main ( ) { string str = \" geeks \" ; string str2 = \" computer \" ; if ( check_isogram ( str ) ) { cout << \" True \" << endl ; } else { cout << \" False \" << endl ; } if ( check_isogram ( str2 ) ) { cout << \" True \" << endl ; } else { cout << \" False \" << endl ; } return 0 ; }", "docstring": "Check if a string is Isogram or not | CPP code to check string is isogram or not ; function to check isogram ; loop to store count of chars and check if it is greater than 1 ; if count > 1 , return false ; Driver code ; checking str as isogram ; checking str2 as isogram", "dfg": [["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 52, "comesFrom", ["i"], [36]], ["i", 69, "comesFrom", ["i"], [36]], ["length", 42, "comesFrom", ["length"], [15]], ["length", 19, "comesFrom", ["length"], [15]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 114, "comesFrom", ["str"], [97]], ["str", 50, "comesFrom", ["str"], [11]], ["str", 67, "comesFrom", ["str"], [11]], ["str2", 142, "comesFrom", ["str2"], [104]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkString ( string s ) { int len = s . length ( ) ; int first = s . size ( ) + 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == '1' ) { first = i ; break ; } } int last = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) { last = i ; break ; } } for ( int i = first ; i <= last ; i ++ ) if ( s [ i ] == '0' ) return false ; return true ; } int main ( ) { string s = \"00011111111100000\" ; checkString ( s ) ? cout << \" VALID STRNEWLINE \" : cout << \" NOT ▁ VALID STRNEWLINE \" ; return 0 ; }", "docstring": "Check if a binary string has a 0 between 1 s or not | Set 1 ( General approach ) | C ++ program to check if a string is valid or not . ; Function returns 1 when string is valid else returns 0 ; Find first occurrence of 1 in s [ ] ; Find last occurrence of 1 in s [ ] ; Check if there is any 0 in range ; Driver code", "dfg": [["i", 41, "comesFrom", ["i"], [37]], ["i", 45, "comesFrom", ["i"], [37]], ["i", 83, "comesFrom", ["i"], [77]], ["i", 87, "comesFrom", ["i"], [77]], ["i", 118, "comesFrom", ["i"], [114]], ["i", 122, "comesFrom", ["i"], [114]], ["i", 63, "comesFrom", ["i"], [37]], ["i", 105, "comesFrom", ["i"], [77]], ["i", 129, "comesFrom", ["i"], [114]], ["i", 53, "comesFrom", ["i"], [37]], ["i", 95, "comesFrom", ["i"], [77]], ["len", 43, "comesFrom", ["len"], [15]], ["len", 79, "comesFrom", ["len"], [15]], ["last", 120, "comesFrom", ["last"], [103]], ["s", 17, "comesFrom", ["s"], [11]], ["s", 157, "comesFrom", ["s"], [149]], ["s", 26, "comesFrom", ["s"], [11]], ["s", 127, "comesFrom", ["s"], [11]], ["s", 51, "comesFrom", ["s"], [11]], ["s", 93, "comesFrom", ["s"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printAllSubstrings ( string s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { char temp [ n - i + 1 ] ; int tempindex = 0 ; for ( int j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s [ j ] ; temp [ tempindex ] = ' \\0' ; printf ( \" % s STRNEWLINE \" , temp ) ; } } } int main ( ) { string s = \" Geeky \" ; printAllSubstrings ( s , s . length ( ) ) ; return 0 ; }", "docstring": "Program to print all substrings of a given string | * C ++ program to print all possible * substrings of a given string * without checking for duplication . ; * Function to print all ( n * ( n + 1 ) ) / 2 * substrings of a given string s of length n . ; * Fix start index in outer loop . * Reveal new character in inner loop till end of string . * Print till - now - formed string . ; Driver program to test above function", "dfg": [["i", 24, "comesFrom", ["i"], [20]], ["i", 28, "comesFrom", ["i"], [20]], ["i", 37, "comesFrom", ["i"], [20]], ["n", 26, "comesFrom", ["n"], [14]], ["n", 56, "comesFrom", ["n"], [14]], ["n", 35, "comesFrom", ["n"], [14]], ["s", 108, "comesFrom", ["s"], [100]], ["s", 110, "comesFrom", ["s"], [100]], ["s", 68, "comesFrom", ["s"], [11]], ["j", 54, "comesFrom", ["j"], [50]], ["j", 58, "comesFrom", ["j"], [50]], ["j", 70, "comesFrom", ["j"], [50]], ["tempindex", 75, "comesFrom", ["tempindex"], [43]], ["tempindex", 64, "comesFrom", ["tempindex"], [43]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void preserveSpace ( string & str ) { int n = str . length ( ) ; int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( str [ start ] == ' ▁ ' ) { start ++ ; continue ; } else if ( str [ end ] == ' ▁ ' ) { end -- ; continue ; } else { swap ( str [ start ] , str [ end ] ) ; start ++ ; end -- ; } } } int main ( ) { string str = \" internship ▁ at ▁ geeks ▁ for ▁ geeks \" ; preserveSpace ( str ) ; cout << str ; return 0 ; }", "docstring": "Reverse a string preserving space positions | C ++ program to implement the above approach ; Initialize two pointers as two corners ; Move both pointers toward each other ; If character at start or end is space , ignore it ; If both are not spaces , do swap ; Driver code", "dfg": [["str", 127, "comesFrom", ["str"], [114]], ["str", 122, "comesFrom", ["str"], [114]], ["n", 32, "comesFrom", ["n"], [16]], ["start", 38, "comesFrom", ["start"], [25]], ["start", 57, "comesFrom", ["start"], [25]], ["start", 47, "comesFrom", ["start"], [25]], ["start", 99, "comesFrom", ["start"], [25]], ["start", 90, "comesFrom", ["start"], [25]], ["end", 40, "comesFrom", ["end"], [30]], ["end", 78, "comesFrom", ["end"], [30]], ["end", 68, "comesFrom", ["end"], [30]], ["end", 102, "comesFrom", ["end"], [30]], ["end", 95, "comesFrom", ["end"], [30]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void amendSentence ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = str [ i ] + 32 ; if ( i != 0 ) cout << \" ▁ \" ; cout << str [ i ] ; } else cout << str [ i ] ; } } int main ( ) { string str = \" BruceWayneIsBatman \" ; amendSentence ( str ) ; return 0 ; }", "docstring": "Put spaces between words starting with capital letters | C ++ program to put spaces between words starting with capital letters . ; Function to amend the sentence ; Traverse the string ; Convert to lowercase if its an uppercase character ; Print space before it if its an uppercase character ; Print the character ; if lowercase character then just print ; Driver code", "dfg": [["i", 21, "comesFrom", ["i"], [17]], ["i", 29, "comesFrom", ["i"], [17]], ["i", 72, "comesFrom", ["i"], [17]], ["i", 37, "comesFrom", ["i"], [17]], ["i", 48, "comesFrom", ["i"], [17]], ["i", 60, "comesFrom", ["i"], [17]], ["i", 86, "comesFrom", ["i"], [17]], ["i", 95, "comesFrom", ["i"], [17]], ["i", 65, "comesFrom", ["i"], [17]], ["str", 114, "comesFrom", ["str"], [106]], ["str", 23, "comesFrom", ["str"], [11]], ["str", 35, "comesFrom", ["str"], [11]], ["str", 46, "comesFrom", ["str"], [11]], ["str", 58, "comesFrom", ["str"], [11]], ["str", 84, "comesFrom", ["str"], [11]], ["str", 93, "comesFrom", ["str"], [11]], ["str", 63, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #include <string> NEW_LINE using namespace std ; string repeat ( string s , int n ) { string s1 = s ; for ( int i = 1 ; i < n ; i ++ ) return s ; } int main ( ) { string s = \" geeks \" ; int n = 3 ; cout << repeat ( s , n ) << endl ; ; return 0 ; }", "docstring": "C ++ program to concatenate a string given number of times | C ++ program to concatenate given string n number of times ; Function which return string by concatenating it . ; Copying given string to temporary string . ; s += s1 ; Concatenating strings ; Driver code", "dfg": [["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["n", 34, "comesFrom", ["n"], [17]], ["n", 66, "comesFrom", ["n"], [56]], ["s", 40, "comesFrom", ["s"], [23]], ["s", 64, "comesFrom", ["s"], [49]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } int countDistinctPermutations ( string str ) { int length = str . length ( ) ; int freq [ MAX_CHAR ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < length ; i ++ ) if ( str [ i ] >= ' a ' ) freq [ str [ i ] - ' a ' ] ++ ; int fact = 1 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) fact = fact * factorial ( freq [ i ] ) ; return factorial ( length ) / fact ; } int main ( ) { string str = \" fvvfhvgv \" ; printf ( \" % d \" , countDistinctPermutations ( str ) ) ; return 0 ; }", "docstring": "Number of distinct permutation a String can have | C ++ program to find number of distinct permutations of a string . ; Utility function to find factorial of n . ; Returns count of distinct permutations of str . ; finding frequency of all the lower case alphabet and storing them in array of integer ; finding factorial of number of appearances and multiplying them since they are repeating alphabets ; finding factorial of size of string and dividing it by factorial found after multiplying ; Driver code", "dfg": [["fact", 46, "comesFrom", ["fact"], [39]], ["fact", 162, "comesFrom", ["fact"], [144]], ["fact", 41, "comesFrom", ["fact"], [39]], ["fact", 146, "comesFrom", ["fact"], [144]], ["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 90, "comesFrom", ["i"], [86]], ["i", 94, "comesFrom", ["i"], [86]], ["i", 137, "comesFrom", ["i"], [133]], ["i", 141, "comesFrom", ["i"], [133]], ["i", 43, "comesFrom", ["i"], [28]], ["i", 101, "comesFrom", ["i"], [86]], ["i", 152, "comesFrom", ["i"], [133]], ["i", 114, "comesFrom", ["i"], [86]], ["n", 34, "comesFrom", ["n"], [17]], ["MAX_CHAR", 68, "comesFrom", ["MAX_CHAR"], [9]], ["MAX_CHAR", 139, "comesFrom", ["MAX_CHAR"], [9]], ["length", 92, "comesFrom", ["length"], [57]], ["length", 61, "comesFrom", ["length"], [57]], ["length", 159, "comesFrom", ["length"], [57]], ["str", 59, "comesFrom", ["str"], [53]], ["str", 99, "comesFrom", ["str"], [53]], ["str", 185, "comesFrom", ["str"], [171]], ["str", 112, "comesFrom", ["str"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool uniqueCharacters ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int bitAtIndex = str [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; } int main ( ) { string str = \" geeksforgeeks \" ; if ( uniqueCharacters ( str ) ) { cout << \" The ▁ String ▁ \" << str << \" ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE \" ; } else { cout << \" The ▁ String ▁ \" << str << \" ▁ has ▁ duplicate ▁ characters STRNEWLINE \" ; } return 0 ; }", "docstring": "Determine if a string has all Unique Characters | C ++ program to illustrate string with unique characters using brute force technique ; Assuming string can have characters a - z , this has 32 bits set to 0 ; if that bit is already set in checker , return false ; otherwise update and continue by setting that bit in the checker ; no duplicates encountered , return true ; driver code", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 34, "comesFrom", ["i"], [22]], ["i", 43, "comesFrom", ["i"], [22]], ["str", 28, "comesFrom", ["str"], [11]], ["str", 102, "comesFrom", ["str"], [92]], ["str", 112, "comesFrom", ["str"], [92]], ["str", 41, "comesFrom", ["str"], [11]], ["str", 127, "comesFrom", ["str"], [92]], ["checker", 73, "comesFrom", ["checker"], [71]], ["checker", 55, "comesFrom", ["checker"], [15]], ["bitAtIndex", 78, "comesFrom", ["bitAtIndex"], [39]], ["bitAtIndex", 60, "comesFrom", ["bitAtIndex"], [39]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; return false ; } string createAltStr ( string str1 , string str2 , int start , int l ) { string finalStr = \" \" ; for ( int i = 0 , j = start ; j < l ; i ++ , j ++ ) finalStr = ( finalStr + str1 . at ( i ) ) + str2 . at ( j ) ; return finalStr ; } string findAltStr ( string str ) { int nv = 0 , nc = 0 ; string vstr = \" \" , cstr = \" \" ; int l = str . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char ch = str . at ( i ) ; if ( isVowel ( ch ) ) { nv ++ ; vstr = vstr + ch ; } else { nc ++ ; cstr = cstr + ch ; } } if ( abs ( nv - nc ) >= 2 ) return \" no ▁ such ▁ string \" ; if ( nv > nc ) return ( vstr . at ( 0 ) + createAltStr ( cstr , vstr , 1 , nv ) ) ; if ( nc > nv ) return ( cstr . at ( 0 ) + createAltStr ( vstr , cstr , 1 , nc ) ) ; if ( cstr . at ( 0 ) < vstr . at ( 0 ) ) return createAltStr ( cstr , vstr , 0 , nv ) ; return createAltStr ( vstr , cstr , 0 , nc ) ; } int main ( ) { string str = \" geeks \" ; cout << findAltStr ( str ) ; return 0 ; }", "docstring": "Alternate vowel and consonant string | C ++ implementation of alternate vowel and consonant string ; ' ch ' is vowel or not ; create alternate vowel and consonant string str1 [ 0. . . l1 - 1 ] and str2 [ start ... l2 - 1 ] ; first adding character of vowel / consonant then adding character of consonant / vowel ; function to find the required alternate vowel and consonant string ; count vowels and update vowel string ; count consonants and update consonant string ; no such string can be formed ; remove first character of vowel string then create alternate string with cstr [ 0. . . nc - 1 ] and vstr [ 1. . . nv - 1 ] ; remove first character of consonant string then create alternate string with vstr [ 0. . . nv - 1 ] and cstr [ 1. . . nc - 1 ] ; if both vowel and consonant strings are of equal length start creating string with consonant ; start creating string with vowel ; Driver program to test above", "dfg": [["finalStr", 124, "comesFrom", ["finalStr"], [103]], ["finalStr", 106, "comesFrom", ["finalStr"], [103]], ["j", 93, "comesFrom", ["j"], [89]], ["j", 100, "comesFrom", ["j"], [89]], ["j", 120, "comesFrom", ["j"], [89]], ["l", 95, "comesFrom", ["l"], [72]], ["l", 174, "comesFrom", ["l"], [157]], ["i", 172, "comesFrom", ["i"], [168]], ["i", 176, "comesFrom", ["i"], [168]], ["i", 97, "comesFrom", ["i"], [85]], ["i", 187, "comesFrom", ["i"], [168]], ["i", 112, "comesFrom", ["i"], [85]], ["nv", 239, "comesFrom", ["nv"], [135]], ["nv", 268, "comesFrom", ["nv"], [135]], ["nv", 316, "comesFrom", ["nv"], [135]], ["nv", 198, "comesFrom", ["nv"], [135]], ["nv", 225, "comesFrom", ["nv"], [135]], ["nv", 260, "comesFrom", ["nv"], [135]], ["nc", 241, "comesFrom", ["nc"], [139]], ["nc", 266, "comesFrom", ["nc"], [139]], ["nc", 328, "comesFrom", ["nc"], [139]], ["nc", 227, "comesFrom", ["nc"], [139]], ["nc", 287, "comesFrom", ["nc"], [139]], ["nc", 210, "comesFrom", ["nc"], [139]], ["vstr", 322, "comesFrom", ["vstr"], [201]], ["vstr", 312, "comesFrom", ["vstr"], [201]], ["vstr", 300, "comesFrom", ["vstr"], [201]], ["vstr", 245, "comesFrom", ["vstr"], [201]], ["vstr", 256, "comesFrom", ["vstr"], [201]], ["vstr", 281, "comesFrom", ["vstr"], [201]], ["vstr", 203, "comesFrom", ["vstr"], [201]], ["cstr", 324, "comesFrom", ["cstr"], [213]], ["cstr", 310, "comesFrom", ["cstr"], [213]], ["cstr", 293, "comesFrom", ["cstr"], [213]], ["cstr", 254, "comesFrom", ["cstr"], [213]], ["cstr", 272, "comesFrom", ["cstr"], [213]], ["cstr", 283, "comesFrom", ["cstr"], [213]], ["cstr", 215, "comesFrom", ["cstr"], [213]], ["ch", 44, "comesFrom", ["ch"], [11]], ["ch", 37, "comesFrom", ["ch"], [11]], ["ch", 30, "comesFrom", ["ch"], [11]], ["ch", 194, "comesFrom", ["ch"], [181]], ["ch", 16, "comesFrom", ["ch"], [11]], ["ch", 23, "comesFrom", ["ch"], [11]], ["ch", 205, "comesFrom", ["ch"], [181]], ["ch", 217, "comesFrom", ["ch"], [181]], ["str", 159, "comesFrom", ["str"], [131]], ["str", 348, "comesFrom", ["str"], [338]], ["str", 183, "comesFrom", ["str"], [131]], ["str2", 116, "comesFrom", ["str2"], [66]], ["str1", 108, "comesFrom", ["str1"], [63]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void isKthBitSet ( int n , int k ) { if ( n & ( 1 << ( k - 1 ) ) ) cout << \" SET \" ; else cout << \" NOT ▁ SET \" ; } int main ( ) { int n = 5 , k = 1 ; isKthBitSet ( n , k ) ; return 0 ; }", "docstring": "Check whether K | CPP program to check if k - th bit of a given number is set or not ; Driver code", "dfg": [["n", 19, "comesFrom", ["n"], [11]], ["n", 61, "comesFrom", ["n"], [51]], ["k", 63, "comesFrom", ["k"], [55]], ["k", 25, "comesFrom", ["k"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { string str = \" geeksforgeeks \" ; reverse ( str . begin ( ) , str . end ( ) ) ; cout << str ; return 0 ; }", "docstring": "Reverse string without using any temporary variable | Reversing a string using reverse ( ) ; Reverse str [ beign . . end ]", "dfg": [["str", 36, "comesFrom", ["str"], [13]], ["str", 21, "comesFrom", ["str"], [13]], ["str", 27, "comesFrom", ["str"], [13]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalRec ( char str [ ] , int s , int e ) { if ( s == e ) return true ; if ( str [ s ] != str [ e ] ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } bool isPalindrome ( char str [ ] ) { int n = strlen ( str ) ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; } int main ( ) { char str [ ] = \" geeg \" ; if ( isPalindrome ( str ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Recursive function to check if a string is palindrome | A recursive C ++ program to check whether a given number is palindrome or not ; A recursive function that check a str [ s . . e ] is palindrome or not . ; If there is only one character ; If first and last characters do not match ; If there are more than two characters , check if middle substring is also palindrome or not . ; An empty string is considered as palindrome ; Driver Code", "dfg": [["s", 24, "comesFrom", ["s"], [16]], ["s", 48, "comesFrom", ["s"], [16]], ["s", 35, "comesFrom", ["s"], [16]], ["s", 59, "comesFrom", ["s"], [16]], ["e", 26, "comesFrom", ["e"], [19]], ["e", 50, "comesFrom", ["e"], [19]], ["e", 40, "comesFrom", ["e"], [19]], ["e", 63, "comesFrom", ["e"], [19]], ["n", 91, "comesFrom", ["n"], [82]], ["n", 105, "comesFrom", ["n"], [82]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; } int main ( ) { string s ( \" abcab \" ) ; cout << countSubstringWithEqualEnds ( s ) ; return 0 ; }", "docstring": "Count substrings with same first and last characters | Most efficient C ++ program to count all substrings with same first and last characters . ; assuming lower case only ; Calculating frequency of each character in the string . ; Computing result using counts ; Driver function", "dfg": [["result", 108, "comesFrom", ["result"], [87]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 55, "comesFrom", ["i"], [47]], ["i", 80, "comesFrom", ["i"], [76]], ["i", 84, "comesFrom", ["i"], [76]], ["i", 62, "comesFrom", ["i"], [47]], ["i", 92, "comesFrom", ["i"], [76]], ["i", 98, "comesFrom", ["i"], [76]], ["n", 53, "comesFrom", ["n"], [26]], ["MAX_CHAR", 82, "comesFrom", ["MAX_CHAR"], [9]], ["MAX_CHAR", 37, "comesFrom", ["MAX_CHAR"], [9]], ["s", 28, "comesFrom", ["s"], [17]], ["s", 128, "comesFrom", ["s"], [117]], ["s", 60, "comesFrom", ["s"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; char maxRepeating ( string str ) { int n = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; } int main ( ) { string str = \" aaaabbaaccde \" ; cout << maxRepeating ( str ) ; return 0 ; }", "docstring": "Maximum consecutive repeating character in string | C ++ program to find the maximum consecutive repeating character in given string ; Returns the maximum repeating character in a given string ; Traverse string except last character ; If current character matches with next ; If doesn 't match, update result  (if required) and reset count ; Driver code", "dfg": [["res", 107, "comesFrom", ["res"], [92]], ["i", 48, "comesFrom", ["i"], [44]], ["i", 52, "comesFrom", ["i"], [44]], ["i", 58, "comesFrom", ["i"], [44]], ["i", 66, "comesFrom", ["i"], [44]], ["i", 71, "comesFrom", ["i"], [44]], ["i", 96, "comesFrom", ["i"], [44]], ["n", 50, "comesFrom", ["n"], [15]], ["n", 60, "comesFrom", ["n"], [15]], ["str", 31, "comesFrom", ["str"], [11]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 126, "comesFrom", ["str"], [116]], ["str", 64, "comesFrom", ["str"], [11]], ["str", 69, "comesFrom", ["str"], [11]], ["str", 94, "comesFrom", ["str"], [11]], ["cur_count", 76, "comesFrom", ["cur_count"], [37]], ["cur_count", 83, "comesFrom", ["cur_count"], [37]], ["cur_count", 90, "comesFrom", ["cur_count"], [37]], ["count", 85, "comesFrom", ["count"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define MAX  10000 NEW_LINE #define CHAR_SIZE  26 NEW_LINE using namespace std ; void precompute ( int mat [ MAX ] [ CHAR_SIZE ] , char str [ ] , int len ) { for ( int i = 0 ; i < CHAR_SIZE ; ++ i ) mat [ len ] [ i ] = len ; for ( int i = len - 1 ; i >= 0 ; -- i ) { for ( int j = 0 ; j < CHAR_SIZE ; ++ j ) mat [ i ] [ j ] = mat [ i + 1 ] [ j ] ; mat [ i ] [ str [ i ] - ' a ' ] = i ; } } bool query ( int mat [ MAX ] [ CHAR_SIZE ] , const char * str , int len ) { int pos = 0 ; for ( int i = 0 ; i < strlen ( str ) ; ++ i ) { if ( mat [ pos ] [ str [ i ] - ' a ' ] >= len ) return false ; else pos = mat [ pos ] [ str [ i ] - ' a ' ] + 1 ; } return true ; } int main ( ) { char S [ ] = \" geeksforgeeks \" ; int len = strlen ( S ) ; int mat [ MAX ] [ CHAR_SIZE ] ; precompute ( mat , S , len ) ; query ( mat , \" gg \" , len ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; query ( mat , \" gro \" , len ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; query ( mat , \" gfg \" , len ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; query ( mat , \" orf \" , len ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }", "docstring": "Queries on subsequence of string | C ++ program to answer subsequence queries for a given string . ; Precompute the position of each character from each position of String S ; Computing position of each character from each position of String S ; Print \" Yes \" if T is subsequence of S , else \" No \" ; Traversing the string T ; If next position is greater than length of S set flag to false . ; Setting position of next character ; Driven Program", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void query ( char s [ ] , int i , int j ) { int n = strlen ( s ) ; i %= n ; j %= n ; ( s [ i ] == s [ j ] ) ? ( cout << \" Yes \" << endl ) : ( cout << \" No \" << endl ) ; } int main ( ) { char X [ ] = \" geeksforgeeks \" ; query ( X , 0 , 8 ) ; query ( X , 8 , 13 ) ; query ( X , 6 , 15 ) ; return 0 ; }", "docstring": "Queries for characters in a repeated string | Queries for same characters in a repeated string ; Print whether index i and j have same element or not . ; Finding relative position of index i , j . ; Checking is element are same at index i , j . ; Driven Program", "dfg": [["n", 32, "comesFrom", ["n"], [23]], ["n", 36, "comesFrom", ["n"], [23]], ["i", 41, "comesFrom", ["i"], [30]], ["j", 46, "comesFrom", ["j"], [34]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( string str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) result ++ ; return result ; } int main ( ) { string str = \" geeksforgeeks \" ; cout << countPairs ( str ) ; return 0 ; }", "docstring": "Count of character pairs at same distance as in English alphabets | A Simple C ++ program to find pairs with distance equal to English alphabet distance ; Function to count pairs ; Increment count if characters are at same distance ; Driver code", "dfg": [["result", 84, "comesFrom", ["result"], [15]], ["result", 80, "comesFrom", ["result"], [15]], ["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 47, "comesFrom", ["i"], [31]], ["i", 75, "comesFrom", ["i"], [31]], ["i", 64, "comesFrom", ["i"], [31]], ["n", 37, "comesFrom", ["n"], [20]], ["n", 53, "comesFrom", ["n"], [20]], ["j", 51, "comesFrom", ["j"], [45]], ["j", 55, "comesFrom", ["j"], [45]], ["j", 77, "comesFrom", ["j"], [45]], ["j", 69, "comesFrom", ["j"], [45]], ["str", 22, "comesFrom", ["str"], [11]], ["str", 103, "comesFrom", ["str"], [93]], ["str", 62, "comesFrom", ["str"], [11]], ["str", 67, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestString ( string str1 , string str2 ) { int count1 [ 26 ] = { 0 } , count2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; string result ; for ( int i = 0 ; i < 26 ; i ++ ) for ( int j = 1 ; j <= min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) result . push_back ( ' a ' + i ) ; cout << result ; } int main ( ) { string str1 = \" geeks \" , str2 = \" cake \" ; longestString ( str1 , str2 ) ; return 0 ; }", "docstring": "Longest common subsequence with permutations allowed | C ++ program to find LCS with permutations allowed ; Function to calculate longest string str1 -- > first string str2 -- > second string count1 [ ] -- > hash array to calculate frequency of characters in str1 count [ 2 ] -- > hash array to calculate frequency of characters in str2 result -- > resultant longest string whose permutations are sub - sequence of given two strings ; calculate frequency of characters ; Now traverse hash array ; append character ( ' a ' + i ) in resultant string ' result ' by min ( count1 [ i ] , count2i ] ) times ; Driver program to run the case", "dfg": [["i", 43, "comesFrom", ["i"], [39]], ["i", 51, "comesFrom", ["i"], [39]], ["i", 76, "comesFrom", ["i"], [72]], ["i", 84, "comesFrom", ["i"], [72]], ["i", 112, "comesFrom", ["i"], [108]], ["i", 116, "comesFrom", ["i"], [108]], ["i", 154, "comesFrom", ["i"], [108]], ["i", 132, "comesFrom", ["i"], [108]], ["i", 137, "comesFrom", ["i"], [108]], ["i", 58, "comesFrom", ["i"], [39]], ["i", 91, "comesFrom", ["i"], [72]], ["result", 159, "comesFrom", ["result"], [103]], ["result", 144, "comesFrom", ["result"], [103]], ["j", 126, "comesFrom", ["j"], [122]], ["j", 141, "comesFrom", ["j"], [122]], ["str1", 182, "comesFrom", ["str1"], [168]], ["str1", 45, "comesFrom", ["str1"], [11]], ["str1", 56, "comesFrom", ["str1"], [11]], ["str2", 184, "comesFrom", ["str2"], [174]], ["str2", 78, "comesFrom", ["str2"], [14]], ["str2", 89, "comesFrom", ["str2"], [14]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; bool checkPattern ( string str , string pattern ) { int len = pattern . length ( ) ; if ( str . length ( ) < len ) return false ; for ( int i = 0 ; i < len - 1 ; i ++ ) { char x = pattern [ i ] ; char y = pattern [ i + 1 ] ; size_t last = str . find_last_of ( x ) ; size_t first = str . find_first_of ( y ) ; if ( last == string :: npos first == string :: npos last > first ) return false ; } return true ; } int main ( ) { string str = \" engineers ▁ rock \" ; string pattern = \" gsr \" ; cout << boolalpha << checkPattern ( str , pattern ) ; return 0 ; }", "docstring": "Check if string follows order of characters defined by a pattern or not | Set 1 | C ++ program check if characters in the input string follows the same order as determined by characters present in the given pattern ; Function to check if characters in the input string follows the same order as determined by characters present in the given pattern ; len stores length of the given pattern ; if length of pattern is more than length of input string , return false ; ; x , y are two adjacent characters in pattern ; find index of last occurrence of character x in the input string ; find index of first occurrence of character y in the input string ; return false if x or y are not present in the input string OR last occurrence of x is after the first occurrence of y in the input string ; return true if string matches the pattern ; Driver code", "dfg": [["i", 46, "comesFrom", ["i"], [42]], ["i", 52, "comesFrom", ["i"], [42]], ["i", 61, "comesFrom", ["i"], [42]], ["i", 69, "comesFrom", ["i"], [42]], ["len", 34, "comesFrom", ["len"], [18]], ["len", 48, "comesFrom", ["len"], [18]], ["pattern", 20, "comesFrom", ["pattern"], [14]], ["pattern", 145, "comesFrom", ["pattern"], [131]], ["pattern", 59, "comesFrom", ["pattern"], [14]], ["pattern", 67, "comesFrom", ["pattern"], [14]], ["str", 143, "comesFrom", ["str"], [124]], ["str", 28, "comesFrom", ["str"], [11]], ["str", 77, "comesFrom", ["str"], [11]], ["str", 87, "comesFrom", ["str"], [11]], ["x", 81, "comesFrom", ["x"], [57]], ["y", 91, "comesFrom", ["y"], [65]], ["last", 96, "comesFrom", ["last"], [75]], ["last", 106, "comesFrom", ["last"], [75]], ["first", 101, "comesFrom", ["first"], [85]], ["first", 108, "comesFrom", ["first"], [85]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int findSum ( string str ) { string temp = \" \" ; int sum = 0 ; for ( char ch : str ) { if ( isdigit ( ch ) ) temp += ch ; else { sum += atoi ( temp . c_str ( ) ) ; temp = \" \" ; } } return sum + atoi ( temp . c_str ( ) ) ; } int main ( ) { string str = \"12abc20yz68\" ; cout << findSum ( str ) ; return 0 ; }", "docstring": "Calculate sum of all numbers present in a string | C ++ program to calculate sum of all numbers present in a string containing alphanumeric characters ; Function to calculate sum of all numbers present in a string containing alphanumeric characters ; A temporary string ; holds sum of all numbers present in the string ; read each character in input string ; if current character is a digit ; if current character is an alphabet ; increment sum by number found earlier ( if any ) ; reset temporary string to empty ; atoi ( temp . c_str ( ) ) takes care of trailing numbers ; Driver code ; input alphanumeric string ; Function call", "dfg": [["str", 31, "comesFrom", ["str"], [11]], ["str", 95, "comesFrom", ["str"], [85]], ["sum", 67, "comesFrom", ["sum"], [47]], ["temp", 71, "comesFrom", ["temp"], [58]], ["temp", 51, "comesFrom", ["temp"], [41]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countkDist ( string str , int k ) { int n = str . length ( ) ; int res = 0 ; int cnt [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - ' a ' ] == 0 ) dist_count ++ ; cnt [ str [ j ] - ' a ' ] ++ ; if ( dist_count == k ) res ++ ; if ( dist_count > k ) break ; } } return res ; } int main ( ) { string str = \" abcbaa \" ; int k = 3 ; cout << \" Total ▁ substrings ▁ with ▁ exactly ▁ \" << k << \" ▁ distinct ▁ characters ▁ : \" << countkDist ( str , k ) << endl ; return 0 ; }", "docstring": "Count number of substrings with exactly k distinct characters | C ++ program to count number of substrings with exactly k distinct characters in a given string ; Function to count number of substrings with exactly k unique characters ; Initialize result ; To store count of characters from ' a ' to ' z ' ; Consider all substrings beginning with str [ i ] ; Initializing array with 0 ; Consider all substrings between str [ i . . j ] ; If this is a new character for this substring , increment dist_count . ; Increment count of current character ; If distinct character count becomes k , then increment result . ; Driver Program", "dfg": [["res", 140, "comesFrom", ["res"], [27]], ["res", 126, "comesFrom", ["res"], [27]], ["i", 44, "comesFrom", ["i"], [40]], ["i", 48, "comesFrom", ["i"], [40]], ["n", 46, "comesFrom", ["n"], [18]], ["n", 78, "comesFrom", ["n"], [18]], ["str", 20, "comesFrom", ["str"], [11]], ["str", 174, "comesFrom", ["str"], [149]], ["str", 107, "comesFrom", ["str"], [11]], ["str", 88, "comesFrom", ["str"], [11]], ["j", 76, "comesFrom", ["j"], [72]], ["j", 80, "comesFrom", ["j"], [72]], ["j", 109, "comesFrom", ["j"], [72]], ["j", 90, "comesFrom", ["j"], [72]], ["k", 166, "comesFrom", ["k"], [156]], ["k", 176, "comesFrom", ["k"], [156]], ["k", 124, "comesFrom", ["k"], [14]], ["k", 133, "comesFrom", ["k"], [14]], ["dist_count", 102, "comesFrom", ["dist_count"], [53]], ["dist_count", 122, "comesFrom", ["dist_count"], [53]], ["dist_count", 131, "comesFrom", ["dist_count"], [53]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; string to_upper ( string & in ) { for ( int i = 0 ; i < in . length ( ) ; i ++ ) if ( ' a ' <= in [ i ] <= ' z ' ) in [ i ] = in [ i ] - ' a ' + ' A ' ; return in ; } int main ( ) { string str = \" geeksforgeeks \" ; cout << to_upper ( str ) ; return 0 ; }", "docstring": "Lower case to upper case | C ++ program to convert a string to uppercase ; Converts a string to uppercase ; Driver code", "dfg": [["i", 22, "comesFrom", ["i"], [18]], ["i", 30, "comesFrom", ["i"], [18]], ["i", 54, "comesFrom", ["i"], [18]], ["i", 43, "comesFrom", ["i"], [18]], ["i", 59, "comesFrom", ["i"], [18]], ["str", 94, "comesFrom", ["str"], [84]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinLength ( string arr [ ] , int n ) { int min = arr [ 0 ] . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] . length ( ) < min ) min = arr [ i ] . length ( ) ; return ( min ) ; } string commonPrefix ( string arr [ ] , int n ) { int minlen = findMinLength ( arr , n ) ; string result ; for ( int i = 0 ; i < minlen ; i ++ ) { current = arr [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) if ( arr [ j ] [ i ] != current ) return result ; result . push_back ( current ) ; } return ( result ) ; } int main ( ) { string arr [ ] = { \" geeksforgeeks \" , \" geeks \" , \" geek \" , \" geezer \" } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; string ans = commonPrefix ( arr , n ) ; if ( ans . length ( ) ) cout << \" The ▁ longest ▁ common ▁ prefix ▁ is ▁ \" << ans ; else cout << \" There ▁ is ▁ no ▁ common ▁ prefix \" ; return ( 0 ) ; }", "docstring": "Longest Common Prefix using Character by Character Matching | A C ++ Program to find the longest common prefix ; A Function to find the string having the minimum length and returns that length ; A Function that returns the longest common prefix from the array of strings ; Our resultant string char current ; The current character ; Current character ( must be same in all strings to be a part of result ) ; Append to result ; Driver program to test above function", "dfg": [["i", 38, "comesFrom", ["i"], [34]], ["i", 42, "comesFrom", ["i"], [34]], ["i", 107, "comesFrom", ["i"], [103]], ["i", 111, "comesFrom", ["i"], [103]], ["i", 122, "comesFrom", ["i"], [103]], ["i", 49, "comesFrom", ["i"], [34]], ["i", 62, "comesFrom", ["i"], [34]], ["i", 146, "comesFrom", ["i"], [103]], ["n", 40, "comesFrom", ["n"], [16]], ["n", 94, "comesFrom", ["n"], [84]], ["n", 134, "comesFrom", ["n"], [84]], ["n", 219, "comesFrom", ["n"], [197]], ["min", 71, "comesFrom", ["min"], [58]], ["min", 56, "comesFrom", ["min"], [20]], ["minlen", 109, "comesFrom", ["minlen"], [88]], ["result", 164, "comesFrom", ["result"], [98]], ["result", 152, "comesFrom", ["result"], [98]], ["result", 154, "comesFrom", ["result"], [98]], ["ans", 236, "comesFrom", ["ans"], [213]], ["ans", 224, "comesFrom", ["ans"], [213]], ["j", 132, "comesFrom", ["j"], [128]], ["j", 136, "comesFrom", ["j"], [128]], ["j", 143, "comesFrom", ["j"], [128]], ["current", 158, "comesFrom", ["current"], [115]], ["current", 149, "comesFrom", ["current"], [115]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printZigZagConcat ( string str , int n ) { if ( n == 1 ) { cout << str ; return ; } int len = str . length ( ) ; string arr [ n ] ; int row = 0 ; bool down ; for ( int i = 0 ; i < len ; ++ i ) { arr [ row ] . push_back ( str [ i ] ) ; if ( row == n - 1 ) down = false ; else if ( row == 0 ) down = true ; ( down ) ? ( row ++ ) : ( row -- ) ; } for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] ; } int main ( ) { string str = \" GEEKSFORGEEKS \" ; int n = 3 ; printZigZagConcat ( str , n ) ; return 0 ; }", "docstring": "Print Concatenation of Zig | C ++ program to print string obtained by concatenation of different rows of Zig - Zag fashion ; Prints concatenation of all rows of str 's Zig-Zag fashion ; Corner Case ( Only one row ) ; Find length of string ; Create an array of strings for all n rows ; Initialize index for array of strings arr [ ] ; True if we are moving down in rows , else false ; Traverse through given string ; append current character to current row ; If last row is reached , change direction to ' up ' ; If 1 st row is reached , change direction to ' down ' ; If direction is down , increment , else decrement ; Print concatenation of all rows ; Driver program", "dfg": [["n", 43, "comesFrom", ["n"], [14]], ["n", 129, "comesFrom", ["n"], [14]], ["n", 19, "comesFrom", ["n"], [14]], ["n", 163, "comesFrom", ["n"], [155]], ["n", 86, "comesFrom", ["n"], [14]], ["i", 61, "comesFrom", ["i"], [57]], ["i", 66, "comesFrom", ["i"], [57]], ["i", 127, "comesFrom", ["i"], [123]], ["i", 132, "comesFrom", ["i"], [123]], ["i", 138, "comesFrom", ["i"], [123]], ["i", 78, "comesFrom", ["i"], [57]], ["len", 63, "comesFrom", ["len"], [32]], ["str", 161, "comesFrom", ["str"], [148]], ["str", 26, "comesFrom", ["str"], [11]], ["str", 34, "comesFrom", ["str"], [11]], ["str", 76, "comesFrom", ["str"], [11]], ["row", 84, "comesFrom", ["row"], [47]], ["row", 110, "comesFrom", ["row"], [47]], ["row", 115, "comesFrom", ["row"], [47]], ["row", 71, "comesFrom", ["row"], [47]], ["row", 97, "comesFrom", ["row"], [47]], ["down", 106, "comesFrom", ["down"], [101]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_CHARS  256 NEW_LINE bool areIsomorphic ( string str1 , string str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; if ( m != n ) return false ; bool marked [ MAX_CHARS ] = { false } ; int map [ MAX_CHARS ] ; memset ( map , -1 , sizeof ( map ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map [ str1 [ i ] ] == -1 ) { if ( marked [ str2 [ i ] ] == true ) return false ; marked [ str2 [ i ] ] = true ; map [ str1 [ i ] ] = str2 [ i ] ; } else if ( map [ str1 [ i ] ] != str2 [ i ] ) return false ; } return true ; } int main ( ) { cout << areIsomorphic ( \" aab \" , \" xxy \" ) << endl ; cout << areIsomorphic ( \" aab \" , \" xyz \" ) << endl ; return 0 ; }", "docstring": "Check if two given strings are isomorphic to each other | C ++ program to check if two strings are isomorphic ; This function returns true if str1 and str2 are isomorphic ; Length of both strings must be same for one to one corresponance ; To mark visited characters in str2 ; To store mapping of every character from str1 to that of str2 . Initialize all entries of map as - 1. ; Process all characters one by on ; If current character of str1 is seen first time in it . ; If current character of str2 is already seen , one to one mapping not possible ; Mark current character of str2 as visited ; Store mapping of current characters ; If this is not first appearance of current character in str1 , then check if previous appearance mapped to same character of str2 ; Driver program", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_CHARS  26 NEW_LINE bool areIsomorphic ( string str1 , string str2 ) { int n = str1 . length ( ) , m = str2 . length ( ) ; if ( n != m ) return false ; int count [ MAX_CHARS ] = { 0 } ; int dcount [ MAX_CHARS ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { count [ str1 [ i ] - ' a ' ] ++ ; dcount [ str2 [ i ] - ' a ' ] ++ ; if ( count [ str1 [ i ] - ' a ' ] != dcount [ str2 [ i ] - ' a ' ] ) return false ; } return true ; } int main ( ) { cout << areIsomorphic ( \" aab \" , \" xxy \" ) << endl ; cout << areIsomorphic ( \" aab \" , \" xyz \" ) << endl ; return 0 ; }", "docstring": "Check if two given strings are isomorphic to each other | C ++ program for the above approach ; This function returns true if str1 and str2 are isomorphic ; Length of both strings must be same for one to one correspondence ; For counting the previous appearances of character in both the strings ; Process all characters one by one ; For string to be isomorphic the previous counts of appearances of current character in both string must be same if it is not same we return false . ; Driver Code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalin ( char str [ ] , int st , int end ) { while ( st < end ) { if ( str [ st ] != str [ end ] ) return false ; st ++ ; end -- ; } return true ; } int findMinInsert ( char str [ ] , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( isPalin ( str , 0 , i ) ) return ( n - i - 1 ) ; } } int main ( ) { char Input [ ] = \" JAVA \" ; printf ( \" % d \" , findMinInsert ( Input , strlen ( Input ) ) ) ; return 0 ; }", "docstring": "Minimum insertions to form shortest palindrome | C ++ program to find minimum number of insertions on left side to form a palindrome . ; Returns true if a string str [ st . . end ] is palindrome ; Returns count of insertions on left side to make str [ ] a palindrome ; Find the largest prefix of given string that is palindrome . ; Characters after the palindromic prefix must be added at the beginning also to make the complete string palindrome ; Driver program", "dfg": [["i", 76, "comesFrom", ["i"], [70]], ["i", 80, "comesFrom", ["i"], [70]], ["i", 92, "comesFrom", ["i"], [70]], ["i", 99, "comesFrom", ["i"], [70]], ["st", 24, "comesFrom", ["st"], [16]], ["st", 44, "comesFrom", ["st"], [16]], ["st", 33, "comesFrom", ["st"], [16]], ["end", 26, "comesFrom", ["end"], [19]], ["end", 47, "comesFrom", ["end"], [19]], ["end", 38, "comesFrom", ["end"], [19]], ["n", 72, "comesFrom", ["n"], [64]], ["n", 97, "comesFrom", ["n"], [64]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; long int removeRecur ( long int n ) { int prev_digit = n % 10 ; long int pow = 10 ; long int res = prev_digit ; while ( n ) { int curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; } int main ( ) { long int n = 12224 ; cout << removeRecur ( n ) ; return 0 ; }", "docstring": "Remove repeated digits in a given number | C ++ program to remove repeated digits ; Store first digits as previous digit ; Initialize power ; Iterate through all digits of n , note that the digits are processed from least significant digit to most significant digit . ; Store current digit ; Add the current digit to the beginning of result ; Update previous result and power ; Remove last digit from n ; Driver program", "dfg": [["res", 77, "comesFrom", ["res"], [54]], ["n", 37, "comesFrom", ["n"], [13]], ["n", 19, "comesFrom", ["n"], [13]], ["n", 95, "comesFrom", ["n"], [87]], ["n", 43, "comesFrom", ["n"], [13]], ["n", 71, "comesFrom", ["n"], [69]], ["curr_digit", 49, "comesFrom", ["curr_digit"], [41]], ["curr_digit", 62, "comesFrom", ["curr_digit"], [41]], ["curr_digit", 56, "comesFrom", ["curr_digit"], [41]], ["prev_digit", 51, "comesFrom", ["prev_digit"], [33]], ["pow", 58, "comesFrom", ["pow"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void stringFilter ( char * str ) { int n = strlen ( str ) ; int i = -1 ; int j = 0 ; while ( j < n ) { if ( j < n - 1 && str [ j ] == ' a ' && str [ j + 1 ] == ' c ' ) j += 2 ; else if ( str [ j ] == ' b ' ) j ++ ; else if ( i >= 0 && str [ j ] == ' c ' && str [ i ] == ' a ' ) i -- , j ++ ; else str [ ++ i ] = str [ j ++ ] ; } str [ ++ i ] = ' \\0' ; } int main ( ) { char str1 [ ] = \" ad \" ; cout << \" Input ▁ = > ▁ \" << str1 << \" Output = > \" stringFilter ( str1 ) ; cout << str1 << endl << endl ; char str2 [ ] = \" acbac \" ; cout << \" Input ▁ = > ▁ \" << str2 << \" Output = > \" stringFilter ( str2 ) ; cout << str2 << endl << endl ; char str3 [ ] = \" aaac \" ; cout << \" Input ▁ = > ▁ \" << str3 << \" Output = > \" stringFilter ( str3 ) ; cout << str3 << endl << endl ; char str4 [ ] = \" react \" ; cout << \" Input ▁ = > ▁ \" << str4 << \" Output = > \" stringFilter ( str4 ) ; cout << str4 << endl << endl ; char str5 [ ] = \" aa \" ; cout << \" Input ▁ = > ▁ \" << str5 << \" Output = > \" stringFilter ( str5 ) ; cout << str5 << endl << endl ; char str6 [ ] = \" ababaac \" ; cout << \" Input ▁ = > ▁ \" << str6 << \" Output = > \" stringFilter ( str6 ) ; cout << str6 << endl << endl ; char str [ ] = \" abc \" ; cout << \" Input ▁ = > ▁ \" << str << \" Output = > \" stringFilter ( str ) ; cout << str << endl << endl ; return 0 ; }", "docstring": "Remove \" b \" and \" ac \" from a given string | A C ++ program to remove \" b \" and ' ac ' from input string ; The main function that removes occurrences of \" a \" and \" bc \" in input string ; previous character ; current character ; check if current and next character forms ac ; if current character is b ; if current char is ' c ▁ & & ▁ last ▁ char ▁ in ▁ output ▁ ▁ is ▁ ' a ' so delete both  ; else copy curr char to output string ; Driver program to test above function", "dfg": [["j", 35, "comesFrom", ["j"], [29]], ["j", 42, "comesFrom", ["j"], [29]], ["j", 90, "comesFrom", ["j"], [72]], ["j", 50, "comesFrom", ["j"], [29]], ["j", 61, "comesFrom", ["j"], [29]], ["j", 81, "comesFrom", ["j"], [72]], ["j", 125, "comesFrom", ["j"], [72]], ["j", 102, "comesFrom", ["j"], [72]], ["j", 137, "comesFrom", ["j"], [72]], ["n", 37, "comesFrom", ["n"], [16]], ["n", 44, "comesFrom", ["n"], [16]], ["i", 145, "comesFrom", ["i"], [24]], ["i", 122, "comesFrom", ["i"], [24]], ["i", 96, "comesFrom", ["i"], [24]], ["i", 113, "comesFrom", ["i"], [24]], ["i", 132, "comesFrom", ["i"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int myAtoi ( const char * str ) { int sign = 1 , base = 0 , i = 0 ; while ( str [ i ] == ' ▁ ' ) { i ++ ; } if ( str [ i ] == ' - ' str [ i ] == ' + ' ) { sign = 1 - 2 * ( str [ i ++ ] == ' - ' ) ; } while ( str [ i ] >= '0' && str [ i ] <= '9' ) { if ( base > INT_MAX / 10 || ( base == INT_MAX / 10 && str [ i ] - '0' > 7 ) ) { if ( sign == 1 ) return INT_MAX ; else return INT_MIN ; } base = 10 * base + ( str [ i ++ ] - '0' ) ; } return base * sign ; } int main ( ) { char str [ ] = \" ▁ - 123\" ; int val = myAtoi ( str ) ; cout << \" ▁ \" << val ; return 0 ; }", "docstring": "Write your own atoi ( ) | A simple C ++ program for implementation of atoi ; if whitespaces then ignore . ; sign of number ; checking for valid input ; handling overflow test case ; Driver Code ; Functional Code", "dfg": [["base", 175, "comesFrom", ["base"], [155]], ["base", 115, "comesFrom", ["base"], [21]], ["base", 159, "comesFrom", ["base"], [155]], ["base", 122, "comesFrom", ["base"], [21]], ["sign", 177, "comesFrom", ["sign"], [71]], ["sign", 143, "comesFrom", ["sign"], [71]], ["val", 208, "comesFrom", ["val"], [195]], ["i", 43, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 51, "comesFrom", ["i"], [25]], ["i", 61, "comesFrom", ["i"], [25]], ["i", 96, "comesFrom", ["i"], [25]], ["i", 105, "comesFrom", ["i"], [25]], ["i", 164, "comesFrom", ["i"], [25]], ["i", 80, "comesFrom", ["i"], [25]], ["i", 130, "comesFrom", ["i"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NO_OF_CHARS  256 NEW_LINE bool areAnagram ( char * str1 , char * str2 ) { int count [ NO_OF_CHARS ] = { 0 } ; int i ; for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count [ str1 [ i ] ] ++ ; count [ str2 [ i ] ] -- ; } if ( str1 [ i ] str2 [ i ] ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] ) return false ; return true ; } int main ( ) { char str1 [ ] = \" geeksforgeeks \" ; char str2 [ ] = \" forgeeksgeeks \" ; if ( areAnagram ( str1 , str2 ) ) cout << \" The ▁ two ▁ strings ▁ are ▁ anagram ▁ of ▁ each ▁ other \" ; else cout << \" The ▁ two ▁ strings ▁ are ▁ not ▁ anagram ▁ of ▁ each ▁ \" \" other \" ; return 0 ; }", "docstring": "Check whether two strings are anagram of each other | C ++ program to check if two strings are anagrams of each other ; function to check if two strings are anagrams of each other ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; If both strings are of different length . Removing this condition will make the program fail for strings like \" aaca \" and \" aca \" ; See if there is any non - zero value in count array ; Driver code ; Function call", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areDistinct ( string str , int i , int j ) { vector < bool > visited ( 26 ) ; for ( int k = i ; k <= j ; k ++ ) { if ( visited [ str [ k ] - ' a ' ] == true ) return false ; visited [ str [ k ] - ' a ' ] = true ; } return true ; } int longestUniqueSubsttr ( string str ) { int n = str . size ( ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( areDistinct ( str , i , j ) ) res = max ( res , j - i + 1 ) ; return res ; } int main ( ) { string str = \" geeksforgeeks \" ; cout << \" The ▁ input ▁ string ▁ is ▁ \" << str << endl ; int len = longestUniqueSubsttr ( str ) ; cout << \" The ▁ length ▁ of ▁ the ▁ longest ▁ non - repeating ▁ \" \" character ▁ substring ▁ is ▁ \" << len ; return 0 ; }", "docstring": "Length of the longest substring without repeating characters | C ++ program to find the length of the longest substring without repeating characters ; This functionr eturns true if all characters in str [ i . . j ] are distinct , otherwise returns false ; Note : Default values in visited are false ; Returns length of the longest substring with all distinct characters . ; result ; Driver code", "dfg": [["res", 160, "comesFrom", ["res"], [146]], ["res", 150, "comesFrom", ["res"], [146]], ["k", 36, "comesFrom", ["k"], [32]], ["k", 40, "comesFrom", ["k"], [32]], ["k", 69, "comesFrom", ["k"], [32]], ["k", 50, "comesFrom", ["k"], [32]], ["j", 38, "comesFrom", ["j"], [17]], ["j", 128, "comesFrom", ["j"], [124]], ["j", 132, "comesFrom", ["j"], [124]], ["j", 143, "comesFrom", ["j"], [124]], ["j", 152, "comesFrom", ["j"], [124]], ["i", 114, "comesFrom", ["i"], [110]], ["i", 118, "comesFrom", ["i"], [110]], ["i", 141, "comesFrom", ["i"], [126]], ["i", 154, "comesFrom", ["i"], [126]], ["n", 116, "comesFrom", ["n"], [94]], ["n", 130, "comesFrom", ["n"], [94]], ["len", 202, "comesFrom", ["len"], [186]], ["str", 181, "comesFrom", ["str"], [169]], ["str", 96, "comesFrom", ["str"], [90]], ["str", 190, "comesFrom", ["str"], [169]], ["str", 139, "comesFrom", ["str"], [90]], ["str", 67, "comesFrom", ["str"], [11]], ["str", 48, "comesFrom", ["str"], [11]], ["visited", 65, "comesFrom", ["visited"], [24]], ["visited", 46, "comesFrom", ["visited"], [24]]]}
{"code": "# include <iostream> NEW_LINE # include <climits> NEW_LINE using namespace std ; int firstNonRepeating ( string str ) { int fi [ 256 ] ; for ( int i = 0 ; i < 256 ; i ++ ) fi [ i ] = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( fi [ str [ i ] ] == -1 ) { fi [ str [ i ] ] = i ; } else { fi [ str [ i ] ] = -2 ; } } int res = INT_MAX ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( fi [ i ] >= 0 ) res = min ( res , fi [ i ] ) ; } if ( res == INT_MAX ) return -1 ; else return res ; } int main ( ) { string str ; str = \" geeksforgeeks \" ; int firstIndex = firstNonRepeating ( str ) ; if ( firstIndex == -1 ) cout << \" Either ▁ all ▁ characters ▁ are ▁ repeating ▁ or ▁ string ▁ is ▁ empty \" ; else cout << \" First ▁ non - repeating ▁ character ▁ is ▁ \" << str [ firstIndex ] ; return 0 ; }", "docstring": "Given a string , find its first non | CPP program to find first non - repeating character ; this function return the index of first non - repeating character if found , or else it returns - 1 ; initializing all elements to - 1 ; sets all repeating characters to - 2 and non - repeating characters contain the index where they occur ; If this character is not - 1 or - 2 then it means that this character occurred only once so find the min index of all characters that occur only once , that 's our first index ; if res remains INT_MAX , it means there are no characters that repeat only once or the string is empty", "dfg": [["i", 30, "comesFrom", ["i"], [26]], ["i", 34, "comesFrom", ["i"], [26]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 59, "comesFrom", ["i"], [47]], ["i", 113, "comesFrom", ["i"], [109]], ["i", 117, "comesFrom", ["i"], [109]], ["i", 39, "comesFrom", ["i"], [26]], ["i", 84, "comesFrom", ["i"], [47]], ["i", 125, "comesFrom", ["i"], [109]], ["i", 69, "comesFrom", ["i"], [47]], ["i", 138, "comesFrom", ["i"], [109]], ["i", 80, "comesFrom", ["i"], [47]], ["i", 93, "comesFrom", ["i"], [47]], ["res", 145, "comesFrom", ["res"], [130]], ["res", 154, "comesFrom", ["res"], [130]], ["res", 134, "comesFrom", ["res"], [130]], ["INT_MAX", 147, "comesFrom", ["INT_MAX"], [104]], ["firstIndex", 181, "comesFrom", ["firstIndex"], [172]], ["firstIndex", 200, "comesFrom", ["firstIndex"], [172]], ["str", 53, "comesFrom", ["str"], [14]], ["str", 176, "comesFrom", ["str"], [165]], ["str", 198, "comesFrom", ["str"], [165]], ["str", 67, "comesFrom", ["str"], [14]], ["str", 78, "comesFrom", ["str"], [14]], ["str", 91, "comesFrom", ["str"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string unique ( string s ) { string str ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s [ i ] ; auto found = str . find ( c ) ; if ( found == std :: string :: npos ) { str += c ; } } return str ; } int main ( ) { string s = \" geeksforgeeks \" ; cout << unique ( s ) << endl ; }", "docstring": "Remove duplicates from a given string | C ++ program to create a unique string ; Function to make the string unique ; loop to traverse the string and check for repeating chars using IndexOf ( ) method in Java ; character at i 'th index of s ; If c is present in str , it returns the index of c , else it returns npos ; Adding c to str if npos is returned ; Driver code ; Input string with repeating chars", "dfg": [["str", 77, "comesFrom", ["str"], [70]], ["str", 52, "comesFrom", ["str"], [15]], ["i", 33, "comesFrom", ["i"], [29]], ["i", 37, "comesFrom", ["i"], [29]], ["i", 46, "comesFrom", ["i"], [29]], ["len", 35, "comesFrom", ["len"], [18]], ["s", 20, "comesFrom", ["s"], [11]], ["s", 44, "comesFrom", ["s"], [11]], ["s", 96, "comesFrom", ["s"], [86]], ["found", 61, "comesFrom", ["found"], [50]], ["c", 56, "comesFrom", ["c"], [42]], ["c", 72, "comesFrom", ["c"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; } void subsetSum ( int arr [ ] , int l , int r , int sum = 0 ) { if ( l > r ) { if ( isPerfect ( sum ) ) { cout << sum << \" ▁ \" ; } return ; } subsetSum ( arr , l + 1 , r , sum + arr [ l ] ) ; subsetSum ( arr , l + 1 , r , sum ) ; } int main ( ) { int arr [ ] = { 5 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; subsetSum ( arr , 0 , N - 1 ) ; return 0 ; }", "docstring": "Sum of all subsets whose sum is a Perfect Number from a given array | C ++ program for the above approach ; Function to check is a given number is a perfect number or not ; Stores the sum of its divisors ; Add all divisors of x to sum_div ; If the sum of divisors is equal to the given number , return true ; Otherwise , return false ; Function to find sum of all subsets from an array whose sum is a perfect number ; Print the current subset sum if it is a perfect number ; Check if sum is a perfect number or not ; Calculate sum of the subset including arr [ l ] ; Calculate sum of the subset excluding arr [ l ] ; Driver Code", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 33, "comesFrom", ["i"], [22]], ["i", 40, "comesFrom", ["i"], [22]], ["i", 47, "comesFrom", ["i"], [22]], ["x", 28, "comesFrom", ["x"], [11]], ["x", 55, "comesFrom", ["x"], [11]], ["x", 38, "comesFrom", ["x"], [11]], ["sum_div", 53, "comesFrom", ["sum_div"], [45]], ["l", 89, "comesFrom", ["l"], [76]], ["l", 118, "comesFrom", ["l"], [76]], ["l", 136, "comesFrom", ["l"], [76]], ["l", 128, "comesFrom", ["l"], [76]], ["r", 91, "comesFrom", ["r"], [79]], ["r", 122, "comesFrom", ["r"], [79]], ["r", 140, "comesFrom", ["r"], [79]], ["N", 186, "comesFrom", ["N"], [165]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void PartitionSub ( int arr [ ] , int i , int N , int K , int nos , vector < vector < int > > & v ) { if ( i >= N ) { if ( nos == K ) { for ( int x = 0 ; x < v . size ( ) ; x ++ ) { cout << \" { ▁ \" ; for ( int y = 0 ; y < v [ x ] . size ( ) ; y ++ ) { cout << v [ x ] [ y ] ; if ( y == v [ x ] . size ( ) - 1 ) { cout << \" ▁ \" ; } else { cout << \" , ▁ \" ; } } if ( x == v . size ( ) - 1 ) { cout << \" } \" ; } else { cout << \" } , ▁ \" ; } } cout << endl ; } return ; } for ( int j = 0 ; j < K ; j ++ ) { if ( v [ j ] . size ( ) > 0 ) { v [ j ] . push_back ( arr [ i ] ) ; PartitionSub ( arr , i + 1 , N , K , nos , v ) ; v [ j ] . pop_back ( ) ; } else { v [ j ] . push_back ( arr [ i ] ) ; PartitionSub ( arr , i + 1 , N , K , nos + 1 , v ) ; v [ j ] . pop_back ( ) ; break ; } } } void partKSubsets ( int arr [ ] , int N , int K ) { vector < vector < int > > v ( K ) ; if ( K == 0 K > N ) { cout << \" Not ▁ Possible \" << endl ; } else { cout << \" The ▁ Subset ▁ Combinations ▁ are : ▁ \" << endl ; PartitionSub ( arr , 0 , N , K , 0 , v ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; partKSubsets ( arr , N , K ) ; }", "docstring": "Print all possible ways to split an array into K subsets | C ++ program for the above approach ; Utility function to find all possible ways to split array into K subsets ; If count of elements in K subsets are greater than or equal to N ; If count of subsets formed is equal to K ; Print K subsets by splitting array into K subsets ; Print current subset ; If current element is the last element of the subset ; Otherwise ; If any subset is occupied , then push the element in that first ; Recursively do the same for remaining elements ; Backtrack ; Otherwise , push it in an empty subset and increase the subset count by 1 ; Break to avoid the case of going in other empty subsets , if available , and forming the same combination ; Function to to find all possible ways to split array into K subsets ; Stores K subset by splitting array into K subsets ; Size of each subset must be less than the number of elements ; Driver Code ; Given array ; Given K ; Size of the array ; Prints all possible splits into subsets", "dfg": [["j", 187, "comesFrom", ["j"], [183]], ["j", 191, "comesFrom", ["j"], [183]], ["j", 199, "comesFrom", ["j"], [183]], ["j", 211, "comesFrom", ["j"], [183]], ["j", 241, "comesFrom", ["j"], [183]], ["j", 253, "comesFrom", ["j"], [183]], ["j", 285, "comesFrom", ["j"], [183]], ["K", 189, "comesFrom", ["K"], [22]], ["K", 326, "comesFrom", ["K"], [309]], ["K", 417, "comesFrom", ["K"], [391]], ["K", 329, "comesFrom", ["K"], [309]], ["K", 49, "comesFrom", ["K"], [22]], ["K", 361, "comesFrom", ["K"], [309]], ["K", 232, "comesFrom", ["K"], [22]], ["K", 274, "comesFrom", ["K"], [22]], ["i", 40, "comesFrom", ["i"], [16]], ["i", 226, "comesFrom", ["i"], [16]], ["i", 218, "comesFrom", ["i"], [16]], ["i", 268, "comesFrom", ["i"], [16]], ["i", 260, "comesFrom", ["i"], [16]], ["N", 42, "comesFrom", ["N"], [19]], ["N", 415, "comesFrom", ["N"], [396]], ["N", 331, "comesFrom", ["N"], [306]], ["N", 359, "comesFrom", ["N"], [306]], ["N", 230, "comesFrom", ["N"], [19]], ["N", 272, "comesFrom", ["N"], [19]], ["nos", 47, "comesFrom", ["nos"], [25]], ["nos", 234, "comesFrom", ["nos"], [25]], ["nos", 276, "comesFrom", ["nos"], [25]], ["x", 59, "comesFrom", ["x"], [55]], ["x", 67, "comesFrom", ["x"], [55]], ["x", 144, "comesFrom", ["x"], [55]], ["x", 88, "comesFrom", ["x"], [55]], ["x", 103, "comesFrom", ["x"], [55]], ["x", 115, "comesFrom", ["x"], [55]], ["y", 84, "comesFrom", ["y"], [80]], ["y", 95, "comesFrom", ["y"], [80]], ["y", 111, "comesFrom", ["y"], [80]], ["y", 106, "comesFrom", ["y"], [80]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int store [ MAX ] , n ; int graph [ MAX ] [ MAX ] ; int d [ MAX ] ; int ans ; void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } bool is_clique ( int b ) { for ( int i = 1 ; i < b ; i ++ ) { for ( int j = i + 1 ; j < b ; j ++ ) if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) return false ; } return true ; } void primeCliques ( int i , int l , bool prime [ ] ) { for ( int j = i + 1 ; j <= n ; j ++ ) { store [ l ] = j ; if ( is_clique ( l + 1 ) ) { if ( prime [ l ] ) ans ++ ; primeCliques ( j , l + 1 , prime ) ; } } } int main ( ) { int edges [ ] [ 2 ] = { { 1 , 2 } , { 2 , 3 } , { 3 , 1 } , { 4 , 3 } , { 4 , 5 } , { 5 , 3 } } ; int size = sizeof ( edges ) / sizeof ( edges [ 0 ] ) ; n = 5 ; bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , n + 1 ) ; for ( int i = 0 ; i < size ; i ++ ) { graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 ; graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 ; d [ edges [ i ] [ 0 ] ] ++ ; d [ edges [ i ] [ 1 ] ] ++ ; } ans = 0 ; primeCliques ( 0 , 1 , prime ) ; cout << ans << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Count the number of Prime Cliques in an undirected graph | C ++ implementation to Count the number of Prime Cliques in an undirected graph ; Stores the vertices ; Graph ; Degree of the vertices ; To store the count of prime cliques ; Function to create Sieve to check primes ; false here indicates that it is not prime ; Condition if prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function to check if the given set of vertices in store array is a clique or not ; Run a loop for all set of edges ; If any edge is missing ; Function to find the count of all the cliques having prime size ; Check if any vertices from i + 1 can be inserted ; Add the vertex to store ; If the graph is not a clique of size k then it cannot be a clique by adding another edge ; increase the count of prime cliques if the size of current clique is prime ; Check if another edge can be added ; Driver code", "dfg": [["MAX", 16, "comesFrom", ["MAX"], [9]], ["MAX", 27, "comesFrom", ["MAX"], [9]], ["MAX", 33, "comesFrom", ["MAX"], [9]], ["MAX", 24, "comesFrom", ["MAX"], [9]], ["p_size", 76, "comesFrom", ["p_size"], [48]], ["p_size", 101, "comesFrom", ["p_size"], [48]], ["p", 78, "comesFrom", ["p"], [68]], ["p", 72, "comesFrom", ["p"], [68]], ["p", 74, "comesFrom", ["p"], [68]], ["p", 86, "comesFrom", ["p"], [68]], ["p", 105, "comesFrom", ["p"], [68]], ["p", 95, "comesFrom", ["p"], [68]], ["i", 131, "comesFrom", ["i"], [127]], ["i", 135, "comesFrom", ["i"], [127]], ["i", 361, "comesFrom", ["i"], [357]], ["i", 365, "comesFrom", ["i"], [357]], ["i", 201, "comesFrom", ["i"], [185]], ["i", 99, "comesFrom", ["i"], [93]], ["i", 144, "comesFrom", ["i"], [127]], ["i", 109, "comesFrom", ["i"], [103]], ["i", 382, "comesFrom", ["i"], [357]], ["i", 404, "comesFrom", ["i"], [357]], ["i", 417, "comesFrom", ["i"], [357]], ["i", 429, "comesFrom", ["i"], [357]], ["i", 373, "comesFrom", ["i"], [357]], ["i", 395, "comesFrom", ["i"], [357]], ["i", 161, "comesFrom", ["i"], [127]], ["b", 133, "comesFrom", ["b"], [121]], ["b", 150, "comesFrom", ["b"], [121]], ["j", 205, "comesFrom", ["j"], [199]], ["j", 209, "comesFrom", ["j"], [199]], ["j", 148, "comesFrom", ["j"], [142]], ["j", 152, "comesFrom", ["j"], [142]], ["j", 218, "comesFrom", ["j"], [199]], ["j", 242, "comesFrom", ["j"], [199]], ["j", 167, "comesFrom", ["j"], [142]], ["n", 207, "comesFrom", ["n"], [19]], ["n", 328, "comesFrom", ["n"], [321]], ["n", 349, "comesFrom", ["n"], [321]], ["size", 363, "comesFrom", ["size"], [306]], ["ans", 453, "comesFrom", ["ans"], [438]], ["ans", 237, "comesFrom", ["ans"], [37]], ["l", 215, "comesFrom", ["l"], [188]], ["l", 224, "comesFrom", ["l"], [188]], ["l", 234, "comesFrom", ["l"], [188]], ["l", 244, "comesFrom", ["l"], [188]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; #define dim  3 NEW_LINE struct Node { int data ; Node * next ; Node * prev ; Node * up ; Node * down ; } ; Node * createNode ( int data ) { Node * temp = new Node ( ) ; temp -> data = data ; temp -> next = NULL ; temp -> prev = NULL ; temp -> up = NULL ; temp -> down = NULL ; return temp ; } Node * constructDoublyListUtil ( int mtrx [ ] [ dim ] , int i , int j , Node * curr ) { if ( i >= dim j >= dim ) { return NULL ; } Node * temp = createNode ( mtrx [ i ] [ j ] ) ; temp -> prev = curr ; temp -> up = curr ; temp -> next = constructDoublyListUtil ( mtrx , i , j + 1 , temp ) ; temp -> down = constructDoublyListUtil ( mtrx , i + 1 , j , temp ) ; return temp ; } Node * constructDoublyList ( int mtrx [ ] [ dim ] ) { return constructDoublyListUtil ( mtrx , 0 , 0 , NULL ) ; } void display ( Node * head ) { Node * rPtr ; Node * dPtr = head ; while ( dPtr ) { rPtr = dPtr ; while ( rPtr ) { cout << rPtr -> data << \" ▁ \" ; rPtr = rPtr -> next ; } cout << \" STRNEWLINE \" ; dPtr = dPtr -> down ; } } int main ( ) { int mtrx [ dim ] [ dim ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; Node * list = constructDoublyList ( mtrx ) ; display ( list ) ; return 0 ; }", "docstring": "Construct a Doubly linked linked list from 2D Matrix | C ++ program to construct a Doubly linked linked list from 2D Matrix ; define dimension of matrix ; struct node of doubly linked list with four pointer next , prev , up , down ; function to create a new node ; function to construct the doubly linked list ; Create Node with value contain in matrix at index ( i , j ) ; Assign address of curr into the prev pointer of temp ; Assign address of curr into the up pointer of temp ; Recursive call for next pointer ; Recursive call for down pointer ; Return newly constructed node whose all four node connected at it 's appropriate position ; Function to construct the doubly linked list ; function call for construct the doubly linked list ; function for displaying doubly linked list data ; pointer to move right ; pointer to move down ; loop till node -> down is not NULL ; loop till node -> right is not NULL ; driver code ; initialise matrix", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int find_x ( int n ) { if ( n == 1 ) return 1 ; double num , den , p ; num = log10 ( n ) ; int x , no ; for ( int i = 2 ; i <= n ; i ++ ) { den = log10 ( i ) ; p = num / den ; no = ( int ) ( pow ( i , int ( p ) ) ) ; if ( abs ( no - n ) < 1e-6 ) { x = i ; break ; } } return x ; } bool is_key ( int n , int x ) { double p ; p = log10 ( n ) / log10 ( x ) ; int no = ( int ) ( pow ( x , int ( p ) ) ) ; if ( n == no ) return true ; return false ; } int evenPaths ( struct Node * node , int count , int x ) { if ( node == NULL || ! is_key ( node -> key , x ) ) { return count ; } if ( ! node -> left && ! node -> right ) { count ++ ; } count = evenPaths ( node -> left , count , x ) ; return evenPaths ( node -> right , count , x ) ; } int countExpPaths ( struct Node * node , int x ) { return evenPaths ( node , 0 , x ) ; } int main ( ) { Node * root = newNode ( 27 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 81 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 10 ) ; root -> right -> left = newNode ( 70 ) ; root -> right -> right = newNode ( 243 ) ; root -> right -> right -> left = newNode ( 81 ) ; root -> right -> right -> right = newNode ( 909 ) ; int x = find_x ( root -> key ) ; cout << countExpPaths ( root , x ) ; return 0 ; }", "docstring": "Count of exponential paths in a Binary Tree | C ++ program to find the count exponential paths in Binary Tree ; A Tree node ; Function to create a new node ; function to find x ; Take log10 of n ; Log ( n ) with base i ; Raising i to the power p ; function To check whether the given node equals to x ^ y for some y > 0 ; Take logx ( n ) with base x ; Utility function to count the exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; function to count exponential paths ; Driver Code ; create Tree ; retrieve the value of x ; Function call", "dfg": [["key", 42, "comesFrom", ["key"], [28]], ["key", 40, "comesFrom", ["key"], [28]], ["key", 431, "comesFrom", ["key"], [28]], ["key", 246, "comesFrom", ["key"], [28]], ["x", 161, "comesFrom", ["x"], [152]], ["x", 295, "comesFrom", ["x"], [232]], ["x", 318, "comesFrom", ["x"], [308]], ["x", 283, "comesFrom", ["x"], [232]], ["x", 440, "comesFrom", ["x"], [425]], ["x", 186, "comesFrom", ["x"], [171]], ["x", 198, "comesFrom", ["x"], [171]], ["x", 248, "comesFrom", ["x"], [232]], ["i", 102, "comesFrom", ["i"], [98]], ["i", 106, "comesFrom", ["i"], [98]], ["i", 114, "comesFrom", ["i"], [98]], ["i", 154, "comesFrom", ["i"], [98]], ["i", 131, "comesFrom", ["i"], [98]], ["n", 104, "comesFrom", ["n"], [64]], ["n", 69, "comesFrom", ["n"], [64]], ["n", 209, "comesFrom", ["n"], [168]], ["n", 87, "comesFrom", ["n"], [64]], ["n", 181, "comesFrom", ["n"], [168]], ["n", 146, "comesFrom", ["n"], [64]], ["no", 211, "comesFrom", ["no"], [190]], ["no", 144, "comesFrom", ["no"], [123]], ["count", 253, "comesFrom", ["count"], [229]], ["count", 293, "comesFrom", ["count"], [273]], ["count", 269, "comesFrom", ["count"], [229]], ["count", 281, "comesFrom", ["count"], [273]], ["num", 119, "comesFrom", ["num"], [83]], ["den", 121, "comesFrom", ["den"], [110]], ["p", 202, "comesFrom", ["p"], [177]], ["p", 135, "comesFrom", ["p"], [117]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1000001 ; int c , n , m , a , b ; void dfs ( int a , int b , vector < int > v [ ] , int vis [ ] ) { vis [ a ] = 1 ; c ++ ; for ( auto i : v [ a ] ) { if ( ! vis [ i ] && i != b ) dfs ( i , b , v , vis ) ; } } void Calculate ( vector < int > v [ ] ) { int vis [ n + 1 ] ; memset ( vis , 0 , sizeof ( vis ) ) ; c = 0 ; dfs ( a , b , v , vis ) ; int ans1 = n - c - 1 ; memset ( vis , 0 , sizeof ( vis ) ) ; c = 0 ; dfs ( b , a , v , vis ) ; int ans2 = n - c - 1 ; cout << ans1 * ans2 << \" STRNEWLINE \" ; } int main ( ) { n = 7 , m = 7 , a = 3 , b = 5 ; int edges [ ] [ 2 ] = { { 1 , 2 } , { 2 , 3 } , { 3 , 4 } , { 4 , 5 } , { 5 , 6 } , { 6 , 7 } , { 7 , 5 } } ; vector < int > v [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { v [ edges [ i ] [ 0 ] ] . push_back ( edges [ i ] [ 1 ] ) ; v [ edges [ i ] [ 1 ] ] . push_back ( edges [ i ] [ 0 ] ) ; } Calculate ( v ) ; return 0 ; }", "docstring": "Number of pairs such that path between pairs has the two vertices A and B | C ++ program to find the number of pairs such that the path between every pair contains two given vertices ; Function to perform DFS on the given graph by fixing the a vertex ; To mark a particular vertex as visited ; Variable to store the count of the vertices which can be reached from a ; Performing the DFS by iterating over the visited array ; If the vertex is not visited and removing the vertex b ; Function to return the number of pairs such that path between any two pairs consists the given two vertices A and B ; Initializing the visited array and assigning it with 0 's ; Initially , the count of vertices is 0 ; Performing DFS by removing the vertex B ; Count the vertices which cannot be reached after removing the vertex B ; Again reinitializing the visited array ; Setting the count of vertices to 0 to perform the DFS again ; Performing the DFS by removing the vertex A ; Count the vertices which cannot be reached after removing the vertex A ; Multiplying both the vertices set ; Driver code ; Loop to store the graph", "dfg": [["i", 287, "comesFrom", ["i"], [283]], ["i", 291, "comesFrom", ["i"], [283]], ["i", 310, "comesFrom", ["i"], [283]], ["i", 332, "comesFrom", ["i"], [283]], ["i", 299, "comesFrom", ["i"], [283]], ["i", 321, "comesFrom", ["i"], [283]], ["c", 54, "comesFrom", ["c"], [14]], ["c", 145, "comesFrom", ["c"], [125]], ["c", 181, "comesFrom", ["c"], [161]], ["m", 289, "comesFrom", ["m"], [205]], ["a", 64, "comesFrom", ["a"], [28]], ["a", 131, "comesFrom", ["a"], [28]], ["a", 169, "comesFrom", ["a"], [28]], ["a", 49, "comesFrom", ["a"], [28]], ["n", 108, "comesFrom", ["n"], [16]], ["n", 275, "comesFrom", ["n"], [201]], ["n", 143, "comesFrom", ["n"], [16]], ["n", 179, "comesFrom", ["n"], [16]], ["b", 133, "comesFrom", ["b"], [31]], ["b", 167, "comesFrom", ["b"], [31]], ["b", 78, "comesFrom", ["b"], [31]], ["b", 84, "comesFrom", ["b"], [31]], ["ans1", 187, "comesFrom", ["ans1"], [141]], ["ans2", 189, "comesFrom", ["ans2"], [177]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define V  4 NEW_LINE void tsp ( int graph [ ] [ V ] , vector < bool > & v , int currPos , int n , int count , int cost , int & ans ) { if ( count == n && graph [ currPos ] [ 0 ] ) { ans = min ( ans , cost + graph [ currPos ] [ 0 ] ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! v [ i ] && graph [ currPos ] [ i ] ) { v [ i ] = true ; tsp ( graph , v , i , n , count + 1 , cost + graph [ currPos ] [ i ] , ans ) ; v [ i ] = false ; } } } ; int main ( ) { int n = 4 ; int graph [ ] [ V ] = { { 0 , 10 , 15 , 20 } , { 10 , 0 , 35 , 25 } , { 15 , 35 , 0 , 30 } , { 20 , 25 , 30 , 0 } } ; vector < bool > v ( n ) ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = false ; v [ 0 ] = true ; int ans = INT_MAX ; tsp ( graph , v , 0 , n , 1 , 0 , ans ) ; cout << ans ; return 0 ; }", "docstring": "Travelling Salesman Problem implementation using BackTracking | C ++ implementation of the approach ; Function to find the minimum weight Hamiltonian Cycle ; If last node is reached and it has a link to the starting node i . e the source then keep the minimum value out of the total cost of traversal and \" ans \" Finally return to check for more possible values ; BACKTRACKING STEP Loop to traverse the adjacency list of currPos node and increasing the count by 1 and cost by graph [ currPos ] [ i ] value ; Mark as visited ; Mark ith node as unvisited ; Driver code ; n is the number of nodes i . e . V ; Boolean array to check if a node has been visited or not ; Mark 0 th node as visited ; Find the minimum weight Hamiltonian Cycle ; ans is the minimum weight Hamiltonian Cycle", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTheArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } cout << endl ; } void generateAllBinaryStrings ( int n , int arr [ ] , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; } int main ( ) { int n = 4 ; int arr [ n ] ; generateAllBinaryStrings ( n , arr , 0 ) ; return 0 ; }", "docstring": "Generate all the binary strings of N bits | C ++ implementation of the above approach : ; Function to print the output ; Function to generate all binary strings ; First assign \"0\" at ith position and try for all other permutations for remaining positions ; And then assign \"1\" at ith position and try for all other permutations for remaining positions ; Driver Code ; Print all binary strings", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 68, "comesFrom", ["i"], [63]], ["i", 85, "comesFrom", ["i"], [63]], ["i", 96, "comesFrom", ["i"], [63]], ["i", 103, "comesFrom", ["i"], [63]], ["i", 114, "comesFrom", ["i"], [63]], ["i", 38, "comesFrom", ["i"], [22]], ["n", 28, "comesFrom", ["n"], [16]], ["n", 133, "comesFrom", ["n"], [126]], ["n", 70, "comesFrom", ["n"], [55]], ["n", 92, "comesFrom", ["n"], [55]], ["n", 110, "comesFrom", ["n"], [55]], ["n", 138, "comesFrom", ["n"], [126]], ["n", 77, "comesFrom", ["n"], [55]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printResult ( char * result , int len ) { for ( int i = 0 ; i <= len ; i ++ ) cout << result [ i ] ; cout << endl ; } void stringCombination ( char result [ ] , char str [ ] , int count [ ] , int level , int size , int length ) { if ( level == size ) return ; for ( int i = 0 ; i < length ; i ++ ) { if ( count [ i ] == 0 ) continue ; count [ i ] -- ; result [ level ] = str [ i ] ; printResult ( result , level ) ; stringCombination ( result , str , count , level + 1 , size , length ) ; count [ i ] ++ ; } } void combination ( string str ) { map < char , int > mp ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { if ( mp . find ( str [ i ] ) != mp . end ( ) ) mp [ str [ i ] ] = mp [ str [ i ] ] + 1 ; else mp [ str [ i ] ] = 1 ; } char * input = new char [ mp . size ( ) ] ; int * count = new int [ mp . size ( ) ] ; char * result = new char [ str . size ( ) ] ; map < char , int > :: iterator it = mp . begin ( ) ; int i = 0 ; for ( it ; it != mp . end ( ) ; it ++ ) { input [ i ] = it -> first ; count [ i ] = it -> second ; i ++ ; } int length = mp . size ( ) ; int size = str . size ( ) ; stringCombination ( result , input , count , 0 , size , length ) ; } int main ( ) { string str = \" ABC \" ; combination ( str ) ; return 0 ; }", "docstring": "Print all the combinations of a string in lexicographical order | C ++ program to find all combinations of a string in lexicographical order ; function to print string ; Method to found all combination of string it is based in tree ; return if level is equal size of string ; if occurrence of char is 0 then skip the iteration of loop ; decrease the char occurrence by 1 ; store the char in result ; print the string till level ; call the function from level + 1 ; backtracking ; declare the map for store each char with occurrence ; initialize the input array with all unique char ; initialize the count array with occurrence the unique char ; temporary char array for store the result ; store the element of input array ; store the element of count array ; size of map ( no of unique char ) ; size of original string ; call function for print string combination ; Driver code", "dfg": [["it", 301, "comesFrom", ["it"], [286]], ["it", 303, "comesFrom", ["it"], [286]], ["it", 311, "comesFrom", ["it"], [286]], ["it", 320, "comesFrom", ["it"], [286]], ["it", 329, "comesFrom", ["it"], [286]], ["i", 25, "comesFrom", ["i"], [21]], ["i", 29, "comesFrom", ["i"], [21]], ["i", 87, "comesFrom", ["i"], [83]], ["i", 91, "comesFrom", ["i"], [83]], ["i", 176, "comesFrom", ["i"], [172]], ["i", 184, "comesFrom", ["i"], [172]], ["i", 333, "comesFrom", ["i"], [295]], ["i", 36, "comesFrom", ["i"], [21]], ["i", 108, "comesFrom", ["i"], [83]], ["i", 119, "comesFrom", ["i"], [83]], ["i", 148, "comesFrom", ["i"], [83]], ["i", 317, "comesFrom", ["i"], [295]], ["i", 326, "comesFrom", ["i"], [295]], ["i", 99, "comesFrom", ["i"], [83]], ["i", 196, "comesFrom", ["i"], [172]], ["i", 210, "comesFrom", ["i"], [172]], ["i", 218, "comesFrom", ["i"], [172]], ["i", 229, "comesFrom", ["i"], [172]], ["len", 27, "comesFrom", ["len"], [15]], ["length", 89, "comesFrom", ["length"], [69]], ["length", 367, "comesFrom", ["length"], [338]], ["length", 143, "comesFrom", ["length"], [69]], ["str", 385, "comesFrom", ["str"], [377]], ["str", 178, "comesFrom", ["str"], [158]], ["str", 349, "comesFrom", ["str"], [158]], ["str", 271, "comesFrom", ["str"], [158]], ["str", 194, "comesFrom", ["str"], [158]], ["str", 208, "comesFrom", ["str"], [158]], ["str", 216, "comesFrom", ["str"], [158]], ["str", 227, "comesFrom", ["str"], [158]], ["level", 74, "comesFrom", ["level"], [63]], ["level", 126, "comesFrom", ["level"], [63]], ["level", 114, "comesFrom", ["level"], [63]], ["level", 137, "comesFrom", ["level"], [63]], ["size", 76, "comesFrom", ["size"], [66]], ["size", 365, "comesFrom", ["size"], [347]], ["size", 180, "comesFrom", ["size"], [66]], ["size", 342, "comesFrom", ["size"], [66]], ["size", 351, "comesFrom", ["size"], [347]], ["size", 141, "comesFrom", ["size"], [66]], ["size", 245, "comesFrom", ["size"], [66]], ["size", 259, "comesFrom", ["size"], [66]], ["size", 273, "comesFrom", ["size"], [66]], ["mp", 288, "comesFrom", ["mp"], [167]], ["mp", 305, "comesFrom", ["mp"], [167]], ["mp", 340, "comesFrom", ["mp"], [167]], ["mp", 206, "comesFrom", ["mp"], [167]], ["mp", 243, "comesFrom", ["mp"], [167]], ["mp", 257, "comesFrom", ["mp"], [167]], ["mp", 190, "comesFrom", ["mp"], [167]], ["mp", 200, "comesFrom", ["mp"], [167]], ["mp", 214, "comesFrom", ["mp"], [167]], ["mp", 225, "comesFrom", ["mp"], [167]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void allCombinationsRec ( vector < int > & arr , int elem , int n ) { if ( elem > n ) { for ( int i : arr ) cout << i << \" ▁ \" ; cout << endl ; return ; } for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( arr [ i ] == -1 && ( i + elem + 1 ) < 2 * n && arr [ i + elem + 1 ] == -1 ) { arr [ i ] = elem ; arr [ i + elem + 1 ] = elem ; allCombinationsRec ( arr , elem + 1 , n ) ; arr [ i ] = -1 ; arr [ i + elem + 1 ] = -1 ; } } } void allCombinations ( int n ) { vector < int > arr ( 2 * n , -1 ) ; int elem = 1 ; allCombinationsRec ( arr , elem , n ) ; } int main ( ) { int n = 3 ; allCombinations ( n ) ; return 0 ; }", "docstring": "Combinations where every element appears twice and distance between appearances is equal to the value | C ++ program to find all combinations where every element appears twice and distance between appearances is equal to the value ; Find all combinations that satisfies given constraints ; if all elements are filled , print the solution ; try all possible combinations for element elem ; if position i and ( i + elem + 1 ) are not occupied in the vector ; place elem at position i and ( i + elem + 1 ) ; recurse for next element ; backtrack ( remove elem from position i and ( i + elem + 1 ) ) ; create a vector of double the size of given number with ; all its elements initialized by 1 ; start from element 1 ; Driver code ; given number", "dfg": [["i", 60, "comesFrom", ["i"], [56]], ["i", 66, "comesFrom", ["i"], [56]], ["i", 105, "comesFrom", ["i"], [56]], ["i", 134, "comesFrom", ["i"], [56]], ["i", 74, "comesFrom", ["i"], [56]], ["i", 80, "comesFrom", ["i"], [56]], ["i", 93, "comesFrom", ["i"], [56]], ["i", 112, "comesFrom", ["i"], [56]], ["i", 141, "comesFrom", ["i"], [56]], ["arr", 180, "comesFrom", ["arr"], [164]], ["elem", 26, "comesFrom", ["elem"], [18]], ["elem", 182, "comesFrom", ["elem"], [174]], ["elem", 108, "comesFrom", ["elem"], [18]], ["elem", 119, "comesFrom", ["elem"], [18]], ["elem", 125, "comesFrom", ["elem"], [18]], ["elem", 82, "comesFrom", ["elem"], [18]], ["elem", 95, "comesFrom", ["elem"], [18]], ["elem", 114, "comesFrom", ["elem"], [18]], ["elem", 143, "comesFrom", ["elem"], [18]], ["n", 28, "comesFrom", ["n"], [21]], ["n", 64, "comesFrom", ["n"], [21]], ["n", 184, "comesFrom", ["n"], [157]], ["n", 200, "comesFrom", ["n"], [194]], ["n", 168, "comesFrom", ["n"], [157]], ["n", 129, "comesFrom", ["n"], [21]], ["n", 89, "comesFrom", ["n"], [21]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define N  8 NEW_LINE static int cx [ N ] = { 1 , 1 , 2 , 2 , -1 , -1 , -2 , -2 } ; static int cy [ N ] = { 2 , -2 , 1 , -1 , 2 , -2 , 1 , -1 } ; bool limits ( int x , int y ) { return ( ( x >= 0 && y >= 0 ) && ( x < N && y < N ) ) ; } bool isempty ( int a [ ] , int x , int y ) { return ( limits ( x , y ) ) && ( a [ y * N + x ] < 0 ) ; } int getDegree ( int a [ ] , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) if ( isempty ( a , ( x + cx [ i ] ) , ( y + cy [ i ] ) ) ) count ++ ; return count ; } bool nextMove ( int a [ ] , int * x , int * y ) { int min_deg_idx = -1 , c , min_deg = ( N + 1 ) , nx , ny ; int start = rand ( ) % N ; for ( int count = 0 ; count < N ; ++ count ) { int i = ( start + count ) % N ; nx = * x + cx [ i ] ; ny = * y + cy [ i ] ; if ( ( isempty ( a , nx , ny ) ) & & ( c = getDegree ( a , nx , ny ) ) < min_deg ) { min_deg_idx = i ; min_deg = c ; } } if ( min_deg_idx == -1 ) return false ; nx = * x + cx [ min_deg_idx ] ; ny = * y + cy [ min_deg_idx ] ; a [ ny * N + nx ] = a [ ( * y ) * N + ( * x ) ] + 1 ; * x = nx ; * y = ny ; return true ; } void print ( int a [ ] ) { for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) printf ( \" % d TABSYMBOL \" , a [ j * N + i ] ) ; printf ( \" STRNEWLINE \" ) ; } } bool neighbour ( int x , int y , int xx , int yy ) { for ( int i = 0 ; i < N ; ++ i ) if ( ( ( x + cx [ i ] ) == xx ) && ( ( y + cy [ i ] ) == yy ) ) return true ; return false ; } bool findClosedTour ( ) { int a [ N * N ] ; for ( int i = 0 ; i < N * N ; ++ i ) a [ i ] = -1 ; int sx = rand ( ) % N ; int sy = rand ( ) % N ; int x = sx , y = sy ; for ( int i = 0 ; i < N * N - 1 ; ++ i ) if ( nextMove ( a , & x , & y ) == 0 ) return false ; if ( ! neighbour ( x , y , sx , sy ) ) return false ; print ( a ) ; return true ; } int main ( ) { srand ( time ( NULL ) ) ; while ( ! findClosedTour ( ) ) { ; } return 0 ; }", "docstring": "Warnsdorff 's algorithm for Knight’s tour problem | C ++ program to for Kinight ' s ▁ tour ▁ problem ▁ using ▁ Warnsdorff ' s algorithm ; Move pattern on basis of the change of x coordinates and y coordinates respectively ; function restricts the knight to remain within the 8 x8 chessboard ; Checks whether a square is valid and empty or not ; Returns the number of empty squares adjacent to ( x , y ) ; Picks next point using Warnsdorff 's heuristic. Returns false if it is not possible to pick next point. ; Try all N adjacent of ( * x , * y ) starting from a random adjacent . Find the adjacent with minimum degree . ; IF we could not find a next cell ; Store coordinates of next point ; Mark next move ; Update next point ; displays the chessboard with all the legal knight 's moves  ; If the knight ends on a square that is one knight 's move from the beginning square,  then tour is closed  ; Generates the legal moves using warnsdorff 's  heuristics. Returns false if not possible  ; Filling up the chessboard matrix with - 1 's ; Randome initial position ; Current points are same as initial points ; Keep picking next points using Warnsdorff 's heuristic ; Check if tour is closed ( Can end at starting point ) ; Driver code ; While we don 't get a solution", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < int > > result ; void solveBoard ( vector < vector < char > > & board , int row , int rowmask , int ldmask , int rdmask , int & ways ) { int n = board . size ( ) ; int all_rows_filled = ( 1 << n ) - 1 ; if ( rowmask == all_rows_filled ) { vector < int > v ; for ( int i = 0 ; i < board . size ( ) ; i ++ ) { for ( int j = 0 ; j < board . size ( ) ; j ++ ) { if ( board [ i ] [ j ] == ' Q ' ) v . push_back ( j + 1 ) ; } } result . push_back ( v ) ; return ; } int safe = all_rows_filled & ( ~ ( rowmask ldmask rdmask ) ) ; while ( safe ) { int p = safe & ( - safe ) ; int col = ( int ) log2 ( p ) ; board [ row ] [ col ] = ' Q ' ; solveBoard ( board , row + 1 , rowmask | p , ( ldmask p ) << 1 , ( rdmask p ) >> 1 , ways ) ; safe = safe & ( safe - 1 ) ; board [ row ] [ col ] = ' ▁ ' ; } return ; } int main ( ) { int n = 4 ; int ways = 0 ; vector < vector < char > > board ; for ( int i = 0 ; i < n ; i ++ ) { vector < char > tmp ; for ( int j = 0 ; j < n ; j ++ ) { tmp . push_back ( ' ▁ ' ) ; } board . push_back ( tmp ) ; } int rowmask = 0 , ldmask = 0 , rdmask = 0 ; int row = 0 ; result . clear ( ) ; solveBoard ( board , row , rowmask , ldmask , rdmask , ways ) ; sort ( result . begin ( ) , result . end ( ) ) ; for ( auto ar : result ) { cout << \" [ \" ; for ( auto it : ar ) cout << it << \" ▁ \" ; cout << \" ] \" ; } return 0 ; }", "docstring": "Printing all solutions in N | CPP program for above approach ; Program to solve N Queens problem ; All_rows_filled is a bit mask having all N bits set ; If rowmask will have all bits set , means queen has been placed successfully in all rows and board is displayed ; We extract a bit mask ( safe ) by rowmask , ldmask and rdmask . all set bits of ' safe ' indicates the safe column index for queen placement of this iteration for row index ( row ) . ; Extracts the right - most set bit ( safe column index ) where queen can be placed for this row ; these bit masks will keep updated in each iteration for next row ; Reset right - most set bit to 0 so , next iteration will continue by placing the queen at another safe column index of this row ; Backtracking , replace ' Q ' by ' ▁ ' ; Driver Code ; Board size ; Function Call", "dfg": [["result", 404, "comesFrom", ["result"], [14]], ["result", 363, "comesFrom", ["result"], [14]], ["result", 144, "comesFrom", ["result"], [14]], ["result", 386, "comesFrom", ["result"], [14]], ["result", 392, "comesFrom", ["result"], [14]], ["safe", 170, "comesFrom", ["safe"], [155]], ["safe", 176, "comesFrom", ["safe"], [155]], ["safe", 239, "comesFrom", ["safe"], [237]], ["safe", 180, "comesFrom", ["safe"], [155]], ["safe", 242, "comesFrom", ["safe"], [237]], ["i", 296, "comesFrom", ["i"], [292]], ["i", 300, "comesFrom", ["i"], [292]], ["i", 86, "comesFrom", ["i"], [82]], ["i", 94, "comesFrom", ["i"], [82]], ["i", 121, "comesFrom", ["i"], [82]], ["n", 298, "comesFrom", ["n"], [271]], ["n", 319, "comesFrom", ["n"], [271]], ["n", 61, "comesFrom", ["n"], [47]], ["board", 371, "comesFrom", ["board"], [287]], ["board", 337, "comesFrom", ["board"], [287]], ["ways", 381, "comesFrom", ["ways"], [276]], ["rowmask", 68, "comesFrom", ["rowmask"], [33]], ["rowmask", 375, "comesFrom", ["rowmask"], [346]], ["rowmask", 162, "comesFrom", ["rowmask"], [33]], ["rowmask", 216, "comesFrom", ["rowmask"], [33]], ["all_rows_filled", 70, "comesFrom", ["all_rows_filled"], [56]], ["all_rows_filled", 157, "comesFrom", ["all_rows_filled"], [56]], ["row", 373, "comesFrom", ["row"], [359]], ["row", 212, "comesFrom", ["row"], [30]], ["row", 196, "comesFrom", ["row"], [30]], ["row", 249, "comesFrom", ["row"], [30]], ["ldmask", 377, "comesFrom", ["ldmask"], [350]], ["ldmask", 163, "comesFrom", ["ldmask"], [36]], ["ldmask", 221, "comesFrom", ["ldmask"], [36]], ["rdmask", 379, "comesFrom", ["rdmask"], [354]], ["rdmask", 164, "comesFrom", ["rdmask"], [39]], ["rdmask", 228, "comesFrom", ["rdmask"], [39]], ["j", 317, "comesFrom", ["j"], [313]], ["j", 321, "comesFrom", ["j"], [313]], ["j", 105, "comesFrom", ["j"], [101]], ["j", 113, "comesFrom", ["j"], [101]], ["j", 124, "comesFrom", ["j"], [101]], ["j", 137, "comesFrom", ["j"], [101]], ["v", 148, "comesFrom", ["v"], [77]], ["v", 133, "comesFrom", ["v"], [77]], ["tmp", 341, "comesFrom", ["tmp"], [308]], ["tmp", 325, "comesFrom", ["tmp"], [308]], ["col", 199, "comesFrom", ["col"], [184]], ["col", 252, "comesFrom", ["col"], [184]], ["p", 218, "comesFrom", ["p"], [174]], ["p", 191, "comesFrom", ["p"], [174]], ["p", 222, "comesFrom", ["p"], [174]], ["p", 229, "comesFrom", ["p"], [174]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < string > split ( const string & s , char delim ) { vector < string > elems ; stringstream ss ( s ) ; string item ; while ( getline ( ss , item , delim ) ) elems . push_back ( item ) ; return elems ; } int printPowerSet ( int arr [ ] , int n ) { vector < string > list ; for ( int i = 0 ; i < ( int ) pow ( 2 , n ) ; i ++ ) { string subset = \" \" ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) subset += to_string ( arr [ j ] ) + \" | \" ; } if ( find ( list . begin ( ) , list . end ( ) , subset ) == list . end ( ) ) list . push_back ( subset ) ; } for ( string subset : list ) { vector < string > arr = split ( subset , ' ▁ ' ) ; for ( string str : arr ) cout << str << \" ▁ \" ; cout << endl ; } } int main ( ) { int arr [ ] = { 10 , 12 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPowerSet ( arr , n ) ; return 0 ; }", "docstring": "Find all distinct subsets of a given set using BitMasking Approach | C ++ program to find all subsets of given set . Any repeated subset is considered only once in the output ; Utility function to split the string using a delim . Refer - http : stackoverflow . com / questions / 236129 / split - a - string - in - c ; Function to find all subsets of given set . Any repeated subset is considered only once in the output ; Run counter i from 000. . 0 to 111. . 1 ; consider each element in the set ; Check if jth bit in the i is set . If the bit is set , we consider jth element from set ; if subset is encountered for the first time If we use set < string > , we can directly insert ; consider every subset ; split the subset and print its elements ; Driver code", "dfg": [["elems", 56, "comesFrom", ["elems"], [26]], ["elems", 48, "comesFrom", ["elems"], [26]], ["subset", 187, "comesFrom", ["subset"], [136]], ["subset", 180, "comesFrom", ["subset"], [136]], ["subset", 200, "comesFrom", ["subset"], [136]], ["subset", 167, "comesFrom", ["subset"], [136]], ["list", 189, "comesFrom", ["list"], [75]], ["list", 176, "comesFrom", ["list"], [75]], ["list", 170, "comesFrom", ["list"], [75]], ["list", 155, "comesFrom", ["list"], [75]], ["list", 161, "comesFrom", ["list"], [75]], ["i", 84, "comesFrom", ["i"], [80]], ["i", 96, "comesFrom", ["i"], [80]], ["i", 125, "comesFrom", ["i"], [80]], ["arr", 214, "comesFrom", ["arr"], [196]], ["arr", 236, "comesFrom", ["arr"], [196]], ["arr", 266, "comesFrom", ["arr"], [196]], ["arr", 253, "comesFrom", ["arr"], [196]], ["arr", 258, "comesFrom", ["arr"], [196]], ["n", 268, "comesFrom", ["n"], [249]], ["n", 116, "comesFrom", ["n"], [68]], ["n", 93, "comesFrom", ["n"], [68]], ["item", 43, "comesFrom", ["item"], [35]], ["item", 52, "comesFrom", ["item"], [35]], ["delim", 45, "comesFrom", ["delim"], [19]], ["j", 114, "comesFrom", ["j"], [110]], ["j", 118, "comesFrom", ["j"], [110]], ["j", 130, "comesFrom", ["j"], [110]], ["j", 142, "comesFrom", ["j"], [110]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool fillUtil ( int res [ ] , int curr , int n ) { if ( curr == 0 ) return true ; int i ; for ( i = 0 ; i < 2 * n - curr - 1 ; i ++ ) { if ( res [ i ] == 0 && res [ i + curr + 1 ] == 0 ) { res [ i ] = res [ i + curr + 1 ] = curr ; if ( fillUtil ( res , curr - 1 , n ) ) return true ; res [ i ] = res [ i + curr + 1 ] = 0 ; } } return false ; } void fill ( int n ) { int res [ 2 * n ] , i ; for ( i = 0 ; i < 2 * n ; i ++ ) res [ i ] = 0 ; if ( fillUtil ( res , n , n ) ) { for ( i = 0 ; i < 2 * n ; i ++ ) cout << res [ i ] << \" ▁ \" ; } else cout << \" Not ▁ Possible \" ; } int main ( ) { fill ( 7 ) ; return 0 ; }", "docstring": "Fill two instances of all numbers from 1 to n in a specific way | A backtracking based C ++ Program to fill two instances of all numbers from 1 to n in a specific way ; A recursive utility function to fill two instances of numbers from 1 to n in res [ 0. .2 n - 1 ] . ' curr ' is current value of n . ; If current number becomes 0 , then all numbers are filled ; Try placing two instances of ' curr ' at all possible locations till solution is found ; Two ' curr ' should be placed at ' curr + 1' distance ; Plave two instances of ' curr ' ; Recur to check if the above placement leads to a solution ; If solution is not possible , then backtrack ; This function prints the result for input number ' n ' using fillUtil ( ) ; Create an array of size 2 n and initialize all elements in it as 0 ; If solution is possible , then print it . ; Driver Code", "dfg": [["i", 40, "comesFrom", ["i"], [36]], ["i", 50, "comesFrom", ["i"], [36]], ["i", 152, "comesFrom", ["i"], [148]], ["i", 158, "comesFrom", ["i"], [148]], ["i", 186, "comesFrom", ["i"], [182]], ["i", 192, "comesFrom", ["i"], [182]], ["i", 163, "comesFrom", ["i"], [148]], ["i", 58, "comesFrom", ["i"], [36]], ["i", 77, "comesFrom", ["i"], [36]], ["i", 109, "comesFrom", ["i"], [36]], ["i", 199, "comesFrom", ["i"], [182]], ["i", 65, "comesFrom", ["i"], [36]], ["i", 82, "comesFrom", ["i"], [36]], ["i", 114, "comesFrom", ["i"], [36]], ["curr", 24, "comesFrom", ["curr"], [16]], ["curr", 46, "comesFrom", ["curr"], [16]], ["curr", 89, "comesFrom", ["curr"], [16]], ["curr", 97, "comesFrom", ["curr"], [16]], ["curr", 67, "comesFrom", ["curr"], [16]], ["curr", 84, "comesFrom", ["curr"], [16]], ["curr", 116, "comesFrom", ["curr"], [16]], ["n", 141, "comesFrom", ["n"], [133]], ["n", 156, "comesFrom", ["n"], [133]], ["n", 174, "comesFrom", ["n"], [133]], ["n", 176, "comesFrom", ["n"], [133]], ["n", 44, "comesFrom", ["n"], [19]], ["n", 190, "comesFrom", ["n"], [133]], ["n", 101, "comesFrom", ["n"], [19]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; class node { public : int color = 1 ; set < int > edges ; } ; int canPaint ( vector < node > & nodes , int n , int m ) { vector < int > visited ( n + 1 , 0 ) ; int maxColors = 1 ; for ( int sv = 1 ; sv <= n ; sv ++ ) { if ( visited [ sv ] ) continue ; visited [ sv ] = 1 ; queue < int > q ; q . push ( sv ) ; while ( ! q . empty ( ) ) { int top = q . front ( ) ; q . pop ( ) ; for ( auto it = nodes [ top ] . edges . begin ( ) ; it != nodes [ top ] . edges . end ( ) ; it ++ ) { if ( nodes [ top ] . color == nodes [ * it ] . color ) nodes [ * it ] . color += 1 ; maxColors = max ( maxColors , max ( nodes [ top ] . color , nodes [ * it ] . color ) ) ; if ( maxColors > m ) return 0 ; if ( ! visited [ * it ] ) { visited [ * it ] = 1 ; q . push ( * it ) ; } } } } return 1 ; } int main ( ) { int n = 4 ; bool graph [ n ] [ n ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } } ; vector < node > nodes ( n + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( graph [ i ] [ j ] ) { nodes [ i ] . edges . insert ( i ) ; nodes [ j ] . edges . insert ( j ) ; } } } cout << canPaint ( nodes , n , m ) ; cout << \" STRNEWLINE \" ; return 0 ; }", "docstring": "m Coloring Problem | Backtracking | CPP program for the above approach ; A node class which stores the color and the edges connected to the node ; Create a visited array of n nodes , initialized to zero ; maxColors used till now are 1 as all nodes are painted color 1 ; Do a full BFS traversal from all unvisited starting points ; If the starting point is unvisited , mark it visited and push it in queue ; BFS Travel starts here ; Checking all adjacent nodes to \" top \" edge in our queue ; IMPORTANT : If the color of the adjacent node is same , increase it by 1 ; If number of colors used shoots m , return 0 ; If the adjacent node is not visited , mark it visited and push it in queue ; Driver code ; Create a vector of n + 1 nodes of type \" node \" The zeroth position is just dummy ( 1 to n to be used ) ; Add edges to each node as per given input ; Connect the undirected graph ; Display final answer", "dfg": [["sv", 70, "comesFrom", ["sv"], [66]], ["sv", 74, "comesFrom", ["sv"], [66]], ["sv", 104, "comesFrom", ["sv"], [66]], ["sv", 82, "comesFrom", ["sv"], [66]], ["sv", 89, "comesFrom", ["sv"], [66]], ["n", 72, "comesFrom", ["n"], [39]], ["n", 341, "comesFrom", ["n"], [266]], ["n", 276, "comesFrom", ["n"], [266]], ["n", 51, "comesFrom", ["n"], [39]], ["n", 273, "comesFrom", ["n"], [266]], ["n", 327, "comesFrom", ["n"], [266]], ["n", 356, "comesFrom", ["n"], [266]], ["n", 406, "comesFrom", ["n"], [266]], ["i", 339, "comesFrom", ["i"], [335]], ["i", 343, "comesFrom", ["i"], [335]], ["i", 366, "comesFrom", ["i"], [335]], ["i", 382, "comesFrom", ["i"], [335]], ["i", 375, "comesFrom", ["i"], [335]], ["nodes", 404, "comesFrom", ["nodes"], [325]], ["nodes", 373, "comesFrom", ["nodes"], [325]], ["nodes", 385, "comesFrom", ["nodes"], [325]], ["j", 354, "comesFrom", ["j"], [350]], ["j", 358, "comesFrom", ["j"], [350]], ["j", 369, "comesFrom", ["j"], [350]], ["j", 394, "comesFrom", ["j"], [350]], ["j", 387, "comesFrom", ["j"], [350]], ["m", 408, "comesFrom", ["m"], [42]], ["m", 221, "comesFrom", ["m"], [42]], ["visited", 80, "comesFrom", ["visited"], [49]], ["visited", 87, "comesFrom", ["visited"], [49]], ["visited", 229, "comesFrom", ["visited"], [49]], ["visited", 236, "comesFrom", ["visited"], [49]], ["q", 100, "comesFrom", ["q"], [98]], ["q", 110, "comesFrom", ["q"], [98]], ["q", 126, "comesFrom", ["q"], [98]], ["q", 120, "comesFrom", ["q"], [98]], ["q", 244, "comesFrom", ["q"], [98]], ["it", 148, "comesFrom", ["it"], [135]], ["it", 161, "comesFrom", ["it"], [135]], ["it", 232, "comesFrom", ["it"], [135]], ["it", 249, "comesFrom", ["it"], [135]], ["it", 177, "comesFrom", ["it"], [135]], ["it", 185, "comesFrom", ["it"], [135]], ["it", 239, "comesFrom", ["it"], [135]], ["it", 210, "comesFrom", ["it"], [135]], ["maxColors", 219, "comesFrom", ["maxColors"], [192]], ["maxColors", 196, "comesFrom", ["maxColors"], [192]], ["top", 152, "comesFrom", ["top"], [118]], ["top", 139, "comesFrom", ["top"], [118]], ["top", 169, "comesFrom", ["top"], [118]], ["top", 202, "comesFrom", ["top"], [118]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int a , b , c , d ; #define MOD  1000000007 NEW_LINE void FastDoubling ( int n , int res [ ] ) { if ( n == 0 ) { res [ 0 ] = 0 ; res [ 1 ] = 1 ; return ; } FastDoubling ( ( n / 2 ) , res ) ; a = res [ 0 ] ; b = res [ 1 ] ; c = 2 * b - a ; if ( c < 0 ) c += MOD ; c = ( a * c ) % MOD ; d = ( a * a + b * b ) % MOD ; if ( n % 2 == 0 ) { res [ 0 ] = c ; res [ 1 ] = d ; } else { res [ 0 ] = d ; res [ 1 ] = c + d ; } } int main ( ) { int N = 6 ; int res [ 2 ] = { 0 } ; FastDoubling ( N , res ) ; cout << res [ 0 ] << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Fast Doubling method to find the Nth Fibonacci number | C ++ program to find the Nth Fibonacci number using Fast Doubling Method ; Function calculate the N - th fibanacci number using fast doubling method ; Base Condition ; Here a = F ( n ) ; Here b = F ( n + 1 ) ; As F ( 2 n ) = F ( n ) [ 2F ( n + 1 ) F ( n ) ] Here c = F ( 2 n ) ; As F ( 2 n + 1 ) = F ( n ) ^ 2 + F ( n + 1 ) ^ 2 Here d = F ( 2 n + 1 ) ; Check if N is odd or even ; Driver code", "dfg": []}
{"code": "#include <iostream> NEW_LINE using namespace std ; int count ( int arr [ ] , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , ( low + high ) / 2 , x ) + count ( arr , 1 + ( low + high ) / 2 , high , x ) ; } int main ( ) { int arr [ ] = { 30 , 1 , 42 , 5 , 56 , 3 , 56 , 9 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int x = 56 ; cout << count ( arr , 0 , n - 1 , x ) ; return 0 ; }", "docstring": "Frequency of an integer in the given array using Divide and Conquer | C ++ implrmrntation of the approach ; Function to return the frequency of x in the subarray arr [ low ... high ] ; If the subarray is invalid or the element is not found ; If there 's only a single element  which is equal to x ; Divide the array into two parts and then find the count of occurrences of x in both the parts ; Driver code", "dfg": [["low", 51, "comesFrom", ["low"], [16]], ["low", 70, "comesFrom", ["low"], [16]], ["low", 28, "comesFrom", ["low"], [16]], ["low", 34, "comesFrom", ["low"], [16]], ["low", 57, "comesFrom", ["low"], [16]], ["low", 73, "comesFrom", ["low"], [16]], ["low", 40, "comesFrom", ["low"], [16]], ["low", 90, "comesFrom", ["low"], [16]], ["high", 53, "comesFrom", ["high"], [19]], ["high", 97, "comesFrom", ["high"], [19]], ["high", 30, "comesFrom", ["high"], [19]], ["high", 36, "comesFrom", ["high"], [19]], ["high", 75, "comesFrom", ["high"], [19]], ["high", 92, "comesFrom", ["high"], [19]], ["x", 60, "comesFrom", ["x"], [22]], ["x", 80, "comesFrom", ["x"], [22]], ["x", 99, "comesFrom", ["x"], [22]], ["x", 161, "comesFrom", ["x"], [145]], ["x", 43, "comesFrom", ["x"], [22]], ["n", 157, "comesFrom", ["n"], [132]]]}
{"code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } int Partition ( int arr [ ] , int l , int r ) { int lst = arr [ r ] , i = l , j = l ; while ( j < r ) { if ( arr [ j ] < lst ) { swap ( & arr [ i ] , & arr [ j ] ) ; i ++ ; } j ++ ; } swap ( & arr [ i ] , & arr [ r ] ) ; return i ; } int randomPartition ( int arr [ ] , int l , int r ) { int n = r - l + 1 ; int pivot = rand ( ) % n ; swap ( & arr [ l + pivot ] , & arr [ r ] ) ; return Partition ( arr , l , r ) ; } void MedianUtil ( int arr [ ] , int l , int r , int k , int & a , int & b ) { if ( l <= r ) { int partitionIndex = randomPartition ( arr , l , r ) ; if ( partitionIndex == k ) { b = arr [ partitionIndex ] ; if ( a != -1 ) return ; } else if ( partitionIndex == k - 1 ) { a = arr [ partitionIndex ] ; if ( b != -1 ) return ; } if ( partitionIndex >= k ) return MedianUtil ( arr , l , partitionIndex - 1 , k , a , b ) ; else return MedianUtil ( arr , partitionIndex + 1 , r , k , a , b ) ; } return ; } void findMedian ( int arr [ ] , int n ) { int ans , a = -1 , b = -1 ; if ( n % 2 == 1 ) { MedianUtil ( arr , 0 , n - 1 , n / 2 , a , b ) ; ans = b ; } else { MedianUtil ( arr , 0 , n - 1 , n / 2 , a , b ) ; ans = ( a + b ) / 2 ; } cout << \" Median ▁ = ▁ \" << ans ; } int main ( ) { int arr [ ] = { 12 , 3 , 5 , 7 , 4 , 19 , 26 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMedian ( arr , n ) ; return 0 ; }", "docstring": "Median of an unsorted array using Quick Select Algorithm | CPP program to find median of an array ; Utility function to swapping of element ; Returns the correct position of pivot element ; Picks a random pivot element between l and r and partitions arr [ l . . r ] around the randomly picked element using partition ( ) ; Utility function to find median ; if l < r ; Find the partition index ; If partition index = k , then we found the median of odd number element in arr [ ] ; If index = k - 1 , then we get a & b as middle element of arr [ ] ; If partitionIndex >= k then find the index in first half of the arr [ ] ; If partitionIndex <= k then find the index in second half of the arr [ ] ; Function to find Median ; If n is odd ; If n is even ; Print the Median of arr [ ] ; Driver program to test above methods", "dfg": [["i", 126, "comesFrom", ["i"], [62]], ["i", 102, "comesFrom", ["i"], [62]], ["i", 115, "comesFrom", ["i"], [62]], ["i", 92, "comesFrom", ["i"], [62]], ["temp", 36, "comesFrom", ["temp"], [22]], ["ans", 425, "comesFrom", ["ans"], [408]], ["a", 377, "comesFrom", ["a"], [346]], ["a", 303, "comesFrom", ["a"], [268]], ["a", 403, "comesFrom", ["a"], [346]], ["a", 322, "comesFrom", ["a"], [268]], ["a", 411, "comesFrom", ["a"], [346]], ["b", 384, "comesFrom", ["b"], [350]], ["b", 379, "comesFrom", ["b"], [350]], ["b", 305, "comesFrom", ["b"], [242]], ["b", 405, "comesFrom", ["b"], [350]], ["b", 324, "comesFrom", ["b"], [242]], ["b", 413, "comesFrom", ["b"], [350]], ["b", 277, "comesFrom", ["b"], [242]], ["j", 72, "comesFrom", ["j"], [66]], ["j", 106, "comesFrom", ["j"], [66]], ["j", 81, "comesFrom", ["j"], [66]], ["j", 98, "comesFrom", ["j"], [66]], ["r", 74, "comesFrom", ["r"], [51]], ["r", 186, "comesFrom", ["r"], [141]], ["r", 220, "comesFrom", ["r"], [202]], ["r", 59, "comesFrom", ["r"], [51]], ["r", 147, "comesFrom", ["r"], [141]], ["r", 121, "comesFrom", ["r"], [51]], ["r", 175, "comesFrom", ["r"], [141]], ["r", 232, "comesFrom", ["r"], [202]], ["r", 318, "comesFrom", ["r"], [202]], ["n", 160, "comesFrom", ["n"], [145]], ["n", 474, "comesFrom", ["n"], [455]], ["n", 356, "comesFrom", ["n"], [340]], ["n", 369, "comesFrom", ["n"], [340]], ["n", 373, "comesFrom", ["n"], [340]], ["n", 395, "comesFrom", ["n"], [340]], ["n", 399, "comesFrom", ["n"], [340]], ["l", 184, "comesFrom", ["l"], [138]], ["l", 218, "comesFrom", ["l"], [199]], ["l", 149, "comesFrom", ["l"], [138]], ["l", 230, "comesFrom", ["l"], [199]], ["l", 295, "comesFrom", ["l"], [199]], ["l", 167, "comesFrom", ["l"], [138]], ["lst", 84, "comesFrom", ["lst"], [55]], ["partitionIndex", 237, "comesFrom", ["partitionIndex"], [224]], ["partitionIndex", 286, "comesFrom", ["partitionIndex"], [224]], ["partitionIndex", 261, "comesFrom", ["partitionIndex"], [224]], ["partitionIndex", 297, "comesFrom", ["partitionIndex"], [224]], ["partitionIndex", 246, "comesFrom", ["partitionIndex"], [224]], ["partitionIndex", 314, "comesFrom", ["partitionIndex"], [224]], ["partitionIndex", 272, "comesFrom", ["partitionIndex"], [224]], ["k", 239, "comesFrom", ["k"], [205]], ["k", 288, "comesFrom", ["k"], [205]], ["k", 301, "comesFrom", ["k"], [205]], ["k", 320, "comesFrom", ["k"], [205]], ["k", 263, "comesFrom", ["k"], [205]], ["pivot", 169, "comesFrom", ["pivot"], [154]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstDigit ( int n ) { while ( n >= 10 ) { n /= 10 ; } return n ; } int getCount ( int n ) { int count = 1 ; while ( n != 0 ) { int leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; } int getLargestNumber ( int k ) { int left = k ; int right = k * 10 ; int mid = ( left + right ) / 2 ; int len = getCount ( mid ) ; while ( len != k ) { mid = ( left + right ) / 2 ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; } int main ( ) { int k = 3 ; cout << getLargestNumber ( k ) ; return 0 ; }", "docstring": "Largest number N which can be reduced to 0 in K steps | C ++ program to implement above approach ; Utility function to return the first digit of a number . ; Remove last digit from number till only one digit is left ; return the first digit ; Utility function that returns the count of numbers written down when starting from n ; Function to find the largest number N which can be reduced to 0 in K steps ; Get the sequence length of the mid point ; Until k sequence length is reached ; Update mid point ; Get count of the new mid point ; Update right to mid ; Update left to mid ; Increment mid point by one while count is equal to k to get the maximum value of mid point ; Driver Code", "dfg": [["n", 27, "comesFrom", ["n"], [21]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 44, "comesFrom", ["n"], [34]], ["n", 54, "comesFrom", ["n"], [34]], ["count", 66, "comesFrom", ["count"], [38]], ["count", 61, "comesFrom", ["count"], [38]], ["mid", 179, "comesFrom", ["mid"], [114]], ["mid", 104, "comesFrom", ["mid"], [89]], ["mid", 173, "comesFrom", ["mid"], [114]], ["mid", 128, "comesFrom", ["mid"], [114]], ["mid", 140, "comesFrom", ["mid"], [114]], ["mid", 147, "comesFrom", ["mid"], [114]], ["mid", 164, "comesFrom", ["mid"], [114]], ["k", 84, "comesFrom", ["k"], [79]], ["k", 111, "comesFrom", ["k"], [79]], ["k", 155, "comesFrom", ["k"], [79]], ["k", 197, "comesFrom", ["k"], [189]], ["k", 135, "comesFrom", ["k"], [79]], ["len", 109, "comesFrom", ["len"], [100]], ["len", 153, "comesFrom", ["len"], [124]], ["len", 133, "comesFrom", ["len"], [124]], ["len", 160, "comesFrom", ["len"], [124]], ["leadDigit", 59, "comesFrom", ["leadDigit"], [50]], ["left", 92, "comesFrom", ["left"], [77]], ["left", 117, "comesFrom", ["left"], [77]], ["right", 94, "comesFrom", ["right"], [82]], ["right", 119, "comesFrom", ["right"], [82]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkReachability ( int N , int X , int Y ) { if ( X == 0 && Y == 0 ) { return \" YES \" ; } if ( N % 2 == 0 ) { return \" YES \" ; } else { if ( X % 2 != Y % 2 ) { return \" NO \" ; } else { return \" YES \" ; } } } int main ( ) { int N = 2 ; int X = 5 , Y = 4 ; cout << checkReachability ( N , X , Y ) ; return 0 ; }", "docstring": "Check if point ( X , Y ) can be reached from origin ( 0 , 0 ) with jump of 1 and N perpendicularly simultaneously | C ++ program for the above approach ; Function to check if ( X , Y ) is reachable from ( 0 , 0 ) using the jumps of given type ; Case where source & destination are the same ; Check for even N ( X , Y ) is reachable or not ; If N is odd and parity of X and Y is different return , no valid sequence of jumps exist ; Driver Code", "dfg": [["X", 22, "comesFrom", ["X"], [14]], ["X", 106, "comesFrom", ["X"], [92]], ["X", 56, "comesFrom", ["X"], [14]], ["Y", 26, "comesFrom", ["Y"], [17]], ["Y", 108, "comesFrom", ["Y"], [96]], ["Y", 60, "comesFrom", ["Y"], [17]], ["N", 39, "comesFrom", ["N"], [11]], ["N", 104, "comesFrom", ["N"], [87]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define MAXN  1000000 NEW_LINE void closestsAngle ( int N , int A ) { double mi = INT_MAX ; int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { double angle = 180.0 * i / N ; if ( fabs ( angle - A ) < fabs ( mi - A ) ) { mi = angle ; ans = i ; } } cout << 2 << ' ▁ ' << 1 << ' ▁ ' << 2 + ans ; } int main ( ) { int N = 3 , A = 15 ; closestsAngle ( N , A ) ; return 0 ; }", "docstring": "Find three vertices in an N | C ++ program for the above approach ; Function to find three vertices that subtends an angle closest to A ; Stores the closest angle to A ; Stores the count of edge which subtend an angle of A ; Iterate in the range [ 1 , N - 2 ] ; Stores the angle subtended ; If absolute ( angle - A ) is less than absolute ( mi - A ) ; Update angle to mi , and also update i to ans ; Print the vertices ; Driver Code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double areaOftriangle ( int side ) { double a = sqrt ( pow ( side / 2 , 2 ) + pow ( side / 2 , 2 ) ) ; double b = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) ; double c = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) ; double s = ( a + b + c ) / 2 ; double area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area ; } int main ( ) { int N = 10 ; cout << areaOftriangle ( N ) ; return 0 ; }", "docstring": "Area of a triangle with two vertices at midpoints of opposite sides of a square and the other vertex lying on vertex of a square | C ++ program for the above approach ; Function to find the area of the triangle that inscribed in square ; Stores the length of the first side of triangle ; Stores the length of the second side of triangle ; Stores the length of the third side of triangle ; Stores the area of the triangle ; Return the resultant area ; Driver Code", "dfg": [["area", 122, "comesFrom", ["area"], [96]], ["N", 139, "comesFrom", ["N"], [131]], ["c", 90, "comesFrom", ["c"], [61]], ["c", 117, "comesFrom", ["c"], [61]], ["a", 86, "comesFrom", ["a"], [15]], ["a", 105, "comesFrom", ["a"], [15]], ["b", 88, "comesFrom", ["b"], [39]], ["b", 111, "comesFrom", ["b"], [39]], ["side", 45, "comesFrom", ["side"], [11]], ["side", 67, "comesFrom", ["side"], [11]], ["side", 21, "comesFrom", ["side"], [11]], ["side", 30, "comesFrom", ["side"], [11]], ["side", 52, "comesFrom", ["side"], [11]], ["side", 74, "comesFrom", ["side"], [11]], ["s", 100, "comesFrom", ["s"], [83]], ["s", 115, "comesFrom", ["s"], [83]], ["s", 109, "comesFrom", ["s"], [83]], ["s", 103, "comesFrom", ["s"], [83]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLine ( int distance , float degree ) { float x = degree * 3.14159 / 180 ; if ( degree > 90 ) { cout << \" Not ▁ Possible \" ; return ; } float result_1 = sin ( x ) ; float result_2 = cos ( x ) ; cout << fixed << setprecision ( 2 ) << result_2 << \" x ▁ + \" << result_1 << \" y ▁ = ▁ \" << distance ; } int main ( ) { int D = 10 ; float A = 30 ; findLine ( D , A ) ; return 0 ; }", "docstring": "Equation of a straight line with perpendicular distance D from origin and an angle A between the perpendicular from origin and x | C ++ program for the approach ; Function to find equation of a line whose distance from origin and angle made by the perpendicular from origin with x - axis is given ; Convert angle from degree to radian ; Handle the special case ; Calculate the sin and cos of angle ; Print the equation of the line ; Driver Code ; Given Input ; Function Call", "dfg": [["distance", 79, "comesFrom", ["distance"], [11]], ["degree", 28, "comesFrom", ["degree"], [14]], ["degree", 20, "comesFrom", ["degree"], [14]], ["D", 99, "comesFrom", ["D"], [88]], ["A", 101, "comesFrom", ["A"], [93]], ["x", 47, "comesFrom", ["x"], [18]], ["x", 55, "comesFrom", ["x"], [18]], ["result_1", 73, "comesFrom", ["result_1"], [43]], ["result_2", 67, "comesFrom", ["result_2"], [51]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int centralPoints ( int arr [ ] [ 2 ] , int N ) { int count = 0 ; int c1 , c2 , c3 , c4 ; for ( int i = 0 ; i < N ; i ++ ) { c1 = 0 , c2 = 0 , c3 = 0 ; c4 = 0 ; int x = arr [ i ] [ 0 ] ; int y = arr [ i ] [ 1 ] ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] [ 0 ] > x && arr [ j ] [ 1 ] == y ) { c1 = 1 ; } if ( arr [ j ] [ 1 ] > y && arr [ j ] [ 0 ] == x ) { c2 = 1 ; } if ( arr [ j ] [ 0 ] < x && arr [ j ] [ 1 ] == y ) { c3 = 1 ; } if ( arr [ j ] [ 1 ] < y && arr [ j ] [ 0 ] == x ) { c4 = 1 ; } } if ( c1 + c2 + c3 + c4 == 4 ) { count ++ ; } } return count ; } int main ( ) { int arr [ 4 ] [ 2 ] = { { 1 , 0 } , { 2 , 0 } , { 1 , 1 } , { 1 , -1 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << centralPoints ( arr , N ) ; return 0 ; }", "docstring": "Count number of coordinates from an array satisfying the given conditions | C ++ program for the above approach ; Function to count the number of coordinates from a given set that satisfies the given conditions ; Stores the count of central points ; Store the count of each x and y coordinates ; Find all possible pairs ; Initialize variables c1 , c2 , c3 , c4 to define the status of conditions ; Stores value of each point ; Check the conditions for each point by generating all possible pairs ; If arr [ j ] [ 0 ] > x and arr [ j ] [ 1 ] == y ; If arr [ j ] [ 0 ] < x and arr [ j ] [ 1 ] = = y ; If arr [ j ] [ 1 ] > y and arr [ j ] [ 0 ] == x ; If arr [ j ] [ 1 ] < y and arr [ j ] [ 0 ] = = x ; If all conditions satisfy then point is central point ; Increment the count by 1 ; Return the count ; Driver Code", "dfg": [["count", 236, "comesFrom", ["count"], [23]], ["count", 230, "comesFrom", ["count"], [23]], ["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["i", 72, "comesFrom", ["i"], [39]], ["i", 83, "comesFrom", ["i"], [39]], ["N", 45, "comesFrom", ["N"], [19]], ["N", 98, "comesFrom", ["N"], [19]], ["N", 301, "comesFrom", ["N"], [280]], ["j", 96, "comesFrom", ["j"], [92]], ["j", 100, "comesFrom", ["j"], [92]], ["j", 108, "comesFrom", ["j"], [92]], ["j", 118, "comesFrom", ["j"], [92]], ["j", 136, "comesFrom", ["j"], [92]], ["j", 146, "comesFrom", ["j"], [92]], ["j", 164, "comesFrom", ["j"], [92]], ["j", 174, "comesFrom", ["j"], [92]], ["j", 192, "comesFrom", ["j"], [92]], ["j", 202, "comesFrom", ["j"], [92]], ["c4", 225, "comesFrom", ["c4"], [211]], ["c3", 223, "comesFrom", ["c3"], [183]], ["x", 114, "comesFrom", ["x"], [68]], ["x", 152, "comesFrom", ["x"], [68]], ["x", 170, "comesFrom", ["x"], [68]], ["x", 208, "comesFrom", ["x"], [68]], ["y", 124, "comesFrom", ["y"], [79]], ["y", 142, "comesFrom", ["y"], [79]], ["y", 180, "comesFrom", ["y"], [79]], ["y", 198, "comesFrom", ["y"], [79]], ["c1", 219, "comesFrom", ["c1"], [127]], ["c2", 221, "comesFrom", ["c2"], [155]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void finalPosition ( char a [ ] , int b [ ] , int M ) { int n = 0 , s = 0 , e = 0 , w = 0 ; char p = ' N ' ; for ( int i = 0 ; i < M ; i ++ ) { if ( p == ' N ' ) { if ( a [ i ] == ' U ' ) { p = ' N ' ; n = n + b [ i ] ; } else if ( a [ i ] == ' D ' ) { p = ' S ' ; s = s + b [ i ] ; } else if ( a [ i ] == ' R ' ) { p = ' E ' ; e = e + b [ i ] ; } else if ( a [ i ] == ' L ' ) { p = ' W ' ; w = w + b [ i ] ; } } else if ( p == ' S ' ) { if ( a [ i ] == ' U ' ) { p = ' S ' ; s = s + b [ i ] ; } else if ( a [ i ] == ' D ' ) { p = ' N ' ; n = n + b [ i ] ; } else if ( a [ i ] == ' R ' ) { p = ' W ' ; w = w + b [ i ] ; } else if ( a [ i ] == ' L ' ) { p = ' E ' ; e = e + b [ i ] ; } } else if ( p == ' E ' ) { if ( a [ i ] == ' U ' ) { p = ' E ' ; e = e + b [ i ] ; } else if ( a [ i ] == ' D ' ) { p = ' W ' ; w = w + b [ i ] ; } else if ( a [ i ] == ' R ' ) { p = ' S ' ; s = s + b [ i ] ; } else if ( a [ i ] == ' L ' ) { p = ' N ' ; n = n + b [ i ] ; } } else if ( p == ' W ' ) { if ( a [ i ] == ' U ' ) { p = ' W ' ; w = w + b [ i ] ; } else if ( a [ i ] == ' D ' ) { p = ' E ' ; e = e + b [ i ] ; } else if ( a [ i ] == ' R ' ) { p = ' N ' ; n = n + b [ i ] ; } else if ( a [ i ] == ' L ' ) { p = ' S ' ; s = s + b [ i ] ; } } } int ver_disp = n - s ; int hor_disp = e - w ; int displacement = floor ( sqrt ( ( ver_disp * ver_disp ) + ( hor_disp * hor_disp ) ) ) ; cout << displacement << \" ▁ \" << p ; } int main ( ) { char A [ ] = { ' U ' , ' R ' , ' R ' , ' R ' , ' R ' } ; int B [ ] = { 1 , 1 , 1 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( B [ 0 ] ) ; finalPosition ( A , B , N ) ; return 0 ; }", "docstring": "Displacement from origin after N moves of given distances in specified directions | C ++ program for the above approach ; Function to find the displacement from the origin and direction after performing the given set of moves ; Stores the distances travelled in the directions North , South , East , and West respectively ; Store the initial position of robot ; Traverse the array B [ ] ; If the current direction is North ; If the current direction is South ; If the current direction is East ; If the current direction is West ; Stores the total vertical displacement ; Stores the total horizontal displacement ; Find the displacement ; Print the displacement and direction after N moves ; Driver Code", "dfg": [["i", 57, "comesFrom", ["i"], [53]], ["i", 61, "comesFrom", ["i"], [53]], ["i", 80, "comesFrom", ["i"], [53]], ["i", 104, "comesFrom", ["i"], [53]], ["i", 113, "comesFrom", ["i"], [53]], ["i", 224, "comesFrom", ["i"], [53]], ["i", 137, "comesFrom", ["i"], [53]], ["i", 146, "comesFrom", ["i"], [53]], ["i", 248, "comesFrom", ["i"], [53]], ["i", 257, "comesFrom", ["i"], [53]], ["i", 368, "comesFrom", ["i"], [53]], ["i", 170, "comesFrom", ["i"], [53]], ["i", 179, "comesFrom", ["i"], [53]], ["i", 281, "comesFrom", ["i"], [53]], ["i", 290, "comesFrom", ["i"], [53]], ["i", 392, "comesFrom", ["i"], [53]], ["i", 401, "comesFrom", ["i"], [53]], ["i", 512, "comesFrom", ["i"], [53]], ["i", 203, "comesFrom", ["i"], [53]], ["i", 314, "comesFrom", ["i"], [53]], ["i", 323, "comesFrom", ["i"], [53]], ["i", 425, "comesFrom", ["i"], [53]], ["i", 434, "comesFrom", ["i"], [53]], ["i", 536, "comesFrom", ["i"], [53]], ["i", 545, "comesFrom", ["i"], [53]], ["i", 347, "comesFrom", ["i"], [53]], ["i", 458, "comesFrom", ["i"], [53]], ["i", 467, "comesFrom", ["i"], [53]], ["i", 569, "comesFrom", ["i"], [53]], ["i", 578, "comesFrom", ["i"], [53]], ["i", 491, "comesFrom", ["i"], [53]], ["i", 602, "comesFrom", ["i"], [53]], ["i", 611, "comesFrom", ["i"], [53]], ["i", 635, "comesFrom", ["i"], [53]], ["M", 59, "comesFrom", ["M"], [21]], ["p", 684, "comesFrom", ["p"], [621]], ["p", 67, "comesFrom", ["p"], [42]], ["p", 211, "comesFrom", ["p"], [189]], ["p", 355, "comesFrom", ["p"], [333]], ["p", 499, "comesFrom", ["p"], [477]], ["n", 644, "comesFrom", ["n"], [596]], ["n", 100, "comesFrom", ["n"], [98]], ["n", 277, "comesFrom", ["n"], [275]], ["n", 487, "comesFrom", ["n"], [485]], ["n", 598, "comesFrom", ["n"], [596]], ["s", 646, "comesFrom", ["s"], [629]], ["s", 133, "comesFrom", ["s"], [131]], ["s", 244, "comesFrom", ["s"], [242]], ["s", 454, "comesFrom", ["s"], [452]], ["s", 631, "comesFrom", ["s"], [629]], ["e", 651, "comesFrom", ["e"], [563]], ["e", 166, "comesFrom", ["e"], [164]], ["e", 388, "comesFrom", ["e"], [386]], ["e", 343, "comesFrom", ["e"], [341]], ["e", 565, "comesFrom", ["e"], [563]], ["w", 653, "comesFrom", ["w"], [530]], ["w", 199, "comesFrom", ["w"], [197]], ["w", 310, "comesFrom", ["w"], [308]], ["w", 421, "comesFrom", ["w"], [419]], ["w", 532, "comesFrom", ["w"], [530]], ["N", 768, "comesFrom", ["N"], [747]], ["displacement", 678, "comesFrom", ["displacement"], [656]], ["ver_disp", 663, "comesFrom", ["ver_disp"], [642]], ["ver_disp", 665, "comesFrom", ["ver_disp"], [642]], ["hor_disp", 669, "comesFrom", ["hor_disp"], [649]], ["hor_disp", 671, "comesFrom", ["hor_disp"], [649]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; } int main ( ) { double A = 3.0 , B = 2.0 ; cout << lengthOfLatusRectum ( A , B ) ; return 0 ; }", "docstring": "Program to find Length of Latus Rectum of an Ellipse | C ++ program for the above approach ; Function to calculate the length of the latus rectum of an ellipse ; Length of major axis ; Length of minor axis ; Length of the latus rectum ; Driver Code ; Given lengths of semi - major and semi - minor axis ; Function call to calculate length of the latus rectum of a ellipse", "dfg": [["latus_rectum", 43, "comesFrom", ["latus_rectum"], [32]], ["A", 22, "comesFrom", ["A"], [11]], ["A", 64, "comesFrom", ["A"], [52]], ["B", 29, "comesFrom", ["B"], [14]], ["B", 66, "comesFrom", ["B"], [56]], ["major", 40, "comesFrom", ["major"], [18]], ["minor", 35, "comesFrom", ["minor"], [25]], ["minor", 37, "comesFrom", ["minor"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void coneSlantHeight ( double cone_h , double cone_r ) { double slant_height_cone = sqrt ( pow ( cone_h , 2 ) + pow ( cone_r , 2 ) ) ; cout << \" Slant ▁ height ▁ of ▁ cone ▁ is : ▁ \" << slant_height_cone << ' ' ; } void pyramidSlantHeight ( double pyramid_h , double pyramid_s ) { double slant_height_pyramid = sqrt ( pow ( pyramid_s / 2 , 2 ) + pow ( pyramid_h , 2 ) ) ; cout << \" Slant ▁ height ▁ of ▁ pyramid ▁ is : ▁ \" << slant_height_pyramid << ' ' ; } int main ( ) { double H1 = 4.5 , R = 6 ; coneSlantHeight ( H1 , R ) ; double H2 = 4 , S = 4.8 ; pyramidSlantHeight ( H2 , S ) ; return 0 ; }", "docstring": "Program to find slant height of cone and pyramid | C ++ program for the above approach ; Function to calculate slant height of a cone ; Store the slant height of cone ; Print the result ; Function to find the slant height of a pyramid ; Store the slant height of pyramid ; Print the result ; Driver Code ; Dimensions of Cone ; Function Call for slant height of Cone ; Dimensions of Pyramid ; Function to calculate slant height of a pyramid", "dfg": [["slant_height_cone", 43, "comesFrom", ["slant_height_cone"], [18]], ["slant_height_pyramid", 88, "comesFrom", ["slant_height_pyramid"], [61]], ["H1", 111, "comesFrom", ["H1"], [101]], ["R", 113, "comesFrom", ["R"], [105]], ["H2", 127, "comesFrom", ["H2"], [117]], ["S", 129, "comesFrom", ["S"], [121]], ["cone_h", 24, "comesFrom", ["cone_h"], [11]], ["cone_r", 31, "comesFrom", ["cone_r"], [14]], ["pyramid_h", 76, "comesFrom", ["pyramid_h"], [54]], ["pyramid_s", 67, "comesFrom", ["pyramid_s"], [57]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float distance ( float x1 , float y1 , float x2 , float y2 ) { return sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; } float lengthOfLatusRectum ( float a , float b , float c ) { pair < float , float > vertex = { ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) } ; pair < float , float > focus = { ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) } ; cout << 4 * distance ( focus . first , focus . second , vertex . first , vertex . second ) ; } int main ( ) { float a = 3 , b = 5 , c = 1 ; lengthOfLatusRectum ( a , b , c ) ; return 0 ; }", "docstring": "Program to find the length of Latus Rectum of a Parabola | C ++ program for the above approach ; Function to calculate distance between two points ; Calculating distance ; Function to calculate length of the latus rectum of a parabola ; Stores the co - ordinates of the vertex of the parabola ; Stores the co - ordinates of the focus of parabola ; Print the distance between focus and vertex ; Driver Code ; Given a , b & c ; Function call", "dfg": [["a", 201, "comesFrom", ["a"], [187]], ["a", 81, "comesFrom", ["a"], [56]], ["a", 105, "comesFrom", ["a"], [56]], ["a", 126, "comesFrom", ["a"], [56]], ["a", 152, "comesFrom", ["a"], [56]], ["a", 90, "comesFrom", ["a"], [56]], ["a", 135, "comesFrom", ["a"], [56]], ["b", 203, "comesFrom", ["b"], [191]], ["b", 76, "comesFrom", ["b"], [59]], ["b", 121, "comesFrom", ["b"], [59]], ["b", 96, "comesFrom", ["b"], [59]], ["b", 98, "comesFrom", ["b"], [59]], ["b", 141, "comesFrom", ["b"], [59]], ["b", 143, "comesFrom", ["b"], [59]], ["c", 205, "comesFrom", ["c"], [195]], ["c", 92, "comesFrom", ["c"], [62]], ["c", 137, "comesFrom", ["c"], [62]], ["focus", 163, "comesFrom", ["focus"], [116]], ["focus", 167, "comesFrom", ["focus"], [116]], ["vertex", 171, "comesFrom", ["vertex"], [71]], ["vertex", 175, "comesFrom", ["vertex"], [71]], ["x2", 27, "comesFrom", ["x2"], [17]], ["x2", 33, "comesFrom", ["x2"], [17]], ["x1", 29, "comesFrom", ["x1"], [11]], ["x1", 35, "comesFrom", ["x1"], [11]], ["y2", 39, "comesFrom", ["y2"], [20]], ["y2", 45, "comesFrom", ["y2"], [20]], ["y1", 41, "comesFrom", ["y1"], [14]], ["y1", 47, "comesFrom", ["y1"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double ConvertDegToRad ( double degree ) { double pi = 3.14159 ; return ( degree * ( pi / 180.0 ) ) ; } void ConvertToCartesian ( pair < double , double > polar ) { polar . second = ConvertDegToRad ( polar . second ) ; pair < double , double > cartesian = { polar . first * cos ( polar . second ) , polar . first * sin ( polar . second ) } ; printf ( \" % 0.3f , ▁ % 0.3f \" , cartesian . first , cartesian . second ) ; } int main ( ) { pair < double , double > polar = { 1.4142 , 45 } ; ConvertToCartesian ( polar ) ; return 0 ; }", "docstring": "Program to convert polar co | C ++ program for the above approach ; Function to convert degree to radian ; Function to convert the polar coordinate to cartesian ; Convert degerees to radian ; Applying the formula : x = rcos ( theata ) , y = rsin ( theta ) ; Print cartesian coordinates ; Driver Code ; Given polar coordinates ; Function to convert polar coordinates to equivalent cartesian coordinates", "dfg": [["degree", 21, "comesFrom", ["degree"], [11]], ["polar", 43, "comesFrom", ["polar"], [40]], ["polar", 123, "comesFrom", ["polar"], [113]], ["polar", 49, "comesFrom", ["polar"], [40]], ["polar", 63, "comesFrom", ["polar"], [40]], ["polar", 74, "comesFrom", ["polar"], [40]], ["polar", 69, "comesFrom", ["polar"], [40]], ["polar", 80, "comesFrom", ["polar"], [40]], ["cartesian", 92, "comesFrom", ["cartesian"], [60]], ["cartesian", 96, "comesFrom", ["cartesian"], [60]], ["pi", 24, "comesFrom", ["pi"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double distance ( pair < double , double > p1 , pair < double , double > p2 ) { double x1 = p1 . first , x2 = p2 . first ; double y1 = p1 . second , y2 = p2 . second ; return sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) * 1.0 ) ; } pair < double , double > find_orthocenter ( pair < double , double > A , pair < double , double > B , pair < double , double > C ) { double AB = distance ( A , B ) ; double BC = distance ( B , C ) ; double CA = distance ( C , A ) ; if ( AB > BC && AB > CA ) return C ; if ( BC > AB && BC > CA ) return A ; return B ; } pair < double , double > find_circumcenter ( pair < double , double > A , pair < double , double > B , pair < double , double > C ) { double AB = distance ( A , B ) ; double BC = distance ( B , C ) ; double CA = distance ( C , A ) ; if ( AB > BC && AB > CA ) return { ( A . first + B . first ) / 2 , ( A . second + B . second ) / 2 } ; if ( BC > AB && BC > CA ) return { ( B . first + C . first ) / 2 , ( B . second + C . second ) / 2 } ; return { ( C . first + A . first ) / 2 , ( C . second + A . second ) / 2 } ; } void findDistance ( pair < double , double > A , pair < double , double > B , pair < double , double > C ) { pair < double , double > circumcenter = find_circumcenter ( A , B , C ) ; pair < double , double > orthocenter = find_orthocenter ( A , B , C ) ; double distance_between = distance ( circumcenter , orthocenter ) ; cout << distance_between << endl ; } int main ( ) { pair < double , double > A , B , C ; A = { 0.0 , 0.0 } ; B = { 6.0 , 0.0 } ; C = { 0.0 , 8.0 } ; findDistance ( A , B , C ) ; return 0 ; }", "docstring": "Distance between orthocenter and circumcenter of a right | C ++ program for the above approach ; Function to calculate Euclidean distance between the points p1 and p2 ; Stores x coordinates of both points ; Stores y coordinates of both points ; Return the Euclid distance using distance formula ; Function to find orthocenter of the right angled triangle ; Find the length of the three sides ; Orthocenter will be the vertex opposite to the largest side ; Function to find the circumcenter of right angle triangle ; Circumcenter will be located at center of hypotenuse ; If AB is the hypotenuse ; If BC is the hypotenuse ; If AC is the hypotenuse ; Function to find distance between orthocenter and circumcenter ; Find circumcenter ; Find orthocenter ; Find the distance between the orthocenter and circumcenter ; Print distance between orthocenter and circumcenter ; Driver Code ; Given coordinates A , B , and C ; Function Call", "dfg": [["B", 168, "comesFrom", ["B"], [100]], ["B", 460, "comesFrom", ["B"], [440]], ["B", 118, "comesFrom", ["B"], [100]], ["B", 126, "comesFrom", ["B"], [100]], ["B", 211, "comesFrom", ["B"], [193]], ["B", 219, "comesFrom", ["B"], [193]], ["B", 376, "comesFrom", ["B"], [353]], ["B", 393, "comesFrom", ["B"], [353]], ["B", 251, "comesFrom", ["B"], [193]], ["B", 263, "comesFrom", ["B"], [193]], ["B", 284, "comesFrom", ["B"], [193]], ["B", 296, "comesFrom", ["B"], [193]], ["C", 152, "comesFrom", ["C"], [108]], ["C", 462, "comesFrom", ["C"], [448]], ["C", 128, "comesFrom", ["C"], [108]], ["C", 136, "comesFrom", ["C"], [108]], ["C", 221, "comesFrom", ["C"], [201]], ["C", 229, "comesFrom", ["C"], [201]], ["C", 378, "comesFrom", ["C"], [361]], ["C", 395, "comesFrom", ["C"], [361]], ["C", 311, "comesFrom", ["C"], [201]], ["C", 323, "comesFrom", ["C"], [201]], ["C", 288, "comesFrom", ["C"], [201]], ["C", 300, "comesFrom", ["C"], [201]], ["A", 165, "comesFrom", ["A"], [92]], ["A", 458, "comesFrom", ["A"], [432]], ["A", 116, "comesFrom", ["A"], [92]], ["A", 138, "comesFrom", ["A"], [92]], ["A", 209, "comesFrom", ["A"], [185]], ["A", 231, "comesFrom", ["A"], [185]], ["A", 374, "comesFrom", ["A"], [345]], ["A", 391, "comesFrom", ["A"], [345]], ["A", 315, "comesFrom", ["A"], [185]], ["A", 327, "comesFrom", ["A"], [185]], ["A", 247, "comesFrom", ["A"], [185]], ["A", 259, "comesFrom", ["A"], [185]], ["p1", 30, "comesFrom", ["p1"], [16]], ["p1", 43, "comesFrom", ["p1"], [16]], ["p2", 36, "comesFrom", ["p2"], [24]], ["p2", 49, "comesFrom", ["p2"], [24]], ["distance_between", 410, "comesFrom", ["distance_between"], [399]], ["AB", 143, "comesFrom", ["AB"], [112]], ["AB", 147, "comesFrom", ["AB"], [112]], ["AB", 158, "comesFrom", ["AB"], [112]], ["AB", 236, "comesFrom", ["AB"], [205]], ["AB", 240, "comesFrom", ["AB"], [205]], ["AB", 275, "comesFrom", ["AB"], [205]], ["BC", 145, "comesFrom", ["BC"], [122]], ["BC", 156, "comesFrom", ["BC"], [122]], ["BC", 160, "comesFrom", ["BC"], [122]], ["BC", 238, "comesFrom", ["BC"], [215]], ["BC", 273, "comesFrom", ["BC"], [215]], ["BC", 277, "comesFrom", ["BC"], [215]], ["CA", 149, "comesFrom", ["CA"], [132]], ["CA", 162, "comesFrom", ["CA"], [132]], ["CA", 242, "comesFrom", ["CA"], [225]], ["CA", 279, "comesFrom", ["CA"], [225]], ["circumcenter", 403, "comesFrom", ["circumcenter"], [370]], ["orthocenter", 405, "comesFrom", ["orthocenter"], [387]], ["x2", 58, "comesFrom", ["x2"], [34]], ["x1", 60, "comesFrom", ["x1"], [28]], ["y2", 67, "comesFrom", ["y2"], [47]], ["y1", 69, "comesFrom", ["y1"], [41]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generatePoints ( int L , int W ) { set < pair < int , int > > hash ; int total = ( L * W ) ; srand ( time ( 0 ) ) ; while ( total -- ) { int X = rand ( ) % L ; int Y = rand ( ) % W ; while ( hash . count ( { X , Y } ) ) { X = rand ( ) % L ; Y = rand ( ) % W ; } hash . insert ( { X , Y } ) ; } for ( auto points : hash ) { cout << \" ( \" << points . first << \" , ▁ \" << points . second << \" ) ▁ \" ; } } int main ( ) { int L = 3 , W = 2 ; generatePoints ( L , W ) ; }", "docstring": "Generate all integral points lying inside a rectangle | C ++ program to implement the above approach ; Function to generate coordinates lying within the rectangle ; Store all possible coordinates that lie within the rectangle ; Stores the number of possible coordinates that lie within the rectangle ; Use current time as seed for random generator ; Generate all possible coordinates ; Generate all possible X - coordinates ; Generate all possible Y - coordinates ; If coordinates ( X , Y ) has not been generated already ; Insert the coordinates ( X , Y ) ; Print the coordinates ; Driver Code ; Rectangle dimensions", "dfg": [["hash", 117, "comesFrom", ["hash"], [26]], ["hash", 100, "comesFrom", ["hash"], [26]], ["hash", 71, "comesFrom", ["hash"], [26]], ["total", 47, "comesFrom", ["total"], [29]], ["L", 160, "comesFrom", ["L"], [150]], ["L", 32, "comesFrom", ["L"], [11]], ["L", 58, "comesFrom", ["L"], [11]], ["L", 89, "comesFrom", ["L"], [11]], ["W", 162, "comesFrom", ["W"], [154]], ["W", 34, "comesFrom", ["W"], [14]], ["W", 67, "comesFrom", ["W"], [14]], ["W", 97, "comesFrom", ["W"], [14]], ["X", 105, "comesFrom", ["X"], [83]], ["X", 76, "comesFrom", ["X"], [52]], ["Y", 107, "comesFrom", ["Y"], [91]], ["Y", 78, "comesFrom", ["Y"], [61]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfTriangles ( int n ) { return floor ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; } int main ( ) { int n = 3 ; cout << noOfTriangles ( n ) << endl ; return 0 ; }", "docstring": "Count triangles required to form a House of Cards of height N | C ++ implementation of the above approach ; Function to find the number of triangles ; Driver Code ; Function call", "dfg": [["n", 51, "comesFrom", ["n"], [43]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 28, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumberOfDigits ( int n , int base ) { int dig = ( floor ( log ( n ) / log ( base ) ) + 1 ) ; return ( dig ) ; } int isAllKs ( int n , int b , int k ) { int len = findNumberOfDigits ( n , b ) ; int sum = k * ( 1 - pow ( b , len ) ) / ( 1 - b ) ; if ( sum == n ) { return ( sum ) ; } } int main ( ) { int N = 13 ; int B = 3 ; int K = 1 ; if ( isAllKs ( N , B , K ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } }", "docstring": "Check if N contains all digits as K in base B | C ++ implementation of the approach ; Function to print the number of digits ; Calculate log using base change property and then take its floor and then add 1 ; Return the output ; Function that returns true if n contains all one 's in base b ; Calculate the sum ; Driver code ; Given number N ; Given base B ; Given digit K ; Function call", "dfg": [["dig", 39, "comesFrom", ["dig"], [18]], ["sum", 90, "comesFrom", ["sum"], [67]], ["sum", 97, "comesFrom", ["sum"], [67]], ["n", 92, "comesFrom", ["n"], [47]], ["n", 61, "comesFrom", ["n"], [47]], ["n", 25, "comesFrom", ["n"], [11]], ["b", 63, "comesFrom", ["b"], [50]], ["b", 85, "comesFrom", ["b"], [50]], ["b", 76, "comesFrom", ["b"], [50]], ["k", 69, "comesFrom", ["k"], [53]], ["N", 126, "comesFrom", ["N"], [108]], ["B", 128, "comesFrom", ["B"], [113]], ["K", 130, "comesFrom", ["K"], [118]], ["len", 78, "comesFrom", ["len"], [57]], ["base", 30, "comesFrom", ["base"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) pow ( ( X2 - X1 ) , 2 ) + ( int ) pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) pow ( ( X3 - X2 ) , 2 ) + ( int ) pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) pow ( ( X3 - X1 ) , 2 ) + ( int ) pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 and B > 0 and C > 0 ) and ( A == ( B + C ) or B == ( A + C ) or C == ( A + B ) ) ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int X1 = 0 , Y1 = 2 ; int X2 = 0 , Y2 = 14 ; int X3 = 9 , Y3 = 2 ; checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) ; return 0 ; }", "docstring": "Check if a right | C ++ program to implement the above approach ; Function to check if right - angled triangle can be formed by the given coordinates ; Calculate the sides ; Check Pythagoras Formula ; Driver Code", "dfg": [["X1", 212, "comesFrom", ["X1"], [184]], ["X1", 40, "comesFrom", ["X1"], [11]], ["X1", 102, "comesFrom", ["X1"], [11]], ["Y1", 214, "comesFrom", ["Y1"], [188]], ["Y1", 54, "comesFrom", ["Y1"], [14]], ["Y1", 116, "comesFrom", ["Y1"], [14]], ["X2", 216, "comesFrom", ["X2"], [193]], ["X2", 38, "comesFrom", ["X2"], [17]], ["X2", 71, "comesFrom", ["X2"], [17]], ["Y2", 218, "comesFrom", ["Y2"], [197]], ["Y2", 52, "comesFrom", ["Y2"], [20]], ["Y2", 85, "comesFrom", ["Y2"], [20]], ["X3", 220, "comesFrom", ["X3"], [202]], ["X3", 69, "comesFrom", ["X3"], [23]], ["X3", 100, "comesFrom", ["X3"], [23]], ["Y3", 222, "comesFrom", ["Y3"], [206]], ["Y3", 83, "comesFrom", ["Y3"], [26]], ["Y3", 114, "comesFrom", ["Y3"], [26]], ["C", 133, "comesFrom", ["C"], [92]], ["C", 155, "comesFrom", ["C"], [92]], ["C", 144, "comesFrom", ["C"], [92]], ["C", 152, "comesFrom", ["C"], [92]], ["A", 125, "comesFrom", ["A"], [30]], ["A", 139, "comesFrom", ["A"], [30]], ["A", 158, "comesFrom", ["A"], [30]], ["A", 150, "comesFrom", ["A"], [30]], ["B", 129, "comesFrom", ["B"], [61]], ["B", 147, "comesFrom", ["B"], [61]], ["B", 160, "comesFrom", ["B"], [61]], ["B", 142, "comesFrom", ["B"], [61]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void createPrefixArray ( int n , int arr [ ] , int prefSize , int pref [ ] ) { for ( int i = 0 ; i < prefSize ; i ++ ) { pref [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] + 1000000 ; pref [ x ] ++ ; } for ( int i = 1 ; i < prefSize ; i ++ ) { pref [ i ] += pref [ i - 1 ] ; } } int pointsOfIntersection ( int m , int segments [ ] [ 4 ] , int size , int pref [ ] ) { int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int x1 = segments [ i ] [ 0 ] ; int x2 = segments [ i ] [ 2 ] ; x1 = x1 + 1000000 ; x2 = x2 + 1000000 ; if ( x1 != x2 ) { if ( x1 > x2 ) { swap ( x1 , x2 ) ; } int Occ_Till_Right = pref [ x2 - 1 ] ; int Occ_Till_Left = pref [ x1 ] ; ans = ans + ( Occ_Till_Right - Occ_Till_Left ) ; } } return ans ; } int main ( ) { int N = 4 ; int M = 8 ; int size = 2000000 + 2 ; int pref [ size ] ; int lines [ N ] = { -5 , -3 , 2 , 3 } ; int segments [ M ] [ 4 ] = { { -2 , 5 , 5 , -6 } , { -5 , -2 , -3 , -5 } , { -2 , 3 , -6 , 1 } , { -1 , -3 , 4 , 2 } , { 2 , 5 , 2 , 1 } , { 4 , 5 , 4 , -5 } , { -2 , -4 , 5 , 3 } , { 1 , 2 , -2 , 1 } } ; createPrefixArray ( N , lines , size , pref ) ; cout << pointsOfIntersection ( M , segments , size , pref ) << endl ; return 0 ; }", "docstring": "Count of intersections of M line segments with N vertical lines in XY plane | C ++ implementation for the above approach . ; Function to create prefix sum array ; Initialize the prefix array to remove garbage values ; Marking the occurences of vertical lines ; x is the value after Index mapping ; Creating the prefix array ; Function returns the count of total intersection ; ans is the number of points of intersection of the line segments with the vertical lines ; Index mapping ; We don 't consider a vertical  line segment because even if  it falls on a verticale line  then it just touches it and  not intersects. ; We have assumed that x1 will be left and x2 right but if not then we just swap them ; Driver code ; N is the number of vertical lines M is the number of line segments ; Format : x1 , y1 , x2 , y1 ; First create the prefix array ; Print the total number of intersections", "dfg": [["ans", 241, "comesFrom", ["ans"], [228]], ["ans", 230, "comesFrom", ["ans"], [228]], ["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 57, "comesFrom", ["i"], [53]], ["i", 61, "comesFrom", ["i"], [53]], ["i", 89, "comesFrom", ["i"], [85]], ["i", 93, "comesFrom", ["i"], [85]], ["i", 146, "comesFrom", ["i"], [142]], ["i", 150, "comesFrom", ["i"], [142]], ["i", 44, "comesFrom", ["i"], [30]], ["i", 99, "comesFrom", ["i"], [85]], ["i", 70, "comesFrom", ["i"], [53]], ["i", 104, "comesFrom", ["i"], [85]], ["i", 159, "comesFrom", ["i"], [142]], ["i", 170, "comesFrom", ["i"], [142]], ["prefSize", 36, "comesFrom", ["prefSize"], [19]], ["prefSize", 91, "comesFrom", ["prefSize"], [19]], ["n", 59, "comesFrom", ["n"], [11]], ["m", 148, "comesFrom", ["m"], [115]], ["size", 269, "comesFrom", ["size"], [260]], ["size", 385, "comesFrom", ["size"], [260]], ["size", 398, "comesFrom", ["size"], [260]], ["N", 275, "comesFrom", ["N"], [250]], ["N", 381, "comesFrom", ["N"], [250]], ["M", 291, "comesFrom", ["M"], [255]], ["M", 394, "comesFrom", ["M"], [255]], ["x1", 178, "comesFrom", ["x1"], [176]], ["x1", 190, "comesFrom", ["x1"], [176]], ["x1", 197, "comesFrom", ["x1"], [176]], ["x1", 225, "comesFrom", ["x1"], [176]], ["x1", 204, "comesFrom", ["x1"], [176]], ["x2", 184, "comesFrom", ["x2"], [182]], ["x2", 192, "comesFrom", ["x2"], [182]], ["x2", 199, "comesFrom", ["x2"], [182]], ["x2", 206, "comesFrom", ["x2"], [182]], ["x2", 215, "comesFrom", ["x2"], [182]], ["x", 77, "comesFrom", ["x"], [66]], ["Occ_Till_Right", 233, "comesFrom", ["Occ_Till_Right"], [211]], ["Occ_Till_Left", 235, "comesFrom", ["Occ_Till_Left"], [221]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_rectangles ( int N , int M ) { int p_x = ( N * ( N - 1 ) ) / 2 ; int p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; } int main ( ) { int N = 3 ; int M = 6 ; cout << count_rectangles ( N , M ) ; }", "docstring": "Count of rectangles possible from N and M straight lines parallel to X and Y axis respectively | C ++ Program to count number of rectangles formed by N lines parallel to X axis M lines parallel to Y axis ; Function to calculate number of rectangles ; Total number of ways to select two lines parallel to X axis ; Total number of ways to select two lines parallel to Y axis ; Total number of rectangles ; Driver Program", "dfg": [["p_x", 48, "comesFrom", ["p_x"], [18]], ["p_y", 50, "comesFrom", ["p_y"], [33]], ["N", 72, "comesFrom", ["N"], [59]], ["N", 21, "comesFrom", ["N"], [11]], ["N", 24, "comesFrom", ["N"], [11]], ["M", 74, "comesFrom", ["M"], [64]], ["M", 36, "comesFrom", ["M"], [14]], ["M", 39, "comesFrom", ["M"], [14]]]}
{"code": "#include \" bits / stdc + + . h \" NEW_LINE #define PI  3.14 NEW_LINE using namespace std ; void calculateAngle ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int ABx = x1 - x2 ; int ABy = y1 - y2 ; int ABz = z1 - z2 ; int BCx = x3 - x2 ; int BCy = y3 - y2 ; int BCz = z3 - z2 ; double dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; double magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; double magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; double angle = dotProduct ; angle /= sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / PI ; cout << abs ( angle ) << endl ; } int main ( ) { int x1 = 1 , y1 = 3 , z1 = 3 ; int x2 = 3 , y2 = 4 , z2 = 5 ; int x3 = 5 , y3 = 6 , z3 = 9 ; calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; return 0 ; }", "docstring": "Angle between a Pair of Lines in 3D | C ++ program for the above approach ; Function to find the angle between the two lines ; Find direction ratio of line AB ; Find direction ratio of line BC ; Find the dotProduct of lines AB & BC ; Find magnitude of line AB and BC ; Find the cosine of the angle formed by line AB and BC ; Find angle in radian ; Print the angle ; Driver Code ; Given coordinates Points A ; Points B ; Points C ; Function Call", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) printf ( \" Wrong ▁ input \" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = 0.5 * ( h * 60 + m ) ; int minute_angle = 6 * m ; int angle = abs ( hour_angle - minute_angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; } float cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; return cosx ; } float distanceEndpoints ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; } int main ( ) { int hour = 3 ; int min = 30 ; int hourHand = 3 ; int minHand = 4 ; double angle = calcAngle ( hour , min ) ; float distance = distanceEndpoints ( minHand , hourHand , angle ) ; cout << distance ; return 0 ; }", "docstring": "Distance between end points of Hour and minute hand at given time | C ++ implementation to find the distance between the end points of the hour and minute hand ; Function to find the angle between Hour hand and minute hand ; Validate the input ; Calculate the angles moved by hour and minute hands with reference to 12 : 00 ; Find the difference between two angles ; Return the smaller angle of two possible angles ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to distance between the endpoints of the hour and minute hand ; Driver Code ; Time ; Length of hour hand ; Length of minute hand ; calling Function for finding angle between hour hand and minute hand ; Function for finding distance between end points of minute hand and hour hand", "dfg": [["angle", 101, "comesFrom", ["angle"], [89]], ["angle", 97, "comesFrom", ["angle"], [89]], ["angle", 300, "comesFrom", ["angle"], [282]], ["angle", 95, "comesFrom", ["angle"], [89]], ["angle", 252, "comesFrom", ["angle"], [224]], ["cosx", 207, "comesFrom", ["cosx"], [181]], ["cosx", 183, "comesFrom", ["cosx"], [181]], ["cosx", 202, "comesFrom", ["cosx"], [181]], ["x1", 140, "comesFrom", ["x1"], [134]], ["x1", 185, "comesFrom", ["x1"], [170]], ["x1", 173, "comesFrom", ["x1"], [170]], ["distance", 305, "comesFrom", ["distance"], [292]], ["h", 19, "comesFrom", ["h"], [11]], ["h", 41, "comesFrom", ["h"], [11]], ["h", 65, "comesFrom", ["h"], [45]], ["h", 25, "comesFrom", ["h"], [11]], ["m", 51, "comesFrom", ["m"], [14]], ["m", 77, "comesFrom", ["m"], [55]], ["m", 28, "comesFrom", ["m"], [14]], ["m", 69, "comesFrom", ["m"], [55]], ["m", 22, "comesFrom", ["m"], [14]], ["min", 288, "comesFrom", ["min"], [267]], ["n", 126, "comesFrom", ["n"], [124]], ["n", 146, "comesFrom", ["n"], [124]], ["n", 177, "comesFrom", ["n"], [124]], ["n", 175, "comesFrom", ["n"], [124]], ["accuracy", 196, "comesFrom", ["accuracy"], [112]], ["c", 228, "comesFrom", ["c"], [220]], ["hour", 286, "comesFrom", ["hour"], [262]], ["minHand", 296, "comesFrom", ["minHand"], [277]], ["hourHand", 298, "comesFrom", ["hourHand"], [272]], ["hour_angle", 84, "comesFrom", ["hour_angle"], [60]], ["minute_angle", 86, "comesFrom", ["minute_angle"], [73]], ["denominator", 179, "comesFrom", ["denominator"], [156]], ["i", 189, "comesFrom", ["i"], [187]], ["i", 160, "comesFrom", ["i"], [150]], ["i", 165, "comesFrom", ["i"], [150]], ["cosval", 200, "comesFrom", ["cosval"], [142]], ["b", 250, "comesFrom", ["b"], [217]], ["b", 241, "comesFrom", ["b"], [217]], ["b", 243, "comesFrom", ["b"], [217]], ["a", 235, "comesFrom", ["a"], [214]], ["a", 237, "comesFrom", ["a"], [214]], ["a", 248, "comesFrom", ["a"], [214]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Pentadecagonal_num ( int n ) { return ( 13 * n * n - 11 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Pentadecagonal_num ( n ) << endl ; n = 10 ; cout << Pentadecagonal_num ( n ) << endl ; return 0 ; }", "docstring": "Pentadecagonal Number | C ++ program to find Nth Pentadecagonal number ; Function to find N - th Pentadecagonal number ; Formula to calculate nth Pentadecagonal number ; Driver code", "dfg": [["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 44, "comesFrom", ["n"], [36]], ["n", 57, "comesFrom", ["n"], [49]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Octadecagonal_num ( int n ) { return ( 16 * n * n - 14 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Octadecagonal_num ( n ) << endl ; n = 10 ; cout << Octadecagonal_num ( n ) << endl ; return 0 ; }", "docstring": "Octadecagonal Number | C ++ program to find Nth Octadecagonal number ; Function to find N - th Octadecagonal number ; Formula to calculate nth Octadecagonal number ; Driver code", "dfg": [["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 44, "comesFrom", ["n"], [36]], ["n", 57, "comesFrom", ["n"], [49]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Icositrigonal_num ( int n ) { return ( 21 * n * n - 19 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icositrigonal_num ( n ) << endl ; n = 10 ; cout << Icositrigonal_num ( n ) ; return 0 ; }", "docstring": "Icositrigonal Number | C ++ program to find nth Icositrigonal number ; Function to find N - th Icositrigonal number ; Formula to calculate nth Icositrigonal number ; Driver Code", "dfg": [["n", 57, "comesFrom", ["n"], [49]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 44, "comesFrom", ["n"], [36]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate_change ( int length , int breadth ) { int change = 0 ; change = length + breadth + ( ( length * breadth ) / 100 ) ; return change ; } int main ( ) { int cL = 20 ; int cB = -10 ; int cA = calculate_change ( cL , cB ) ; printf ( \" % d \" , cA ) ; return 0 ; }", "docstring": "Find the percentage change in the area of a Rectangle | CPP implementation to find the percentage ; Function to calculate percentage change in area of rectangle ; Driver code", "dfg": [["change", 39, "comesFrom", ["change"], [22]], ["cA", 73, "comesFrom", ["cA"], [58]], ["length", 24, "comesFrom", ["length"], [11]], ["length", 30, "comesFrom", ["length"], [11]], ["breadth", 26, "comesFrom", ["breadth"], [14]], ["breadth", 32, "comesFrom", ["breadth"], [14]], ["cL", 62, "comesFrom", ["cL"], [48]], ["cB", 64, "comesFrom", ["cB"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int n , int m , int obstacles , double range [ ] ) { double val = min ( n , m ) ; sort ( range , range + obstacles ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { range [ i ] = 2 * range [ i ] ; val -= range [ i ] ; if ( val <= 0 ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return -1 ; } } int main ( ) { int n = 4 , m = 5 , obstacles = 3 ; double range [ ] = { 1.0 , 1.25 , 1.15 } ; cout << solve ( n , m , obstacles , range ) << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Minimum number of Circular obstacles required to obstruct the path in a Grid | C ++ program to find the minimum number of obstacles required ; Function to find the minimum number of obstacles required ; Find the minimum range required to put obstacles ; Sorting the radius ; If val is less than zero then we have find the number of obstacles required ; Driver function", "dfg": [["i", 58, "comesFrom", ["i"], [52]], ["i", 62, "comesFrom", ["i"], [52]], ["i", 68, "comesFrom", ["i"], [52]], ["i", 82, "comesFrom", ["i"], [52]], ["i", 75, "comesFrom", ["i"], [52]], ["val", 105, "comesFrom", ["val"], [78]], ["val", 87, "comesFrom", ["val"], [78]], ["n", 30, "comesFrom", ["n"], [11]], ["n", 150, "comesFrom", ["n"], [121]], ["m", 32, "comesFrom", ["m"], [14]], ["m", 152, "comesFrom", ["m"], [125]], ["obstacles", 41, "comesFrom", ["obstacles"], [17]], ["obstacles", 54, "comesFrom", ["obstacles"], [17]], ["obstacles", 154, "comesFrom", ["obstacles"], [129]], ["c", 93, "comesFrom", ["c"], [45]], ["c", 98, "comesFrom", ["c"], [45]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double area ( double d1 , double a ) { double d2 = sqrt ( 4 * ( a * a ) - d1 * d1 ) ; double area = 0.5 * d1 * d2 ; return area ; } int main ( ) { double d = 7.07 ; double a = 5 ; printf ( \" % 0.8f \" , area ( d , a ) ) ; }", "docstring": "Program to calculate area of a rhombus whose one side and diagonal are given | C ++ program to calculate the area of a rhombus whose one side and one diagonal is given ; function to calculate the area of the rhombus ; Second diagonal ; area of rhombus ; return the area ; Driver code", "dfg": [["area", 45, "comesFrom", ["area"], [36]], ["area", 69, "comesFrom", ["area"], [36]], ["d2", 42, "comesFrom", ["d2"], [18]], ["d1", 40, "comesFrom", ["d1"], [11]], ["d1", 30, "comesFrom", ["d1"], [11]], ["d1", 32, "comesFrom", ["d1"], [11]], ["d", 71, "comesFrom", ["d"], [54]], ["a", 73, "comesFrom", ["a"], [59]], ["a", 25, "comesFrom", ["a"], [14]], ["a", 27, "comesFrom", ["a"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; } int main ( ) { int a = 1 , b = 1 , c = 1 ; int x1 = 1 , y1 = 1 ; int x2 = 2 , y2 = 1 ; if ( pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) ) cout << \" Yes \" ; else cout << \" No \" ; }", "docstring": "Check whether two points ( x1 , y1 ) and ( x2 , y2 ) lie on same side of a given line or not | C ++ program to check if two points lie on the same side or not ; Function to check if two points lie on the same side or not ; int fx1 ; Variable to store a * x1 + b * y1 - c int fx2 ; Variable to store a * x2 + b * y2 - c ; If fx1 and fx2 have same sign ; Driver code", "dfg": [["c", 42, "comesFrom", ["c"], [17]], ["c", 54, "comesFrom", ["c"], [17]], ["c", 117, "comesFrom", ["c"], [87]], ["a", 113, "comesFrom", ["a"], [79]], ["a", 34, "comesFrom", ["a"], [11]], ["a", 46, "comesFrom", ["a"], [11]], ["b", 115, "comesFrom", ["b"], [83]], ["b", 38, "comesFrom", ["b"], [14]], ["b", 50, "comesFrom", ["b"], [14]], ["x1", 119, "comesFrom", ["x1"], [92]], ["x1", 36, "comesFrom", ["x1"], [20]], ["y1", 121, "comesFrom", ["y1"], [96]], ["y1", 40, "comesFrom", ["y1"], [23]], ["x2", 123, "comesFrom", ["x2"], [101]], ["x2", 48, "comesFrom", ["x2"], [26]], ["y2", 125, "comesFrom", ["y2"], [105]], ["y2", 52, "comesFrom", ["y2"], [29]], ["fx1", 59, "comesFrom", ["fx1"], [32]], ["fx2", 61, "comesFrom", ["fx2"], [44]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void newvol ( double x ) { cout << \" percentage ▁ increase ▁ \" << \" in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ \" << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << \" % \" << endl ; } int main ( ) { double x = 10 ; newvol ( x ) ; return 0 ; }", "docstring": "Percentage increase in volume of the cube if a side of cube is increased by a given percentage | C ++ program to find percentage increase in the volume of the cube if a side of cube is increased by a given percentage ; Driver code", "dfg": [["x", 69, "comesFrom", ["x"], [63]], ["x", 35, "comesFrom", ["x"], [11]], ["x", 26, "comesFrom", ["x"], [11]], ["x", 42, "comesFrom", ["x"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriangles ( int n ) { int num = n ; cout << num << \" ▁ \" ; cout << num * ( num - 4 ) * ( num - 5 ) / 6 ; } int main ( ) { int n ; n = 6 ; findTriangles ( n ) ; return 0 ; }", "docstring": "Number of triangles formed by joining vertices of n | C ++ program to implement the above problem ; Function to find the number of triangles ; print the number of triangles having two side common ; print the number of triangles having no side common ; Driver code ; initialize the number of sides of a polygon", "dfg": [["num", 21, "comesFrom", ["num"], [15]], ["num", 29, "comesFrom", ["num"], [15]], ["num", 38, "comesFrom", ["num"], [15]], ["num", 32, "comesFrom", ["num"], [15]], ["n", 60, "comesFrom", ["n"], [54]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void radius ( int n , int d ) { cout << \" The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ \" << d / ( 2 * n - 2 ) << endl ; } int main ( ) { int d = 42 , n = 4 ; radius ( n , d ) ; return 0 ; }", "docstring": "Find the radii of the circles which are lined in a row , and distance between the centers of first and last circle is given | C ++ program to find radii of the circles which are lined in a row and distance between the centers of first and last circle is given ; Driver code", "dfg": [["n", 52, "comesFrom", ["n"], [46]], ["n", 28, "comesFrom", ["n"], [11]], ["d", 54, "comesFrom", ["d"], [42]], ["d", 23, "comesFrom", ["d"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void radius ( int n , int d ) { cout << \" The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ \" << d / ( n - 1 ) << endl ; } int main ( ) { int d = 42 , n = 4 ; radius ( n , d ) ; return 0 ; }", "docstring": "Find the side of the squares which are lined in a row , and distance between the centers of first and last square is given | C ++ program to find side of the squares which are lined in a row and distance between the centers of first and last squares is given ; Driver code", "dfg": [["n", 50, "comesFrom", ["n"], [44]], ["n", 26, "comesFrom", ["n"], [11]], ["d", 52, "comesFrom", ["d"], [40]], ["d", 23, "comesFrom", ["d"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; cout << num ; } int main ( ) { int n ; n = 6 ; findTriangles ( n ) ; return 0 ; }", "docstring": "Number of triangles formed by joining vertices of n | C ++ program to implement the above problem ; Function to find the number of triangles ; print the number of triangles ; Driver code ; initialize the number of sides of a polygon", "dfg": [["num", 29, "comesFrom", ["num"], [17]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 46, "comesFrom", ["n"], [40]], ["n", 22, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void diameter ( double r ) { cout << \" The ▁ length ▁ of ▁ the ▁ longest ▁ chord \" << \" ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ \" << 2 * r << endl ; } int main ( ) { double r = 4 ; diameter ( r ) ; return 0 ; }", "docstring": "Find the Diameter or Longest chord of a Circle | C ++ program to find the longest chord or diameter of the circle whose radius is given ; Function to find the longest chord ; Driver code ; Get the radius ; Find the diameter", "dfg": [["r", 43, "comesFrom", ["r"], [37]], ["r", 26, "comesFrom", ["r"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double getSlope ( double m ) { return m ; } int main ( ) { double m = 2 ; cout << getSlope ( m ) ; return 0 ; }", "docstring": "Slope of the line parallel to the line with the given slope | C ++ implementation of the approach ; Function to return the slope of the line which is parallel to the line with the given slope ; Driver code", "dfg": [["m", 15, "comesFrom", ["m"], [11]], ["m", 32, "comesFrom", ["m"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define LLI  long long int NEW_LINE LLI totalTriangles ( LLI h , LLI v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; LLI Total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return Total ; } int main ( ) { int h = 2 , v = 2 ; cout << totalTriangles ( h , v ) ; return 0 ; }", "docstring": "Total number of triangles formed when there are H horizontal and V vertical lines | C ++ implementation of the approach ; Function to return total triangles ; Only possible triangle is the given triangle ; If only vertical lines are present ; If only horizontal lines are present ; Return total triangles ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return -1 ; float x = r ; float V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 ; return V ; } int main ( ) { float r = 5 , R = 8 , h = 11 ; cout << sph ( r , R , h ) << endl ; return 0 ; }", "docstring": "Largest sphere that can be inscribed in a right circular cylinder inscribed in a frustum | C ++ Program to find the biggest sphere that can be inscribed within a right circular cylinder which in turn is inscribed within a frustum ; Function to find the biggest sphere ; the radii and height cannot be negative ; radius of the sphere ; volume of the sphere ; Driver code", "dfg": [["V", 61, "comesFrom", ["V"], [43]], ["h", 30, "comesFrom", ["h"], [17]], ["h", 90, "comesFrom", ["h"], [78]], ["r", 22, "comesFrom", ["r"], [11]], ["r", 86, "comesFrom", ["r"], [70]], ["r", 52, "comesFrom", ["r"], [40]], ["R", 26, "comesFrom", ["R"], [14]], ["R", 88, "comesFrom", ["R"], [74]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkOrtho ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m1 * m2 == -1 ) return true ; else return false ; } } int main ( ) { int x1 = 0 , y1 = 4 , x2 = 0 , y2 = -9 ; int x3 = 2 , y3 = 0 , x4 = -1 , y4 = 0 ; checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }", "docstring": "Check whether two straight lines are orthogonal or not | C ++ implementation of above approach ; Function to check if two straight lines are orthogonal or not ; Both lines have infinite slope ; Only line 1 has infinite slope ; Only line 2 has infinite slope ; Find slopes of the lines ; Check if their product is - 1 ; Driver code", "dfg": [["x1", 221, "comesFrom", ["x1"], [186]], ["x1", 44, "comesFrom", ["x1"], [11]], ["x1", 62, "comesFrom", ["x1"], [11]], ["x1", 116, "comesFrom", ["x1"], [11]], ["x1", 146, "comesFrom", ["x1"], [11]], ["y1", 223, "comesFrom", ["y1"], [190]], ["y1", 110, "comesFrom", ["y1"], [14]], ["y1", 140, "comesFrom", ["y1"], [14]], ["x2", 225, "comesFrom", ["x2"], [194]], ["x2", 42, "comesFrom", ["x2"], [17]], ["x2", 60, "comesFrom", ["x2"], [17]], ["x2", 114, "comesFrom", ["x2"], [17]], ["x2", 144, "comesFrom", ["x2"], [17]], ["y2", 227, "comesFrom", ["y2"], [198]], ["y2", 108, "comesFrom", ["y2"], [20]], ["y2", 138, "comesFrom", ["y2"], [20]], ["x3", 229, "comesFrom", ["x3"], [203]], ["x3", 50, "comesFrom", ["x3"], [23]], ["x3", 100, "comesFrom", ["x3"], [23]], ["x3", 78, "comesFrom", ["x3"], [23]], ["x3", 160, "comesFrom", ["x3"], [23]], ["y3", 231, "comesFrom", ["y3"], [207]], ["y3", 72, "comesFrom", ["y3"], [26]], ["y3", 154, "comesFrom", ["y3"], [26]], ["x4", 233, "comesFrom", ["x4"], [211]], ["x4", 48, "comesFrom", ["x4"], [29]], ["x4", 98, "comesFrom", ["x4"], [29]], ["x4", 76, "comesFrom", ["x4"], [29]], ["x4", 158, "comesFrom", ["x4"], [29]], ["y4", 235, "comesFrom", ["y4"], [215]], ["y4", 70, "comesFrom", ["y4"], [32]], ["y4", 152, "comesFrom", ["y4"], [32]], ["m2", 83, "comesFrom", ["m2"], [67]], ["m2", 167, "comesFrom", ["m2"], [149]], ["m1", 121, "comesFrom", ["m1"], [105]], ["m1", 165, "comesFrom", ["m1"], [135]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float pentdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.22 * a ; return d ; } int main ( ) { float a = 6 ; cout << pentdiagonal ( a ) << endl ; return 0 ; }", "docstring": "Diagonal of a Regular Pentagon | C ++ Program to find the diagonal of a regular pentagon ; Function to find the diagonal of a regular pentagon ; Side cannot be negative ; Length of the diagonal ; Driver code", "dfg": [["d", 31, "comesFrom", ["d"], [24]], ["a", 16, "comesFrom", ["a"], [11]], ["a", 28, "comesFrom", ["a"], [11]], ["a", 48, "comesFrom", ["a"], [40]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float hexagonArea ( float d ) { return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 ; } int main ( ) { float d = 10 ; cout << \" Area ▁ of ▁ hexagon : ▁ \" << hexagonArea ( d ) ; return 0 ; }", "docstring": "Area of hexagon with given diagonal length | C ++ program to find the area of Hexagon with given diagonal ; Function to calculate area ; Formula to find area ; Main", "dfg": [["d", 52, "comesFrom", ["d"], [40]], ["d", 25, "comesFrom", ["d"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; } int main ( ) { int n = 6 , m = 6 , a = 4 ; cout << Squares ( n , m , a ) ; return 0 ; }", "docstring": "Number of squares of side length required to cover an N * M rectangle | CPP program to find number of squares of a * a required to cover n * m rectangle ; function to find number of squares of a * a required to cover n * m rectangle ; Driver code ; function call", "dfg": [["a", 30, "comesFrom", ["a"], [17]], ["a", 42, "comesFrom", ["a"], [17]], ["a", 72, "comesFrom", ["a"], [60]], ["a", 25, "comesFrom", ["a"], [17]], ["a", 37, "comesFrom", ["a"], [17]], ["n", 68, "comesFrom", ["n"], [52]], ["n", 35, "comesFrom", ["n"], [11]], ["m", 70, "comesFrom", ["m"], [56]], ["m", 23, "comesFrom", ["m"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float octadiagonal ( float a ) { if ( a < 0 ) return -1 ; return a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; } int main ( ) { float a = 4 ; cout << octadiagonal ( a ) << endl ; return 0 ; }", "docstring": "Length of the Diagonal of the Octagon | C ++ Program to find the diagonal of the octagon ; Function to find the diagonal of the octagon ; side cannot be negative ; diagonal of the octagon ; Driver code", "dfg": [["a", 24, "comesFrom", ["a"], [11]], ["a", 16, "comesFrom", ["a"], [11]], ["a", 55, "comesFrom", ["a"], [47]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void CalPeri ( ) { int s = 5 , Perimeter ; Perimeter = 10 * s ; cout << \" The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ \" << Perimeter ; } int main ( ) { CalPeri ( ) ; return 0 ; }", "docstring": "Program to Calculate the Perimeter of a Decagon | C ++ program to Calculate the Perimeter of a Decagon ; Function for finding the perimeter ; Driver code", "dfg": [["Perimeter", 31, "comesFrom", ["Perimeter"], [19]], ["s", 23, "comesFrom", ["s"], [13]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double findEdges ( double s1 , double s2 , double s3 ) { double a = sqrt ( s1 * s2 / s3 ) ; double b = sqrt ( s3 * s1 / s2 ) ; double c = sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; } int main ( ) { double s1 , s2 , s3 ; s1 = 65 , s2 = 156 , s3 = 60 ; cout << findEdges ( s1 , s2 , s3 ) ; return 0 ; }", "docstring": "Sum of lengths of all 12 edges of any rectangular parallelepiped | C ++ program to illustrate the above problem ; function to find the sum of all the edges of parallelepiped ; to calculate the length of one edge ; sum of all the edges of one side ; net sum will be equal to the summation of edges of all the sides ; Driver code ; initialize the area of three faces which has a common vertex", "dfg": [["sum", 68, "comesFrom", ["sum"], [57]], ["c", 63, "comesFrom", ["c"], [45]], ["a", 59, "comesFrom", ["a"], [21]], ["b", 61, "comesFrom", ["b"], [33]], ["s1", 99, "comesFrom", ["s1"], [83]], ["s1", 53, "comesFrom", ["s1"], [11]], ["s1", 25, "comesFrom", ["s1"], [11]], ["s1", 39, "comesFrom", ["s1"], [11]], ["s2", 101, "comesFrom", ["s2"], [87]], ["s2", 41, "comesFrom", ["s2"], [14]], ["s2", 27, "comesFrom", ["s2"], [14]], ["s2", 51, "comesFrom", ["s2"], [14]], ["s3", 103, "comesFrom", ["s3"], [91]], ["s3", 29, "comesFrom", ["s3"], [17]], ["s3", 37, "comesFrom", ["s3"], [17]], ["s3", 49, "comesFrom", ["s3"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; } int main ( ) { int n = 3 ; cout << \" Max ▁ number ▁ of ▁ pieces ▁ for ▁ n ▁ = ▁ \" << n << \" ▁ is ▁ \" << findMaximumPieces ( 3 ) ; return 0 ; }", "docstring": "Maximum number of pieces in N cuts | C ++ program to find maximum no of pieces by given number of cuts ; Function for finding maximum pieces with n cuts . ; to maximize number of pieces x is the horizontal cuts ; Now ( x ) is the horizontal cuts and ( n - x ) is vertical cuts , then maximum number of pieces = ( x + 1 ) * ( n - x + 1 ) ; Driver code ; Taking the maximum number of cuts allowed as 3 ; Finding and printing the max number of pieces", "dfg": [["n", 17, "comesFrom", ["n"], [11]], ["n", 55, "comesFrom", ["n"], [45]], ["n", 30, "comesFrom", ["n"], [11]], ["x", 24, "comesFrom", ["x"], [15]], ["x", 32, "comesFrom", ["x"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) cout << \" Coplanar \" << endl ; else cout << \" Not ▁ Coplanar \" << endl ; } int main ( ) { int x1 = 3 ; int y1 = 2 ; int z1 = -5 ; int x2 = -1 ; int y2 = 4 ; int z2 = -3 ; int x3 = -3 ; int y3 = 8 ; int z3 = -5 ; int x4 = -3 ; int y4 = 2 ; int z4 = 1 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; return 0 ; }", "docstring": "Program to check whether 4 points in a 3 | C ++ program to check if 4 points in a 3 - D plane are Coplanar ; Function to find equation of plane . ; checking if the 4 th point satisfies the above equation ; Driver Code ; function calling", "dfg": [["x2", 50, "comesFrom", ["x2"], [20]], ["x2", 249, "comesFrom", ["x2"], [197]], ["x1", 52, "comesFrom", ["x1"], [11]], ["x1", 73, "comesFrom", ["x1"], [11]], ["x1", 243, "comesFrom", ["x1"], [182]], ["x1", 129, "comesFrom", ["x1"], [11]], ["y2", 57, "comesFrom", ["y2"], [23]], ["y2", 251, "comesFrom", ["y2"], [202]], ["y1", 59, "comesFrom", ["y1"], [14]], ["y1", 80, "comesFrom", ["y1"], [14]], ["y1", 245, "comesFrom", ["y1"], [187]], ["y1", 133, "comesFrom", ["y1"], [14]], ["z2", 64, "comesFrom", ["z2"], [26]], ["z2", 253, "comesFrom", ["z2"], [207]], ["z1", 66, "comesFrom", ["z1"], [17]], ["z1", 87, "comesFrom", ["z1"], [17]], ["z1", 247, "comesFrom", ["z1"], [192]], ["z1", 137, "comesFrom", ["z1"], [17]], ["x3", 71, "comesFrom", ["x3"], [29]], ["x3", 255, "comesFrom", ["x3"], [212]], ["y3", 78, "comesFrom", ["y3"], [32]], ["y3", 257, "comesFrom", ["y3"], [217]], ["z3", 85, "comesFrom", ["z3"], [35]], ["z3", 259, "comesFrom", ["z3"], [222]], ["x4", 261, "comesFrom", ["x4"], [227]], ["y4", 263, "comesFrom", ["y4"], [232]], ["z4", 265, "comesFrom", ["z4"], [237]], ["b1", 92, "comesFrom", ["b1"], [55]], ["b1", 118, "comesFrom", ["b1"], [55]], ["c2", 94, "comesFrom", ["c2"], [83]], ["c2", 109, "comesFrom", ["c2"], [83]], ["b2", 96, "comesFrom", ["b2"], [76]], ["b2", 116, "comesFrom", ["b2"], [76]], ["c1", 98, "comesFrom", ["c1"], [62]], ["c1", 105, "comesFrom", ["c1"], [62]], ["a2", 103, "comesFrom", ["a2"], [69]], ["a2", 120, "comesFrom", ["a2"], [69]], ["a1", 107, "comesFrom", ["a1"], [48]], ["a1", 114, "comesFrom", ["a1"], [48]], ["d", 154, "comesFrom", ["d"], [123]], ["c", 135, "comesFrom", ["c"], [112]], ["c", 150, "comesFrom", ["c"], [112]], ["b", 131, "comesFrom", ["b"], [101]], ["b", 146, "comesFrom", ["b"], [101]], ["z", 152, "comesFrom", ["z"], [44]], ["a", 127, "comesFrom", ["a"], [90]], ["a", 142, "comesFrom", ["a"], [90]], ["x", 144, "comesFrom", ["x"], [38]], ["y", 148, "comesFrom", ["y"], [41]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = 3.14159 ; float A = ( 180 / pi ) * ( acos ( d ) ) ; cout << \" Angle ▁ is ▁ \" << A << \" ▁ degree \" ; } int main ( ) { float a1 = 1 ; float b1 = 1 ; float c1 = 2 ; float d1 = 1 ; float a2 = 2 ; float b2 = -1 ; float c2 = 1 ; float d2 = -4 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }", "docstring": "Angle between two Planes in 3D | C ++ program to find the Angle between two Planes in 3 D . ; Function to find Angle ; Driver Code", "dfg": [["d", 87, "comesFrom", ["d"], [85]], ["d", 112, "comesFrom", ["d"], [85]], ["A", 122, "comesFrom", ["A"], [101]], ["a1", 176, "comesFrom", ["a1"], [135]], ["a1", 36, "comesFrom", ["a1"], [14]], ["a1", 54, "comesFrom", ["a1"], [14]], ["a1", 56, "comesFrom", ["a1"], [14]], ["b1", 178, "comesFrom", ["b1"], [140]], ["b1", 40, "comesFrom", ["b1"], [17]], ["b1", 58, "comesFrom", ["b1"], [17]], ["b1", 60, "comesFrom", ["b1"], [17]], ["c1", 180, "comesFrom", ["c1"], [145]], ["c1", 44, "comesFrom", ["c1"], [20]], ["c1", 62, "comesFrom", ["c1"], [20]], ["c1", 64, "comesFrom", ["c1"], [20]], ["a2", 182, "comesFrom", ["a2"], [155]], ["a2", 38, "comesFrom", ["a2"], [23]], ["a2", 72, "comesFrom", ["a2"], [23]], ["a2", 74, "comesFrom", ["a2"], [23]], ["b2", 184, "comesFrom", ["b2"], [160]], ["b2", 42, "comesFrom", ["b2"], [26]], ["b2", 76, "comesFrom", ["b2"], [26]], ["b2", 78, "comesFrom", ["b2"], [26]], ["c2", 186, "comesFrom", ["c2"], [165]], ["c2", 46, "comesFrom", ["c2"], [29]], ["c2", 80, "comesFrom", ["c2"], [29]], ["c2", 82, "comesFrom", ["c2"], [29]], ["e1", 90, "comesFrom", ["e1"], [50]], ["e2", 92, "comesFrom", ["e2"], [68]], ["pi", 106, "comesFrom", ["pi"], [96]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE #include <iostream> NEW_LINE #include <iomanip> NEW_LINE using namespace std ; void mirror_point ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << \" ▁ x3 ▁ = ▁ \" << x3 ; cout << \" ▁ y3 ▁ = ▁ \" << y3 ; cout << \" ▁ z3 ▁ = ▁ \" << z3 ; } int main ( ) { float a = 1 ; float b = -2 ; float c = 0 ; float d = 0 ; float x1 = -1 ; float y1 = 3 ; float z1 = 4 ; mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; return 0 ; }", "docstring": "Mirror of a point through a 3 D plane | C ++ program to find Mirror of a point through a 3 D plane ; Function to mirror image ; Driver Code ; function call", "dfg": [["x3", 157, "comesFrom", ["x3"], [106]], ["y3", 165, "comesFrom", ["y3"], [115]], ["z3", 173, "comesFrom", ["z3"], [124]], ["x1", 85, "comesFrom", ["x1"], [32]], ["x1", 112, "comesFrom", ["x1"], [32]], ["x1", 226, "comesFrom", ["x1"], [202]], ["x1", 48, "comesFrom", ["x1"], [32]], ["y1", 94, "comesFrom", ["y1"], [35]], ["y1", 121, "comesFrom", ["y1"], [35]], ["y1", 228, "comesFrom", ["y1"], [207]], ["y1", 52, "comesFrom", ["y1"], [35]], ["z1", 103, "comesFrom", ["z1"], [38]], ["z1", 130, "comesFrom", ["z1"], [38]], ["z1", 230, "comesFrom", ["z1"], [212]], ["z1", 56, "comesFrom", ["z1"], [38]], ["a", 218, "comesFrom", ["a"], [182]], ["a", 81, "comesFrom", ["a"], [20]], ["a", 65, "comesFrom", ["a"], [20]], ["a", 67, "comesFrom", ["a"], [20]], ["a", 46, "comesFrom", ["a"], [20]], ["b", 220, "comesFrom", ["b"], [187]], ["b", 90, "comesFrom", ["b"], [23]], ["b", 50, "comesFrom", ["b"], [23]], ["b", 69, "comesFrom", ["b"], [23]], ["b", 71, "comesFrom", ["b"], [23]], ["c", 222, "comesFrom", ["c"], [192]], ["c", 99, "comesFrom", ["c"], [26]], ["c", 54, "comesFrom", ["c"], [26]], ["c", 73, "comesFrom", ["c"], [26]], ["c", 75, "comesFrom", ["c"], [26]], ["d", 224, "comesFrom", ["d"], [197]], ["d", 58, "comesFrom", ["d"], [29]], ["k", 83, "comesFrom", ["k"], [42]], ["k", 92, "comesFrom", ["k"], [42]], ["k", 101, "comesFrom", ["k"], [42]], ["x2", 110, "comesFrom", ["x2"], [79]], ["y2", 119, "comesFrom", ["y2"], [88]], ["z2", 128, "comesFrom", ["z2"], [97]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; } int main ( ) { int radius = 2 ; int totalRectangles ; totalRectangles = countRectangles ( radius ) ; cout << totalRectangles << \" ▁ rectangles ▁ can ▁ be \" << \" cut ▁ from ▁ a ▁ circle ▁ of ▁ Radius ▁ \" << radius ; return 0 ; }", "docstring": "Number of rectangles in a circle of radius R | C ++ program to find the number of rectangles that can be cut from a circle of Radius R ; Function to return the total possible rectangles that can be cut from the circle ; Diameter = 2 * Radius ; Square of diameter which is the square of the maximum length diagonal ; generate all combinations of a and b in the range ( 1 , ( 2 * Radius - 1 ) ) ( Both inclusive ) ; Calculate the Diagonal length of this rectangle ; If this rectangle 's Diagonal Length  is less than the Diameter, it is a  valid rectangle, thus increment counter ; Driver Code ; Radius of the circle", "dfg": [["rectangles", 94, "comesFrom", ["rectangles"], [15]], ["rectangles", 87, "comesFrom", ["rectangles"], [15]], ["a", 40, "comesFrom", ["a"], [36]], ["a", 46, "comesFrom", ["a"], [36]], ["a", 71, "comesFrom", ["a"], [36]], ["a", 73, "comesFrom", ["a"], [36]], ["radius", 129, "comesFrom", ["radius"], [103]], ["radius", 24, "comesFrom", ["radius"], [11]], ["radius", 44, "comesFrom", ["radius"], [11]], ["radius", 114, "comesFrom", ["radius"], [103]], ["radius", 61, "comesFrom", ["radius"], [11]], ["diameter", 29, "comesFrom", ["diameter"], [20]], ["diameter", 31, "comesFrom", ["diameter"], [20]], ["b", 57, "comesFrom", ["b"], [53]], ["b", 63, "comesFrom", ["b"], [53]], ["b", 75, "comesFrom", ["b"], [53]], ["b", 77, "comesFrom", ["b"], [53]], ["totalRectangles", 119, "comesFrom", ["totalRectangles"], [110]], ["diagonalLengthSquare", 82, "comesFrom", ["diagonalLengthSquare"], [68]], ["diameterSquare", 84, "comesFrom", ["diameterSquare"], [27]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int simi_aaa ( int a1 [ ] , int a2 [ ] ) { sort ( a1 , a1 + 3 ) ; sort ( a2 , a2 + 3 ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; } int simi_sas ( int s1 [ ] , int s2 [ ] , int a1 [ ] , int a2 [ ] ) { sort ( a1 , a1 + 3 ) ; sort ( a2 , a2 + 3 ) ; sort ( s1 , s1 + 3 ) ; sort ( s2 , s2 + 3 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; } int simi_sss ( int s1 [ ] , int s2 [ ] ) { sort ( s1 , s1 + 3 ) ; sort ( s2 , s2 + 3 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; } int main ( ) { int s1 [ ] = { 2 , 3 , 3 } ; int s2 [ ] = { 4 , 6 , 6 } ; int a1 [ ] = { 80 , 60 , 40 } ; int a2 [ ] = { 40 , 60 , 80 } ; int aaa = simi_aaa ( a1 , a2 ) ; int sss = simi_sss ( s1 , s2 ) ; int sas = simi_sas ( s1 , s2 , a1 , a2 ) ; if ( aaa == 1 sss == 1 sas == 1 ) { cout << \" Triangles ▁ are ▁ \" << \" similar ▁ by ▁ \" ; if ( aaa == 1 ) cout << \" AAA ▁ \" ; if ( sss == 1 ) cout << \" SSS ▁ \" ; if ( sas == 1 ) cout << \" SAS . \" ; } else cout << \" Triangles ▁ are ▁ \" << \" not ▁ similar \" ; return 0 ; }", "docstring": "Program to check similarity of given two triangles | C ++ program to check similarity between two triangles . ; Function for AAA similarity ; Check for AAA ; Function for SAS similarity ; angle b / w two smallest sides is largest . ; since we take angle b / w the sides . ; Function for SSS similarity ; Check for SSS ; Driver Code ; function call for AAA similarity ; function call for SSS similarity ; function call for SAS similarity ; Check if triangles are similar or not", "dfg": [["sas", 460, "comesFrom", ["sas"], [439]], ["sas", 501, "comesFrom", ["sas"], [439]], ["aaa", 454, "comesFrom", ["aaa"], [419]], ["aaa", 477, "comesFrom", ["aaa"], [419]], ["sss", 457, "comesFrom", ["sss"], [429]], ["sss", 489, "comesFrom", ["sss"], [429]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int center_pentadecagonal_num ( long int n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } int main ( ) { long int n = 3 ; cout << n << \" th ▁ number ▁ : ▁ \" << center_pentadecagonal_num ( n ) ; cout << endl ; n = 10 ; cout << n << \" th ▁ number ▁ : ▁ \" << center_pentadecagonal_num ( n ) ; return 0 ; }", "docstring": "Centered Pentadecagonal Number | C ++ Program to find nth centered pentadecagonal number ; centered pentadecagonal function ; Formula to calculate nth centered pentadecagonal number ; Driver Code", "dfg": [["n", 46, "comesFrom", ["n"], [40]], ["n", 54, "comesFrom", ["n"], [40]], ["n", 67, "comesFrom", ["n"], [61]], ["n", 75, "comesFrom", ["n"], [61]], ["n", 21, "comesFrom", ["n"], [12]], ["n", 25, "comesFrom", ["n"], [12]], ["n", 19, "comesFrom", ["n"], [12]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int center_nonadecagon_num ( long int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; } int main ( ) { long int n = 2 ; cout << n << \" th ▁ centered ▁ nonadecagonal ▁ number ▁ : ▁ \" << center_nonadecagon_num ( n ) ; cout << endl ; n = 7 ; cout << n << \" th ▁ centered ▁ nonadecagonal ▁ number ▁ : ▁ \" << center_nonadecagon_num ( n ) ; return 0 ; }", "docstring": "Centered nonadecagonal number | C ++ Program to find nth centered nonadecagonal number ; centered nonadecagonal function ; Formula to calculate nth centered nonadecagonal number ; Driver Code", "dfg": [["n", 46, "comesFrom", ["n"], [40]], ["n", 54, "comesFrom", ["n"], [40]], ["n", 67, "comesFrom", ["n"], [61]], ["n", 75, "comesFrom", ["n"], [61]], ["n", 21, "comesFrom", ["n"], [12]], ["n", 25, "comesFrom", ["n"], [12]], ["n", 19, "comesFrom", ["n"], [12]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << n << \" rd ▁ Hendecagonal ▁ number : ▁ \" ; cout << hendecagonal_num ( n ) ; cout << endl ; n = 10 ; cout << n << \" th ▁ Hendecagonal ▁ number : ▁ \" ; cout << hendecagonal_num ( n ) ; return 0 ; }", "docstring": "Hendecagonal number | C ++ program to find nth Hendecagonal number ; Function to find Hendecagonal number ; Formula to calculate nth Hendecagonal number ; Driver Code", "dfg": [["n", 42, "comesFrom", ["n"], [36]], ["n", 65, "comesFrom", ["n"], [59]], ["n", 52, "comesFrom", ["n"], [36]], ["n", 75, "comesFrom", ["n"], [59]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 24, "comesFrom", ["n"], [11]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cen_octagonalnum ( long int n ) { return ( 4 * n * n - 4 * n + 1 ) ; } int main ( ) { long int n = 6 ; cout << n << \" th ▁ centered \" << \" ▁ octagonal ▁ number ▁ : ▁ \" ; cout << cen_octagonalnum ( n ) ; cout << endl ; n = 11 ; cout << n << \" th ▁ centered \" << \" ▁ octagonal ▁ number ▁ : ▁ \" ; cout << cen_octagonalnum ( n ) ; return 0 ; }", "docstring": "Centered Octagonal Number | Program to find nth centered octagonal number ; Centered octagonal number function ; Formula to calculate nth centered octagonal number & return it into main function . ; Driver Code", "dfg": [["n", 44, "comesFrom", ["n"], [38]], ["n", 58, "comesFrom", ["n"], [38]], ["n", 71, "comesFrom", ["n"], [65]], ["n", 85, "comesFrom", ["n"], [65]], ["n", 21, "comesFrom", ["n"], [12]], ["n", 25, "comesFrom", ["n"], [12]], ["n", 19, "comesFrom", ["n"], [12]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( int arr [ ] , int i , int j , int m , int c ) { if ( i == j ) return false ; int lhs = arr [ j ] ; int rhs = m * arr [ i ] + c ; return ( lhs == rhs ) ; } int findOrderedPoints ( int arr [ ] , int n , int m , int c ) { int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 1 , c = 1 ; cout << findOrderedPoints ( arr , n , m , c ) ; return 0 ; }", "docstring": "Number of ordered points pair satisfying line equation | CPP code to count the number of ordered pairs satisfying Line Equation ; Checks if ( i , j ) is valid , a point ( i , j ) is valid if point ( arr [ i ] , arr [ j ] ) satisfies the equation y = mx + c And i is not equal to j ; check if i equals to j ; Equation LHS = y , and RHS = mx + c ; Returns the number of ordered pairs ( i , j ) for which point ( arr [ i ] , arr [ j ] ) satisfies the equation of the line y = mx + c ; for every possible ( i , j ) check if ( a [ i ] , a [ j ] ) satisfies the equation y = mx + c ; ( firstIndex , secondIndex ) is same as ( i , j ) ; check if ( firstIndex , secondIndex ) is a valid point ; Driver Code ; equation of line is y = mx + c", "dfg": [["counter", 148, "comesFrom", ["counter"], [84]], ["counter", 142, "comesFrom", ["counter"], [84]], ["i", 95, "comesFrom", ["i"], [91]], ["i", 99, "comesFrom", ["i"], [91]], ["i", 30, "comesFrom", ["i"], [16]], ["i", 52, "comesFrom", ["i"], [16]], ["n", 97, "comesFrom", ["n"], [74]], ["n", 112, "comesFrom", ["n"], [74]], ["n", 204, "comesFrom", ["n"], [174]], ["j", 32, "comesFrom", ["j"], [19]], ["j", 42, "comesFrom", ["j"], [19]], ["j", 110, "comesFrom", ["j"], [106]], ["j", 114, "comesFrom", ["j"], [106]], ["c", 55, "comesFrom", ["c"], [25]], ["c", 208, "comesFrom", ["c"], [194]], ["c", 139, "comesFrom", ["c"], [80]], ["lhs", 59, "comesFrom", ["lhs"], [38]], ["rhs", 61, "comesFrom", ["rhs"], [46]], ["m", 48, "comesFrom", ["m"], [22]], ["m", 206, "comesFrom", ["m"], [190]], ["m", 137, "comesFrom", ["m"], [77]], ["firstIndex", 133, "comesFrom", ["firstIndex"], [119]], ["secondIndex", 135, "comesFrom", ["secondIndex"], [123]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; } int main ( ) { int r = 8 , R = 4 , r1 = 2 , x1 = 6 , y1 = 0 ; if ( checkcircle ( r , R , r1 , x1 , y1 ) ) cout << \" yes \" << endl ; else cout << \" no \" << endl ; return 0 ; }", "docstring": "Check if a given circle lies completely inside the ring formed by two concentric circles | CPP code to check if a circle lies in the ring ; Function to check if circle lies in the ring ; distance between center of circle center of concentric circles ( origin ) using Pythagoras theorem ; Condition to check if circle is strictly inside the ring ; Driver Code ; Both circle with radius ' r ' and ' R ' have center ( 0 , 0 )", "dfg": [["R", 46, "comesFrom", ["R"], [14]], ["R", 88, "comesFrom", ["R"], [66]], ["r", 52, "comesFrom", ["r"], [11]], ["r", 86, "comesFrom", ["r"], [62]], ["r1", 90, "comesFrom", ["r1"], [70]], ["r1", 44, "comesFrom", ["r1"], [17]], ["r1", 50, "comesFrom", ["r1"], [17]], ["x1", 92, "comesFrom", ["x1"], [74]], ["x1", 31, "comesFrom", ["x1"], [20]], ["x1", 33, "comesFrom", ["x1"], [20]], ["y1", 94, "comesFrom", ["y1"], [78]], ["y1", 35, "comesFrom", ["y1"], [23]], ["y1", 37, "comesFrom", ["y1"], [23]], ["dis", 42, "comesFrom", ["dis"], [27]], ["dis", 48, "comesFrom", ["dis"], [27]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double surface_area_octahedron ( double side ) { return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ; } int main ( ) { double side = 7 ; cout << \" Surface ▁ area ▁ of ▁ octahedron ▁ = \" << surface_area_octahedron ( side ) << endl ; }", "docstring": "Program for Surface Area of Octahedron | CPP Program to calculate surface area of Octahedron ; utility Function ; Driver Function", "dfg": [["side", 26, "comesFrom", ["side"], [11]], ["side", 28, "comesFrom", ["side"], [11]], ["side", 51, "comesFrom", ["side"], [39]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCk ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int count_Straightlines ( int n , int m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; } int main ( ) { int n = 4 , m = 3 ; cout << count_Straightlines ( n , m ) ; return 0 ; }", "docstring": "Count of different straight lines with total n points with m collinear | CPP program to count number of straight lines with n total points , out of which m are collinear . ; Returns value of binomial coefficient Code taken from https : goo . gl / vhy4jp ; C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; function to calculate number of straight lines can be formed ; driver function", "dfg": [["i", 44, "comesFrom", ["i"], [40]], ["i", 48, "comesFrom", ["i"], [40]], ["i", 59, "comesFrom", ["i"], [40]], ["n", 46, "comesFrom", ["n"], [11]], ["n", 144, "comesFrom", ["n"], [132]], ["n", 110, "comesFrom", ["n"], [100]], ["k", 20, "comesFrom", ["k"], [14]], ["k", 92, "comesFrom", ["k"], [14]], ["k", 61, "comesFrom", ["k"], [14]], ["j", 64, "comesFrom", ["j"], [55]], ["j", 68, "comesFrom", ["j"], [55]], ["j", 73, "comesFrom", ["j"], [55]], ["j", 78, "comesFrom", ["j"], [55]], ["j", 83, "comesFrom", ["j"], [55]], ["m", 146, "comesFrom", ["m"], [136]], ["m", 117, "comesFrom", ["m"], [103]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( side , 3 ) ) ) ; } int main ( ) { int side = 4 ; cout << \" Volume ▁ of ▁ dodecahedron ▁ = ▁ \" << vol_of_dodecahedron ( side ) ; }", "docstring": "Calculate Volume of Dodecahedron | CPP program to calculate Volume of dodecahedron ; utility Function ; Driver Function", "dfg": [["side", 64, "comesFrom", ["side"], [52]], ["side", 38, "comesFrom", ["side"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void overflow ( int H , int r , int h , int N , int R ) { float tank_cap = 3.14 * r * r * H ; float water_vol = 3.14 * r * r * h ; float balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; float vol = water_vol + balls_vol ; if ( vol > tank_cap ) { cout << \" Overflow \" << endl ; } else { cout << \" Not ▁ in ▁ overflow ▁ state \" << endl ; } } int main ( ) { int H = 10 , r = 5 , h = 5 , N = 2 , R = 2 ; overflow ( H , r , h , N , R ) ; return 0 ; }", "docstring": "Program to check if water tank overflows when n solid balls are dipped in the water tank | C ++ Program to check if water tank overflows when n solid balls are dipped in the water tank ; function to find if tak will overflow or not ; cylinder capacity ; volume of water in tank ; volume of n balls ; total volume of water and n dipped balls ; condition to check if tank is in overflow state or not ; main function ; giving dimensions ; calling function", "dfg": [["H", 35, "comesFrom", ["H"], [11]], ["H", 130, "comesFrom", ["H"], [108]], ["h", 46, "comesFrom", ["h"], [17]], ["h", 134, "comesFrom", ["h"], [116]], ["R", 65, "comesFrom", ["R"], [23]], ["R", 138, "comesFrom", ["R"], [124]], ["R", 63, "comesFrom", ["R"], [23]], ["R", 61, "comesFrom", ["R"], [23]], ["water_vol", 70, "comesFrom", ["water_vol"], [38]], ["balls_vol", 72, "comesFrom", ["balls_vol"], [49]], ["vol", 76, "comesFrom", ["vol"], [68]], ["tank_cap", 78, "comesFrom", ["tank_cap"], [27]], ["r", 132, "comesFrom", ["r"], [112]], ["r", 33, "comesFrom", ["r"], [14]], ["r", 44, "comesFrom", ["r"], [14]], ["r", 31, "comesFrom", ["r"], [14]], ["r", 42, "comesFrom", ["r"], [14]], ["N", 136, "comesFrom", ["N"], [120]], ["N", 51, "comesFrom", ["N"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float volume ( int radius , int height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; } void check_and_print ( float required_time , float given_time ) { if ( required_time < given_time ) cout << \" Overflow \" ; else if ( required_time > given_time ) cout << \" Underflow \" ; else cout << \" Filled \" ; } int main ( ) { int radius = 5 , height = 10 , rate_of_flow = 10 ; float given_time = 70.0 ; float required_time = volume ( radius , height ) / rate_of_flow ; check_and_print ( required_time , given_time ) ; return 0 ; }", "docstring": "Program to check if tank will overflow , underflow or filled in given time | C ++ program to check if Tank will overflow or not in given time ; function to calculate the volume of tank ; function to print overflow / filled / underflow accordingly ; driver function ; radius of the tank ; height of the tank ; rate of flow of water ; time given ; calculate the required time ; printing the result", "dfg": [["height", 29, "comesFrom", ["height"], [14]], ["height", 106, "comesFrom", ["height"], [86]], ["required_time", 45, "comesFrom", ["required_time"], [37]], ["required_time", 113, "comesFrom", ["required_time"], [100]], ["required_time", 58, "comesFrom", ["required_time"], [37]], ["given_time", 47, "comesFrom", ["given_time"], [40]], ["given_time", 115, "comesFrom", ["given_time"], [95]], ["given_time", 60, "comesFrom", ["given_time"], [40]], ["rate_of_flow", 109, "comesFrom", ["rate_of_flow"], [90]], ["radius", 27, "comesFrom", ["radius"], [11]], ["radius", 25, "comesFrom", ["radius"], [11]], ["radius", 104, "comesFrom", ["radius"], [82]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; return cosx ; } float third_side ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; } int main ( ) { float c = 49 ; int a = 5 , b = 8 ; cout << third_side ( a , b , c ) ; return 0 ; }", "docstring": "Program to find third side of triangle using law of cosines | CPP program to find third side of triangle using law of cosines ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to find third side ; Driver program to check the above function ; function call", "dfg": [["cosx", 110, "comesFrom", ["cosx"], [84]], ["cosx", 86, "comesFrom", ["cosx"], [84]], ["cosx", 105, "comesFrom", ["cosx"], [84]], ["x1", 43, "comesFrom", ["x1"], [37]], ["x1", 88, "comesFrom", ["x1"], [73]], ["x1", 76, "comesFrom", ["x1"], [73]], ["n", 29, "comesFrom", ["n"], [27]], ["n", 49, "comesFrom", ["n"], [27]], ["n", 80, "comesFrom", ["n"], [27]], ["n", 78, "comesFrom", ["n"], [27]], ["accuracy", 99, "comesFrom", ["accuracy"], [15]], ["c", 131, "comesFrom", ["c"], [123]], ["c", 186, "comesFrom", ["c"], [165]], ["a", 182, "comesFrom", ["a"], [170]], ["a", 138, "comesFrom", ["a"], [117]], ["a", 140, "comesFrom", ["a"], [117]], ["a", 151, "comesFrom", ["a"], [117]], ["b", 184, "comesFrom", ["b"], [174]], ["b", 153, "comesFrom", ["b"], [120]], ["b", 144, "comesFrom", ["b"], [120]], ["b", 146, "comesFrom", ["b"], [120]], ["denominator", 82, "comesFrom", ["denominator"], [59]], ["i", 92, "comesFrom", ["i"], [90]], ["i", 63, "comesFrom", ["i"], [53]], ["i", 68, "comesFrom", ["i"], [53]], ["angle", 155, "comesFrom", ["angle"], [127]], ["cosval", 103, "comesFrom", ["cosval"], [45]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) cout << \" Fits STRNEWLINE \" ; else cout << \" Doesn ' t ▁ Fit STRNEWLINE \" ; } int main ( ) { int R = 8 , r = 4 ; int x = 5 , y = 3 , rad = 3 ; fitOrNotFit ( R , r , x , y , rad ) ; return 0 ; }", "docstring": "Check whether given circle resides in boundary maintained by two other circles | CPP program to check whether circle with given co - ordinates reside within the boundary of outer circle and inner circle ; function to check if given circle fit in boundary or not ; Distance from the center ; Checking the corners of circle ; driver program ; Radius of outer circle and inner circle respectively ; Co - ordinates and radius of the circle to be checked", "dfg": [["R", 105, "comesFrom", ["R"], [82]], ["R", 52, "comesFrom", ["R"], [11]], ["R", 58, "comesFrom", ["R"], [11]], ["r", 107, "comesFrom", ["r"], [86]], ["r", 60, "comesFrom", ["r"], [14]], ["x", 109, "comesFrom", ["x"], [91]], ["x", 33, "comesFrom", ["x"], [17]], ["y", 111, "comesFrom", ["y"], [95]], ["y", 40, "comesFrom", ["y"], [20]], ["rad", 113, "comesFrom", ["rad"], [99]], ["rad", 50, "comesFrom", ["rad"], [23]], ["rad", 56, "comesFrom", ["rad"], [23]], ["val", 48, "comesFrom", ["val"], [27]], ["val", 54, "comesFrom", ["val"], [27]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define EPSILON  numeric_limits<double>::epsilon() NEW_LINE bool compareDoubles ( double A , double B ) { double diff = A - B ; return ( diff < EPSILON ) && ( - diff < EPSILON ) ; } int numberOfTringles ( int a [ ] , int b [ ] , int c [ ] , int n ) { double slope [ n ] ; for ( int i = 0 ; i < n ; i ++ ) slope [ i ] = ( a [ i ] * 1.0 ) / b [ i ] ; sort ( slope , slope + n ) ; int count [ n ] , k = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( compareDoubles ( slope [ i ] , slope [ i - 1 ] ) ) this_count ++ ; else { count [ k ++ ] = this_count ; this_count = 1 ; } } count [ k ++ ] = this_count ; int sum1 = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum1 += count [ i ] ; int sum2 = 0 ; for ( int i = 0 ; i < k ; i ++ ) { temp [ i ] = count [ i ] * ( sum1 - count [ i ] ) ; sum2 += temp [ i ] ; } sum2 /= 2 ; int sum3 = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum3 += count [ i ] * ( sum2 - temp [ i ] ) ; sum3 /= 3 ; return sum3 ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 } ; int b [ ] = { 2 , 4 , 5 , 5 } ; int c [ ] = { 5 , 7 , 8 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << \" The ▁ number ▁ of ▁ triangles ▁ that \" \" ▁ can ▁ be ▁ formed ▁ are : ▁ \" << numberOfTringles ( a , b , c , n ) ; return 0 ; }", "docstring": "Number of Triangles that can be formed given a set of lines in Euclidean Plane | C ++ program to find the number of triangles that can be formed using a set of lines in Euclidean Plane ; double variables can ' t ▁ be ▁ checked ▁ precisely ▁ using ▁ ' == ' this function returns true if the double variables are equal ; This function returns the number of triangles for a given set of lines ; slope array stores the slope of lines ; slope array is sorted so that all lines with same slope come together ; After sorting slopes , count different slopes . k is index in count [ ] . ; int this_count = 1 ; Count of current slope ; calculating sum1 ( Sum of all slopes ) sum1 = m1 + m2 + ... ; calculating sum2 . sum2 = m1 * m2 + m2 * m3 + ... ; int temp [ n ] ; Needed for sum3 ; calculating sum3 which gives the final answer m1 * m2 * m3 + m2 * m3 * m4 + ... ; Driver code ; lines are stored as arrays of a , b and c for ' ax + by = c ' ; n is the number of lines", "dfg": []}
{"code": "#include <iostream> NEW_LINE using namespace std ; #define pdd  pair<double, double> NEW_LINE void lineFromPoints ( pdd P , pdd Q ) { double a = Q . second - P . second ; double b = P . first - Q . first ; double c = a * ( P . first ) + b * ( P . second ) ; if ( b < 0 ) { cout << \" The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ \" \" is : ▁ \" << a << \" x ▁ - ▁ \" << b << \" y ▁ = ▁ \" << c << endl ; } else { cout << \" The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ \" \" is : ▁ \" << a << \" x ▁ + ▁ \" << b << \" y ▁ = ▁ \" << c << endl ; } } int main ( ) { pdd P = make_pair ( 3 , 2 ) ; pdd Q = make_pair ( 2 , 6 ) ; lineFromPoints ( P , Q ) ; return 0 ; }", "docstring": "Program to find line passing through 2 Points | C ++ Implementation to find the line passing through two points ; This pair is used to store the X and Y coordinate of a point respectively ; Function to find the line given two points ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPolygonWithMidpoints ( int arr [ ] , int N , int midpoints ) { for ( int j = 0 ; j < midpoints ; j ++ ) { int val = 1 ; for ( int k = j ; k < N ; k += midpoints ) { val &= arr [ k ] ; } if ( val && N / midpoints > 2 ) { cout << \" Polygon ▁ possible ▁ with ▁ side ▁ length ▁ \" << << ( N / midpoints ) << endl ; return true ; } } return false ; } void isPolygonPossible ( int arr [ ] , int N ) { int limit = sqrt ( N ) ; for ( int i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , ( N / i ) ) ) return ; } } cout << \" Not ▁ possiblen \" ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isPolygonPossible ( arr , N ) ; return 0 ; }", "docstring": "Regular polygon using only 1 s in a binary numbered circle | C ++ program to find whether a regular polygon is possible in circle with 1 s as vertices ; method returns true if polygon is possible with ' midpoints ' number of midpoints ; loop for getting first vertex of polygon ; loop over array values at ' midpoints ' distance ; and ( & ) all those values , if even one of them is 0 , val will be 0 ; if val is still 1 and ( N / midpoints ) or ( number of vertices ) are more than two ( for a polygon minimum ) print result and return true ; method prints sides in the polygon or print not possible in case of no possible polygon ; limit for iterating over divisors ; If i divides N then i and ( N / i ) will be divisors ; check polygon for both divisors ; Driver code to test above methods", "dfg": [["j", 29, "comesFrom", ["j"], [25]], ["j", 33, "comesFrom", ["j"], [25]], ["midpoints", 31, "comesFrom", ["midpoints"], [19]], ["midpoints", 55, "comesFrom", ["midpoints"], [19]], ["midpoints", 72, "comesFrom", ["midpoints"], [19]], ["midpoints", 88, "comesFrom", ["midpoints"], [19]], ["i", 129, "comesFrom", ["i"], [125]], ["i", 133, "comesFrom", ["i"], [125]], ["i", 141, "comesFrom", ["i"], [125]], ["i", 154, "comesFrom", ["i"], [125]], ["i", 166, "comesFrom", ["i"], [125]], ["limit", 131, "comesFrom", ["limit"], [115]], ["N", 233, "comesFrom", ["N"], [214]], ["N", 51, "comesFrom", ["N"], [16]], ["N", 119, "comesFrom", ["N"], [111]], ["N", 139, "comesFrom", ["N"], [111]], ["N", 70, "comesFrom", ["N"], [16]], ["N", 86, "comesFrom", ["N"], [16]], ["N", 152, "comesFrom", ["N"], [111]], ["N", 161, "comesFrom", ["N"], [111]], ["N", 164, "comesFrom", ["N"], [111]], ["k", 49, "comesFrom", ["k"], [45]], ["k", 62, "comesFrom", ["k"], [53]], ["val", 68, "comesFrom", ["val"], [58]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } pair < int , int > getReducedForm ( int dy , int dx ) { int g = gcd ( abs ( dy ) , abs ( dx ) ) ; bool sign = ( dy < 0 ) ^ ( dx < 0 ) ; if ( sign ) return make_pair ( - abs ( dy ) / g , abs ( dx ) / g ) ; else return make_pair ( abs ( dy ) / g , abs ( dx ) / g ) ; } int minLinesToCoverPoints ( int points [ ] [ 2 ] , int N , int xO , int yO ) { set < pair < int , int > > st ; pair < int , int > temp ; int minLines = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int curX = points [ i ] [ 0 ] ; int curY = points [ i ] [ 1 ] ; temp = getReducedForm ( curY - yO , curX - xO ) ; if ( st . find ( temp ) == st . end ( ) ) { st . insert ( temp ) ; minLines ++ ; } } return minLines ; } int main ( ) { int xO , yO ; xO = 1 ; yO = 0 ; int points [ ] [ 2 ] = { { -1 , 3 } , { 4 , 3 } , { 2 , 1 } , { -1 , -2 } , { 3 , -3 } } ; int N = sizeof ( points ) / sizeof ( points [ 0 ] ) ; cout << minLinesToCoverPoints ( points , N , xO , yO ) ; return 0 ; }", "docstring": "Minimum lines to cover all points | C ++ program to get minimum lines to cover all the points ; Utility method to get gcd of a and b ; method returns reduced form of dy / dx as a pair ; get sign of result ; method returns minimum number of lines to cover all points where all lines goes through ( xO , yO ) ; set to store slope as a pair ; loop over all points once ; get x and y co - ordinate of current point ; if this slope is not there in set , increase ans by 1 and insert in set ; Driver code to test above methods", "dfg": [["minLines", 250, "comesFrom", ["minLines"], [167]], ["minLines", 244, "comesFrom", ["minLines"], [167]], ["a", 24, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]], ["sign", 85, "comesFrom", ["sign"], [69]], ["i", 178, "comesFrom", ["i"], [174]], ["i", 182, "comesFrom", ["i"], [174]], ["i", 191, "comesFrom", ["i"], [174]], ["i", 202, "comesFrom", ["i"], [174]], ["N", 180, "comesFrom", ["N"], [138]], ["N", 333, "comesFrom", ["N"], [312]], ["b", 19, "comesFrom", ["b"], [14]], ["b", 29, "comesFrom", ["b"], [14]], ["b", 33, "comesFrom", ["b"], [14]], ["xO", 335, "comesFrom", ["xO"], [263]], ["xO", 218, "comesFrom", ["xO"], [141]], ["yO", 337, "comesFrom", ["yO"], [267]], ["yO", 214, "comesFrom", ["yO"], [144]], ["dy", 72, "comesFrom", ["dy"], [46]], ["dy", 59, "comesFrom", ["dy"], [46]], ["dy", 93, "comesFrom", ["dy"], [46]], ["dy", 112, "comesFrom", ["dy"], [46]], ["dx", 78, "comesFrom", ["dx"], [49]], ["dx", 64, "comesFrom", ["dx"], [49]], ["dx", 100, "comesFrom", ["dx"], [49]], ["dx", 119, "comesFrom", ["dx"], [49]], ["g", 96, "comesFrom", ["g"], [53]], ["g", 103, "comesFrom", ["g"], [53]], ["g", 115, "comesFrom", ["g"], [53]], ["g", 122, "comesFrom", ["g"], [53]], ["curY", 212, "comesFrom", ["curY"], [198]], ["curX", 216, "comesFrom", ["curX"], [187]], ["st", 223, "comesFrom", ["st"], [156]], ["st", 230, "comesFrom", ["st"], [156]], ["st", 237, "comesFrom", ["st"], [156]], ["temp", 227, "comesFrom", ["temp"], [208]], ["temp", 241, "comesFrom", ["temp"], [208]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } int findMaximumHeight ( int N ) { int n = 1 + 8 * N ; int maxH = ( -1 + squareRoot ( n ) ) / 2 ; return maxH ; } int main ( ) { int N = 12 ; cout << findMaximumHeight ( N ) << endl ; return 0 ; }", "docstring": "Maximum height when coins are arranged in a triangle | C ++ program to find maximum height of arranged coin triangle ; Returns the square root of n . Note that the function ; We are using n itself as initial approximation This can definitely be improved ; e decides the accuracy level ; Method to find maximum height of arrangement of coins ; calculating portion inside the square root ; Driver code to test above method", "dfg": [["x", 56, "comesFrom", ["x"], [38]], ["x", 31, "comesFrom", ["x"], [15]], ["x", 52, "comesFrom", ["x"], [38]], ["x", 41, "comesFrom", ["x"], [38]], ["maxH", 90, "comesFrom", ["maxH"], [76]], ["e", 35, "comesFrom", ["e"], [25]], ["y", 33, "comesFrom", ["y"], [20]], ["y", 43, "comesFrom", ["y"], [20]], ["N", 73, "comesFrom", ["N"], [63]], ["N", 107, "comesFrom", ["N"], [99]], ["n", 50, "comesFrom", ["n"], [17]], ["n", 83, "comesFrom", ["n"], [67]]]}
{"code": "#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; class Point { public : int x , y ; Point ( int a = 0 , int b = 0 ) : x ( a ) , y ( b ) { } } ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int getCount ( Point p , Point q ) { if ( p . x == q . x ) return abs ( p . y - q . y ) - 1 ; if ( p . y == q . y ) return abs ( p . x - q . x ) - 1 ; return gcd ( abs ( p . x - q . x ) , abs ( p . y - q . y ) ) - 1 ; } int main ( ) { Point p ( 1 , 9 ) ; Point q ( 8 , 16 ) ; cout << \" The ▁ number ▁ of ▁ integral ▁ points ▁ between ▁ \" << \" ( \" << p . x << \" , ▁ \" << p . y << \" ) ▁ and ▁ ( \" << q . x << \" , ▁ \" << q . y << \" ) ▁ is ▁ \" << getCount ( p , q ) ; return 0 ; }", "docstring": "Number of Integral Points between Two Points | C ++ code to find the number of integral points lying on the line joining the two given points ; Class to represent an Integral point on XY plane . ; Utility function to find GCD of two numbers GCD of a and b ; Finds the no . of Integral points between two given points . ; If line joining p and q is parallel to x axis , then count is difference of y values ; If line joining p and q is parallel to y axis , then count is difference of x values ; Driver program to test above", "dfg": [["a", 63, "comesFrom", ["a"], [50]], ["a", 70, "comesFrom", ["a"], [50]], ["b", 58, "comesFrom", ["b"], [53]], ["b", 68, "comesFrom", ["b"], [53]], ["b", 72, "comesFrom", ["b"], [53]], ["p", 88, "comesFrom", ["p"], [80]], ["p", 112, "comesFrom", ["p"], [80]], ["p", 228, "comesFrom", ["p"], [169]], ["p", 99, "comesFrom", ["p"], [80]], ["p", 123, "comesFrom", ["p"], [80]], ["p", 139, "comesFrom", ["p"], [80]], ["p", 150, "comesFrom", ["p"], [80]], ["p", 202, "comesFrom", ["p"], [169]], ["p", 194, "comesFrom", ["p"], [169]], ["q", 92, "comesFrom", ["q"], [83]], ["q", 116, "comesFrom", ["q"], [83]], ["q", 230, "comesFrom", ["q"], [177]], ["q", 218, "comesFrom", ["q"], [177]], ["q", 103, "comesFrom", ["q"], [83]], ["q", 127, "comesFrom", ["q"], [83]], ["q", 210, "comesFrom", ["q"], [177]], ["q", 143, "comesFrom", ["q"], [83]], ["q", 154, "comesFrom", ["q"], [83]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; struct Point { int x , y ; } ; int distSq ( Point p , Point q ) { return ( p . x - q . x ) * ( p . x - q . x ) + ( p . y - q . y ) * ( p . y - q . y ) ; } bool isSquare ( Point p1 , Point p2 , Point p3 , Point p4 ) { if ( d2 == 0 d3 == 0 d4 == 0 ) return false ; if ( d2 == d3 && 2 * d2 == d4 && 2 * distSq ( p2 , p4 ) == distSq ( p2 , p3 ) ) { return true ; } if ( d3 == d4 && 2 * d3 == d2 && 2 * distSq ( p3 , p2 ) == distSq ( p3 , p4 ) ) { return true ; } if ( d2 == d4 && 2 * d2 == d3 && 2 * distSq ( p2 , p3 ) == distSq ( p2 , p4 ) ) { return true ; } return false ; } int main ( ) { Point p1 = { 20 , 10 } , p2 = { 10 , 20 } , p3 = { 20 , 20 } , p4 = { 10 , 10 } ; isSquare ( p1 , p2 , p3 , p4 ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }", "docstring": "How to check if given four points form a square | A C ++ program to check if four given points form a square or not . ; Structure of a point in 2D space ; A utility function to find square of distance from point ' p ' to point ' q ' ; This function returns true if ( p1 , p2 , p3 , p4 ) form a square , otherwise false ; int d2 = distSq ( p1 , p2 ) ; from p1 to p2 int d3 = distSq ( p1 , p3 ) ; from p1 to p3 int d4 = distSq ( p1 , p4 ) ; from p1 to p4 ; If lengths if ( p1 , p2 ) and ( p1 , p3 ) are same , then following conditions must met to form a square . 1 ) Square of length of ( p1 , p4 ) is same as twice the square of ( p1 , p2 ) 2 ) Square of length of ( p2 , p3 ) is same as twice the square of ( p2 , p4 ) ; The below two cases are similar to above case ; Driver program to test above function", "dfg": [["p1", 243, "comesFrom", ["p1"], [209]], ["p2", 245, "comesFrom", ["p2"], [217]], ["p2", 123, "comesFrom", ["p2"], [76]], ["p2", 189, "comesFrom", ["p2"], [76]], ["p2", 116, "comesFrom", ["p2"], [76]], ["p2", 151, "comesFrom", ["p2"], [76]], ["p2", 182, "comesFrom", ["p2"], [76]], ["p3", 247, "comesFrom", ["p3"], [225]], ["p3", 125, "comesFrom", ["p3"], [79]], ["p3", 156, "comesFrom", ["p3"], [79]], ["p3", 149, "comesFrom", ["p3"], [79]], ["p3", 184, "comesFrom", ["p3"], [79]], ["p4", 249, "comesFrom", ["p4"], [233]], ["p4", 158, "comesFrom", ["p4"], [82]], ["p4", 191, "comesFrom", ["p4"], [82]], ["p4", 118, "comesFrom", ["p4"], [82]], ["p", 29, "comesFrom", ["p"], [21]], ["p", 39, "comesFrom", ["p"], [21]], ["p", 49, "comesFrom", ["p"], [21]], ["p", 59, "comesFrom", ["p"], [21]], ["q", 33, "comesFrom", ["q"], [24]], ["q", 43, "comesFrom", ["q"], [24]], ["q", 53, "comesFrom", ["q"], [24]], ["q", 63, "comesFrom", ["q"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDivisors ( int n ) { int divisors = 0 ; int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) { divisors ++ ; } } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) { divisors ++ ; } } return divisors ; } int possibleTriplets ( int N ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { count += countDivisors ( N - i ) ; } return count ; } int main ( ) { int N = 10 ; cout << possibleTriplets ( N ) ; return 0 ; }", "docstring": "Count triplets such that product of two numbers added with third number is N | C ++ program for the above approach ; Function to find the divisors of the number ( N - i ) ; Stores the resultant count of divisors of ( N - i ) ; Iterate over range [ 1 , sqrt ( N ) ] ; Return the total divisors ; Function to find the number of triplets such that A * B - C = N ; Loop to fix the value of C ; Adding the number of divisors in count ; Return count of triplets ; Driver Code", "dfg": [["divisors", 95, "comesFrom", ["divisors"], [15]], ["divisors", 47, "comesFrom", ["divisors"], [15]], ["divisors", 89, "comesFrom", ["divisors"], [15]], ["count", 136, "comesFrom", ["count"], [125]], ["n", 32, "comesFrom", ["n"], [11]], ["n", 40, "comesFrom", ["n"], [11]], ["n", 57, "comesFrom", ["n"], [11]], ["n", 82, "comesFrom", ["n"], [11]], ["i", 34, "comesFrom", ["i"], [24]], ["i", 72, "comesFrom", ["i"], [24]], ["i", 76, "comesFrom", ["i"], [24]], ["i", 117, "comesFrom", ["i"], [113]], ["i", 121, "comesFrom", ["i"], [113]], ["i", 28, "comesFrom", ["i"], [24]], ["i", 30, "comesFrom", ["i"], [24]], ["i", 54, "comesFrom", ["i"], [24]], ["i", 65, "comesFrom", ["i"], [24]], ["i", 42, "comesFrom", ["i"], [24]], ["i", 59, "comesFrom", ["i"], [24]], ["i", 84, "comesFrom", ["i"], [24]], ["i", 131, "comesFrom", ["i"], [113]], ["N", 119, "comesFrom", ["N"], [102]], ["N", 153, "comesFrom", ["N"], [145]], ["N", 129, "comesFrom", ["N"], [102]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPlanes ( int A [ ] , int B [ ] , int N ) { set < int > St ; for ( int i = 0 ; i < N ; i ++ ) { int t = ( A [ i ] % B [ i ] > 0 ) ? 1 : 0 ; t += ( A [ i ] / B [ i ] ) + t ; St . insert ( t ) ; } return St . size ( ) ; } int main ( ) { int A [ ] = { 1 , 3 , 5 , 4 , 8 } ; int B [ ] = { 1 , 2 , 2 , 1 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << maxPlanes ( A , B , N ) ; return 0 ; }", "docstring": "Maximize count of planes that can be stopped per second with help of given initial position and speed | C ++ program for the above approach ; Function to find maximum number of planes that can be stopped from landing ; Stores the times needed for landing for each plane ; Iterate over the arrays ; Stores the time needed for landing of current plane ; Update the value of t ; Append the t in set St ; Return the answer ; Driver Code", "dfg": [["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 71, "comesFrom", ["i"], [33]], ["i", 76, "comesFrom", ["i"], [33]], ["i", 51, "comesFrom", ["i"], [33]], ["i", 56, "comesFrom", ["i"], [33]], ["N", 39, "comesFrom", ["N"], [21]], ["N", 161, "comesFrom", ["N"], [138]], ["St", 91, "comesFrom", ["St"], [28]], ["St", 82, "comesFrom", ["St"], [28]], ["t", 80, "comesFrom", ["t"], [66]], ["t", 86, "comesFrom", ["t"], [66]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) cout << \" Bob \" ; else cout << \" Alice \" ; } int main ( ) { int K = 7 , N = 50 ; predictTheWinner ( K , N ) ; return 0 ; }", "docstring": "Find the player who will win by choosing a number in range [ 1 , K ] with sum total N | C ++ program for above approach ; Function to predict the winner ; Driver Code ; Given Input ; Function call", "dfg": [["K", 59, "comesFrom", ["K"], [49]], ["K", 22, "comesFrom", ["K"], [11]], ["N", 61, "comesFrom", ["N"], [53]], ["N", 19, "comesFrom", ["N"], [14]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void maxRightmostElement ( int N , int k , int arr [ ] ) { int ans = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int d = min ( arr [ i ] / 2 , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * 2 ; } cout << ans << endl ; } int main ( ) { int N = 4 , k = 5 , arr [ ] = { 3 , 8 , 1 , 4 } ; maxRightmostElement ( N , k , arr ) ; return 0 ; }", "docstring": "Maximize the rightmost element of an array in k operations in Linear Time | C ++ program for above approach ; Function to calculate maximum value of Rightmost element ; Initializing ans to store Maximum valued rightmost element ; Calculating maximum value of Rightmost element ; Printing rightmost element ; Driver Code ; Given Input ; Function Call", "dfg": [["i", 41, "comesFrom", ["i"], [35]], ["i", 45, "comesFrom", ["i"], [35]], ["i", 81, "comesFrom", ["i"], [35]], ["i", 56, "comesFrom", ["i"], [35]], ["i", 68, "comesFrom", ["i"], [35]], ["ans", 93, "comesFrom", ["ans"], [84]], ["N", 128, "comesFrom", ["N"], [104]], ["N", 37, "comesFrom", ["N"], [11]], ["N", 27, "comesFrom", ["N"], [11]], ["N", 77, "comesFrom", ["N"], [11]], ["N", 64, "comesFrom", ["N"], [11]], ["k", 130, "comesFrom", ["k"], [108]], ["k", 61, "comesFrom", ["k"], [14]], ["d", 74, "comesFrom", ["d"], [50]], ["d", 86, "comesFrom", ["d"], [50]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int smallestMaximum ( int N , int K ) { int sum = ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return ( sum / N ) + 1 ; else return sum / N ; } int main ( ) { int N = 4 ; int K = 3 ; cout << smallestMaximum ( N , K ) << endl ; return 0 ; }", "docstring": "Minimize the maximum element in constructed Array with sum divisible by K | C ++ program for the above approach . ; Function to find smallest maximum number in an array whose sum is divisible by K . ; Minimum possible sum possible for an array of size N such that its sum is divisible by K ; If sum is not divisible by N ; If sum is divisible by N ; Driver code .", "dfg": [["K", 32, "comesFrom", ["K"], [14]], ["K", 29, "comesFrom", ["K"], [14]], ["K", 79, "comesFrom", ["K"], [69]], ["K", 24, "comesFrom", ["K"], [14]], ["sum", 36, "comesFrom", ["sum"], [18]], ["sum", 53, "comesFrom", ["sum"], [18]], ["sum", 44, "comesFrom", ["sum"], [18]], ["N", 38, "comesFrom", ["N"], [11]], ["N", 55, "comesFrom", ["N"], [11]], ["N", 46, "comesFrom", ["N"], [11]], ["N", 77, "comesFrom", ["N"], [64]], ["N", 22, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string findIfPossible ( int N , int S , int X ) { if ( S >= X and S % 2 == X % 2 ) { if ( N >= 3 ) { return \" Yes \" ; } if ( N == 1 ) { if ( S == X ) { return \" Yes \" ; } else { return \" No \" ; } } if ( N == 2 ) { int C = ( S - X ) / 2 ; int A = C ; int B = C ; A = A + X ; if ( ( ( A ^ B ) == X ) ) { return \" Yes \" ; } else { return \" No \" ; } } } else { return \" No \" ; } } int main ( ) { int N = 3 , S = 10 , X = 4 ; cout << findIfPossible ( N , S , X ) ; return 0 ; }", "docstring": "Check if it is possible to construct an Array of size N having sum as S and XOR value as X | C ++ program for the above approach ; Function to find if any sequence is possible or not . ; Since , S is greater than equal to X , and either both are odd or even There always exists a sequence ; Only one case possible is S == X or NOT ; ; Considering the above conditions true , check if XOR of S ^ ( S - X ) is X or not ; Driver Code", "dfg": [["S", 22, "comesFrom", ["S"], [14]], ["S", 173, "comesFrom", ["S"], [159]], ["S", 26, "comesFrom", ["S"], [14]], ["S", 57, "comesFrom", ["S"], [14]], ["S", 88, "comesFrom", ["S"], [14]], ["X", 24, "comesFrom", ["X"], [17]], ["X", 175, "comesFrom", ["X"], [163]], ["X", 30, "comesFrom", ["X"], [17]], ["X", 59, "comesFrom", ["X"], [17]], ["X", 109, "comesFrom", ["X"], [17]], ["X", 120, "comesFrom", ["X"], [17]], ["X", 90, "comesFrom", ["X"], [17]], ["N", 171, "comesFrom", ["N"], [155]], ["N", 37, "comesFrom", ["N"], [11]], ["N", 50, "comesFrom", ["N"], [11]], ["N", 79, "comesFrom", ["N"], [11]], ["A", 107, "comesFrom", ["A"], [105]], ["A", 115, "comesFrom", ["A"], [105]], ["B", 117, "comesFrom", ["B"], [101]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string isPossible ( int arr [ ] , int n ) { int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) mini = min ( mini , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; int Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return \" No \" ; } return \" Yes \" ; } int main ( ) { int arr [ ] = { 1 , 1 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << isPossible ( arr , N ) ; return 0 ; }", "docstring": "Check whether each Array element can be reduced to minimum element by replacing it with remainder with some X | C ++ program for the above approach ; Function to check if every integer in the array can be reduced to the minimum array element ; Stores the minimum array element ; Find the minimum element ; Traverse the array arr [ ] ; Stores the maximum value in the range ; Check whether mini lies in the range or not ; Otherwise , return Yes ; Driver Code", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 57, "comesFrom", ["i"], [53]], ["i", 61, "comesFrom", ["i"], [53]], ["i", 46, "comesFrom", ["i"], [27]], ["i", 69, "comesFrom", ["i"], [53]], ["i", 82, "comesFrom", ["i"], [53]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 59, "comesFrom", ["n"], [16]], ["Max", 99, "comesFrom", ["Max"], [77]], ["N", 155, "comesFrom", ["N"], [134]], ["mini", 42, "comesFrom", ["mini"], [38]], ["mini", 72, "comesFrom", ["mini"], [38]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcdOfTwoNos ( int num1 , int num2 ) { if ( num1 == 0 ) return num2 ; if ( num2 == 0 ) return num1 ; if ( num1 == num2 ) return num1 ; if ( num1 > num2 ) return gcdOfTwoNos ( num1 - num2 , num2 ) ; return gcdOfTwoNos ( num1 , num2 - num1 ) ; } int Min_sum ( int arr [ ] , int N ) { int min_sum = 1000000 , maxGcd = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int gcd ; if ( i == 0 ) gcd = arr [ 1 ] ; else { gcd = arr [ i - 1 ] ; } for ( int j = 0 ; j < N ; j ++ ) { if ( j != i ) gcd = gcdOfTwoNos ( gcd , arr [ j ] ) ; } int c = arr [ i ] ; if ( gcd > maxGcd ) maxGcd = gcd ; } return maxGcd ; } int main ( ) { int arr [ ] = { 16 , 5 , 10 , 25 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << Min_sum ( arr , N ) ; return 0 ; }", "docstring": "Maximum number which can divide all array element after one replacement | C ++ Implementation for the above approach ; Function to return gcd of two numbers ; If one of numbers is 0 then gcd is other number ; If both are equal then that value is gcd ; One is greater ; Function to return minimum sum ; Initialize min_sum with large value ; Initialize variable gcd ; Storing value of arr [ i ] in c ; Update maxGcd if gcd is greater than maxGcd ; returning the maximum divisor of all elements ; Driver code", "dfg": [["maxGcd", 189, "comesFrom", ["maxGcd"], [183]], ["maxGcd", 181, "comesFrom", ["maxGcd"], [88]], ["num2", 24, "comesFrom", ["num2"], [14]], ["num2", 28, "comesFrom", ["num2"], [14]], ["num2", 39, "comesFrom", ["num2"], [14]], ["num2", 48, "comesFrom", ["num2"], [14]], ["num2", 57, "comesFrom", ["num2"], [14]], ["num2", 65, "comesFrom", ["num2"], [14]], ["num2", 55, "comesFrom", ["num2"], [14]], ["num1", 33, "comesFrom", ["num1"], [11]], ["num1", 42, "comesFrom", ["num1"], [11]], ["num1", 19, "comesFrom", ["num1"], [11]], ["num1", 37, "comesFrom", ["num1"], [11]], ["num1", 46, "comesFrom", ["num1"], [11]], ["num1", 63, "comesFrom", ["num1"], [11]], ["num1", 67, "comesFrom", ["num1"], [11]], ["num1", 53, "comesFrom", ["num1"], [11]], ["i", 99, "comesFrom", ["i"], [95]], ["i", 103, "comesFrom", ["i"], [95]], ["i", 112, "comesFrom", ["i"], [95]], ["i", 174, "comesFrom", ["i"], [95]], ["i", 154, "comesFrom", ["i"], [95]], ["i", 129, "comesFrom", ["i"], [95]], ["N", 101, "comesFrom", ["N"], [80]], ["N", 144, "comesFrom", ["N"], [80]], ["N", 231, "comesFrom", ["N"], [213]], ["j", 142, "comesFrom", ["j"], [138]], ["j", 146, "comesFrom", ["j"], [138]], ["j", 152, "comesFrom", ["j"], [138]], ["j", 164, "comesFrom", ["j"], [138]], ["gcd", 179, "comesFrom", ["gcd"], [156]], ["gcd", 185, "comesFrom", ["gcd"], [156]], ["gcd", 160, "comesFrom", ["gcd"], [156]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOddIntegers ( int arr [ ] , int N ) { int Fact [ N ] = { } ; Fact [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { Fact [ i ] = i * Fact [ i - 1 ] ; } int freq [ 10 ] = { } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int ans = 0 ; for ( int i = 1 ; i <= 9 ; i += 2 ) { if ( ! freq [ i ] ) continue ; freq [ i ] -- ; for ( int j = 1 ; j <= 9 ; j ++ ) { int cur_ans = 0 ; if ( freq [ j ] == 0 ) { continue ; } freq [ j ] -- ; cur_ans = Fact [ N - 2 ] ; for ( int k = 0 ; k <= 9 ; k ++ ) { cur_ans = cur_ans / Fact [ freq [ k ] ] ; } ans += cur_ans ; freq [ j ] ++ ; } freq [ i ] ++ ; } return ans ; } int main ( ) { int A [ ] = { 2 , 3 , 4 , 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( int ) ; cout << countOddIntegers ( A , N ) ; return 0 ; }", "docstring": "Count of distinct N | C ++ Program for the above approach ; Function to find the count of distinct odd integers with N digits using the given digits in the array arr [ ] ; Stores the factorial of a number ; Calculate the factorial of all numbers from 1 to N ; Stores the frequency of each digit ; Stores the final answer ; Loop to iterate over all values of Nth digit i and 1 st digit j ; If digit i does not exist in the given array move to next i ; Fixing i as Nth digit ; Stores the answer of a specific value of i and j ; If digit j does not exist move to the next j ; Fixing j as 1 st digit ; Calculate number of ways to arrange remaining N - 2 digits ; Including j back into the set of digits ; Including i back into the set of the digits ; Return Answer ; Driver Code ; Function Call", "dfg": [["ans", 231, "comesFrom", ["ans"], [212]], ["i", 42, "comesFrom", ["i"], [38]], ["i", 46, "comesFrom", ["i"], [38]], ["i", 81, "comesFrom", ["i"], [77]], ["i", 85, "comesFrom", ["i"], [77]], ["i", 111, "comesFrom", ["i"], [107]], ["i", 55, "comesFrom", ["i"], [38]], ["i", 52, "comesFrom", ["i"], [38]], ["i", 132, "comesFrom", ["i"], [115]], ["i", 225, "comesFrom", ["i"], [115]], ["i", 125, "comesFrom", ["i"], [115]], ["i", 59, "comesFrom", ["i"], [38]], ["i", 93, "comesFrom", ["i"], [77]], ["N", 44, "comesFrom", ["N"], [16]], ["N", 83, "comesFrom", ["N"], [16]], ["N", 22, "comesFrom", ["N"], [16]], ["N", 277, "comesFrom", ["N"], [259]], ["N", 179, "comesFrom", ["N"], [16]], ["j", 143, "comesFrom", ["j"], [139]], ["j", 147, "comesFrom", ["j"], [139]], ["j", 171, "comesFrom", ["j"], [139]], ["j", 218, "comesFrom", ["j"], [139]], ["j", 160, "comesFrom", ["j"], [139]], ["k", 191, "comesFrom", ["k"], [187]], ["k", 195, "comesFrom", ["k"], [187]], ["k", 207, "comesFrom", ["k"], [187]], ["cur_ans", 214, "comesFrom", ["cur_ans"], [199]], ["cur_ans", 201, "comesFrom", ["cur_ans"], [199]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigits ( int N ) { int sum = 0 ; while ( N ) { sum += ( N % 10 ) ; N = N / 10 ; } return sum ; } int CountPair ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { int val = arr [ i ] + sumOfDigits ( arr [ i ] ) ; mp [ val ] ++ ; } int count = 0 ; for ( auto x : mp ) { int val = x . first ; int times = x . second ; count += ( ( times * ( times - 1 ) ) / 2 ) ; } return count ; } int main ( ) { int arr [ ] = { 105 , 96 , 20 , 2 , 87 , 96 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CountPair ( arr , N ) ; return 0 ; }", "docstring": "Count pairs in an array having sum of elements with their respective sum of digits equal | C ++ program for the above approach ; Function to find the sum of digits of the number N ; Stores the sum of digits ; If the number N is greater than 0 ; Return the sum ; Function to find the count of pairs such that arr [ i ] + sumOfDigits ( arr [ i ] ) is equal to ( arr [ j ] + sumOfDigits ( arr [ j ] ) ; Stores the frequency of value of arr [ i ] + sumOfDigits ( arr [ i ] ) ; Traverse the given array ; Find the value ; Increment the frequency ; Stores the total count of pairs ; Traverse the map mp ; Update the count of pairs ; Return the total count of pairs ; Driver Code", "dfg": [["sum", 40, "comesFrom", ["sum"], [24]], ["mp", 111, "comesFrom", ["mp"], [61]], ["mp", 94, "comesFrom", ["mp"], [61]], ["count", 146, "comesFrom", ["count"], [128]], ["N", 21, "comesFrom", ["N"], [11]], ["N", 195, "comesFrom", ["N"], [174]], ["N", 34, "comesFrom", ["N"], [32]], ["N", 27, "comesFrom", ["N"], [11]], ["i", 70, "comesFrom", ["i"], [66]], ["i", 74, "comesFrom", ["i"], [66]], ["i", 83, "comesFrom", ["i"], [66]], ["i", 90, "comesFrom", ["i"], [66]], ["n", 72, "comesFrom", ["n"], [52]], ["val", 96, "comesFrom", ["val"], [79]], ["times", 132, "comesFrom", ["times"], [122]], ["times", 135, "comesFrom", ["times"], [122]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void build_tree ( int * b , vector < int > & seg_tree , int l , int r , int vertex ) { if ( l == r ) { seg_tree [ vertex ] = b [ l ] ; return ; } int mid = ( l + r ) / 2 ; build_tree ( b , seg_tree , l , mid , 2 * vertex ) ; build_tree ( b , seg_tree , mid + 1 , r , 2 * vertex + 1 ) ; seg_tree [ vertex ] = __gcd ( seg_tree [ 2 * vertex ] , seg_tree [ 2 * vertex + 1 ] ) ; } int range_gcd ( vector < int > & seg_tree , int v , int tl , int tr , int l , int r ) { if ( l > r ) return 0 ; if ( l == tl && r == tr ) return seg_tree [ v ] ; int tm = ( tl + tr ) / 2 ; return __gcd ( range_gcd ( seg_tree , 2 * v , tl , tm , l , min ( tm , r ) ) , range_gcd ( seg_tree , 2 * v + 1 , tm + 1 , tr , max ( tm + 1 , l ) , r ) ) ; } void maxSubarrayLen ( int arr [ ] , int n ) { vector < int > seg_tree ( 4 * ( n ) + 1 , 0 ) ; build_tree ( arr , seg_tree , 0 , n - 1 , 1 ) ; int maxLen = 0 ; int l = 0 , r = 0 ; while ( r < n && l < n ) { if ( range_gcd ( seg_tree , 1 , 0 , n - 1 , l , r ) == 1 ) { l ++ ; } maxLen = max ( maxLen , r - l + 1 ) ; r ++ ; } cout << maxLen ; } int main ( ) { int arr [ ] = { 410 , 52 , 51 , 180 , 222 , 33 , 33 } ; int N = sizeof ( arr ) / sizeof ( int ) ; maxSubarrayLen ( arr , N ) ; return 0 ; }", "docstring": "Longest subarray with GCD greater than 1 | C ++ program of the above approach ; Function to build the Segment Tree from the given array to process range queries in log ( N ) time ; Termination Condition ; Find the mid value ; Left and Right Recursive Call ; Update the Segment Tree Node ; Function to return the GCD of the elements of the Array from index l to index r ; Base Case ; Find the middle range ; Find the GCD and return ; Function to print maximum length of the subarray having GCD > one ; Stores the Segment Tree ; Function call to build the Segment tree from array arr [ ] ; Store maximum length of subarray ; Starting and ending pointer of the current window ; Case where the GCD of the current window is 1 ; Update the maximum length ; Print answer ; Driver Code", "dfg": [["maxLen", 352, "comesFrom", ["maxLen"], [333]], ["maxLen", 337, "comesFrom", ["maxLen"], [333]], ["seg_tree", 271, "comesFrom", ["seg_tree"], [254]], ["seg_tree", 311, "comesFrom", ["seg_tree"], [254]], ["l", 33, "comesFrom", ["l"], [22]], ["l", 68, "comesFrom", ["l"], [22]], ["l", 149, "comesFrom", ["l"], [141]], ["l", 158, "comesFrom", ["l"], [141]], ["l", 302, "comesFrom", ["l"], [288]], ["l", 55, "comesFrom", ["l"], [22]], ["l", 198, "comesFrom", ["l"], [141]], ["l", 45, "comesFrom", ["l"], [22]], ["l", 329, "comesFrom", ["l"], [288]], ["l", 230, "comesFrom", ["l"], [141]], ["l", 321, "comesFrom", ["l"], [288]], ["l", 341, "comesFrom", ["l"], [288]], ["r", 35, "comesFrom", ["r"], [25]], ["r", 87, "comesFrom", ["r"], [25]], ["r", 151, "comesFrom", ["r"], [144]], ["r", 162, "comesFrom", ["r"], [144]], ["r", 298, "comesFrom", ["r"], [292]], ["r", 346, "comesFrom", ["r"], [292]], ["r", 57, "comesFrom", ["r"], [25]], ["r", 233, "comesFrom", ["r"], [144]], ["r", 204, "comesFrom", ["r"], [144]], ["r", 323, "comesFrom", ["r"], [292]], ["r", 339, "comesFrom", ["r"], [292]], ["mid", 70, "comesFrom", ["mid"], [52]], ["mid", 83, "comesFrom", ["mid"], [52]], ["N", 398, "comesFrom", ["N"], [382]], ["vertex", 74, "comesFrom", ["vertex"], [28]], ["vertex", 98, "comesFrom", ["vertex"], [28]], ["vertex", 91, "comesFrom", ["vertex"], [28]], ["vertex", 40, "comesFrom", ["vertex"], [28]], ["vertex", 107, "comesFrom", ["vertex"], [28]], ["vertex", 114, "comesFrom", ["vertex"], [28]], ["tl", 160, "comesFrom", ["tl"], [135]], ["tl", 176, "comesFrom", ["tl"], [135]], ["tl", 194, "comesFrom", ["tl"], [135]], ["tr", 164, "comesFrom", ["tr"], [138]], ["tr", 178, "comesFrom", ["tr"], [138]], ["tr", 222, "comesFrom", ["tr"], [138]], ["v", 169, "comesFrom", ["v"], [132]], ["v", 192, "comesFrom", ["v"], [132]], ["v", 214, "comesFrom", ["v"], [132]], ["n", 275, "comesFrom", ["n"], [247]], ["n", 300, "comesFrom", ["n"], [247]], ["n", 304, "comesFrom", ["n"], [247]], ["n", 259, "comesFrom", ["n"], [247]], ["n", 317, "comesFrom", ["n"], [247]], ["tm", 196, "comesFrom", ["tm"], [173]], ["tm", 218, "comesFrom", ["tm"], [173]], ["tm", 202, "comesFrom", ["tm"], [173]], ["tm", 226, "comesFrom", ["tm"], [173]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findAandB ( int N ) { int K = log2 ( N ) ; int B = ( 1 << K ) ; int A = B ^ N ; cout << A << ' ▁ ' << B ; } int main ( ) { int N = 26 ; findAandB ( N ) ; return 0 ; }", "docstring": "Smallest pair of integers with minimum difference whose Bitwise XOR is N | C ++ program for the above approach ; Function to find the numbers A and B whose Bitwise XOR is N and the difference between them is minimum ; Find the MSB of the N ; Find the value of B ; Find the value of A ; Print the result ; Driver Code", "dfg": [["B", 48, "comesFrom", ["B"], [23]], ["B", 34, "comesFrom", ["B"], [23]], ["N", 36, "comesFrom", ["N"], [11]], ["N", 63, "comesFrom", ["N"], [57]], ["N", 19, "comesFrom", ["N"], [11]], ["K", 28, "comesFrom", ["K"], [15]], ["A", 40, "comesFrom", ["A"], [32]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findValuesOfK ( int g ) { int count = 0 ; for ( int i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { if ( i != g / i ) { if ( i & 1 ) { count ++ ; } if ( ( g / i ) & 1 ) { count ++ ; } } else if ( i & 1 ) { count ++ ; } } } cout << count ; } int main ( ) { int G = 125 ; findValuesOfK ( G ) ; return 0 ; }", "docstring": "Find all possible values of K such that the sum of first N numbers starting from K is G | C ++ program for the above approach ; Function to find the count the value of K such that sum of the first N numbers from K is G ; Stores the total count of K ; Iterate till square root of g ; If the number is factor of g ; If the second factor is not equal to first factor ; Check if two factors are odd or not ; If second factor is the same as the first factor then check if the first factor is odd or not ; Print the resultant count ; Driver Code", "dfg": [["g", 30, "comesFrom", ["g"], [11]], ["g", 38, "comesFrom", ["g"], [11]], ["g", 49, "comesFrom", ["g"], [11]], ["g", 68, "comesFrom", ["g"], [11]], ["i", 32, "comesFrom", ["i"], [22]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 28, "comesFrom", ["i"], [22]], ["i", 40, "comesFrom", ["i"], [22]], ["i", 47, "comesFrom", ["i"], [22]], ["i", 51, "comesFrom", ["i"], [22]], ["i", 56, "comesFrom", ["i"], [22]], ["i", 84, "comesFrom", ["i"], [22]], ["i", 70, "comesFrom", ["i"], [22]], ["count", 97, "comesFrom", ["count"], [15]], ["count", 61, "comesFrom", ["count"], [15]], ["count", 76, "comesFrom", ["count"], [15]], ["count", 89, "comesFrom", ["count"], [15]], ["G", 112, "comesFrom", ["G"], [106]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double Avgdifference ( double arr [ ] , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; } int main ( ) { double arr [ ] = { 3 , 8 , 9 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << Avgdifference ( arr , N , K ) ; return 0 ; }", "docstring": "Difference between maximum and minimum average of all K | C ++ program for the above approach ; Function to find the difference between the maximum and minimum subarrays of length K ; Stores the sum of subarray over the range [ 0 , K ] ; Iterate over the range [ 0 , K ] ; Store min and max sum ; Iterate over the range [ K , N - K ] ; Increment sum by arr [ i ] - arr [ i - K ] ; Update max and min moving sum ; Return difference between max and min average ; Driver Code ; Given Input ; Function Call", "dfg": [["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 65, "comesFrom", ["i"], [61]], ["i", 73, "comesFrom", ["i"], [61]], ["i", 45, "comesFrom", ["i"], [30]], ["i", 81, "comesFrom", ["i"], [61]], ["i", 86, "comesFrom", ["i"], [61]], ["K", 36, "comesFrom", ["K"], [19]], ["K", 119, "comesFrom", ["K"], [63]], ["K", 69, "comesFrom", ["K"], [63]], ["K", 171, "comesFrom", ["K"], [159]], ["K", 88, "comesFrom", ["K"], [63]], ["N", 67, "comesFrom", ["N"], [16]], ["N", 169, "comesFrom", ["N"], [143]], ["max", 114, "comesFrom", ["max"], [107]], ["max", 103, "comesFrom", ["max"], [54]], ["min", 116, "comesFrom", ["min"], [97]], ["min", 93, "comesFrom", ["min"], [49]], ["sum", 95, "comesFrom", ["sum"], [77]], ["sum", 99, "comesFrom", ["sum"], [77]], ["sum", 105, "comesFrom", ["sum"], [77]], ["sum", 109, "comesFrom", ["sum"], [77]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSet ( int N , int K ) { vector < int > a ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . push_back ( i ) ; } int MaxDistinct = ( N - K ) + ( K / 2 ) ; reverse ( a . begin ( ) , a . end ( ) ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) cout << a [ i ] << \" ▁ \" ; } int main ( ) { int N = 5 , K = 3 ; findSet ( N , K ) ; return 0 ; }", "docstring": "Count of distinct integers in range [ 1 , N ] that do not have any subset sum as K | C ++ program for the above approach ; Function to find maximum number of distinct integers in [ 1 , N ] having no subset with sum equal to K ; Declare a vector to store the required numbers ; Store all the numbers in [ 1 , N ] except K ; Store the maximum number of distinct numbers ; Reverse the array ; Print the required numbers ; Driver Code ; Given Input ; Function Call", "dfg": [["i", 30, "comesFrom", ["i"], [26]], ["i", 34, "comesFrom", ["i"], [26]], ["i", 89, "comesFrom", ["i"], [85]], ["i", 93, "comesFrom", ["i"], [85]], ["i", 40, "comesFrom", ["i"], [26]], ["i", 48, "comesFrom", ["i"], [26]], ["i", 100, "comesFrom", ["i"], [85]], ["N", 32, "comesFrom", ["N"], [11]], ["N", 124, "comesFrom", ["N"], [114]], ["N", 56, "comesFrom", ["N"], [11]], ["MaxDistinct", 91, "comesFrom", ["MaxDistinct"], [53]], ["K", 126, "comesFrom", ["K"], [118]], ["K", 42, "comesFrom", ["K"], [14]], ["K", 58, "comesFrom", ["K"], [14]], ["K", 62, "comesFrom", ["K"], [14]], ["a", 69, "comesFrom", ["a"], [21]], ["a", 75, "comesFrom", ["a"], [21]], ["a", 98, "comesFrom", ["a"], [21]], ["a", 44, "comesFrom", ["a"], [21]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long ExtendedEuclidAlgo ( long long a , long long b , long long & x , long long & y ) { if ( b == 0 ) { x = 1 ; y = 0 ; return a ; } else { long long x1 , y1 ; long long gcd = ExtendedEuclidAlgo ( b , a % b , x1 , y1 ) ; x = y1 ; y = x1 - floor ( a / b ) * y1 ; return gcd ; } } void linearCongruence ( long long A , long long B , long long N ) { A = A % N ; B = B % N ; long long u = 0 , v = 0 ; long long d = ExtendedEuclidAlgo ( A , N , u , v ) ; if ( B % d != 0 ) { cout << -1 << endl ; return ; } long long x0 = ( u * ( B / d ) ) % N ; if ( x0 < 0 ) x0 += N ; for ( long long i = 0 ; i <= d - 1 ; i ++ ) cout << ( x0 + i * ( N / d ) ) % N << \" ▁ \" ; } int main ( ) { long long A = 15 ; long long B = 9 ; long long N = 18 ; linearCongruence ( A , B , N ) ; return 0 ; }", "docstring": "Solve Linear Congruences Ax = B ( mod N ) for values of x in range [ 0 , N | C ++ program for the above approach ; Function to stores the values of x and y and find the value of gcd ( a , b ) ; Base Case ; Store the result of recursive call ; Update x and y using results of recursive call ; Function to give the distinct solutions of ax = b ( mod n ) ; Function Call to find the value of d and u ; No solution exists ; Else , initialize the value of x0 ; Print all the answers ; Driver Code ; Input ; Function Call", "dfg": [["i", 201, "comesFrom", ["i"], [197]], ["i", 207, "comesFrom", ["i"], [197]], ["i", 215, "comesFrom", ["i"], [197]], ["b", 32, "comesFrom", ["b"], [17]], ["b", 63, "comesFrom", ["b"], [17]], ["b", 67, "comesFrom", ["b"], [17]], ["b", 86, "comesFrom", ["b"], [17]], ["a", 46, "comesFrom", ["a"], [13]], ["a", 65, "comesFrom", ["a"], [13]], ["a", 84, "comesFrom", ["a"], [13]], ["A", 114, "comesFrom", ["A"], [112]], ["A", 256, "comesFrom", ["A"], [238]], ["A", 140, "comesFrom", ["A"], [112]], ["N", 116, "comesFrom", ["N"], [109]], ["N", 122, "comesFrom", ["N"], [109]], ["N", 181, "comesFrom", ["N"], [109]], ["N", 191, "comesFrom", ["N"], [109]], ["N", 260, "comesFrom", ["N"], [250]], ["N", 142, "comesFrom", ["N"], [109]], ["N", 224, "comesFrom", ["N"], [109]], ["N", 218, "comesFrom", ["N"], [109]], ["B", 120, "comesFrom", ["B"], [118]], ["B", 258, "comesFrom", ["B"], [244]], ["B", 151, "comesFrom", ["B"], [118]], ["B", 175, "comesFrom", ["B"], [118]], ["x0", 185, "comesFrom", ["x0"], [169]], ["x0", 213, "comesFrom", ["x0"], [189]], ["d", 203, "comesFrom", ["d"], [136]], ["d", 153, "comesFrom", ["d"], [136]], ["d", 177, "comesFrom", ["d"], [136]], ["d", 220, "comesFrom", ["d"], [136]], ["gcd", 92, "comesFrom", ["gcd"], [59]], ["u", 144, "comesFrom", ["u"], [126]], ["u", 172, "comesFrom", ["u"], [126]], ["v", 146, "comesFrom", ["v"], [130]], ["y1", 76, "comesFrom", ["y1"], [55]], ["y1", 71, "comesFrom", ["y1"], [55]], ["y1", 89, "comesFrom", ["y1"], [55]], ["x1", 80, "comesFrom", ["x1"], [53]], ["x1", 69, "comesFrom", ["x1"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorialWithoutMul ( int N ) { int ans = N ; for ( int i = N - 1 ; i > 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; } int main ( ) { int N = 5 ; cout << factorialWithoutMul ( N ) << endl ; return 0 ; }", "docstring": "Factorial of a number without using multiplication | C ++ program for the above approach ; Function to calculate factorial of the number without using multiplication operator ; variable to store the final factorial ; Outer loop ; Inner loop ; Driver code ; Input ; Function calling", "dfg": [["ans", 65, "comesFrom", ["ans"], [59]], ["ans", 57, "comesFrom", ["ans"], [15]], ["i", 28, "comesFrom", ["i"], [22]], ["i", 32, "comesFrom", ["i"], [22]], ["i", 50, "comesFrom", ["i"], [22]], ["N", 24, "comesFrom", ["N"], [17]], ["N", 82, "comesFrom", ["N"], [74]], ["j", 48, "comesFrom", ["j"], [44]], ["j", 52, "comesFrom", ["j"], [44]], ["sum", 61, "comesFrom", ["sum"], [55]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void tripletAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } cout << ans ; } int main ( ) { int arr [ ] = { 3 , 5 , 4 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; tripletAndSum ( arr , N ) ; return 0 ; }", "docstring": "Sum of Bitwise AND of all unordered triplets of an array | C ++ program for the above approach ; Function to calculate sum of Bitwise AND of all unordered triplets from a given array such that ( i < j < k ) ; Stores the resultant sum of Bitwise AND of all triplets ; Generate all triplets of ( arr [ i ] , arr [ j ] , arr [ k ] ) ; Add Bitwise AND to ans ; Print the result ; Driver Code", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 44, "comesFrom", ["i"], [27]], ["i", 77, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 50, "comesFrom", ["n"], [16]], ["n", 67, "comesFrom", ["n"], [16]], ["ans", 95, "comesFrom", ["ans"], [73]], ["N", 138, "comesFrom", ["N"], [119]], ["j", 48, "comesFrom", ["j"], [42]], ["j", 52, "comesFrom", ["j"], [42]], ["j", 61, "comesFrom", ["j"], [42]], ["j", 82, "comesFrom", ["j"], [42]], ["k", 65, "comesFrom", ["k"], [59]], ["k", 69, "comesFrom", ["k"], [59]], ["k", 87, "comesFrom", ["k"], [59]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int tripletAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; } int main ( ) { int arr [ ] = { 3 , 5 , 4 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << tripletAndSum ( arr , N ) ; return 0 ; }", "docstring": "Sum of Bitwise AND of all unordered triplets of an array | C ++ program for the above approach ; Function to calculate sum of Bitwise AND of all unordered triplets from a given array such that ( i < j < k ) ; Stores the resultant sum of Bitwise AND of all triplets ; Traverse over all the bits ; Count number of elements with the current bit set ; There are ( cnt ) C ( 3 ) numbers with the current bit set and each triplet contributes 2 ^ bit to the result ; Return the resultant sum ; Driver Code", "dfg": [["ans", 102, "comesFrom", ["ans"], [76]], ["bit", 31, "comesFrom", ["bit"], [27]], ["bit", 35, "comesFrom", ["bit"], [27]], ["bit", 69, "comesFrom", ["bit"], [27]], ["bit", 81, "comesFrom", ["bit"], [27]], ["i", 51, "comesFrom", ["i"], [47]], ["i", 55, "comesFrom", ["i"], [47]], ["i", 63, "comesFrom", ["i"], [47]], ["n", 53, "comesFrom", ["n"], [16]], ["N", 147, "comesFrom", ["N"], [126]], ["cnt", 72, "comesFrom", ["cnt"], [40]], ["cnt", 84, "comesFrom", ["cnt"], [40]], ["cnt", 93, "comesFrom", ["cnt"], [40]], ["cnt", 87, "comesFrom", ["cnt"], [40]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestPermutation ( int arr [ ] , int N ) { vector < bool > w ( 2 * N + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { w [ arr [ i ] ] = true ; } set < int > S ; for ( int i = 1 ; i <= 2 * N ; i ++ ) { if ( ! w [ i ] ) S . insert ( i ) ; } bool found = true ; vector < int > P ; for ( int i = 0 ; i < N ; i ++ ) { auto it = S . lower_bound ( arr [ i ] ) ; if ( it == S . end ( ) ) { found = false ; break ; } P . push_back ( arr [ i ] ) ; P . push_back ( * it ) ; S . erase ( it ) ; } if ( ! found ) { cout << \" - 1 STRNEWLINE \" ; } else { for ( int i = 0 ; i < 2 * N ; i ++ ) cout << P [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 4 , 1 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; smallestPermutation ( arr , N ) ; return 0 ; }", "docstring": "Lexicographically smallest permutation of length 2 N that can be obtained from an N | C ++ program for the above approach ; Function to find the lexicographically smallest permutation of length 2 * N satisfying the given conditions ; Stores if i - th element is placed at odd position or not ; Traverse the array ; Mark arr [ i ] true ; Stores all the elements not placed at odd positions ; Iterate in the range [ 1 , 2 * N ] ; If w [ i ] is not marked ; Stores whether it is possible to obtain the required permutation or not ; Stores the permutation ; Traverse the array arr [ ] ; Finds the iterator of the smallest number greater than the arr [ i ] ; If it is S . end ( ) ; Mark found false ; Push arr [ i ] and * it into the array ; Erase the current element from the Set ; If found is not marked ; Otherwise , ; Print the permutation ; Driver Code ; Given Input ; Function call", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 71, "comesFrom", ["i"], [67]], ["i", 77, "comesFrom", ["i"], [67]], ["i", 115, "comesFrom", ["i"], [111]], ["i", 119, "comesFrom", ["i"], [111]], ["i", 202, "comesFrom", ["i"], [198]], ["i", 208, "comesFrom", ["i"], [198]], ["i", 93, "comesFrom", ["i"], [67]], ["i", 86, "comesFrom", ["i"], [67]], ["i", 160, "comesFrom", ["i"], [111]], ["i", 51, "comesFrom", ["i"], [35]], ["i", 132, "comesFrom", ["i"], [111]], ["i", 215, "comesFrom", ["i"], [198]], ["N", 41, "comesFrom", ["N"], [16]], ["N", 117, "comesFrom", ["N"], [16]], ["N", 75, "comesFrom", ["N"], [16]], ["N", 262, "comesFrom", ["N"], [243]], ["N", 27, "comesFrom", ["N"], [16]], ["N", 206, "comesFrom", ["N"], [16]], ["found", 183, "comesFrom", ["found"], [147]], ["w", 47, "comesFrom", ["w"], [23]], ["w", 84, "comesFrom", ["w"], [23]], ["it", 138, "comesFrom", ["it"], [124]], ["it", 176, "comesFrom", ["it"], [124]], ["it", 169, "comesFrom", ["it"], [124]], ["P", 154, "comesFrom", ["P"], [106]], ["P", 164, "comesFrom", ["P"], [106]], ["P", 213, "comesFrom", ["P"], [106]], ["S", 172, "comesFrom", ["S"], [62]], ["S", 89, "comesFrom", ["S"], [62]], ["S", 126, "comesFrom", ["S"], [62]], ["S", 140, "comesFrom", ["S"], [62]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSubsequenceSum ( int A [ ] , int N ) { int ans = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ A [ i ] - i ] += A [ i ] ; ans = max ( ans , mp [ A [ i ] - i ] ) ; } cout << ans << endl ; } int main ( ) { int A [ ] = { 10 , 7 , 1 , 9 , 10 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maximumSubsequenceSum ( A , N ) ; return 0 ; }", "docstring": "Maximum sum of a subsequence having difference between their indices equal to the difference between their values | C ++ program for the above approach ; Function to find the maximum sum of a subsequence having difference between indices equal to difference in their values ; Stores the maximum sum ; Stores the value for each A [ i ] - i ; Traverse the array ; Update the value in map ; Update the answer ; Finally , print the answer ; Driver Code ; Given Input ; Function Call", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 59, "comesFrom", ["i"], [35]], ["i", 54, "comesFrom", ["i"], [35]], ["i", 51, "comesFrom", ["i"], [35]], ["i", 75, "comesFrom", ["i"], [35]], ["i", 72, "comesFrom", ["i"], [35]], ["N", 41, "comesFrom", ["N"], [16]], ["N", 131, "comesFrom", ["N"], [112]], ["ans", 82, "comesFrom", ["ans"], [62]], ["ans", 66, "comesFrom", ["ans"], [62]], ["mp", 47, "comesFrom", ["mp"], [30]], ["mp", 68, "comesFrom", ["mp"], [30]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void nearestPerfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = sqrt ( arr [ i ] ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) cout << a << \" ▁ \" ; else cout << b << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 5 , 2 , 7 , 13 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nearestPerfectSquare ( arr , N ) ; return 0 ; }", "docstring": "Find the nearest perfect square for each element of the array | C ++ program for the above approach ; Function to find the nearest perfect square for every element in the given array ; Traverse the array ; Calculate square root of current element ; Calculate perfect square ; Find the nearest ; Driver Code", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 41, "comesFrom", ["i"], [22]], ["i", 72, "comesFrom", ["i"], [22]], ["i", 83, "comesFrom", ["i"], [22]], ["N", 28, "comesFrom", ["N"], [16]], ["N", 146, "comesFrom", ["N"], [127]], ["sr", 48, "comesFrom", ["sr"], [35]], ["sr", 50, "comesFrom", ["sr"], [35]], ["sr", 56, "comesFrom", ["sr"], [35]], ["sr", 62, "comesFrom", ["sr"], [35]], ["a", 89, "comesFrom", ["a"], [46]], ["a", 75, "comesFrom", ["a"], [46]], ["b", 79, "comesFrom", ["b"], [53]], ["b", 98, "comesFrom", ["b"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime [ 100001 ] ; void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } void NumberofSets ( int N ) { SieveOfEratosthenes ( N ) ; if ( N == 2 ) { cout << 1 << endl ; } else if ( N == 3 ) { cout << 2 << endl ; } else { int ans = 1 ; for ( int i = N / 2 + 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) { ans += 1 ; } } cout << ans << endl ; } } int main ( ) { int N = 9 ; NumberofSets ( N ) ; return 0 ; }", "docstring": "Count of sets possible using integers from a range [ 2 , N ] using given operations that are in Equivalence Relation | C ++ program for the above approach ; Sieve of Eratosthenes to find primes less than or equal to N ; Function to find number of Sets ; Handle Base Case ; Set which contains less than or equal to N / 2 ; Number greater than N / 2 and are prime increment it by 1 ; If the number is prime Increment answer by 1 ; Driver Code ; Input ; Function Call", "dfg": [["n", 43, "comesFrom", ["n"], [17]], ["n", 70, "comesFrom", ["n"], [17]], ["p", 45, "comesFrom", ["p"], [35]], ["p", 39, "comesFrom", ["p"], [35]], ["p", 41, "comesFrom", ["p"], [35]], ["p", 74, "comesFrom", ["p"], [35]], ["p", 53, "comesFrom", ["p"], [35]], ["p", 64, "comesFrom", ["p"], [35]], ["p", 66, "comesFrom", ["p"], [35]], ["N", 95, "comesFrom", ["N"], [90]], ["N", 100, "comesFrom", ["N"], [90]], ["N", 187, "comesFrom", ["N"], [181]], ["N", 115, "comesFrom", ["N"], [90]], ["N", 147, "comesFrom", ["N"], [90]], ["N", 139, "comesFrom", ["N"], [90]], ["i", 68, "comesFrom", ["i"], [62]], ["i", 145, "comesFrom", ["i"], [137]], ["i", 149, "comesFrom", ["i"], [137]], ["i", 78, "comesFrom", ["i"], [72]], ["i", 157, "comesFrom", ["i"], [137]], ["ans", 169, "comesFrom", ["ans"], [161]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int floorDifference ( int A [ ] , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = totalSum / X ; return abs ( totalFloorSum - perElementSum ) ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int X = 4 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << floorDifference ( A , N , X ) ; return 0 ; }", "docstring": "Absolute difference between floor of Array sum divided by X and floor sum of every Array element when divided by X | C ++ program for the above approach ; Function to find absolute difference between the two sum values ; Variable to store total sum ; Variable to store sum of A [ i ] / X ; Traverse the array ; Update totalSum ; Update perElementSum ; Floor of total sum divided by X ; Return the absolute difference ; Driver Code ; Input ; Size of Array ; Function call to find absolute difference between the two sum values", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 51, "comesFrom", ["i"], [35]], ["i", 58, "comesFrom", ["i"], [35]], ["N", 41, "comesFrom", ["N"], [16]], ["N", 131, "comesFrom", ["N"], [110]], ["totalSum", 67, "comesFrom", ["totalSum"], [47]], ["X", 69, "comesFrom", ["X"], [19]], ["X", 133, "comesFrom", ["X"], [105]], ["X", 61, "comesFrom", ["X"], [19]], ["totalFloorSum", 74, "comesFrom", ["totalFloorSum"], [65]], ["perElementSum", 76, "comesFrom", ["perElementSum"], [54]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } int toDeci ( string str , int base ) { int len = str . size ( ) ; int power = 1 ; int num = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { printf ( \" Invalid ▁ Number \" ) ; return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; } char reVal ( int num ) { if ( num >= 0 && num <= 9 ) return ( char ) ( num + '0' ) ; else return ( char ) ( num - 10 + ' A ' ) ; } string fromDeci ( int base , int inputNum ) { string res = \" \" ; while ( inputNum > 0 ) { res += reVal ( inputNum % base ) ; inputNum /= base ; } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; } void convertBase ( string s , int a , int b ) { int num = toDeci ( s , a ) ; string ans = fromDeci ( b , num ) ; cout << ans ; } int main ( ) { string s = \"10B \" ; int a = 16 , b = 10 ; convertBase ( s , a , b ) ; return 0 ; }", "docstring": "Convert a number from base A to base B | C ++ program for the above approach ; Function to return ASCII value of a character ; Function to convert a number from given base to decimal number ; Stores the length of the string ; Initialize power of base ; Initialize result ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 2 ] * base + str [ len - 3 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Update num ; Update power ; Function to return equivalent character of a given value ; Function to convert a given decimal number to a given base ; Store the result ; Repeatedly divide inputNum by base and take remainder ; Update res ; Update inputNum ; Reverse the result ; Function to convert a given number from a base to another base ; Convert the number from base A to decimal ; Convert the number from decimal to base B ; Print the result ; Driver Code ; Given input ; Function Call", "dfg": [["num", 144, "comesFrom", ["num"], [124]], ["num", 156, "comesFrom", ["num"], [151]], ["num", 160, "comesFrom", ["num"], [151]], ["num", 281, "comesFrom", ["num"], [265]], ["num", 169, "comesFrom", ["num"], [151]], ["num", 182, "comesFrom", ["num"], [151]], ["res", 248, "comesFrom", ["res"], [218]], ["res", 234, "comesFrom", ["res"], [218]], ["res", 240, "comesFrom", ["res"], [218]], ["i", 92, "comesFrom", ["i"], [86]], ["i", 96, "comesFrom", ["i"], [86]], ["i", 106, "comesFrom", ["i"], [86]], ["i", 130, "comesFrom", ["i"], [86]], ["ans", 286, "comesFrom", ["ans"], [275]], ["inputNum", 213, "comesFrom", ["inputNum"], [201]], ["inputNum", 222, "comesFrom", ["inputNum"], [201]], ["s", 312, "comesFrom", ["s"], [295]], ["s", 269, "comesFrom", ["s"], [255]], ["a", 314, "comesFrom", ["a"], [302]], ["a", 271, "comesFrom", ["a"], [258]], ["b", 316, "comesFrom", ["b"], [306]], ["b", 279, "comesFrom", ["b"], [261]], ["c", 16, "comesFrom", ["c"], [11]], ["c", 22, "comesFrom", ["c"], [11]], ["c", 32, "comesFrom", ["c"], [11]], ["c", 43, "comesFrom", ["c"], [11]], ["str", 67, "comesFrom", ["str"], [58]], ["str", 104, "comesFrom", ["str"], [58]], ["str", 128, "comesFrom", ["str"], [58]], ["len", 88, "comesFrom", ["len"], [65]], ["base", 229, "comesFrom", ["base"], [198]], ["base", 110, "comesFrom", ["base"], [61]], ["base", 140, "comesFrom", ["base"], [61]], ["base", 224, "comesFrom", ["base"], [198]], ["power", 134, "comesFrom", ["power"], [74]], ["power", 138, "comesFrom", ["power"], [136]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int N ) { if ( N == 1 N == 0 ) return 1 ; return N * fact ( N - 1 ) ; } void prefixFactorialArray ( int arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = fact ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; prefixFactorialArray ( arr , N ) ; return 0 ; }", "docstring": "Prefix Factorials of a Prefix Sum Array | C ++ program for the above approach ; Function to find the factorial of a number N ; Base Case ; Find the factorial recursively ; Function to find the prefix factorial array ; Find the prefix sum array ; Find the factorials of each array element ; Print the resultant array ; Driver Code", "dfg": [["N", 27, "comesFrom", ["N"], [11]], ["N", 56, "comesFrom", ["N"], [44]], ["N", 84, "comesFrom", ["N"], [44]], ["N", 113, "comesFrom", ["N"], [44]], ["N", 172, "comesFrom", ["N"], [153]], ["N", 16, "comesFrom", ["N"], [11]], ["N", 19, "comesFrom", ["N"], [11]], ["N", 31, "comesFrom", ["N"], [11]], ["i", 54, "comesFrom", ["i"], [50]], ["i", 58, "comesFrom", ["i"], [50]], ["i", 82, "comesFrom", ["i"], [78]], ["i", 86, "comesFrom", ["i"], [78]], ["i", 111, "comesFrom", ["i"], [107]], ["i", 115, "comesFrom", ["i"], [107]], ["i", 64, "comesFrom", ["i"], [50]], ["i", 92, "comesFrom", ["i"], [78]], ["i", 69, "comesFrom", ["i"], [50]], ["i", 123, "comesFrom", ["i"], [107]], ["i", 99, "comesFrom", ["i"], [78]], ["arr", 138, "comesFrom", ["arr"], [41]], ["arr", 170, "comesFrom", ["arr"], [41]], ["arr", 62, "comesFrom", ["arr"], [41]], ["arr", 67, "comesFrom", ["arr"], [41]], ["arr", 90, "comesFrom", ["arr"], [41]], ["arr", 157, "comesFrom", ["arr"], [41]], ["arr", 121, "comesFrom", ["arr"], [41]], ["arr", 162, "comesFrom", ["arr"], [41]], ["arr", 97, "comesFrom", ["arr"], [41]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; } int main ( ) { int N = 3 ; cout << findAverage ( N ) ; return 0 ; }", "docstring": "Mean of fourth powers of first N natural numbers | C ++ program for the above approach ; Function to find the average of the fourth power of first N natural numbers ; Store the resultant average calculated using formula ; Return the average ; Driver Code", "dfg": [["avg", 54, "comesFrom", ["avg"], [15]], ["N", 71, "comesFrom", ["N"], [63]], ["N", 45, "comesFrom", ["N"], [11]], ["N", 27, "comesFrom", ["N"], [11]], ["N", 37, "comesFrom", ["N"], [11]], ["N", 43, "comesFrom", ["N"], [11]], ["N", 25, "comesFrom", ["N"], [11]], ["N", 35, "comesFrom", ["N"], [11]], ["N", 23, "comesFrom", ["N"], [11]], ["N", 33, "comesFrom", ["N"], [11]], ["N", 21, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > removeEveryKth ( vector < int > l , int k ) { for ( int i = 0 ; i < l . size ( ) ; i ++ ) { if ( i % k == 0 ) l [ i ] = 0 ; } vector < int > arr ; arr . push_back ( 0 ) ; for ( int i = 1 ; i < l . size ( ) ; i ++ ) { if ( l [ i ] != 0 ) arr . push_back ( l [ i ] ) ; } return arr ; } void printArray ( vector < int > l ) { for ( int i = 1 ; i < l . size ( ) ; i ++ ) cout << l [ i ] << \" ▁ \" ; cout << endl ; } void printSequence ( int n , int k ) { vector < int > l ( n + 1 ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) l [ i ] = i ; int x = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int p = l [ x ] + l [ x + 1 ] ; l = removeEveryKth ( l , p ) ; x += 1 ; } printArray ( l ) ; } int main ( ) { int N = 8 ; int K = 2 ; printSequence ( N , K ) ; }", "docstring": "Modify array by removing ( arr [ i ] + arr [ i + 1 ] ) th element exactly K times | C ++ program for the above approach ; Function to modify array by removing every K - th element from the array ; Check if current element is the k - th element ; Stores the elements after removing every kth element ; Append the current element if it is not k - th element ; Return the new array after removing every k - th element ; Function to print the array ; Traverse the array l [ ] ; Function to print the array after performing the given operations exactly k times ; Store first N natural numbers ; Iterate over the range [ 0 , k - 1 ] ; Store sums of the two consecutive terms ; Remove every p - th element from the array ; Increment x by 1 for the next iteration ; Print the resultant array ; Driver Code ; Given arrays ; Function Call", "dfg": [["arr", 111, "comesFrom", ["arr"], [62]], ["arr", 64, "comesFrom", ["arr"], [62]], ["arr", 99, "comesFrom", ["arr"], [62]], ["i", 30, "comesFrom", ["i"], [26]], ["i", 38, "comesFrom", ["i"], [26]], ["i", 78, "comesFrom", ["i"], [74]], ["i", 86, "comesFrom", ["i"], [74]], ["i", 131, "comesFrom", ["i"], [127]], ["i", 139, "comesFrom", ["i"], [127]], ["i", 186, "comesFrom", ["i"], [182]], ["i", 192, "comesFrom", ["i"], [182]], ["i", 214, "comesFrom", ["i"], [210]], ["i", 218, "comesFrom", ["i"], [210]], ["i", 200, "comesFrom", ["i"], [182]], ["i", 197, "comesFrom", ["i"], [182]], ["i", 44, "comesFrom", ["i"], [26]], ["i", 146, "comesFrom", ["i"], [127]], ["i", 52, "comesFrom", ["i"], [26]], ["i", 94, "comesFrom", ["i"], [74]], ["i", 105, "comesFrom", ["i"], [74]], ["k", 216, "comesFrom", ["k"], [165]], ["k", 46, "comesFrom", ["k"], [20]], ["n", 188, "comesFrom", ["n"], [162]], ["n", 174, "comesFrom", ["n"], [162]], ["l", 253, "comesFrom", ["l"], [237]], ["l", 32, "comesFrom", ["l"], [17]], ["l", 80, "comesFrom", ["l"], [17]], ["l", 133, "comesFrom", ["l"], [121]], ["l", 195, "comesFrom", ["l"], [172]], ["l", 144, "comesFrom", ["l"], [121]], ["l", 50, "comesFrom", ["l"], [17]], ["l", 92, "comesFrom", ["l"], [17]], ["l", 225, "comesFrom", ["l"], [172]], ["l", 230, "comesFrom", ["l"], [172]], ["l", 241, "comesFrom", ["l"], [237]], ["l", 103, "comesFrom", ["l"], [17]], ["N", 274, "comesFrom", ["N"], [263]], ["K", 276, "comesFrom", ["K"], [268]], ["p", 243, "comesFrom", ["p"], [223]], ["x", 227, "comesFrom", ["x"], [203]], ["x", 232, "comesFrom", ["x"], [203]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int makeEqual ( int * arr , int n ) { int fre0 [ 33 ] = { 0 } ; int fre1 [ 33 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; for ( int j = 0 ; j < 33 ; j ++ ) { if ( x & 1 ) { fre1 [ j ] += 1 ; } else { fre0 [ j ] += 1 ; } x = x >> 1 ; } } int ans = 0 ; for ( int i = 0 ; i < 33 ; i ++ ) { ans += min ( fre0 [ i ] , fre1 [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << makeEqual ( arr , N ) ; return 0 ; }", "docstring": "Minimum number of bits of array elements required to be flipped to make all array elements equal | C ++ program for the above approach ; Function to count minimum number of bits required to be flipped to make all array elements equal ; Stores the count of unset bits ; Stores the count of set bits ; Traverse the array ; Traverse the bit of arr [ i ] ; If current bit is set ; Increment fre1 [ j ] ; Otherwise ; Increment fre0 [ j ] ; Right shift x by 1 ; Stores the count of total moves ; Traverse the range [ 0 , 32 ] ; Update the value of ans ; Return the minimum number of flips required ; Driver Code", "dfg": [["ans", 146, "comesFrom", ["ans"], [129]], ["i", 45, "comesFrom", ["i"], [41]], ["i", 49, "comesFrom", ["i"], [41]], ["i", 121, "comesFrom", ["i"], [117]], ["i", 125, "comesFrom", ["i"], [117]], ["i", 58, "comesFrom", ["i"], [41]], ["i", 135, "comesFrom", ["i"], [117]], ["i", 140, "comesFrom", ["i"], [117]], ["n", 47, "comesFrom", ["n"], [15]], ["j", 68, "comesFrom", ["j"], [64]], ["j", 72, "comesFrom", ["j"], [64]], ["j", 85, "comesFrom", ["j"], [64]], ["j", 95, "comesFrom", ["j"], [64]], ["N", 187, "comesFrom", ["N"], [166]], ["x", 78, "comesFrom", ["x"], [54]], ["x", 103, "comesFrom", ["x"], [101]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int arr [ ] , int N , int K ) { int sum = 0 ; vector < long long > v ; for ( int i = 0 ; i < N ; i ++ ) { v . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] % K == 0 ) { long long x = v [ i ] / K ; for ( int j = 0 ; j < K ; j ++ ) { v . push_back ( x ) ; } } else break ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) sum = sum + v [ i ] ; return sum ; } int main ( ) { int arr [ ] = { 4 , 6 , 8 , 2 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sum ( arr , N , K ) ; return 0 ; }", "docstring": "Sum of array elements possible by appending arr [ i ] / K to the end of the array K times for array elements divisible by K | C ++ program for the above approach ; Function to calculate sum of array elements after adding arr [ i ] / K to the end of the array if arr [ i ] is divisible by K ; Stores the sum of the array ; Traverse the array arr [ ] ; Traverse the vector ; If v [ i ] is divisible by K ; Iterate over the range [ 0 , K ] ; Update v ; Otherwise ; Traverse the vector v ; Return the sum of the updated array ; Driver Code", "dfg": [["sum", 158, "comesFrom", ["sum"], [148]], ["sum", 204, "comesFrom", ["sum"], [148]], ["sum", 150, "comesFrom", ["sum"], [148]], ["i", 41, "comesFrom", ["i"], [37]], ["i", 45, "comesFrom", ["i"], [37]], ["i", 67, "comesFrom", ["i"], [63]], ["i", 75, "comesFrom", ["i"], [63]], ["i", 137, "comesFrom", ["i"], [133]], ["i", 145, "comesFrom", ["i"], [133]], ["i", 154, "comesFrom", ["i"], [133]], ["i", 55, "comesFrom", ["i"], [37]], ["i", 83, "comesFrom", ["i"], [63]], ["i", 97, "comesFrom", ["i"], [63]], ["N", 43, "comesFrom", ["N"], [16]], ["N", 208, "comesFrom", ["N"], [187]], ["v", 69, "comesFrom", ["v"], [32]], ["v", 139, "comesFrom", ["v"], [32]], ["v", 49, "comesFrom", ["v"], [32]], ["v", 152, "comesFrom", ["v"], [32]], ["v", 81, "comesFrom", ["v"], [32]], ["v", 95, "comesFrom", ["v"], [32]], ["v", 117, "comesFrom", ["v"], [32]], ["K", 210, "comesFrom", ["K"], [182]], ["K", 86, "comesFrom", ["K"], [19]], ["K", 111, "comesFrom", ["K"], [19]], ["K", 100, "comesFrom", ["K"], [19]], ["j", 109, "comesFrom", ["j"], [105]], ["j", 113, "comesFrom", ["j"], [105]], ["x", 121, "comesFrom", ["x"], [93]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int arr [ ] = { 1 , -1 , 3 , -2 , -1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; check ( arr , N ) ; return 0 ; }", "docstring": "Check if sum of arr [ i ] / j for all possible pairs ( i , j ) in an array is 0 or not | C ++ program for the above approach ; Function to check if sum of all values of ( arr [ i ] / j ) for all 0 < i <= j < ( N - 1 ) is 0 or not ; Stores the required sum ; Traverse the array ; If the sum is equal to 0 ; Otherwise ; Driver Code", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 42, "comesFrom", ["i"], [27]], ["N", 33, "comesFrom", ["N"], [16]], ["N", 107, "comesFrom", ["N"], [88]], ["sum", 47, "comesFrom", ["sum"], [38]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void expectedValue ( int P , int a , int b , int N ) { double expValue = P + ( N * 0.5 * ( a + b ) ) ; cout << expValue ; } int main ( ) { int P = 3000 , a = 20 , b = 10 , N = 30 ; expectedValue ( P , a , b , N ) ; return 0 ; }", "docstring": "Program to calculate expected increase in price P after N consecutive days | C ++ program for the above approach ; Function to find the increased value of P after N days ; Expected value of the number P after N days ; Print the expected value ; Driver Code", "dfg": [["expValue", 42, "comesFrom", ["expValue"], [24]], ["P", 26, "comesFrom", ["P"], [11]], ["P", 69, "comesFrom", ["P"], [51]], ["a", 71, "comesFrom", ["a"], [55]], ["a", 34, "comesFrom", ["a"], [14]], ["b", 73, "comesFrom", ["b"], [59]], ["b", 36, "comesFrom", ["b"], [17]], ["N", 75, "comesFrom", ["N"], [63]], ["N", 29, "comesFrom", ["N"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int startingPoint ( int A [ ] , int N ) { int sum = 0 ; int in = 0 ; int min = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( sum < min ) { min = sum ; in = i + 1 ; } } if ( sum < 0 ) { return -1 ; } return in % N ; } int main ( ) { int arr [ ] = { 3 , -6 , 7 , -4 , -4 , 6 , -1 } ; int N = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; cout << startingPoint ( arr , N ) ; return 0 ; }", "docstring": "Find the index in a circular array from which prefix sum is always non | C ++ program for the above approach ; Function to find the starting index of the given circular array s . t . prefix sum array is non negative ; Stores the sum of the array ; Stores the starting index ; Stores the minimum prefix sum of A [ 0. . i ] ; Traverse the array arr [ ] ; Update the value of sum ; If sum is less than min ; Update the min as the value of prefix sum ; Update in ; Otherwise , no such index is possible ; Driver Code", "dfg": [["i", 41, "comesFrom", ["i"], [37]], ["i", 45, "comesFrom", ["i"], [37]], ["i", 53, "comesFrom", ["i"], [37]], ["i", 69, "comesFrom", ["i"], [37]], ["N", 43, "comesFrom", ["N"], [16]], ["N", 89, "comesFrom", ["N"], [16]], ["N", 142, "comesFrom", ["N"], [119]], ["in", 87, "comesFrom", ["in"], [67]], ["sum", 77, "comesFrom", ["sum"], [49]], ["sum", 58, "comesFrom", ["sum"], [49]], ["sum", 65, "comesFrom", ["sum"], [49]], ["min", 60, "comesFrom", ["min"], [30]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; struct node { int data ; node * next ; } ; node * EvalNearestMult ( node * N , int K ) { node * temp = N ; int t ; while ( N != NULL ) { if ( N -> data < K ) N -> data = 0 ; else { if ( N -> data == K ) N -> data = K ; else { N -> data = ( N -> data / K ) * K ; } } N = N -> next ; } return temp ; } void printList ( node * N ) { while ( N != NULL ) { cout << N -> data << \" ▁ \" ; N = N -> next ; } } int main ( ) { node * head = NULL ; node * second = NULL ; node * third = NULL ; head = new node ( ) ; second = new node ( ) ; third = new node ( ) ; head -> data = 3 ; head -> next = second ; second -> data = 4 ; second -> next = third ; third -> data = 8 ; third -> next = NULL ; node * t = EvalNearestMult ( head , 3 ) ; printList ( t ) ; return 0 ; }", "docstring": "Modify Linked List by replacing each node by nearest multiple of K | C ++ program for the above approach ; Structure of node ; Function to replace the node N by the nearest multiple of K ; Traverse the Linked List ; If data is less than K ; If the data of current node is same as K ; Otherwise change the value ; Move to the next node ; Return the updated LL ; Function to print the nodes of the Linked List ; Traverse the LL ; Print the node 's data ; Driver Code ; Given Linked List", "dfg": [["second", 193, "comesFrom", ["second"], [169]], ["second", 195, "comesFrom", ["second"], [169]], ["second", 201, "comesFrom", ["second"], [169]], ["third", 205, "comesFrom", ["third"], [176]], ["third", 207, "comesFrom", ["third"], [176]], ["third", 213, "comesFrom", ["third"], [176]], ["N", 42, "comesFrom", ["N"], [35]], ["N", 111, "comesFrom", ["N"], [95]], ["N", 116, "comesFrom", ["N"], [95]], ["N", 97, "comesFrom", ["N"], [95]], ["N", 133, "comesFrom", ["N"], [131]], ["N", 49, "comesFrom", ["N"], [35]], ["N", 55, "comesFrom", ["N"], [35]], ["N", 123, "comesFrom", ["N"], [95]], ["N", 65, "comesFrom", ["N"], [35]], ["N", 71, "comesFrom", ["N"], [35]], ["N", 79, "comesFrom", ["N"], [35]], ["N", 84, "comesFrom", ["N"], [35]], ["head", 183, "comesFrom", ["head"], [162]], ["head", 189, "comesFrom", ["head"], [162]], ["head", 225, "comesFrom", ["head"], [162]], ["t", 221, "comesFrom", ["t"], [38]], ["t", 232, "comesFrom", ["t"], [38]], ["K", 53, "comesFrom", ["K"], [28]], ["K", 69, "comesFrom", ["K"], [28]], ["K", 75, "comesFrom", ["K"], [28]], ["K", 91, "comesFrom", ["K"], [28]], ["K", 88, "comesFrom", ["K"], [28]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearestPow ( int x , int y ) { if ( y == 1 ) return 1 ; int k = log10 ( x ) / log10 ( y ) ; if ( abs ( pow ( y , k ) - x ) < abs ( pow ( y , ( k + 1 ) ) - x ) ) return pow ( y , k ) ; return pow ( y , ( k + 1 ) ) ; } void replacebyNearestPower ( vector < int > arr ) { int prev = arr [ arr . size ( ) - 1 ] ; int lastNext = arr [ 0 ] ; int next = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int temp = arr [ i ] ; if ( i == arr . size ( ) - 1 ) next = lastNext ; else next = arr [ ( i + 1 ) % arr . size ( ) ] ; int prevPow = nearestPow ( arr [ i ] , prev ) ; int nextPow = nearestPow ( arr [ i ] , next ) ; if ( abs ( arr [ i ] - prevPow ) < abs ( arr [ i ] - nextPow ) ) arr [ i ] = prevPow ; else arr [ i ] = nextPow ; prev = temp ; } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { vector < int > arr { 2 , 3 , 4 , 1 , 2 } ; replacebyNearestPower ( arr ) ; }", "docstring": "Modify array by replacing elements with the nearest power of its previous or next element | C ++ program for the above approach ; Function to calculate the power of y which is nearest to x ; Base Case ; Stores the logarithmic value of x with base y ; Function to replace each array element by the nearest power of its previous or next element ; Stores the previous and next element ; Traverse the array ; Calculate nearest power for previous and next elements ; Replacing the array values ; Print the updated array ; Driver Code ; Given array", "dfg": [["i", 134, "comesFrom", ["i"], [130]], ["i", 142, "comesFrom", ["i"], [130]], ["i", 263, "comesFrom", ["i"], [259]], ["i", 271, "comesFrom", ["i"], [259]], ["i", 156, "comesFrom", ["i"], [130]], ["i", 151, "comesFrom", ["i"], [130]], ["i", 278, "comesFrom", ["i"], [259]], ["i", 238, "comesFrom", ["i"], [130]], ["i", 195, "comesFrom", ["i"], [130]], ["i", 208, "comesFrom", ["i"], [130]], ["i", 246, "comesFrom", ["i"], [130]], ["i", 220, "comesFrom", ["i"], [130]], ["i", 230, "comesFrom", ["i"], [130]], ["i", 176, "comesFrom", ["i"], [130]], ["y", 19, "comesFrom", ["y"], [14]], ["y", 80, "comesFrom", ["y"], [14]], ["y", 72, "comesFrom", ["y"], [14]], ["y", 36, "comesFrom", ["y"], [14]], ["y", 45, "comesFrom", ["y"], [14]], ["y", 57, "comesFrom", ["y"], [14]], ["arr", 103, "comesFrom", ["arr"], [97]], ["arr", 117, "comesFrom", ["arr"], [97]], ["arr", 310, "comesFrom", ["arr"], [295]], ["arr", 136, "comesFrom", ["arr"], [97]], ["arr", 265, "comesFrom", ["arr"], [97]], ["arr", 149, "comesFrom", ["arr"], [97]], ["arr", 276, "comesFrom", ["arr"], [97]], ["arr", 236, "comesFrom", ["arr"], [97]], ["arr", 105, "comesFrom", ["arr"], [97]], ["arr", 173, "comesFrom", ["arr"], [97]], ["arr", 193, "comesFrom", ["arr"], [97]], ["arr", 206, "comesFrom", ["arr"], [97]], ["arr", 244, "comesFrom", ["arr"], [97]], ["arr", 158, "comesFrom", ["arr"], [97]], ["arr", 218, "comesFrom", ["arr"], [97]], ["arr", 228, "comesFrom", ["arr"], [97]], ["arr", 181, "comesFrom", ["arr"], [97]], ["k", 74, "comesFrom", ["k"], [27]], ["k", 83, "comesFrom", ["k"], [27]], ["k", 47, "comesFrom", ["k"], [27]], ["k", 60, "comesFrom", ["k"], [27]], ["temp", 253, "comesFrom", ["temp"], [147]], ["x", 31, "comesFrom", ["x"], [11]], ["x", 50, "comesFrom", ["x"], [11]], ["x", 66, "comesFrom", ["x"], [11]], ["lastNext", 168, "comesFrom", ["lastNext"], [115]], ["prevPow", 241, "comesFrom", ["prevPow"], [189]], ["prevPow", 223, "comesFrom", ["prevPow"], [189]], ["prev", 198, "comesFrom", ["prev"], [101]], ["next", 211, "comesFrom", ["next"], [171]], ["nextPow", 249, "comesFrom", ["nextPow"], [202]], ["nextPow", 233, "comesFrom", ["nextPow"], [202]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool makeSumX ( int arr [ ] , int X , int S , int i , int N ) { if ( i == N ) { return S == X ; } string a = to_string ( arr [ i ] ) ; int l = stoi ( a . substr ( 0 , a . length ( ) - 1 ) ) ; int r = stoi ( a . substr ( 1 ) ) ; bool x = makeSumX ( arr , X , S + l , i + 1 , N ) ; bool y = makeSumX ( arr , X , S + r , i + 1 , N ) ; return ( x y ) ; } void Check ( int arr [ ] , int X , int N ) { if ( makeSumX ( arr , X , 0 , 0 , N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int arr [ ] = { 545 , 433 , 654 , 23 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 134 ; Check ( arr , X , N ) ; return 0 ; }", "docstring": "Check if sum of array can be made equal to X by removing either the first or last digits of every array element | C ++ program for the above approach ; Utility Function to check if the sum of the array elements can be made equal to X by removing either the first or last digits of every array element ; Base Case ; Convert arr [ i ] to string ; Remove last digit ; Remove first digit ; Recursive function call ; Function to check if sum of given array can be made equal to X or not ; Driver code ; Function Call", "dfg": [["x", 128, "comesFrom", ["x"], [87]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 99, "comesFrom", ["i"], [22]], ["i", 119, "comesFrom", ["i"], [22]], ["i", 48, "comesFrom", ["i"], [22]], ["N", 32, "comesFrom", ["N"], [25]], ["N", 228, "comesFrom", ["N"], [202]], ["N", 103, "comesFrom", ["N"], [25]], ["N", 123, "comesFrom", ["N"], [25]], ["N", 160, "comesFrom", ["N"], [145]], ["y", 129, "comesFrom", ["y"], [107]], ["X", 226, "comesFrom", ["X"], [218]], ["X", 38, "comesFrom", ["X"], [16]], ["X", 93, "comesFrom", ["X"], [16]], ["X", 113, "comesFrom", ["X"], [16]], ["X", 154, "comesFrom", ["X"], [142]], ["S", 36, "comesFrom", ["S"], [19]], ["S", 95, "comesFrom", ["S"], [19]], ["S", 115, "comesFrom", ["S"], [19]], ["l", 97, "comesFrom", ["l"], [53]], ["r", 117, "comesFrom", ["r"], [74]], ["a", 57, "comesFrom", ["a"], [42]], ["a", 78, "comesFrom", ["a"], [42]], ["a", 63, "comesFrom", ["a"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( int m , int y ) { int res1 = log ( y ) / log ( m ) ; double res2 = log ( y ) / log ( m ) ; return ( res1 == res2 ) ; } int numSub ( int arr [ ] , int n , int m ) { int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPower ( m , arr [ i ] ) ) { cnt ++ ; ans += ( cnt * ( cnt - 1 ) ) / 2 ; } else { cnt = 0 ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 3 } ; int m = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << numSub ( arr , n , m ) ; return 0 ; }", "docstring": "Count subarrays having product equal to the power of a given Prime Number | C ++ program for the above approach ; Function to check if y is a power of m or not ; Calculate log y base m and store it in a variable with integer datatype ; Calculate log y base m and store it in a variable with double datatype ; If res1 and res2 are equal , return True . Otherwise , return false ; Function to count the number of subarrays having product of elements equal to a power of m , where m is a prime number ; Stores the count of subarrays required ; Stores current sequence of consecutive array elements which are a multiple of m ; Traverse the array ; If arr [ i ] is a power of M ; Increment cnt ; Update ans ; Update cnt ; Return the count of subarrays ; Driver Code ; Input", "dfg": [["ans", 131, "comesFrom", ["ans"], [107]], ["i", 83, "comesFrom", ["i"], [79]], ["i", 87, "comesFrom", ["i"], [79]], ["i", 99, "comesFrom", ["i"], [79]], ["n", 85, "comesFrom", ["n"], [60]], ["n", 181, "comesFrom", ["n"], [160]], ["res1", 45, "comesFrom", ["res1"], [18]], ["res2", 47, "comesFrom", ["res2"], [31]], ["m", 183, "comesFrom", ["m"], [155]], ["m", 27, "comesFrom", ["m"], [11]], ["m", 40, "comesFrom", ["m"], [11]], ["m", 95, "comesFrom", ["m"], [63]], ["y", 22, "comesFrom", ["y"], [14]], ["y", 35, "comesFrom", ["y"], [14]], ["cnt", 104, "comesFrom", ["cnt"], [72]], ["cnt", 110, "comesFrom", ["cnt"], [72]], ["cnt", 113, "comesFrom", ["cnt"], [72]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntPairs ( int arr [ ] , int N ) { int res = 0 ; int bit [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int pos = log2 ( arr [ i ] ) ; bit [ pos ] ++ ; } for ( int i = 0 ; i < 32 ; i ++ ) { res += ( bit [ i ] * ( bit [ i ] - 1 ) ) / 2 ; } return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntPairs ( arr , N ) ; }", "docstring": "Count pairs whose Bitwise AND exceeds Bitwise XOR from a given array | C ++ program to implement the above approach ; Function to count pairs that satisfy the above condition ; Stores the count of pairs ; Stores the count of array elements having same positions of MSB ; Traverse the array ; Stores the index of MSB of array elements ; Calculate number of pairs ; Driver Code ; Given Input ; Function call to count pairs satisfying the given condition", "dfg": [["res", 104, "comesFrom", ["res"], [82]], ["i", 41, "comesFrom", ["i"], [37]], ["i", 45, "comesFrom", ["i"], [37]], ["i", 74, "comesFrom", ["i"], [70]], ["i", 78, "comesFrom", ["i"], [70]], ["i", 56, "comesFrom", ["i"], [37]], ["i", 87, "comesFrom", ["i"], [70]], ["i", 93, "comesFrom", ["i"], [70]], ["N", 43, "comesFrom", ["N"], [16]], ["N", 149, "comesFrom", ["N"], [128]], ["pos", 62, "comesFrom", ["pos"], [50]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumMEX ( int arr [ ] , int N , int K ) { set < int > s ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s . insert ( i ) ; for ( int i = 0 ; i < K ; i ++ ) s . erase ( arr [ i ] ) ; int mex = * ( s . begin ( ) ) ; for ( int i = K ; i < N ; i ++ ) { s . erase ( arr [ i ] ) ; s . insert ( arr [ i - K ] ) ; int firstElem = * ( s . begin ( ) ) ; mex = min ( mex , firstElem ) ; } cout << mex << ' ▁ ' ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumMEX ( arr , N , K ) ; return 0 ; }", "docstring": "Minimum MEX from all subarrays of length K | C ++ program for the above approach ; Function to return minimum MEX from all K - length subarrays ; Stores element from [ 1 , N + 1 ] which are not present in subarray ; Store number 1 to N + 1 in set s ; Find the MEX of K - length subarray starting from index 0 ; Find the MEX of all subarrays of length K by erasing arr [ i ] and inserting arr [ i - K ] ; Store first element of set ; Updating the mex ; Print minimum MEX of all K length subarray ; Driver Code", "dfg": [["i", 35, "comesFrom", ["i"], [31]], ["i", 41, "comesFrom", ["i"], [31]], ["i", 58, "comesFrom", ["i"], [54]], ["i", 62, "comesFrom", ["i"], [54]], ["i", 94, "comesFrom", ["i"], [90]], ["i", 98, "comesFrom", ["i"], [90]], ["i", 48, "comesFrom", ["i"], [31]], ["i", 71, "comesFrom", ["i"], [54]], ["i", 108, "comesFrom", ["i"], [90]], ["i", 118, "comesFrom", ["i"], [90]], ["K", 60, "comesFrom", ["K"], [19]], ["K", 208, "comesFrom", ["K"], [182]], ["K", 120, "comesFrom", ["K"], [92]], ["N", 96, "comesFrom", ["N"], [16]], ["N", 37, "comesFrom", ["N"], [16]], ["N", 206, "comesFrom", ["N"], [187]], ["mex", 148, "comesFrom", ["mex"], [136]], ["mex", 140, "comesFrom", ["mex"], [136]], ["s", 44, "comesFrom", ["s"], [26]], ["s", 65, "comesFrom", ["s"], [26]], ["s", 102, "comesFrom", ["s"], [26]], ["s", 112, "comesFrom", ["s"], [26]], ["s", 80, "comesFrom", ["s"], [26]], ["s", 129, "comesFrom", ["s"], [26]], ["firstElem", 142, "comesFrom", ["firstElem"], [125]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallerNumbers ( int arr [ ] , int N ) { int hash [ 100000 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) hash [ arr [ i ] ] ++ ; int sum = 0 ; for ( int i = 1 ; i < 100000 ; i ++ ) { hash [ i ] += hash [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { cout << \"0\" ; continue ; } cout << hash [ arr [ i ] - 1 ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 3 , 4 , 1 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; smallerNumbers ( arr , N ) ; return 0 ; }", "docstring": "Count smaller elements present in the array for each array element | C ++ program for the above approach ; Function to count for each array element , the number of elements that are smaller than that element ; Stores the frequencies of array elements ; Traverse the array ; Update frequency of arr [ i ] ; Initialize sum with 0 ; Compute prefix sum of the array hash [ ] ; Traverse the array arr [ ] ; If current element is 0 ; Print the resultant count ; Driver Code", "dfg": [["i", 36, "comesFrom", ["i"], [32]], ["i", 40, "comesFrom", ["i"], [32]], ["i", 64, "comesFrom", ["i"], [60]], ["i", 68, "comesFrom", ["i"], [60]], ["i", 92, "comesFrom", ["i"], [88]], ["i", 96, "comesFrom", ["i"], [88]], ["i", 74, "comesFrom", ["i"], [60]], ["i", 47, "comesFrom", ["i"], [32]], ["i", 79, "comesFrom", ["i"], [60]], ["i", 104, "comesFrom", ["i"], [88]], ["i", 125, "comesFrom", ["i"], [88]], ["N", 38, "comesFrom", ["N"], [16]], ["N", 94, "comesFrom", ["N"], [16]], ["N", 179, "comesFrom", ["N"], [160]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int truncMod ( int a , int n ) { int q = a / n ; return a - n * q ; } int main ( ) { int a , b ; a = 9 ; b = 4 ; cout << a << \" ▁ % ▁ \" << b << \" ▁ = ▁ \" << truncMod ( a , b ) << endl ; a = -9 ; b = 4 ; cout << a << \" ▁ % ▁ \" << b << \" ▁ = ▁ \" << truncMod ( a , b ) << endl ; a = 9 ; b = -4 ; cout << a << \" ▁ % ▁ \" << b << \" ▁ = ▁ \" << truncMod ( a , b ) << endl ; a = -9 ; b = -4 ; cout << a << \" ▁ % ▁ \" << b << \" ▁ = ▁ \" << truncMod ( a , b ) << endl ; }", "docstring": "Modulo Operations in Programming With Negative Results | C ++ 14 program to illustrate modulo operations using the above equation ; Function to calculate and return the remainder of a % n ; ( a / n ) implicitly gives the truncated result ; Driver Code ; Modulo of two positive numbers ; Modulo of a negative number by a positive number ; Modulo of a positive number by a negative number ; Modulo of two negative numbers", "dfg": [["a", 25, "comesFrom", ["a"], [11]], ["a", 20, "comesFrom", ["a"], [11]], ["a", 66, "comesFrom", ["a"], [42]], ["a", 97, "comesFrom", ["a"], [73]], ["a", 128, "comesFrom", ["a"], [104]], ["a", 159, "comesFrom", ["a"], [135]], ["a", 52, "comesFrom", ["a"], [42]], ["a", 83, "comesFrom", ["a"], [73]], ["a", 114, "comesFrom", ["a"], [104]], ["a", 145, "comesFrom", ["a"], [135]], ["n", 22, "comesFrom", ["n"], [14]], ["n", 27, "comesFrom", ["n"], [14]], ["q", 29, "comesFrom", ["q"], [18]], ["b", 58, "comesFrom", ["b"], [46]], ["b", 68, "comesFrom", ["b"], [46]], ["b", 89, "comesFrom", ["b"], [77]], ["b", 99, "comesFrom", ["b"], [77]], ["b", 120, "comesFrom", ["b"], [108]], ["b", 130, "comesFrom", ["b"], [108]], ["b", 151, "comesFrom", ["b"], [139]], ["b", 161, "comesFrom", ["b"], [139]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double average ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; return ( double ) sum / N ; } double mean ( int arr [ ] , int N ) { double avg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { avg += ( arr [ i ] - avg ) / ( i + 1 ) ; } return avg ; } int main ( ) { int arr [ ] = { INT_MAX , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Average ▁ by ▁ Standard ▁ method : ▁ \" << fixed << setprecision ( 10 ) << average ( arr , N ) << endl ; cout << \" Average ▁ by ▁ Efficient ▁ method : ▁ \" << fixed << setprecision ( 10 ) << mean ( arr , N ) << endl ; return 0 ; }", "docstring": "Program for average of an array without running into overflow | C ++ program for the above approach ; Function to calculate average of an array using standard method ; Stores the sum of array ; Find the sum of the array ; Return the average ; Function to calculate average of an array using efficient method ; Store the average of the array ; Traverse the array arr [ ] ; Update avg ; Return avg ; Driver Code ; Input ; Function call", "dfg": [["avg", 105, "comesFrom", ["avg"], [86]], ["avg", 94, "comesFrom", ["avg"], [86]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 78, "comesFrom", ["i"], [74]], ["i", 82, "comesFrom", ["i"], [74]], ["i", 42, "comesFrom", ["i"], [27]], ["i", 98, "comesFrom", ["i"], [74]], ["i", 91, "comesFrom", ["i"], [74]], ["N", 33, "comesFrom", ["N"], [16]], ["N", 51, "comesFrom", ["N"], [16]], ["N", 80, "comesFrom", ["N"], [63]], ["N", 159, "comesFrom", ["N"], [127]], ["N", 181, "comesFrom", ["N"], [127]], ["sum", 49, "comesFrom", ["sum"], [38]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int arr [ ] , int N ) { int count = 0 ; unordered_map < double , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { double val = 1.0 * arr [ i ] ; double idx = 1.0 * ( i + 1 ) ; count += mp [ val / idx ] ; mp [ val / idx ] ++ ; } cout << count ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 6 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , N ) ; return 0 ; }", "docstring": "Count number of pairs ( i , j ) from an array such that arr [ i ] * j = arr [ j ] * i | C ++ program for the above approach ; Function to count pairs from an array satisfying given conditions ; Stores the total count of pairs ; Stores count of a [ i ] / i ; Traverse the array ; Updating count ; Update frequency in the Map ; Print count of pairs ; Driver Code ; Given array ; Size of the array ; Function call to count pairs satisfying given conditions", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 54, "comesFrom", ["i"], [35]], ["i", 63, "comesFrom", ["i"], [35]], ["N", 41, "comesFrom", ["N"], [16]], ["N", 133, "comesFrom", ["N"], [114]], ["count", 88, "comesFrom", ["count"], [68]], ["mp", 70, "comesFrom", ["mp"], [30]], ["mp", 77, "comesFrom", ["mp"], [30]], ["val", 72, "comesFrom", ["val"], [48]], ["val", 79, "comesFrom", ["val"], [48]], ["idx", 74, "comesFrom", ["idx"], [58]], ["idx", 81, "comesFrom", ["idx"], [58]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void add_edge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void dfs ( vector < int > & parent , vector < int > adj [ ] , int u , int par = -1 ) { parent [ u ] = par ; for ( auto child : adj [ u ] ) { if ( child != par ) dfs ( parent , adj , child , u ) ; } } void countSmallerAncestors ( vector < int > adj [ ] , int n ) { vector < int > parent ( int ( 1e5 ) , 0 ) ; dfs ( parent , adj , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { int node = i ; int cnt = 0 ; while ( parent [ node ] != -1 ) { if ( parent [ node ] < i ) cnt += 1 ; node = parent [ node ] ; } cout << cnt << \" ▁ \" ; } } int main ( ) { int N = 6 ; vector < int > adj [ int ( 1e5 ) ] ; add_edge ( adj , 1 , 5 ) ; add_edge ( adj , 1 , 4 ) ; add_edge ( adj , 4 , 6 ) ; add_edge ( adj , 5 , 3 ) ; add_edge ( adj , 5 , 2 ) ; countSmallerAncestors ( adj , N ) ; return 0 ; }", "docstring": "Count ancestors with smaller value for each node of a Binary Tree | C ++ program for the above approach ; Function to add an edge between nodes u and v ; Function to perform the DFS Traversal and store parent of each node ; Store the immediate parent ; Traverse the children of the current node ; Recursively call for function dfs for the child node ; Function to count the number of ancestors with values smaller than that of the current node ; Stores the parent of each node ; Perform the DFS Traversal ; Traverse all the nodes ; Store the number of ancestors smaller than node ; Loop until parent [ node ] != - 1 ; If the condition satisfies , increment cnt by 1 ; Print the required result for the current node ; Driver Code ; Tree Formation", "dfg": [["i", 155, "comesFrom", ["i"], [151]], ["i", 159, "comesFrom", ["i"], [151]], ["i", 190, "comesFrom", ["i"], [166]], ["n", 157, "comesFrom", ["n"], [122]], ["v", 32, "comesFrom", ["v"], [22]], ["v", 37, "comesFrom", ["v"], [22]], ["u", 42, "comesFrom", ["u"], [19]], ["u", 87, "comesFrom", ["u"], [65]], ["u", 75, "comesFrom", ["u"], [65]], ["u", 27, "comesFrom", ["u"], [19]], ["u", 105, "comesFrom", ["u"], [65]], ["parent", 141, "comesFrom", ["parent"], [129]], ["parent", 175, "comesFrom", ["parent"], [129]], ["parent", 198, "comesFrom", ["parent"], [129]], ["parent", 185, "comesFrom", ["parent"], [129]], ["N", 285, "comesFrom", ["N"], [220]], ["cnt", 206, "comesFrom", ["cnt"], [192]], ["node", 177, "comesFrom", ["node"], [164]], ["node", 200, "comesFrom", ["node"], [196]], ["node", 187, "comesFrom", ["node"], [164]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubsequences ( vector < int > A ) { int odd = 0 ; int even = 0 ; for ( int el : A ) { if ( el % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) cout << ( 0 ) ; else cout << ( 1 << ( A . size ( ) - 1 ) ) ; } int main ( ) { vector < int > A = { 1 , 3 , 4 } ; countSubsequences ( A ) ; }", "docstring": "Count subsequences having odd Bitwise XOR values from an array | C ++ program for the above approach ; Function to count the subsequences having odd bitwise XOR value ; Stores count of odd elements ; Stores count of even elements ; Traverse the array A [ ] ; If el is odd ; If count of odd elements is 0 ; Driver Code ; Given array A [ ] ; Function call to count subsequences having odd bitwise XOR value", "dfg": [["A", 32, "comesFrom", ["A"], [14]], ["A", 102, "comesFrom", ["A"], [90]], ["A", 70, "comesFrom", ["A"], [14]], ["odd", 53, "comesFrom", ["odd"], [18]], ["odd", 43, "comesFrom", ["odd"], [18]], ["even", 47, "comesFrom", ["even"], [23]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxModProdSubarr ( int arr [ ] , int n , int M ) { int ans = 0 ; int length = n ; for ( int i = 0 ; i < n ; i ++ ) { int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } cout << \" Maximum ▁ subarray ▁ product ▁ is ▁ \" << ans << endl ; cout << \" Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ product ▁ \" << \" subarray ▁ is ▁ \" << length << endl ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = 5 ; maxModProdSubarr ( arr , N , M ) ; return 0 ; }", "docstring": "Maximum subarray product modulo M | C ++ program for above approach ; Function to find maximum subarray product modulo M and minimum length of the subarray ; Stores maximum subarray product modulo M and minimum length of the subarray ; Stores the minimum length of subarray having maximum product ; Traverse the array ; Stores the product of a subarray ; Calculate Subarray whose start index is i ; Multiply product by arr [ i ] ; If product greater than ans ; Update ans ; Update length ; Print maximum subarray product mod M ; Print minimum length of subarray having maximum product ; Drivers Code", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 74, "comesFrom", ["i"], [57]], ["i", 97, "comesFrom", ["i"], [57]], ["i", 106, "comesFrom", ["i"], [57]], ["n", 41, "comesFrom", ["n"], [30]], ["n", 61, "comesFrom", ["n"], [30]], ["ans", 120, "comesFrom", ["ans"], [87]], ["ans", 84, "comesFrom", ["ans"], [23]], ["length", 134, "comesFrom", ["length"], [102]], ["length", 93, "comesFrom", ["length"], [28]], ["N", 184, "comesFrom", ["N"], [160]], ["M", 186, "comesFrom", ["M"], [176]], ["M", 78, "comesFrom", ["M"], [19]], ["j", 59, "comesFrom", ["j"], [55]], ["j", 63, "comesFrom", ["j"], [55]], ["j", 95, "comesFrom", ["j"], [55]], ["j", 104, "comesFrom", ["j"], [55]], ["product", 82, "comesFrom", ["product"], [67]], ["product", 89, "comesFrom", ["product"], [67]], ["product", 70, "comesFrom", ["product"], [67]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int coprime ( int a , int b ) { return ( __gcd ( a , b ) == 1 ) ; } int numOfPairs ( vector < string > arr , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( coprime ( stoi ( arr [ i ] ) , stoi ( arr [ j ] ) ) ) { count = count + 1 ; } } } return count ; } int noOfCoPrimePairs ( int N , int d1 , int d2 ) { vector < string > l ; l . push_back ( to_string ( d1 ) ) ; l . push_back ( to_string ( d2 ) ) ; sort ( l . begin ( ) , l . end ( ) ) ; if ( N < stoi ( l [ 1 ] ) ) return 0 ; vector < string > total = l ; vector < string > temp2 = l ; int flag = 0 ; vector < string > temp3 ; while ( l [ 0 ] . length ( ) < 10 ) { for ( int i = 0 ; i < l . size ( ) ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( stoi ( l [ i ] + temp2 [ j ] ) > N ) { flag = 1 ; break ; } total . push_back ( l [ i ] + temp2 [ j ] ) ; temp3 . push_back ( l [ i ] + temp2 [ j ] ) ; } if ( flag == 1 ) break ; } if ( flag == 1 ) break ; l = temp3 ; vector < string > temp3 ; } int lenOfTotal = total . size ( ) ; int ans = numOfPairs ( total , lenOfTotal ) ; cout << ( ans ) ; } int main ( ) { int N = 30 , d1 = 2 , d2 = 3 ; noOfCoPrimePairs ( N , d1 , d2 ) ; }", "docstring": "Number of co | C ++ program for the above approach ; Function to check whether given integers are co - prime or not ; Utility function to count number of co - prime pairs ; Traverse the array ; If co - prime ; Increment count ; Return count ; Function to count number of co - prime pairs ; Stores digits in string form ; Sort the list ; Keep two copies of list l ; Generate 2 digit numbers using d1 and d2 ; If current number does not exceed N ; Stores length of list ; Stores number of co - prime pairs ; Print number of co - prime pairs ; Driver Code ; Given value of N , d1 , d2 ; Function call to count number of co - prime pairs", "dfg": [["count", 114, "comesFrom", ["count"], [104]], ["count", 106, "comesFrom", ["count"], [104]], ["i", 55, "comesFrom", ["i"], [51]], ["i", 61, "comesFrom", ["i"], [51]], ["i", 234, "comesFrom", ["i"], [230]], ["i", 242, "comesFrom", ["i"], [230]], ["i", 70, "comesFrom", ["i"], [51]], ["i", 90, "comesFrom", ["i"], [51]], ["i", 292, "comesFrom", ["i"], [230]], ["i", 307, "comesFrom", ["i"], [230]], ["i", 267, "comesFrom", ["i"], [230]], ["N", 57, "comesFrom", ["N"], [40]], ["N", 173, "comesFrom", ["N"], [121]], ["N", 391, "comesFrom", ["N"], [377]], ["N", 76, "comesFrom", ["N"], [40]], ["N", 276, "comesFrom", ["N"], [121]], ["l", 136, "comesFrom", ["l"], [134]], ["l", 146, "comesFrom", ["l"], [134]], ["l", 158, "comesFrom", ["l"], [134]], ["l", 164, "comesFrom", ["l"], [134]], ["l", 177, "comesFrom", ["l"], [134]], ["l", 215, "comesFrom", ["l"], [200]], ["l", 236, "comesFrom", ["l"], [200]], ["l", 290, "comesFrom", ["l"], [200]], ["l", 305, "comesFrom", ["l"], [200]], ["l", 265, "comesFrom", ["l"], [200]], ["ans", 367, "comesFrom", ["ans"], [355]], ["d1", 393, "comesFrom", ["d1"], [381]], ["d1", 142, "comesFrom", ["d1"], [124]], ["d2", 395, "comesFrom", ["d2"], [385]], ["d2", 152, "comesFrom", ["d2"], [127]], ["j", 74, "comesFrom", ["j"], [68]], ["j", 78, "comesFrom", ["j"], [68]], ["j", 253, "comesFrom", ["j"], [249]], ["j", 257, "comesFrom", ["j"], [249]], ["j", 98, "comesFrom", ["j"], [68]], ["j", 297, "comesFrom", ["j"], [249]], ["j", 312, "comesFrom", ["j"], [249]], ["j", 272, "comesFrom", ["j"], [249]], ["temp3", 336, "comesFrom", ["temp3"], [211]], ["temp3", 301, "comesFrom", ["temp3"], [211]], ["total", 348, "comesFrom", ["total"], [190]], ["total", 359, "comesFrom", ["total"], [190]], ["total", 286, "comesFrom", ["total"], [190]], ["lenOfTotal", 361, "comesFrom", ["lenOfTotal"], [346]], ["a", 21, "comesFrom", ["a"], [11]], ["b", 23, "comesFrom", ["b"], [14]], ["flag", 328, "comesFrom", ["flag"], [279]], ["flag", 319, "comesFrom", ["flag"], [279]], ["arr", 88, "comesFrom", ["arr"], [37]], ["arr", 96, "comesFrom", ["arr"], [37]], ["temp2", 295, "comesFrom", ["temp2"], [198]], ["temp2", 310, "comesFrom", ["temp2"], [198]], ["temp2", 270, "comesFrom", ["temp2"], [198]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void tile_placing ( vector < vector < int > > grid , int N ) { int dp [ N + 5 ] = { 0 } ; int orig_cost = 0 ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { orig_cost += grid [ i ] [ j ] ; } } dp [ 0 ] = 0 ; dp [ 1 ] = abs ( grid [ 0 ] [ 0 ] - grid [ 1 ] [ 0 ] ) ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = max ( dp [ i - 1 ] + abs ( grid [ 0 ] [ i - 1 ] - grid [ 1 ] [ i - 1 ] ) , dp [ i - 2 ] + abs ( grid [ 0 ] [ i - 2 ] - grid [ 0 ] [ i - 1 ] ) + abs ( grid [ 1 ] [ i - 2 ] - grid [ 1 ] [ i - 1 ] ) ) ; } cout << orig_cost - dp [ N ] ; } int32_t main ( ) { vector < vector < int > > M = { { 7 , 5 , 1 , 3 } , { 8 , 6 , 0 , 2 } } ; int N = M [ 0 ] . size ( ) ; tile_placing ( M , N ) ; return 0 ; }", "docstring": "Minimize cost of placing tiles of dimensions 2 * 1 over a Matrix | C ++ program for the above approach ; Function to find the minimum cost in placing N tiles in a grid M [ ] [ ] ; Stores the minimum profit after placing i tiles ; Traverse the grid [ ] [ ] ; Update the orig_cost ; Traverse over the range [ 2 , N ] ; Place tiles horizentally or vertically ; Print the answer ; Driver Code", "dfg": [["i", 47, "comesFrom", ["i"], [43]], ["i", 51, "comesFrom", ["i"], [43]], ["i", 120, "comesFrom", ["i"], [116]], ["i", 124, "comesFrom", ["i"], [116]], ["i", 130, "comesFrom", ["i"], [116]], ["i", 74, "comesFrom", ["i"], [43]], ["i", 137, "comesFrom", ["i"], [116]], ["i", 167, "comesFrom", ["i"], [116]], ["i", 149, "comesFrom", ["i"], [116]], ["i", 159, "comesFrom", ["i"], [116]], ["i", 202, "comesFrom", ["i"], [116]], ["i", 212, "comesFrom", ["i"], [116]], ["i", 179, "comesFrom", ["i"], [116]], ["i", 189, "comesFrom", ["i"], [116]], ["N", 122, "comesFrom", ["N"], [20]], ["N", 282, "comesFrom", ["N"], [267]], ["N", 26, "comesFrom", ["N"], [20]], ["N", 64, "comesFrom", ["N"], [20]], ["N", 226, "comesFrom", ["N"], [20]], ["orig_cost", 222, "comesFrom", ["orig_cost"], [70]], ["M", 280, "comesFrom", ["M"], [242]], ["M", 269, "comesFrom", ["M"], [242]], ["j", 62, "comesFrom", ["j"], [58]], ["j", 66, "comesFrom", ["j"], [58]], ["j", 77, "comesFrom", ["j"], [58]], ["grid", 96, "comesFrom", ["grid"], [17]], ["grid", 104, "comesFrom", ["grid"], [17]], ["grid", 72, "comesFrom", ["grid"], [17]], ["grid", 144, "comesFrom", ["grid"], [17]], ["grid", 154, "comesFrom", ["grid"], [17]], ["grid", 197, "comesFrom", ["grid"], [17]], ["grid", 207, "comesFrom", ["grid"], [17]], ["grid", 174, "comesFrom", ["grid"], [17]], ["grid", 184, "comesFrom", ["grid"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSplit ( int arr [ ] , int N ) { for ( int l = 1 ; l <= N - 4 ; l ++ ) { for ( int r = l + 2 ; r <= N - 2 ; r ++ ) { int lsum = 0 , rsum = 0 , msum = 0 ; for ( int i = 0 ; i <= l - 1 ; i ++ ) { lsum += arr [ i ] ; } for ( int i = l + 1 ; i <= r - 1 ; i ++ ) { msum += arr [ i ] ; } for ( int i = r + 1 ; i < N ; i ++ ) { rsum += arr [ i ] ; } if ( lsum == rsum && rsum == msum ) { cout << l << \" ▁ \" << r << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int arr [ ] = { 2 , 5 , 12 , 7 , 19 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSplit ( arr , N ) ; return 0 ; }", "docstring": "Print indices of pair of array elements required to be removed to split array into 3 equal sum subarrays | C ++ program for the above approach ; Function to check if array can be split into three equal sum subarrays by removing two elements ; Stores sum of all three subarrays ; Sum of left subarray ; Sum of middle subarray ; Sum of right subarray ; Check if sum of subarrays are equal ; Print the possible pair ; If no pair exists , print - 1 ; Driver code ; Given array ; Size of the array", "dfg": [["l", 26, "comesFrom", ["l"], [22]], ["l", 32, "comesFrom", ["l"], [22]], ["l", 41, "comesFrom", ["l"], [22]], ["l", 77, "comesFrom", ["l"], [22]], ["l", 98, "comesFrom", ["l"], [22]], ["l", 158, "comesFrom", ["l"], [22]], ["N", 28, "comesFrom", ["N"], [16]], ["N", 226, "comesFrom", ["N"], [207]], ["N", 47, "comesFrom", ["N"], [16]], ["N", 131, "comesFrom", ["N"], [16]], ["r", 45, "comesFrom", ["r"], [39]], ["r", 51, "comesFrom", ["r"], [39]], ["r", 104, "comesFrom", ["r"], [39]], ["r", 125, "comesFrom", ["r"], [39]], ["r", 164, "comesFrom", ["r"], [39]], ["i", 75, "comesFrom", ["i"], [71]], ["i", 81, "comesFrom", ["i"], [71]], ["i", 102, "comesFrom", ["i"], [96]], ["i", 108, "comesFrom", ["i"], [96]], ["i", 129, "comesFrom", ["i"], [123]], ["i", 133, "comesFrom", ["i"], [123]], ["i", 89, "comesFrom", ["i"], [71]], ["i", 116, "comesFrom", ["i"], [96]], ["i", 141, "comesFrom", ["i"], [123]], ["lsum", 147, "comesFrom", ["lsum"], [85]], ["rsum", 149, "comesFrom", ["rsum"], [137]], ["rsum", 151, "comesFrom", ["rsum"], [137]], ["msum", 153, "comesFrom", ["msum"], [112]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int A [ ] , int n , int Q [ ] , int q ) { int one = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; int glows = 0 , count = 0 ; if ( one >= ceil ( n / 2 ) ) glows = 1 ; for ( int i = 0 ; i < q ; i ++ ) { int prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= ceil ( n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; } int main ( ) { int n = 3 ; int arr [ ] = { 1 , 1 , 0 } ; int q = 3 ; int Q [ ] = { 3 , 2 , 1 } ; cout << solve ( arr , n , Q , q ) ; return 0 ; }", "docstring": "Count the number of times a Bulb switches its state | C ++ program for the above approach ; Function to find the number of times a bulb switches its state ; Count of 1 s ; Traverse the array ; Update count of 1 s ; Update the status of bulb ; Traverse the array Q [ ] ; Stores previous state of the bulb ; Toggle the switch and update count of 1 s ; If the bulb switches state ; Return count ; Driver Code ; Input ; Queries ; Function call to find number of times the bulb toggles", "dfg": [["count", 183, "comesFrom", ["count"], [63]], ["count", 178, "comesFrom", ["count"], [63]], ["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 89, "comesFrom", ["i"], [85]], ["i", 93, "comesFrom", ["i"], [85]], ["i", 50, "comesFrom", ["i"], [35]], ["i", 140, "comesFrom", ["i"], [85]], ["i", 108, "comesFrom", ["i"], [85]], ["i", 125, "comesFrom", ["i"], [85]], ["n", 41, "comesFrom", ["n"], [16]], ["n", 233, "comesFrom", ["n"], [192]], ["n", 73, "comesFrom", ["n"], [16]], ["n", 154, "comesFrom", ["n"], [16]], ["q", 91, "comesFrom", ["q"], [24]], ["q", 237, "comesFrom", ["q"], [210]], ["one", 69, "comesFrom", ["one"], [28]], ["one", 55, "comesFrom", ["one"], [28]], ["one", 116, "comesFrom", ["one"], [28]], ["one", 133, "comesFrom", ["one"], [28]], ["one", 150, "comesFrom", ["one"], [28]], ["prev", 174, "comesFrom", ["prev"], [98]], ["glows", 176, "comesFrom", ["glows"], [167]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; } int elementsHavingDigitSumK ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( sumOfDigits ( arr [ i ] ) == K ) { count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 23 , 54 , 87 , 29 , 92 , 62 } ; int K = 11 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; elementsHavingDigitSumK ( arr , N , K ) ; return 0 ; }", "docstring": "Count array elements having sum of digits equal to K | C ++ program for the above approach ; Function to calculate the sum of digits of the number N ; Stores the sum of digits ; Return the sum ; Function to count array elements ; Store the count of array elements having sum of digits K ; Traverse the array ; If sum of digits is equal to K ; Increment the count ; Print the count ; Driver Code ; Given array ; Given value of K ; Size of the array ; Function call to count array elements having sum of digits equal to K", "dfg": [["sum", 38, "comesFrom", ["sum"], [26]], ["i", 68, "comesFrom", ["i"], [64]], ["i", 73, "comesFrom", ["i"], [64]], ["i", 82, "comesFrom", ["i"], [64]], ["N", 70, "comesFrom", ["N"], [50]], ["N", 21, "comesFrom", ["N"], [11]], ["N", 148, "comesFrom", ["N"], [129]], ["N", 28, "comesFrom", ["N"], [11]], ["count", 96, "comesFrom", ["count"], [57]], ["count", 89, "comesFrom", ["count"], [57]], ["K", 150, "comesFrom", ["K"], [124]], ["K", 86, "comesFrom", ["K"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isOperand ( char x ) { return ( x >= ' a ' && x <= ' z ' ) || ( x >= ' A ' && x <= ' Z ' ) ; } string getInfix ( string exp ) { stack < string > s ; for ( int i = 0 ; exp [ i ] != ' \\0' ; i ++ ) { if ( isOperand ( exp [ i ] ) ) { string op ( 1 , exp [ i ] ) ; s . push ( op ) ; } else { string op1 = s . top ( ) ; s . pop ( ) ; string op2 = s . top ( ) ; s . pop ( ) ; s . push ( \" ( \" + op2 + exp [ i ] + op1 + \" ) \" ) ; } } return s . top ( ) ; } int main ( ) { string exp = \" ab * c + \" ; cout << getInfix ( exp ) ; return 0 ; }", "docstring": "Postfix to Infix | CPP program to find infix for a given postfix . ; Get Infix for a given postfix expression ; Push operands ; We assume that input is a valid postfix and expect an operator . ; There must be a single element in stack now which is the required infix . ; Driver code", "dfg": [["i", 81, "comesFrom", ["i"], [68]], ["i", 74, "comesFrom", ["i"], [68]], ["i", 91, "comesFrom", ["i"], [68]], ["i", 103, "comesFrom", ["i"], [68]], ["i", 159, "comesFrom", ["i"], [68]], ["exp", 72, "comesFrom", ["exp"], [56]], ["exp", 195, "comesFrom", ["exp"], [185]], ["exp", 89, "comesFrom", ["exp"], [56]], ["exp", 101, "comesFrom", ["exp"], [56]], ["exp", 157, "comesFrom", ["exp"], [56]], ["s", 172, "comesFrom", ["s"], [63]], ["s", 107, "comesFrom", ["s"], [63]], ["s", 126, "comesFrom", ["s"], [63]], ["s", 141, "comesFrom", ["s"], [63]], ["s", 147, "comesFrom", ["s"], [63]], ["s", 120, "comesFrom", ["s"], [63]], ["s", 135, "comesFrom", ["s"], [63]], ["x", 16, "comesFrom", ["x"], [11]], ["x", 24, "comesFrom", ["x"], [11]], ["x", 34, "comesFrom", ["x"], [11]], ["x", 42, "comesFrom", ["x"], [11]], ["op", 111, "comesFrom", ["op"], [97]], ["op1", 162, "comesFrom", ["op1"], [118]], ["op2", 155, "comesFrom", ["op2"], [133]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left , * right ; node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; int updatetree ( node * root ) { if ( ! root ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return root -> data ; int leftsum = updatetree ( root -> left ) ; int rightsum = updatetree ( root -> right ) ; root -> data += leftsum ; return root -> data + rightsum ; } void inorder ( node * node ) { if ( node == NULL ) return ; inorder ( node -> left ) ; cout << node -> data << \" ▁ \" ; inorder ( node -> right ) ; } int main ( ) { struct node * root = new node ( 1 ) ; root -> left = new node ( 2 ) ; root -> right = new node ( 3 ) ; root -> left -> left = new node ( 4 ) ; root -> left -> right = new node ( 5 ) ; root -> right -> right = new node ( 6 ) ; updatetree ( root ) ; cout << \" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ is : ▁ STRNEWLINE \" ; inorder ( root ) ; return 0 ; }", "docstring": "Change a Binary Tree so that every node stores sum of all nodes in left subtree | C ++ program to store sum of nodes in left subtree in every node ; A tree node ; Constructor that allocates a new node with the given data and NULL left and right pointers . ; Function to modify a Binary Tree so that every node stores sum of values in its left child including its own value ; Base cases ; Update left and right subtrees ; Add leftsum to current node ; Return sum of values under root ; Utility function to do inorder traversal ; Driver code ; Let us construct below tree 1 / \\ 2 3 / \\ \\ 4 5 6", "dfg": [["data", 82, "comesFrom", ["data"], [25]], ["data", 106, "comesFrom", ["data"], [25]], ["data", 113, "comesFrom", ["data"], [25]], ["data", 32, "comesFrom", ["data"], [25]], ["data", 145, "comesFrom", ["data"], [25]], ["data", 30, "comesFrom", ["data"], [25]], ["leftsum", 108, "comesFrom", ["leftsum"], [85]], ["rightsum", 115, "comesFrom", ["rightsum"], [95]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void calculateSpan ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S , n ) ; return 0 ; }", "docstring": "The Stock Span Problem | C ++ program for brute force method to calculate stock span values ; Fills array S [ ] with span values ; Span value of first day is always 1 ; Calculate span value of remaining days by linearly checking previous days ; Initialize span value ; Traverse left while the next element on left is smaller than price [ i ] ; A utility function to print elements of array ; Driver code ; Fill the span values in array S [ ] ; print the calculated span values", "dfg": [["i", 38, "comesFrom", ["i"], [34]], ["i", 42, "comesFrom", ["i"], [34]], ["i", 110, "comesFrom", ["i"], [106]], ["i", 114, "comesFrom", ["i"], [106]], ["i", 48, "comesFrom", ["i"], [34]], ["i", 58, "comesFrom", ["i"], [34]], ["i", 121, "comesFrom", ["i"], [106]], ["i", 85, "comesFrom", ["i"], [34]], ["i", 71, "comesFrom", ["i"], [34]], ["n", 40, "comesFrom", ["n"], [16]], ["n", 112, "comesFrom", ["n"], [100]], ["n", 172, "comesFrom", ["n"], [154]], ["n", 179, "comesFrom", ["n"], [154]], ["n", 188, "comesFrom", ["n"], [154]], ["j", 80, "comesFrom", ["j"], [56]], ["j", 63, "comesFrom", ["j"], [56]], ["j", 76, "comesFrom", ["j"], [56]]]}
{"code": "#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; void calculateSpan ( int price [ ] , int n , int S [ ] ) { stack < int > st ; st . push ( 0 ) ; S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! st . empty ( ) && price [ st . top ( ) ] <= price [ i ] ) st . pop ( ) ; S [ i ] = ( st . empty ( ) ) ? ( i + 1 ) : ( i - st . top ( ) ) ; st . push ( i ) ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S , n ) ; return 0 ; }", "docstring": "The Stock Span Problem | C ++ linear time solution for stock span problem ; A stack based efficient method to calculate stock span values ; Create a stack and push index of first element to it ; Span value of first element is always 1 ; Calculate span values for rest of the elements ; Pop elements from stack while stack is not empty and top of stack is smaller than price [ i ] ; If stack becomes empty , then price [ i ] is greater than all elements on left of it , i . e . , price [ 0 ] , price [ 1 ] , . . price [ i - 1 ] . Else price [ i ] is greater than elements after top of stack ; Push this element to stack ; A utility function to print elements of array ; Driver program to test above function ; Fill the span values in array S [ ] ; print the calculated span values", "dfg": [["i", 54, "comesFrom", ["i"], [50]], ["i", 58, "comesFrom", ["i"], [50]], ["i", 148, "comesFrom", ["i"], [144]], ["i", 152, "comesFrom", ["i"], [144]], ["i", 124, "comesFrom", ["i"], [50]], ["i", 93, "comesFrom", ["i"], [50]], ["i", 159, "comesFrom", ["i"], [144]], ["i", 105, "comesFrom", ["i"], [50]], ["i", 111, "comesFrom", ["i"], [50]], ["i", 82, "comesFrom", ["i"], [50]], ["n", 56, "comesFrom", ["n"], [19]], ["n", 150, "comesFrom", ["n"], [138]], ["n", 210, "comesFrom", ["n"], [192]], ["n", 217, "comesFrom", ["n"], [192]], ["n", 226, "comesFrom", ["n"], [192]], ["st", 33, "comesFrom", ["st"], [31]], ["st", 120, "comesFrom", ["st"], [31]], ["st", 85, "comesFrom", ["st"], [31]], ["st", 65, "comesFrom", ["st"], [31]], ["st", 97, "comesFrom", ["st"], [31]], ["st", 113, "comesFrom", ["st"], [31]], ["st", 73, "comesFrom", ["st"], [31]]]}
{"code": "#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; void calculateSpan ( int A [ ] , int n , int ans [ ] ) { ans [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int counter = 1 ; while ( ( i - counter ) >= 0 && A [ i ] >= A [ i - counter ] ) { counter += ans [ i - counter ] ; } ans [ i ] = counter ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S , n ) ; return 0 ; }", "docstring": "The Stock Span Problem | C ++ program for a linear time solution for stock span problem without using stack ; An efficient method to calculate stock span values implementing the same idea without using stack ; Span value of first element is always 1 ; Calculate span values for rest of the elements ; A utility function to print elements of array ; Driver program to test above function ; Fill the span values in array S [ ] ; print the calculated span values", "dfg": [["i", 41, "comesFrom", ["i"], [37]], ["i", 45, "comesFrom", ["i"], [37]], ["i", 115, "comesFrom", ["i"], [111]], ["i", 119, "comesFrom", ["i"], [111]], ["i", 89, "comesFrom", ["i"], [37]], ["i", 126, "comesFrom", ["i"], [111]], ["i", 57, "comesFrom", ["i"], [37]], ["i", 66, "comesFrom", ["i"], [37]], ["i", 71, "comesFrom", ["i"], [37]], ["i", 81, "comesFrom", ["i"], [37]], ["n", 43, "comesFrom", ["n"], [19]], ["n", 117, "comesFrom", ["n"], [105]], ["n", 177, "comesFrom", ["n"], [159]], ["n", 184, "comesFrom", ["n"], [159]], ["n", 193, "comesFrom", ["n"], [159]], ["counter", 92, "comesFrom", ["counter"], [77]], ["counter", 59, "comesFrom", ["counter"], [50]], ["counter", 73, "comesFrom", ["counter"], [50]], ["counter", 83, "comesFrom", ["counter"], [77]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << \" ▁ - - ▁ \" << next << endl ; } } int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNGE ( arr , n ) ; return 0 ; }", "docstring": "Next Greater Element | Simple C ++ program to print next greater elements in a given array ; prints element and NGE pair for all elements of arr [ ] of size n ; Driver Code", "dfg": [["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 48, "comesFrom", ["i"], [28]], ["i", 64, "comesFrom", ["i"], [28]], ["i", 88, "comesFrom", ["i"], [28]], ["n", 34, "comesFrom", ["n"], [16]], ["n", 141, "comesFrom", ["n"], [122]], ["n", 54, "comesFrom", ["n"], [16]], ["j", 52, "comesFrom", ["j"], [46]], ["j", 56, "comesFrom", ["j"], [46]], ["j", 69, "comesFrom", ["j"], [46]], ["j", 77, "comesFrom", ["j"], [46]], ["next", 95, "comesFrom", ["next"], [73]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void mirror ( struct Node * node ) { if ( node == NULL ) return ; else { struct Node * temp ; mirror ( node -> left ) ; mirror ( node -> right ) ; temp = node -> left ; node -> left = node -> right ; node -> right = temp ; } } void inOrder ( struct Node * node ) { if ( node == NULL ) return ; inOrder ( node -> left ) ; cout << node -> data << \" ▁ \" ; inOrder ( node -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << \" Inorder ▁ traversal ▁ of ▁ the ▁ constructed \" << \" ▁ tree ▁ is \" << endl ; inOrder ( root ) ; mirror ( root ) ; cout << \" Inorder traversal of the mirror tree \" << \" ▁ is ▁ STRNEWLINE \" ; inOrder ( root ) ; return 0 ; }", "docstring": "Convert a Binary Tree into its Mirror Tree | C ++ program to convert a binary tree to its mirror ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Change a tree so that the roles of the left and right pointers are swapped at every node . So the tree ... 4 / \\ 2 5 / \\ 1 3 is changed to ... 4 / \\ 5 2 / \\ 3 1 ; do the subtrees ; swap the pointers in this node ; Helper function to print Inorder traversal . ; Driver Code ; Print inorder traversal of the input tree ; Convert tree to its mirror ; Print inorder traversal of the mirror tree", "dfg": [["data", 57, "comesFrom", ["data"], [31]], ["data", 55, "comesFrom", ["data"], [31]], ["data", 165, "comesFrom", ["data"], [31]], ["temp", 133, "comesFrom", ["temp"], [115]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void fillNext ( int next [ ] , int a [ ] , int n ) { stack < int > s ; s . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) ) { int cur = s . top ( ) ; if ( a [ cur ] < a [ i ] ) { next [ cur ] = i ; s . pop ( ) ; } else break ; } s . push ( i ) ; } while ( ! s . empty ( ) ) { int cur = s . top ( ) ; next [ cur ] = -1 ; s . pop ( ) ; } } void count ( int a [ ] , int dp [ ] , int n ) { int next [ n ] ; memset ( next , 0 , sizeof ( next ) ) ; fillNext ( next , a , n ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( next [ i ] == -1 ) dp [ i ] = 0 ; else dp [ i ] = 1 + dp [ next [ i ] ] ; } } int answerQuery ( int dp [ ] , int index ) { return dp [ index ] ; } int main ( ) { int a [ ] = { 3 , 4 , 2 , 7 , 5 , 8 , 10 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int dp [ n ] ; count ( a , dp , n ) ; cout << answerQuery ( dp , 3 ) << endl ; cout << answerQuery ( dp , 6 ) << endl ; cout << answerQuery ( dp , 1 ) << endl ; return 0 ; }", "docstring": "Number of NGEs to the right |  ; array to store the next greater element index ; use of stl stack in c ++ ; push the 0 th index to the stack ; traverse in the loop from 1 - nth index ; iterate till loop is empty ; get the topmost index in the stack ; if the current element is greater then the top index - th element , then this will be the next greatest index of the top index - th element ; initialize the cur index position 's  next greatest as index ; pop the cur index as its greater element has been found ; if not greater then break ; push the i index so that its next greatest can be found ; iterate for all other index left inside stack ; mark it as - 1 as no element in greater then it in right ; Function to count the number of next greater numbers to the right ; initializes the next array as 0 ; calls the function to pre - calculate the next greatest element indexes ; if the i - th element has no next greater element to right ; Count of next greater numbers to right . ; answers all queries in O ( 1 ) ; returns the number of next greater elements to the right . ; driver program to test the above function ; calls the function to count the number of greater elements to the right for every element . ; query 1 answered ; query 2 answered ; query 3 answered", "dfg": [["i", 44, "comesFrom", ["i"], [40]], ["i", 48, "comesFrom", ["i"], [40]], ["i", 197, "comesFrom", ["i"], [191]], ["i", 201, "comesFrom", ["i"], [191]], ["i", 106, "comesFrom", ["i"], [40]], ["i", 209, "comesFrom", ["i"], [191]], ["i", 216, "comesFrom", ["i"], [191]], ["i", 89, "comesFrom", ["i"], [40]], ["i", 224, "comesFrom", ["i"], [191]], ["i", 80, "comesFrom", ["i"], [40]], ["i", 233, "comesFrom", ["i"], [191]], ["n", 46, "comesFrom", ["n"], [21]], ["n", 164, "comesFrom", ["n"], [158]], ["n", 305, "comesFrom", ["n"], [287]], ["n", 185, "comesFrom", ["n"], [158]], ["n", 314, "comesFrom", ["n"], [287]], ["n", 193, "comesFrom", ["n"], [158]], ["s", 30, "comesFrom", ["s"], [28]], ["s", 102, "comesFrom", ["s"], [28]], ["s", 113, "comesFrom", ["s"], [28]], ["s", 136, "comesFrom", ["s"], [28]], ["s", 123, "comesFrom", ["s"], [28]], ["s", 55, "comesFrom", ["s"], [28]], ["s", 65, "comesFrom", ["s"], [28]], ["s", 91, "comesFrom", ["s"], [28]], ["index", 254, "comesFrom", ["index"], [248]], ["cur", 131, "comesFrom", ["cur"], [121]], ["cur", 75, "comesFrom", ["cur"], [63]], ["cur", 86, "comesFrom", ["cur"], [63]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > no_NGN ( int arr [ ] , int n ) { vector < int > nxt ; stack < int > s ; nxt . push_back ( 0 ) ; s . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ i ] >= arr [ s . top ( ) ] ) s . pop ( ) ; if ( s . empty ( ) ) nxt . push_back ( 0 ) ; else nxt . push_back ( nxt [ n - s . top ( ) - 1 ] + 1 ) ; s . push ( i ) ; } reverse ( nxt . begin ( ) , nxt . end ( ) ) ; return nxt ; } int main ( ) { int n = 8 ; int arr [ ] = { 3 , 4 , 2 , 7 , 5 , 8 , 10 , 6 } ; vector < int > nxt = no_NGN ( arr , n ) ; cout << nxt [ 3 ] << endl ; cout << nxt [ 6 ] << endl ; cout << nxt [ 1 ] << endl ; return 0 ; }", "docstring": "Number of NGEs to the right |  ; use of stl stack in c ++ ; push the ( n - 1 ) th index to the stack ; traverse in reverse order ; if no element is greater than arr [ i ] the number of NGEs to right is 0 ; number of NGEs to right of arr [ i ] is one greater than the number of NGEs to right of higher number to its right ; reverse again because values are in reverse order ; returns the vector of number of next greater elements to the right of each index . ; Driver code ; query 1 answered ; query 2 answered ; query 3 answered", "dfg": [["nxt", 156, "comesFrom", ["nxt"], [26]], ["nxt", 34, "comesFrom", ["nxt"], [26]], ["nxt", 207, "comesFrom", ["nxt"], [196]], ["nxt", 216, "comesFrom", ["nxt"], [196]], ["nxt", 225, "comesFrom", ["nxt"], [196]], ["nxt", 142, "comesFrom", ["nxt"], [26]], ["nxt", 148, "comesFrom", ["nxt"], [26]], ["nxt", 104, "comesFrom", ["nxt"], [26]], ["nxt", 112, "comesFrom", ["nxt"], [26]], ["nxt", 116, "comesFrom", ["nxt"], [26]], ["i", 59, "comesFrom", ["i"], [53]], ["i", 63, "comesFrom", ["i"], [53]], ["i", 136, "comesFrom", ["i"], [53]], ["i", 78, "comesFrom", ["i"], [53]], ["s", 41, "comesFrom", ["s"], [32]], ["s", 132, "comesFrom", ["s"], [32]], ["s", 90, "comesFrom", ["s"], [32]], ["s", 98, "comesFrom", ["s"], [32]], ["s", 70, "comesFrom", ["s"], [32]], ["s", 83, "comesFrom", ["s"], [32]], ["s", 120, "comesFrom", ["s"], [32]], ["n", 45, "comesFrom", ["n"], [19]], ["n", 55, "comesFrom", ["n"], [19]], ["n", 202, "comesFrom", ["n"], [165]], ["n", 118, "comesFrom", ["n"], [19]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE vector < int > nextGreaterInLeft ( int a [ ] , int n ) { vector < int > left_index ( MAX , 0 ) ; stack < int > s ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && a [ i ] > a [ s . top ( ) - 1 ] ) { int r = s . top ( ) ; s . pop ( ) ; left_index [ r - 1 ] = i + 1 ; } s . push ( i + 1 ) ; } return left_index ; } vector < int > nextGreaterInRight ( int a [ ] , int n ) { vector < int > right_index ( MAX , 0 ) ; stack < int > s ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! s . empty ( ) && a [ i ] > a [ s . top ( ) - 1 ] ) { int r = s . top ( ) ; s . pop ( ) ; right_index [ r - 1 ] = i + 1 ; } s . push ( i + 1 ) ; } return right_index ; } int LRProduct ( int arr [ ] , int n ) { vector < int > left = nextGreaterInLeft ( arr , n ) ; vector < int > right = nextGreaterInRight ( arr , n ) ; int ans = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { ans = max ( ans , left [ i ] * right [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 1 ] ) ; cout << LRProduct ( arr , n ) ; return 0 ; }", "docstring": "Maximum product of indexes of next greater on left and right | C ++ program to find the max LRproduct [ i ] among all i ; function to find just next greater element in left side ; checking if current element is greater than top ; on index of top store the current element index which is just greater than top element ; else push the current element in stack ; function to find just next greater element in right side ; checking if current element is greater than top ; on index of top store the current element index which is just greater than top element stored index should be start with 1 ; else push the current element in stack ; Function to find maximum LR product ; for each element storing the index of just greater element in left side ; for each element storing the index of just greater element in right side ; finding the max index product ; Drivers code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE #include <list> NEW_LINE using namespace std ; #define N  8 NEW_LINE bool MATRIX [ N ] [ N ] = { { 0 , 0 , 1 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 } } ; bool knows ( int a , int b ) { return MATRIX [ a ] [ b ] ; } int findCelebrity ( int n ) { int indegree [ n ] = { 0 } , outdegree [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x = knows ( i , j ) ; outdegree [ i ] += x ; indegree [ j ] += x ; } } for ( int i = 0 ; i < n ; i ++ ) if ( indegree [ i ] == n - 1 && outdegree [ i ] == 0 ) return i ; return -1 ; } int main ( ) { int n = 4 ; int id = findCelebrity ( n ) ; id == -1 ? cout << \" No ▁ celebrity \" : cout << \" Celebrity ▁ ID ▁ \" << id ; return 0 ; }", "docstring": "The Celebrity Problem | C ++ program to find celebrity ; Max # of persons in the party ; Person with 2 is celebrity ; Returns - 1 if celebrity is not present . If present , returns id ( value from 0 to n - 1 ) . ; the graph needs not be constructed as the edges can be found by using knows function degree array ; ; query for all edges ; set the degrees ; find a person with indegree n - 1 and out degree 0 ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE #include <list> NEW_LINE using namespace std ; #define N  8 NEW_LINE bool MATRIX [ N ] [ N ] = { { 0 , 0 , 1 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 } } ; bool knows ( int a , int b ) { return MATRIX [ a ] [ b ] ; } int findPotentialCelebrity ( int n ) { if ( n == 0 ) return -1 ; int id = findPotentialCelebrity ( n - 1 ) ; if ( id == -1 ) return n - 1 ; else if ( knows ( id , n - 1 ) ) { return n - 1 ; } else if ( knows ( n - 1 , id ) ) { return id ; } return -1 ; } int Celebrity ( int n ) { int id = findPotentialCelebrity ( n ) ; if ( id == -1 ) return id ; else { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i != id ) { c1 += knows ( id , i ) ; c2 += knows ( i , id ) ; } if ( c1 == 0 && c2 == n - 1 ) return id ; return -1 ; } } int main ( ) { int n = 4 ; int id = Celebrity ( n ) ; id == -1 ? cout << \" No ▁ celebrity \" : cout << \" Celebrity ▁ ID ▁ \" << id ; return 0 ; }", "docstring": "The Celebrity Problem | C ++ program to find celebrity ; Max # of persons in the party ; Person with 2 is celebrity ; Returns - 1 if a ' potential ▁ celebrity ' is not present . If present , returns id ( value from 0 to n - 1 ) . ; base case - when n reaches 0 , returns - 1 since n represents the number of people , 0 people implies no celebrity ( = - 1 ) ; find the celebrity with n - 1 persons ; if there are no celebrities ; if the id knows the nth person then the id cannot be a celebrity , but nth person could be one ; if the nth person knows the id , then the nth person cannot be a celebrity and the id could be one ; if there is no celebrity ; Returns - 1 if celebrity is not present . If present , returns id ( value from 0 to n - 1 ) . a wrapper over findCelebrity ; find the celebrity ; check if the celebrity found is really the celebrity ; check the id is really the celebrity ; if the person is known to everyone . ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int precedence ( char op ) { if ( op == ' + ' op == ' - ' ) return 1 ; if ( op == ' * ' op == ' / ' ) return 2 ; return 0 ; } int applyOp ( int a , int b , char op ) { switch ( op ) { case ' + ' : return a + b ; case ' - ' : return a - b ; case ' * ' : return a * b ; case ' / ' : return a / b ; } } int evaluate ( string tokens ) { int i ; stack < int > values ; stack < char > ops ; for ( i = 0 ; i < tokens . length ( ) ; i ++ ) { if ( tokens [ i ] == ' ▁ ' ) continue ; else if ( tokens [ i ] == ' ( ' ) { ops . push ( tokens [ i ] ) ; } else if ( isdigit ( tokens [ i ] ) ) { int val = 0 ; while ( i < tokens . length ( ) && isdigit ( tokens [ i ] ) ) { val = ( val * 10 ) + ( tokens [ i ] - '0' ) ; i ++ ; } values . push ( val ) ; i -- ; } else if ( tokens [ i ] == ' ) ' ) { while ( ! ops . empty ( ) && ops . top ( ) != ' ( ' ) { int val2 = values . top ( ) ; values . pop ( ) ; int val1 = values . top ( ) ; values . pop ( ) ; char op = ops . top ( ) ; ops . pop ( ) ; values . push ( applyOp ( val1 , val2 , op ) ) ; } if ( ! ops . empty ( ) ) ops . pop ( ) ; } else { while ( ! ops . empty ( ) && precedence ( ops . top ( ) ) >= precedence ( tokens [ i ] ) ) { int val2 = values . top ( ) ; values . pop ( ) ; int val1 = values . top ( ) ; values . pop ( ) ; char op = ops . top ( ) ; ops . pop ( ) ; values . push ( applyOp ( val1 , val2 , op ) ) ; } ops . push ( tokens [ i ] ) ; } } while ( ! ops . empty ( ) ) { int val2 = values . top ( ) ; values . pop ( ) ; int val1 = values . top ( ) ; values . pop ( ) ; char op = ops . top ( ) ; ops . pop ( ) ; values . push ( applyOp ( val1 , val2 , op ) ) ; } return values . top ( ) ; } int main ( ) { cout << evaluate ( \"10 ▁ + ▁ 2 ▁ * ▁ 6\" ) << \" STRNEWLINE \" ; cout << evaluate ( \"100 ▁ * ▁ 2 ▁ + ▁ 12\" ) << \" STRNEWLINE \" ; cout << evaluate ( \"100 ▁ * ▁ ( ▁ 2 ▁ + ▁ 12 ▁ ) \" ) << \" STRNEWLINE \" ; cout << evaluate ( \"100 ▁ * ▁ ( ▁ 2 ▁ + ▁ 12 ▁ ) ▁ / ▁ 14\" ) ; return 0 ; }", "docstring": "Expression Evaluation | CPP program to evaluate a given expression where tokens are separated by space . ; Function to find precedence of operators . ; Function to perform arithmetic operations . ; Function that returns value of expression after evaluation . ; stack to store integer values . ; stack to store operators . ; Current token is a whitespace , skip it . ; Current token is an opening brace , push it to ' ops ' ; Current token is a number , push it to stack for numbers . ; There may be more than one digits in number . ; right now the i points to the character next to the digit , since the for loop also increases the i , we would skip one token position ; we need to decrease the value of i by 1 to correct the offset . ; Closing brace encountered , solve entire brace . ; pop opening brace . ; Current token is an operator . ; While top of ' ops ' has same or greater precedence to current token , which is an operator . Apply operator on top of ' ops ' to top two elements in values stack . ; Push current token to ' ops ' . ; Entire expression has been parsed at this point , apply remaining ops to remaining values . ; Top of ' values ' contains result , return it . ; Driver method to test above methods", "dfg": [["op", 73, "comesFrom", ["op"], [68]], ["op", 16, "comesFrom", ["op"], [11]], ["op", 23, "comesFrom", ["op"], [11]], ["op", 36, "comesFrom", ["op"], [11]], ["op", 43, "comesFrom", ["op"], [11]], ["op", 556, "comesFrom", ["op"], [532]], ["op", 369, "comesFrom", ["op"], [345]], ["op", 474, "comesFrom", ["op"], [450]], ["i", 154, "comesFrom", ["i"], [150]], ["i", 162, "comesFrom", ["i"], [150]], ["i", 170, "comesFrom", ["i"], [150]], ["i", 186, "comesFrom", ["i"], [150]], ["i", 273, "comesFrom", ["i"], [150]], ["i", 202, "comesFrom", ["i"], [150]], ["i", 214, "comesFrom", ["i"], [150]], ["i", 226, "comesFrom", ["i"], [150]], ["i", 262, "comesFrom", ["i"], [150]], ["i", 282, "comesFrom", ["i"], [150]], ["i", 238, "comesFrom", ["i"], [150]], ["i", 485, "comesFrom", ["i"], [150]], ["i", 254, "comesFrom", ["i"], [150]], ["i", 414, "comesFrom", ["i"], [150]], ["values", 562, "comesFrom", ["values"], [140]], ["values", 510, "comesFrom", ["values"], [140]], ["values", 525, "comesFrom", ["values"], [140]], ["values", 546, "comesFrom", ["values"], [140]], ["values", 504, "comesFrom", ["values"], [140]], ["values", 519, "comesFrom", ["values"], [140]], ["values", 266, "comesFrom", ["values"], [140]], ["values", 323, "comesFrom", ["values"], [140]], ["values", 338, "comesFrom", ["values"], [140]], ["values", 359, "comesFrom", ["values"], [140]], ["values", 317, "comesFrom", ["values"], [140]], ["values", 332, "comesFrom", ["values"], [140]], ["values", 428, "comesFrom", ["values"], [140]], ["values", 443, "comesFrom", ["values"], [140]], ["values", 464, "comesFrom", ["values"], [140]], ["values", 422, "comesFrom", ["values"], [140]], ["values", 437, "comesFrom", ["values"], [140]], ["tokens", 156, "comesFrom", ["tokens"], [130]], ["tokens", 168, "comesFrom", ["tokens"], [130]], ["tokens", 184, "comesFrom", ["tokens"], [130]], ["tokens", 200, "comesFrom", ["tokens"], [130]], ["tokens", 212, "comesFrom", ["tokens"], [130]], ["tokens", 280, "comesFrom", ["tokens"], [130]], ["tokens", 228, "comesFrom", ["tokens"], [130]], ["tokens", 236, "comesFrom", ["tokens"], [130]], ["tokens", 483, "comesFrom", ["tokens"], [130]], ["tokens", 252, "comesFrom", ["tokens"], [130]], ["tokens", 412, "comesFrom", ["tokens"], [130]], ["a", 84, "comesFrom", ["a"], [62]], ["a", 96, "comesFrom", ["a"], [62]], ["a", 108, "comesFrom", ["a"], [62]], ["a", 120, "comesFrom", ["a"], [62]], ["b", 86, "comesFrom", ["b"], [65]], ["b", 98, "comesFrom", ["b"], [65]], ["b", 110, "comesFrom", ["b"], [65]], ["b", 122, "comesFrom", ["b"], [65]], ["ops", 494, "comesFrom", ["ops"], [146]], ["ops", 540, "comesFrom", ["ops"], [146]], ["ops", 534, "comesFrom", ["ops"], [146]], ["ops", 196, "comesFrom", ["ops"], [146]], ["ops", 383, "comesFrom", ["ops"], [146]], ["ops", 479, "comesFrom", ["ops"], [146]], ["ops", 353, "comesFrom", ["ops"], [146]], ["ops", 377, "comesFrom", ["ops"], [146]], ["ops", 295, "comesFrom", ["ops"], [146]], ["ops", 301, "comesFrom", ["ops"], [146]], ["ops", 347, "comesFrom", ["ops"], [146]], ["ops", 458, "comesFrom", ["ops"], [146]], ["ops", 395, "comesFrom", ["ops"], [146]], ["ops", 452, "comesFrom", ["ops"], [146]], ["ops", 403, "comesFrom", ["ops"], [146]], ["val1", 552, "comesFrom", ["val1"], [517]], ["val1", 365, "comesFrom", ["val1"], [330]], ["val1", 470, "comesFrom", ["val1"], [435]], ["val2", 554, "comesFrom", ["val2"], [502]], ["val2", 367, "comesFrom", ["val2"], [315]], ["val2", 472, "comesFrom", ["val2"], [420]], ["val", 270, "comesFrom", ["val"], [243]], ["val", 246, "comesFrom", ["val"], [243]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void mirror ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { Node * curr = q . front ( ) ; q . pop ( ) ; swap ( curr -> left , curr -> right ) ; if ( curr -> left ) q . push ( curr -> left ) ; if ( curr -> right ) q . push ( curr -> right ) ; } } void inOrder ( struct Node * node ) { if ( node == NULL ) return ; inOrder ( node -> left ) ; cout << node -> data << \" ▁ \" ; inOrder ( node -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << \" Inorder traversal of the \" STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" constructed tree is \" ; inOrder ( root ) ; mirror ( root ) ; cout << \" Inorder traversal of the \" STRNEWLINE TABSYMBOL TABSYMBOL \" mirror tree is \" ; inOrder ( root ) ; return 0 ; }", "docstring": "Convert a Binary Tree into its Mirror Tree | Iterative CPP program to convert a Binary Tree to its mirror ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Change a tree so that the roles of the left and right pointers are swapped at every node . So the tree ... 4 / \\ 2 5 / \\ 1 3 is changed to ... 4 / \\ 5 2 / \\ 3 1 ; Do BFS . While doing BFS , keep swapping left and right children ; pop top node from queue ; swap left child with right child ; push left and right children ; Helper function to print Inorder traversal . ; Driver program to test mirror ( ) ; Print inorder traversal of the input tree ; Convert tree to its mirror ; Print inorder traversal of the mirror tree", "dfg": [["data", 46, "comesFrom", ["data"], [31]], ["data", 44, "comesFrom", ["data"], [31]], ["data", 191, "comesFrom", ["data"], [31]], ["q", 87, "comesFrom", ["q"], [85]], ["q", 97, "comesFrom", ["q"], [85]], ["q", 114, "comesFrom", ["q"], [85]], ["q", 108, "comesFrom", ["q"], [85]], ["q", 137, "comesFrom", ["q"], [85]], ["q", 152, "comesFrom", ["q"], [85]]]}
{"code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <limits.h> NEW_LINE struct Stack { unsigned capacity ; int top ; int * array ; } ; struct Stack * createStack ( unsigned capacity ) { struct Stack * stack = ( struct Stack * ) malloc ( sizeof ( struct Stack ) ) ; stack -> capacity = capacity ; stack -> top = -1 ; stack -> array = ( int * ) malloc ( stack -> capacity * sizeof ( int ) ) ; return stack ; } int isFull ( struct Stack * stack ) { return ( stack -> top == stack -> capacity - 1 ) ; } int isEmpty ( struct Stack * stack ) { return ( stack -> top == -1 ) ; } void push ( struct Stack * stack , int item ) { if ( isFull ( stack ) ) return ; stack -> array [ ++ stack -> top ] = item ; } int pop ( struct Stack * stack ) { if ( isEmpty ( stack ) ) return INT_MIN ; return stack -> array [ stack -> top -- ] ; } void moveDisk ( char fromPeg , char toPeg , int disk ) { printf ( \" Move ▁ the ▁ disk ▁ % d ▁ from ▁ \\' % c \\' ▁ to ▁ \\' % c \\' STRNEWLINE \" , disk , fromPeg , toPeg ) ; } void moveDisksBetweenTwoPoles ( struct Stack * src , struct Stack * dest , char s , char d ) { int pole1TopDisk = pop ( src ) ; int pole2TopDisk = pop ( dest ) ; if ( pole1TopDisk == INT_MIN ) { push ( src , pole2TopDisk ) ; moveDisk ( d , s , pole2TopDisk ) ; } else if ( pole2TopDisk == INT_MIN ) { push ( dest , pole1TopDisk ) ; moveDisk ( s , d , pole1TopDisk ) ; } else if ( pole1TopDisk > pole2TopDisk ) { push ( src , pole1TopDisk ) ; push ( src , pole2TopDisk ) ; moveDisk ( d , s , pole2TopDisk ) ; } else { push ( dest , pole2TopDisk ) ; push ( dest , pole1TopDisk ) ; moveDisk ( s , d , pole1TopDisk ) ; } } void tohIterative ( int num_of_disks , struct Stack * src , struct Stack * aux , struct Stack * dest ) { int i , total_num_of_moves ; char s = ' S ' , d = ' D ' , a = ' A ' ; if ( num_of_disks % 2 == 0 ) { char temp = d ; d = a ; a = temp ; } total_num_of_moves = pow ( 2 , num_of_disks ) - 1 ; for ( i = num_of_disks ; i >= 1 ; i -- ) push ( src , i ) ; for ( i = 1 ; i <= total_num_of_moves ; i ++ ) { if ( i % 3 == 1 ) moveDisksBetweenTwoPoles ( src , dest , s , d ) ; else if ( i % 3 == 2 ) moveDisksBetweenTwoPoles ( src , aux , s , a ) ; else if ( i % 3 == 0 ) moveDisksBetweenTwoPoles ( aux , dest , a , d ) ; } } int main ( ) { unsigned num_of_disks = 3 ; struct Stack * src , * dest , * aux ; src = createStack ( num_of_disks ) ; aux = createStack ( num_of_disks ) ; dest = createStack ( num_of_disks ) ; tohIterative ( num_of_disks , src , aux , dest ) ; return 0 ; }", "docstring": "Iterative Tower of Hanoi | C Program for Iterative Tower of Hanoi ; A structure to represent a stack ; function to create a stack of given capacity . ; Stack is full when top is equal to the last index ; Stack is empty when top is equal to - 1 ; Function to add an item to stack . It increases top by 1 ; Function to remove an item from stack . It decreases top by 1 ; Function to show the movement of disks ; Function to implement legal movement between two poles ; When pole 1 is empty ; When pole2 pole is empty ; When top disk of pole1 > top disk of pole2 ; When top disk of pole1 < top disk of pole2 ; Function to implement TOH puzzle ; If number of disks is even , then interchange destination pole and auxiliary pole ; Larger disks will be pushed first ; Driver Program ; Input : number of disks ; Create three stacks of size ' num _ of _ disks ' to hold the disks", "dfg": [["capacity", 59, "comesFrom", ["capacity"], [33]], ["capacity", 57, "comesFrom", ["capacity"], [33]], ["capacity", 108, "comesFrom", ["capacity"], [33]], ["capacity", 79, "comesFrom", ["capacity"], [33]], ["item", 164, "comesFrom", ["item"], [142]], ["num_of_disks", 467, "comesFrom", ["num_of_disks"], [381]], ["num_of_disks", 602, "comesFrom", ["num_of_disks"], [564]], ["num_of_disks", 431, "comesFrom", ["num_of_disks"], [381]], ["num_of_disks", 583, "comesFrom", ["num_of_disks"], [564]], ["num_of_disks", 590, "comesFrom", ["num_of_disks"], [564]], ["num_of_disks", 597, "comesFrom", ["num_of_disks"], [564]], ["num_of_disks", 458, "comesFrom", ["num_of_disks"], [381]], ["i", 469, "comesFrom", ["i"], [465]], ["i", 473, "comesFrom", ["i"], [465]], ["i", 489, "comesFrom", ["i"], [485]], ["i", 493, "comesFrom", ["i"], [485]], ["i", 480, "comesFrom", ["i"], [465]], ["i", 499, "comesFrom", ["i"], [485]], ["i", 519, "comesFrom", ["i"], [485]], ["i", 539, "comesFrom", ["i"], [485]], ["total_num_of_moves", 491, "comesFrom", ["total_num_of_moves"], [452]], ["src", 604, "comesFrom", ["src"], [579]], ["dest", 608, "comesFrom", ["dest"], [593]], ["aux", 606, "comesFrom", ["aux"], [586]], ["disk", 225, "comesFrom", ["disk"], [208]], ["fromPeg", 227, "comesFrom", ["fromPeg"], [202]], ["toPeg", 229, "comesFrom", ["toPeg"], [205]], ["pole1TopDisk", 271, "comesFrom", ["pole1TopDisk"], [254]], ["pole1TopDisk", 305, "comesFrom", ["pole1TopDisk"], [254]], ["pole1TopDisk", 314, "comesFrom", ["pole1TopDisk"], [254]], ["pole1TopDisk", 321, "comesFrom", ["pole1TopDisk"], [254]], ["pole1TopDisk", 330, "comesFrom", ["pole1TopDisk"], [254]], ["pole1TopDisk", 363, "comesFrom", ["pole1TopDisk"], [254]], ["pole1TopDisk", 372, "comesFrom", ["pole1TopDisk"], [254]], ["a", 445, "comesFrom", ["a"], [421]], ["a", 533, "comesFrom", ["a"], [447]], ["a", 551, "comesFrom", ["a"], [447]], ["temp", 449, "comesFrom", ["temp"], [439]], ["pole2TopDisk", 280, "comesFrom", ["pole2TopDisk"], [262]], ["pole2TopDisk", 289, "comesFrom", ["pole2TopDisk"], [262]], ["pole2TopDisk", 296, "comesFrom", ["pole2TopDisk"], [262]], ["pole2TopDisk", 323, "comesFrom", ["pole2TopDisk"], [262]], ["pole2TopDisk", 337, "comesFrom", ["pole2TopDisk"], [262]], ["pole2TopDisk", 346, "comesFrom", ["pole2TopDisk"], [262]], ["pole2TopDisk", 356, "comesFrom", ["pole2TopDisk"], [262]], ["d", 285, "comesFrom", ["d"], [250]], ["d", 513, "comesFrom", ["d"], [443]], ["d", 312, "comesFrom", ["d"], [250]], ["d", 342, "comesFrom", ["d"], [250]], ["d", 370, "comesFrom", ["d"], [250]], ["d", 553, "comesFrom", ["d"], [443]], ["s", 287, "comesFrom", ["s"], [247]], ["s", 511, "comesFrom", ["s"], [405]], ["s", 310, "comesFrom", ["s"], [247]], ["s", 531, "comesFrom", ["s"], [405]], ["s", 344, "comesFrom", ["s"], [247]], ["s", 368, "comesFrom", ["s"], [247]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void deleteMid ( stack < char > & st , int n , int curr = 0 ) { if ( st . empty ( ) curr == n ) return ; char x = st . top ( ) ; st . pop ( ) ; deleteMid ( st , n , curr + 1 ) ; if ( curr != n / 2 ) st . push ( x ) ; } int main ( ) { stack < char > st ; st . push ( '1' ) ; st . push ( '2' ) ; st . push ( '3' ) ; st . push ( '4' ) ; st . push ( '5' ) ; st . push ( '6' ) ; st . push ( '7' ) ; deleteMid ( st , st . size ( ) ) ; while ( ! st . empty ( ) ) { char p = st . top ( ) ; st . pop ( ) ; cout << p << \" ▁ \" ; } return 0 ; }", "docstring": "Delete middle element of a stack | C ++ code to delete middle of a stack without using additional data structure . ; Deletes middle of stack of size n . Curr is current item number ; If stack is empty or all items are traversed ; Remove current item ; Remove other items ; Put all items back except middle ; Driver function to test above functions ; push elements into the stack ; Printing stack after deletion of middle .", "dfg": [["st", 92, "comesFrom", ["st"], [90]], ["st", 101, "comesFrom", ["st"], [90]], ["st", 110, "comesFrom", ["st"], [90]], ["st", 119, "comesFrom", ["st"], [90]], ["st", 128, "comesFrom", ["st"], [90]], ["st", 137, "comesFrom", ["st"], [90]], ["st", 146, "comesFrom", ["st"], [90]], ["st", 157, "comesFrom", ["st"], [90]], ["st", 159, "comesFrom", ["st"], [90]], ["st", 169, "comesFrom", ["st"], [90]], ["st", 185, "comesFrom", ["st"], [90]], ["st", 179, "comesFrom", ["st"], [90]], ["n", 35, "comesFrom", ["n"], [18]], ["n", 58, "comesFrom", ["n"], [18]], ["n", 69, "comesFrom", ["n"], [18]], ["x", 77, "comesFrom", ["x"], [40]], ["p", 193, "comesFrom", ["p"], [177]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; stack < int > sortStack ( stack < int > input ) { stack < int > tmpStack ; while ( ! input . empty ( ) ) { int tmp = input . top ( ) ; input . pop ( ) ; while ( ! tmpStack . empty ( ) && tmpStack . top ( ) < tmp ) { input . push ( tmpStack . top ( ) ) ; tmpStack . pop ( ) ; } tmpStack . push ( tmp ) ; } return tmpStack ; } void sortArrayUsingStacks ( int arr [ ] , int n ) { stack < int > input ; for ( int i = 0 ; i < n ; i ++ ) input . push ( arr [ i ] ) ; stack < int > tmpStack = sortStack ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = tmpStack . top ( ) ; tmpStack . pop ( ) ; } } int main ( ) { int arr [ ] = { 10 , 5 , 15 , 45 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArrayUsingStacks ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; return 0 ; }", "docstring": "Sorting array using Stacks | C ++ program to sort an array using stack ; This function return the sorted stack ; pop out the first element ; while temporary stack is not empty and top of stack is smaller than temp ; pop from temporary stack and push it to the input stack ; push temp in tempory of stack ; Push array elements to stack ; Sort the temporary stack ; Put stack elements in arrp [ ] ; main function", "dfg": [["tmpStack", 96, "comesFrom", ["tmpStack"], [24]], ["tmpStack", 87, "comesFrom", ["tmpStack"], [24]], ["tmpStack", 178, "comesFrom", ["tmpStack"], [145]], ["tmpStack", 172, "comesFrom", ["tmpStack"], [145]], ["tmpStack", 80, "comesFrom", ["tmpStack"], [24]], ["tmpStack", 54, "comesFrom", ["tmpStack"], [24]], ["tmpStack", 60, "comesFrom", ["tmpStack"], [24]], ["tmpStack", 73, "comesFrom", ["tmpStack"], [24]], ["i", 124, "comesFrom", ["i"], [120]], ["i", 128, "comesFrom", ["i"], [120]], ["i", 159, "comesFrom", ["i"], [155]], ["i", 163, "comesFrom", ["i"], [155]], ["i", 236, "comesFrom", ["i"], [232]], ["i", 240, "comesFrom", ["i"], [232]], ["i", 137, "comesFrom", ["i"], [120]], ["i", 169, "comesFrom", ["i"], [155]], ["i", 247, "comesFrom", ["i"], [232]], ["n", 126, "comesFrom", ["n"], [108]], ["n", 161, "comesFrom", ["n"], [108]], ["n", 238, "comesFrom", ["n"], [207]], ["n", 226, "comesFrom", ["n"], [207]], ["input", 131, "comesFrom", ["input"], [115]], ["input", 149, "comesFrom", ["input"], [115]], ["input", 29, "comesFrom", ["input"], [17]], ["input", 45, "comesFrom", ["input"], [17]], ["input", 39, "comesFrom", ["input"], [17]], ["input", 69, "comesFrom", ["input"], [17]], ["tmp", 91, "comesFrom", ["tmp"], [37]], ["tmp", 66, "comesFrom", ["tmp"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; void push ( Node * * head_ref , Node * node ) { node -> right = ( * head_ref ) ; node -> left = NULL ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> left = node ; ( * head_ref ) = node ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << \" ▁ \" ; node = node -> right ; } } void spiralLevelOrder ( Node * root ) { if ( root == NULL ) return ; deque < Node * > q ; q . push_front ( root ) ; stack < Node * > stk ; int level = 0 ; while ( ! q . empty ( ) ) { int nodeCount = q . size ( ) ; if ( level & 1 ) { while ( nodeCount > 0 ) { Node * node = q . front ( ) ; q . pop_front ( ) ; stk . push ( node ) ; if ( node -> left != NULL ) q . push_back ( node -> left ) ; if ( node -> right != NULL ) q . push_back ( node -> right ) ; nodeCount -- ; } } else { while ( nodeCount > 0 ) { Node * node = q . back ( ) ; q . pop_back ( ) ; stk . push ( node ) ; if ( node -> right != NULL ) q . push_front ( node -> right ) ; if ( node -> left != NULL ) q . push_front ( node -> left ) ; nodeCount -- ; } } level ++ ; } Node * head = NULL ; while ( ! stk . empty ( ) ) { push ( & head , stk . top ( ) ) ; stk . pop ( ) ; } cout << \" Created ▁ DLL ▁ is : STRNEWLINE \" ; printList ( head ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> left -> right = newNode ( 13 ) ; root -> right -> right -> left = newNode ( 14 ) ; spiralLevelOrder ( root ) ; return 0 ; }", "docstring": "Convert a Binary Tree into Doubly Linked List in spiral fashion | c ++ program to convert Binary Tree into Doubly Linked List where the nodes are represented spirally . ; A Binary Tree Node ; Given a reference to the head of a list and a node , inserts the node on the front of the list . ; Make right of given node as head and left as NULL ; change left of head node to given node ; move the head to point to the given node ; Function to prints contents of DLL ; Function to print corner node at each level ; Base Case ; Create an empty deque for doing spiral level order traversal and enqueue root ; create a stack to store Binary Tree nodes to insert into DLL later ; nodeCount indicates number of Nodes at current level . ; Dequeue all Nodes of current level and Enqueue all Nodes of next level odd level ; dequeue node from front & push it to stack ; insert its left and right children in the back of the deque ; even level ; dequeue node from the back & push it to stack ; inserts its right and left children in the front of the deque ; head pointer for DLL ; pop all nodes from stack and push them in the beginning of the list ; Utility function to create a new tree Node ; Driver program to test above functions ; Let us create binary tree shown in above diagram ; root -> right -> left -> left = newNode ( 12 ) ; ; root -> right -> right -> right = newNode ( 15 ) ;", "dfg": [["data", 388, "comesFrom", ["data"], [374]], ["data", 386, "comesFrom", ["data"], [374]], ["node", 104, "comesFrom", ["node"], [102]], ["node", 187, "comesFrom", ["node"], [102]], ["node", 205, "comesFrom", ["node"], [102]], ["node", 210, "comesFrom", ["node"], [102]], ["node", 227, "comesFrom", ["node"], [102]], ["node", 258, "comesFrom", ["node"], [102]], ["node", 276, "comesFrom", ["node"], [102]], ["node", 220, "comesFrom", ["node"], [102]], ["node", 237, "comesFrom", ["node"], [102]], ["node", 281, "comesFrom", ["node"], [102]], ["node", 298, "comesFrom", ["node"], [102]], ["node", 291, "comesFrom", ["node"], [102]], ["node", 308, "comesFrom", ["node"], [102]], ["q", 133, "comesFrom", ["q"], [131]], ["q", 155, "comesFrom", ["q"], [131]], ["q", 165, "comesFrom", ["q"], [131]], ["q", 195, "comesFrom", ["q"], [131]], ["q", 189, "comesFrom", ["q"], [131]], ["q", 216, "comesFrom", ["q"], [131]], ["q", 233, "comesFrom", ["q"], [131]], ["q", 266, "comesFrom", ["q"], [131]], ["q", 260, "comesFrom", ["q"], [131]], ["q", 287, "comesFrom", ["q"], [131]], ["q", 304, "comesFrom", ["q"], [131]], ["level", 318, "comesFrom", ["level"], [148]], ["level", 173, "comesFrom", ["level"], [148]], ["stk", 331, "comesFrom", ["stk"], [145]], ["stk", 350, "comesFrom", ["stk"], [145]], ["stk", 343, "comesFrom", ["stk"], [145]], ["stk", 201, "comesFrom", ["stk"], [145]], ["stk", 272, "comesFrom", ["stk"], [145]], ["nodeCount", 180, "comesFrom", ["nodeCount"], [163]], ["nodeCount", 242, "comesFrom", ["nodeCount"], [163]], ["nodeCount", 251, "comesFrom", ["nodeCount"], [163]], ["nodeCount", 313, "comesFrom", ["nodeCount"], [163]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverseWords ( string str ) { stack < char > st ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( str [ i ] != ' ▁ ' ) st . push ( str [ i ] ) ; else { while ( st . empty ( ) == false ) { cout << st . top ( ) ; st . pop ( ) ; } cout << \" ▁ \" ; } } while ( st . empty ( ) == false ) { cout << st . top ( ) ; st . pop ( ) ; } } int main ( ) { string str = \" Geeks ▁ for ▁ Geeks \" ; reverseWords ( str ) ; return 0 ; }", "docstring": "Reverse individual words | C ++ program to reverse individual words in a given string using STL list ; reverses individual words of a string ; Traverse given string and push all characters to stack until we see a space . ; When we see a space , we print contents of stack . ; Since there may not be space after last word . ; Driver program to test function", "dfg": [["i", 27, "comesFrom", ["i"], [23]], ["i", 36, "comesFrom", ["i"], [23]], ["i", 43, "comesFrom", ["i"], [23]], ["i", 58, "comesFrom", ["i"], [23]], ["str", 139, "comesFrom", ["str"], [131]], ["str", 29, "comesFrom", ["str"], [11]], ["str", 41, "comesFrom", ["str"], [11]], ["str", 56, "comesFrom", ["str"], [11]], ["st", 100, "comesFrom", ["st"], [18]], ["st", 117, "comesFrom", ["st"], [18]], ["st", 52, "comesFrom", ["st"], [18]], ["st", 111, "comesFrom", ["st"], [18]], ["st", 66, "comesFrom", ["st"], [18]], ["st", 83, "comesFrom", ["st"], [18]], ["st", 77, "comesFrom", ["st"], [18]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define MAXN  100005 NEW_LINE using namespace std ; void makeNext ( int arr [ ] , int n , int nextBig [ ] ) { stack < pair < int , int > > s ; for ( int i = n - 1 ; i >= 0 ; i -- ) { nextBig [ i ] = i ; while ( ! s . empty ( ) && s . top ( ) . first < arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) nextBig [ i ] = s . top ( ) . second ; s . push ( pair < int , int > ( arr [ i ] , i ) ) ; } } void makePrev ( int arr [ ] , int n , int prevBig [ ] ) { stack < pair < int , int > > s ; for ( int i = 0 ; i < n ; i ++ ) { prevBig [ i ] = -1 ; while ( ! s . empty ( ) && s . top ( ) . first < arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) prevBig [ i ] = s . top ( ) . second ; s . push ( pair < int , int > ( arr [ i ] , i ) ) ; } } int wrapper ( int arr [ ] , int n ) { int nextBig [ MAXN ] ; int prevBig [ MAXN ] ; int maxi [ MAXN ] ; int ans = 0 ; makePrev ( arr , n , prevBig ) ; makeNext ( arr , n , nextBig ) ; for ( int i = 0 ; i < n ; i ++ ) if ( nextBig [ i ] != i ) maxi [ nextBig [ i ] - i ] = max ( maxi [ nextBig [ i ] - i ] , i - prevBig [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) ans += maxi [ i ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << wrapper ( arr , n ) << endl ; return 0 ; }", "docstring": "Count subarrays where second highest lie before highest | C ++ program to count number of distinct instance where second highest number lie before highest number in all subarrays . ; Finding the next greater element of the array . ; Finding the previous greater element of the array . ; Wrapper Function ; Finding previous largest element ; Finding next largest element ; Driven Program", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaxArea ( int hist [ ] , int n ) { stack < int > s ; int max_area = 0 ; int tp ; int area_with_top ; int i = 0 ; while ( i < n ) { if ( s . empty ( ) || hist [ s . top ( ) ] <= hist [ i ] ) s . push ( i ++ ) ; else { tp = s . top ( ) ; s . pop ( ) ; area_with_top = hist [ tp ] * ( s . empty ( ) ? i : i - s . top ( ) - 1 ) ; if ( max_area < area_with_top ) max_area = area_with_top ; } } while ( s . empty ( ) == false ) { tp = s . top ( ) ; s . pop ( ) ; area_with_top = hist [ tp ] * ( s . empty ( ) ? i : i - s . top ( ) - 1 ) ; if ( max_area < area_with_top ) max_area = area_with_top ; } return max_area ; } int main ( ) { int hist [ ] = { 6 , 2 , 5 , 4 , 5 , 1 , 6 } ; int n = sizeof ( hist ) / sizeof ( hist [ 0 ] ) ; cout << \" Maximum ▁ area ▁ is ▁ \" << getMaxArea ( hist , n ) ; return 0 ; }", "docstring": "Largest Rectangular Area in a Histogram | Set 2 | C ++ program to find maximum rectangular area in linear time ; The main function to find the maximum rectangular area under given histogram with n bars ; Create an empty stack . The stack holds indexes of hist [ ] array . The bars stored in stack are always in increasing order of their heights . ; Initialize max area ; To store top of stack ; To store area with top bar as the smallest bar ; Run through all bars of given histogram ; If this bar is higher than the bar on top stack , push it to stack ; If this bar is lower than top of stack , then calculate area of rectangle with stack top as the smallest ( or minimum height ) bar . ' i ' is ' right ▁ index ' for the top and element before top in stack is ' left ▁ index ' ; store the top index ; pop the top ; Calculate the area with hist [ tp ] stack as smallest bar ; update max area , if needed ; Now pop the remaining bars from stack and calculate area with every popped bar as the smallest bar ; Driver program to test above function", "dfg": [["max_area", 197, "comesFrom", ["max_area"], [191]], ["max_area", 187, "comesFrom", ["max_area"], [127]], ["max_area", 123, "comesFrom", ["max_area"], [26]], ["i", 43, "comesFrom", ["i"], [37]], ["i", 74, "comesFrom", ["i"], [37]], ["i", 172, "comesFrom", ["i"], [37]], ["i", 67, "comesFrom", ["i"], [37]], ["i", 174, "comesFrom", ["i"], [37]], ["i", 108, "comesFrom", ["i"], [37]], ["i", 110, "comesFrom", ["i"], [37]], ["n", 45, "comesFrom", ["n"], [16]], ["n", 252, "comesFrom", ["n"], [227]], ["s", 135, "comesFrom", ["s"], [23]], ["s", 152, "comesFrom", ["s"], [23]], ["s", 70, "comesFrom", ["s"], [23]], ["s", 146, "comesFrom", ["s"], [23]], ["s", 50, "comesFrom", ["s"], [23]], ["s", 88, "comesFrom", ["s"], [23]], ["s", 82, "comesFrom", ["s"], [23]], ["s", 166, "comesFrom", ["s"], [23]], ["s", 58, "comesFrom", ["s"], [23]], ["s", 176, "comesFrom", ["s"], [23]], ["s", 102, "comesFrom", ["s"], [23]], ["s", 112, "comesFrom", ["s"], [23]], ["area_with_top", 189, "comesFrom", ["area_with_top"], [158]], ["area_with_top", 193, "comesFrom", ["area_with_top"], [158]], ["area_with_top", 125, "comesFrom", ["area_with_top"], [94]], ["area_with_top", 129, "comesFrom", ["area_with_top"], [94]], ["tp", 162, "comesFrom", ["tp"], [144]], ["tp", 98, "comesFrom", ["tp"], [80]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { cout << \" Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ \" << from_rod << \" ▁ to ▁ rod ▁ \" << to_rod << endl ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; cout << \" Move ▁ disk ▁ \" << n << \" ▁ from ▁ rod ▁ \" << from_rod << \" ▁ to ▁ rod ▁ \" << to_rod << endl ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; } int main ( ) { int n = 4 ; towerOfHanoi ( n , ' A ' , ' C ' , ' B ' ) ; return 0 ; }", "docstring": "Program for Tower of Hanoi | C ++ recursive function to solve tower of hanoi puzzle ; Driver code ; Number of disks ; A , B and C are names of rods", "dfg": [["n", 25, "comesFrom", ["n"], [11]], ["n", 110, "comesFrom", ["n"], [104]], ["n", 51, "comesFrom", ["n"], [11]], ["n", 86, "comesFrom", ["n"], [11]], ["n", 68, "comesFrom", ["n"], [11]], ["from_rod", 55, "comesFrom", ["from_rod"], [14]], ["from_rod", 94, "comesFrom", ["from_rod"], [14]], ["from_rod", 74, "comesFrom", ["from_rod"], [14]], ["from_rod", 36, "comesFrom", ["from_rod"], [14]], ["aux_rod", 57, "comesFrom", ["aux_rod"], [20]], ["aux_rod", 90, "comesFrom", ["aux_rod"], [20]], ["to_rod", 59, "comesFrom", ["to_rod"], [17]], ["to_rod", 80, "comesFrom", ["to_rod"], [17]], ["to_rod", 92, "comesFrom", ["to_rod"], [17]], ["to_rod", 42, "comesFrom", ["to_rod"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMaxOfMin ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = INT_MIN ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } cout << maxOfMin << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMaxOfMin ( arr , n ) ; return 0 ; }", "docstring": "Find maximum of minimum for every window size in a given array | A naive method to find maximum of minimum of all windows of different sizes ; Consider all windows of different sizes starting from size 1 ; Initialize max of min for current window size k ; Traverse through all windows of current size k ; Find minimum of current window ; Update maxOfMin if required ; Print max of min for current window size ; Driver program", "dfg": [["k", 26, "comesFrom", ["k"], [22]], ["k", 30, "comesFrom", ["k"], [22]], ["k", 50, "comesFrom", ["k"], [22]], ["k", 73, "comesFrom", ["k"], [22]], ["n", 28, "comesFrom", ["n"], [16]], ["n", 167, "comesFrom", ["n"], [148]], ["n", 48, "comesFrom", ["n"], [16]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 52, "comesFrom", ["i"], [42]], ["i", 61, "comesFrom", ["i"], [42]], ["i", 83, "comesFrom", ["i"], [42]], ["i", 94, "comesFrom", ["i"], [42]], ["maxOfMin", 113, "comesFrom", ["maxOfMin"], [106]], ["maxOfMin", 104, "comesFrom", ["maxOfMin"], [35]], ["j", 71, "comesFrom", ["j"], [67]], ["j", 75, "comesFrom", ["j"], [67]], ["j", 85, "comesFrom", ["j"], [67]], ["j", 96, "comesFrom", ["j"], [67]], ["min", 102, "comesFrom", ["min"], [90]], ["min", 108, "comesFrom", ["min"], [90]], ["min", 88, "comesFrom", ["min"], [57]]]}
{"code": "#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; void printMaxOfMin ( int arr [ ] , int n ) { stack < int > s ; int left [ n + 1 ] ; int right [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = -1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . top ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . top ( ) ; s . push ( i ) ; } int ans [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) cout << ans [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMaxOfMin ( arr , n ) ; return 0 ; }", "docstring": "Find maximum of minimum for every window size in a given array | An efficient C ++ program to find maximum of all minimums of windows of different sizes ; Used to find previous and next smaller ; Arrays to store previous and next smaller ; Initialize elements of left [ ] and right [ ] ; Fill elements of left [ ] using logic discussed on www . geeksforgeeks . org / next - greater - element / https : ; Empty the stack as stack is going to be used for right [ ] ; Fill elements of right [ ] using same logic ; Create and initialize answer array ; Fill answer array by comparing minimums of all lengths computed using left [ ] and right [ ] ; length of the interval ; arr [ i ] is a possible answer for this length ' len ' interval , check if arr [ i ] is more than max for ' len ' ; Some entries in ans [ ] may not be filled yet . Fill them by taking values from right side of ans [ ] ; Print the result ; Driver program", "dfg": [["i", 51, "comesFrom", ["i"], [47]], ["i", 55, "comesFrom", ["i"], [47]], ["i", 81, "comesFrom", ["i"], [77]], ["i", 85, "comesFrom", ["i"], [77]], ["i", 170, "comesFrom", ["i"], [164]], ["i", 174, "comesFrom", ["i"], [164]], ["i", 250, "comesFrom", ["i"], [246]], ["i", 254, "comesFrom", ["i"], [246]], ["i", 271, "comesFrom", ["i"], [267]], ["i", 275, "comesFrom", ["i"], [267]], ["i", 322, "comesFrom", ["i"], [316]], ["i", 326, "comesFrom", ["i"], [316]], ["i", 356, "comesFrom", ["i"], [352]], ["i", 360, "comesFrom", ["i"], [352]], ["i", 142, "comesFrom", ["i"], [77]], ["i", 231, "comesFrom", ["i"], [164]], ["i", 259, "comesFrom", ["i"], [246]], ["i", 331, "comesFrom", ["i"], [316]], ["i", 61, "comesFrom", ["i"], [47]], ["i", 68, "comesFrom", ["i"], [47]], ["i", 367, "comesFrom", ["i"], [352]], ["i", 129, "comesFrom", ["i"], [77]], ["i", 218, "comesFrom", ["i"], [164]], ["i", 338, "comesFrom", ["i"], [316]], ["i", 109, "comesFrom", ["i"], [77]], ["i", 198, "comesFrom", ["i"], [164]], ["i", 284, "comesFrom", ["i"], [267]], ["i", 289, "comesFrom", ["i"], [267]], ["i", 308, "comesFrom", ["i"], [267]], ["i", 343, "comesFrom", ["i"], [316]], ["n", 53, "comesFrom", ["n"], [19]], ["n", 83, "comesFrom", ["n"], [19]], ["n", 252, "comesFrom", ["n"], [19]], ["n", 273, "comesFrom", ["n"], [19]], ["n", 358, "comesFrom", ["n"], [19]], ["n", 31, "comesFrom", ["n"], [19]], ["n", 39, "comesFrom", ["n"], [19]], ["n", 238, "comesFrom", ["n"], [19]], ["n", 421, "comesFrom", ["n"], [402]], ["n", 71, "comesFrom", ["n"], [19]], ["n", 166, "comesFrom", ["n"], [19]], ["n", 318, "comesFrom", ["n"], [19]], ["s", 155, "comesFrom", ["s"], [26]], ["s", 138, "comesFrom", ["s"], [26]], ["s", 149, "comesFrom", ["s"], [26]], ["s", 227, "comesFrom", ["s"], [26]], ["s", 112, "comesFrom", ["s"], [26]], ["s", 201, "comesFrom", ["s"], [26]], ["s", 121, "comesFrom", ["s"], [26]], ["s", 132, "comesFrom", ["s"], [26]], ["s", 210, "comesFrom", ["s"], [26]], ["s", 221, "comesFrom", ["s"], [26]], ["s", 92, "comesFrom", ["s"], [26]], ["s", 181, "comesFrom", ["s"], [26]], ["s", 100, "comesFrom", ["s"], [26]], ["s", 189, "comesFrom", ["s"], [26]], ["len", 296, "comesFrom", ["len"], [280]], ["len", 303, "comesFrom", ["len"], [280]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxLen ( string str ) { int n = str . length ( ) ; stack < int > stk ; stk . push ( -1 ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) stk . push ( i ) ; else { if ( ! stk . empty ( ) ) { stk . pop ( ) ; } if ( ! stk . empty ( ) ) result = max ( result , i - stk . top ( ) ) ; else stk . push ( i ) ; } } return result ; } int main ( ) { string str = \" ( ( ( ) ( ) \" ; cout << findMaxLen ( str ) << endl ; str = \" ( ) ( ( ) ) ) ) ) \" ; cout << findMaxLen ( str ) << endl ; return 0 ; }", "docstring": "Length of the longest valid substring | C ++ program to find length of the longest valid substring ; method to get length of the longest valid ; Create a stack and push - 1 as initial index to it . ; Initialize result ; Traverse all characters of given string ; If opening bracket , push index of it ; If closing bracket , i . e . , str [ i ] = ' ) ' ; Pop the previous opening bracket 's index ; Check if this length formed with base of current valid substring is more than max so far ; If stack is empty . push current index as base for next valid substring ( if any ) ; Driver code ; Function call ; Function call", "dfg": [["result", 130, "comesFrom", ["result"], [104]], ["result", 108, "comesFrom", ["result"], [104]], ["i", 48, "comesFrom", ["i"], [44]], ["i", 52, "comesFrom", ["i"], [44]], ["i", 73, "comesFrom", ["i"], [44]], ["i", 60, "comesFrom", ["i"], [44]], ["i", 124, "comesFrom", ["i"], [44]], ["i", 110, "comesFrom", ["i"], [44]], ["n", 50, "comesFrom", ["n"], [15]], ["stk", 29, "comesFrom", ["stk"], [27]], ["stk", 69, "comesFrom", ["stk"], [27]], ["stk", 81, "comesFrom", ["stk"], [27]], ["stk", 88, "comesFrom", ["stk"], [27]], ["stk", 98, "comesFrom", ["stk"], [27]], ["stk", 120, "comesFrom", ["stk"], [27]], ["stk", 112, "comesFrom", ["stk"], [27]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 149, "comesFrom", ["str"], [139]], ["str", 164, "comesFrom", ["str"], [154]], ["str", 58, "comesFrom", ["str"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define N  12 NEW_LINE using namespace std ; int dfs ( vector < int > tree [ N ] , int visit [ N ] , int * ans , int node ) { int num = 0 , temp = 0 ; visit [ node ] = 1 ; for ( int i = 0 ; i < tree [ node ] . size ( ) ; i ++ ) { if ( visit [ tree [ node ] [ i ] ] == 0 ) { temp = dfs ( tree , visit , ans , tree [ node ] [ i ] ) ; ( temp % 2 ) ? ( num += temp ) : ( ( * ans ) ++ ) ; } } return num + 1 ; } int minEdge ( vector < int > tree [ N ] , int n ) { int visit [ n + 2 ] ; int ans = 0 ; memset ( visit , 0 , sizeof visit ) ; dfs ( tree , visit , & ans , 1 ) ; return ans ; } int main ( ) { int n = 10 ; vector < int > tree [ n + 2 ] ; tree [ 1 ] . push_back ( 3 ) ; tree [ 3 ] . push_back ( 1 ) ; tree [ 1 ] . push_back ( 6 ) ; tree [ 6 ] . push_back ( 1 ) ; tree [ 1 ] . push_back ( 2 ) ; tree [ 2 ] . push_back ( 1 ) ; tree [ 3 ] . push_back ( 4 ) ; tree [ 4 ] . push_back ( 3 ) ; tree [ 6 ] . push_back ( 8 ) ; tree [ 8 ] . push_back ( 6 ) ; tree [ 2 ] . push_back ( 7 ) ; tree [ 7 ] . push_back ( 2 ) ; tree [ 2 ] . push_back ( 5 ) ; tree [ 5 ] . push_back ( 2 ) ; tree [ 4 ] . push_back ( 9 ) ; tree [ 9 ] . push_back ( 4 ) ; tree [ 4 ] . push_back ( 10 ) ; tree [ 10 ] . push_back ( 4 ) ; cout << minEdge ( tree , n ) << endl ; return 0 ; }", "docstring": "Convert a tree to forest of even nodes | C ++ program to find maximum number to be removed to convert a tree into forest containing trees of even number of nodes ; Return the number of nodes of subtree having node as a root . ; Mark node as visited . ; Traverse the adjacency list to find non - visited node . ; Finding number of nodes of the subtree of a subtree . ; If nodes are even , increment number of edges to removed . Else leave the node as child of subtree . ; Return the maximum number of edge to remove to make forest . ; Driven Program", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxLen ( string s ) { if ( s . length ( ) <= 1 ) return 0 ; int curMax = 0 ; vector < int > longest ( s . size ( ) , 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ) ' && i - longest [ i - 1 ] - 1 >= 0 && s [ i - longest [ i - 1 ] - 1 ] == ' ( ' ) { longest [ i ] = longest [ i - 1 ] + 2 + ( ( i - longest [ i - 1 ] - 2 >= 0 ) ? longest [ i - longest [ i - 1 ] - 2 ] : 0 ) ; curMax = max ( longest [ i ] , curMax ) ; } } return curMax ; } int main ( ) { string str = \" ( ( ( ) ( ) \" ; cout << findMaxLen ( str ) << endl ; str = \" ( ) ( ( ) ) ) ) ) \" ; cout << findMaxLen ( str ) << endl ; return 0 ; }", "docstring": "Length of the longest valid substring | C ++ program to find length of the longest valid substring ; Initialize curMax to zero ; Iterate over the string starting from second index ; Driver code ; Function call ; Function call", "dfg": [["curMax", 175, "comesFrom", ["curMax"], [160]], ["curMax", 169, "comesFrom", ["curMax"], [160]], ["i", 54, "comesFrom", ["i"], [50]], ["i", 62, "comesFrom", ["i"], [50]], ["i", 115, "comesFrom", ["i"], [50]], ["i", 70, "comesFrom", ["i"], [50]], ["i", 79, "comesFrom", ["i"], [50]], ["i", 94, "comesFrom", ["i"], [50]], ["i", 166, "comesFrom", ["i"], [50]], ["i", 120, "comesFrom", ["i"], [50]], ["i", 83, "comesFrom", ["i"], [50]], ["i", 98, "comesFrom", ["i"], [50]], ["i", 129, "comesFrom", ["i"], [50]], ["i", 145, "comesFrom", ["i"], [50]], ["i", 133, "comesFrom", ["i"], [50]], ["i", 149, "comesFrom", ["i"], [50]], ["s", 56, "comesFrom", ["s"], [11]], ["s", 16, "comesFrom", ["s"], [11]], ["s", 38, "comesFrom", ["s"], [11]], ["s", 92, "comesFrom", ["s"], [11]], ["s", 68, "comesFrom", ["s"], [11]], ["str", 194, "comesFrom", ["str"], [184]], ["str", 209, "comesFrom", ["str"], [199]], ["longest", 113, "comesFrom", ["longest"], [36]], ["longest", 118, "comesFrom", ["longest"], [36]], ["longest", 164, "comesFrom", ["longest"], [36]], ["longest", 81, "comesFrom", ["longest"], [36]], ["longest", 143, "comesFrom", ["longest"], [36]], ["longest", 96, "comesFrom", ["longest"], [36]], ["longest", 131, "comesFrom", ["longest"], [36]], ["longest", 147, "comesFrom", ["longest"], [36]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( string s , int n ) { int left = 0 , right = 0 , maxlength = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) left ++ ; else right ++ ; if ( left == right ) maxlength = max ( maxlength , 2 * right ) ; else if ( right > left ) left = right = 0 ; } left = right = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ( ' ) left ++ ; else right ++ ; if ( left == right ) maxlength = max ( maxlength , 2 * left ) ; else if ( left > right ) left = right = 0 ; } return maxlength ; } int main ( ) { cout << solve ( \" ( ( ( ) ( ) ( ) ( ) ( ( ( ( ) ) \" , 16 ) ; return 0 ; }", "docstring": "Length of the longest valid substring | C ++ program to implement the above approach ; Function to return the length of the longest valid substring ; Variables for left and right counter . maxlength to store the maximum length found so far ; Iterating the string from left to right ; If \" ( \" is encountered , then left counter is incremented else right counter is incremented ; Whenever left is equal to right , it signifies that the subsequence is valid and ; Reseting the counters when the subsequence becomes invalid ; Iterating the string from right to left ; If \" ( \" is encountered , then left counter is incremented else right counter is incremented ; Whenever left is equal to right , it signifies that the subsequence is valid and ; Reseting the counters when the subsequence becomes invalid ; Driver code ; Function call", "dfg": [["maxlength", 171, "comesFrom", ["maxlength"], [145]], ["maxlength", 75, "comesFrom", ["maxlength"], [71]], ["maxlength", 149, "comesFrom", ["maxlength"], [145]], ["i", 37, "comesFrom", ["i"], [33]], ["i", 41, "comesFrom", ["i"], [33]], ["i", 111, "comesFrom", ["i"], [105]], ["i", 115, "comesFrom", ["i"], [105]], ["i", 49, "comesFrom", ["i"], [33]], ["i", 123, "comesFrom", ["i"], [105]], ["n", 39, "comesFrom", ["n"], [14]], ["n", 107, "comesFrom", ["n"], [14]], ["left", 58, "comesFrom", ["left"], [18]], ["left", 67, "comesFrom", ["left"], [18]], ["left", 132, "comesFrom", ["left"], [96]], ["left", 141, "comesFrom", ["left"], [96]], ["left", 87, "comesFrom", ["left"], [18]], ["left", 159, "comesFrom", ["left"], [96]], ["left", 153, "comesFrom", ["left"], [96]], ["right", 69, "comesFrom", ["right"], [22]], ["right", 143, "comesFrom", ["right"], [98]], ["right", 62, "comesFrom", ["right"], [22]], ["right", 136, "comesFrom", ["right"], [98]], ["right", 85, "comesFrom", ["right"], [22]], ["right", 161, "comesFrom", ["right"], [98]], ["right", 79, "comesFrom", ["right"], [22]], ["s", 47, "comesFrom", ["s"], [11]], ["s", 121, "comesFrom", ["s"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkRedundancy ( string & str ) { stack < char > st ; for ( auto & ch : str ) { if ( ch == ' ) ' ) { char top = st . top ( ) ; st . pop ( ) ; bool flag = true ; while ( ! st . empty ( ) and top != ' ( ' ) { if ( top == ' + ' top == ' - ' top == ' * ' top == ' / ' ) flag = false ; top = st . top ( ) ; st . pop ( ) ; } if ( flag == true ) return true ; } else st . push ( ch ) ; } return false ; } void findRedundant ( string & str ) { bool ans = checkRedundancy ( str ) ; if ( ans == true ) cout << \" Yes STRNEWLINE \" ; else cout << \" No STRNEWLINE \" ; } int main ( ) { string str = \" ( ( a + b ) ) \" ; findRedundant ( str ) ; str = \" ( a + ( b ) / c ) \" ; findRedundant ( str ) ; str = \" ( a + b * ( c - d ) ) \" ; findRedundant ( str ) ; return 0 ; }", "docstring": "Expression contains redundant bracket or not | C ++ Program to check whether valid expression is redundant or not ; Function to check redundant brackets in a balanced expression ; create a stack of characters ; Iterate through the given expression ; if current character is close parenthesis ' ) ' ; If immediate pop have open parenthesis ' ( ' duplicate brackets found ; Check for operators in expression ; Fetch top element of stack ; If operators not found ; push open parenthesis ' ( ' , ; operators and operands to stack ; Function to check redundant brackets ; Driver code", "dfg": [["str", 202, "comesFrom", ["str"], [194]], ["str", 213, "comesFrom", ["str"], [205]], ["str", 224, "comesFrom", ["str"], [216]], ["ans", 170, "comesFrom", ["ans"], [161]], ["st", 50, "comesFrom", ["st"], [19]], ["st", 140, "comesFrom", ["st"], [19]], ["st", 44, "comesFrom", ["st"], [19]], ["st", 122, "comesFrom", ["st"], [19]], ["st", 64, "comesFrom", ["st"], [19]], ["st", 116, "comesFrom", ["st"], [19]], ["flag", 131, "comesFrom", ["flag"], [110]], ["top", 46, "comesFrom", ["top"], [42]], ["top", 70, "comesFrom", ["top"], [42]], ["top", 102, "comesFrom", ["top"], [42]], ["top", 118, "comesFrom", ["top"], [114]], ["top", 95, "comesFrom", ["top"], [42]], ["top", 81, "comesFrom", ["top"], [42]], ["top", 88, "comesFrom", ["top"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; bool adjSign ( string s , int i ) { if ( i == 0 ) return true ; if ( s [ i - 1 ] == ' - ' ) return false ; return true ; } ; void eval ( string s , vector < int > & v , bool add ) { stack < bool > stk ; stk . push ( true ) ; int i = 0 ; while ( s [ i ] != ' \\0' ) { if ( s [ i ] == ' + ' s [ i ] == ' - ' ) { i ++ ; continue ; } if ( s [ i ] == ' ( ' ) { if ( adjSign ( s , i ) ) stk . push ( stk . top ( ) ) ; else stk . push ( ! stk . top ( ) ) ; } else if ( s [ i ] == ' ) ' ) stk . pop ( ) ; else { if ( stk . top ( ) ) v [ s [ i ] - ' a ' ] += ( adjSign ( s , i ) ? add ? 1 : -1 : add ? -1 : 1 ) ; else v [ s [ i ] - ' a ' ] += ( adjSign ( s , i ) ? add ? -1 : 1 : add ? 1 : -1 ) ; } i ++ ; } } ; bool areSame ( string expr1 , string expr2 ) { vector < int > v ( MAX_CHAR , 0 ) ; eval ( expr1 , v , true ) ; eval ( expr2 , v , false ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( v [ i ] != 0 ) return false ; return true ; } int main ( ) { string expr1 = \" - ( a + b + c ) \" , expr2 = \" - a - b - c \" ; if ( areSame ( expr1 , expr2 ) ) cout << \" Yes STRNEWLINE \" ; else cout << \" No STRNEWLINE \" ; return 0 ; }", "docstring": "Check if two expressions with brackets are same | CPP program to check if two expressions evaluate to same . ; Return local sign of the operand . For example , in the expr a - b - ( c ) , local signs of the operands are + a , - b , + c ; Evaluate expressions into the count vector of the 26 alphabets . If add is true , then add count to the count vector of the alphabets , else remove count from the count vector . ; stack stores the global sign for operands . ; + means true global sign is positive initially ; global sign for the bracket is pushed to the stack ; global sign is popped out which was pushed in for the last bracket ; global sign is positive ( we use different values in two calls of functions so that we finally check if all vector elements are 0. ; global sign is negative here ; Returns true if expr1 and expr2 represent same expressions ; Create a vector for all operands and initialize the vector as 0. ; Put signs of all operands in expr1 ; Subtract signs of operands in expr2 ; If expressions are same , vector must be 0. ; Driver code", "dfg": [["i", 334, "comesFrom", ["i"], [330]], ["i", 338, "comesFrom", ["i"], [330]], ["i", 25, "comesFrom", ["i"], [20]], ["i", 282, "comesFrom", ["i"], [86]], ["i", 94, "comesFrom", ["i"], [86]], ["i", 36, "comesFrom", ["i"], [20]], ["i", 126, "comesFrom", ["i"], [86]], ["i", 345, "comesFrom", ["i"], [330]], ["i", 136, "comesFrom", ["i"], [86]], ["i", 106, "comesFrom", ["i"], [86]], ["i", 116, "comesFrom", ["i"], [86]], ["i", 152, "comesFrom", ["i"], [86]], ["i", 185, "comesFrom", ["i"], [86]], ["i", 229, "comesFrom", ["i"], [86]], ["i", 214, "comesFrom", ["i"], [86]], ["i", 265, "comesFrom", ["i"], [86]], ["i", 250, "comesFrom", ["i"], [86]], ["MAX_CHAR", 336, "comesFrom", ["MAX_CHAR"], [9]], ["MAX_CHAR", 304, "comesFrom", ["MAX_CHAR"], [9]], ["v", 313, "comesFrom", ["v"], [302]], ["v", 322, "comesFrom", ["v"], [302]], ["v", 343, "comesFrom", ["v"], [302]], ["stk", 78, "comesFrom", ["stk"], [76]], ["stk", 155, "comesFrom", ["stk"], [76]], ["stk", 194, "comesFrom", ["stk"], [76]], ["stk", 167, "comesFrom", ["stk"], [76]], ["stk", 159, "comesFrom", ["stk"], [76]], ["stk", 204, "comesFrom", ["stk"], [76]], ["stk", 172, "comesFrom", ["stk"], [76]], ["expr1", 311, "comesFrom", ["expr1"], [292]], ["expr1", 379, "comesFrom", ["expr1"], [363]], ["expr2", 320, "comesFrom", ["expr2"], [295]], ["expr2", 381, "comesFrom", ["expr2"], [369]], ["s", 34, "comesFrom", ["s"], [17]], ["s", 92, "comesFrom", ["s"], [59]], ["s", 134, "comesFrom", ["s"], [59]], ["s", 104, "comesFrom", ["s"], [59]], ["s", 114, "comesFrom", ["s"], [59]], ["s", 150, "comesFrom", ["s"], [59]], ["s", 183, "comesFrom", ["s"], [59]], ["s", 212, "comesFrom", ["s"], [59]], ["s", 227, "comesFrom", ["s"], [59]], ["s", 248, "comesFrom", ["s"], [59]], ["s", 263, "comesFrom", ["s"], [59]], ["add", 232, "comesFrom", ["add"], [69]], ["add", 238, "comesFrom", ["add"], [69]], ["add", 268, "comesFrom", ["add"], [69]], ["add", 274, "comesFrom", ["add"], [69]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void test ( string expression , int index ) { int i ; if ( expression [ index ] != ' [ ' ) { cout << expression << \" , ▁ \" << index << \" : ▁ - 1 STRNEWLINE \" ; return ; } stack < int > st ; for ( i = index ; i < expression . length ( ) ; i ++ ) { if ( expression [ i ] == ' [ ' ) st . push ( expression [ i ] ) ; else if ( expression [ i ] == ' ] ' ) { st . pop ( ) ; if ( st . empty ( ) ) { cout << expression << \" , ▁ \" << index << \" : ▁ \" << i << \" STRNEWLINE \" ; return ; } } } cout << expression << \" , ▁ \" << index << \" : ▁ - 1 STRNEWLINE \" ; } int main ( ) { test ( \" [ ABC [ 23 ] ] [89 ] \" , 0 ) ; test ( \" [ ABC [ 23 ] ] [89 ] \" , 4 ) ; test ( \" [ ABC [ 23 ] ] [89 ] \" , 9 ) ; test ( \" [ ABC [ 23 ] ] [89 ] \" , 1 ) ; return 0 ; }", "docstring": "Find index of closing bracket for a given opening bracket in an expression | CPP program to find index of closing bracket for given opening bracket . ; Function to find index of closing bracket for given opening bracket . ; If index given is invalid and is not an opening bracket . ; Stack to store opening brackets . ; Traverse through string starting from given index . ; If current character is an opening bracket push it in stack . ; If current character is a closing bracket , pop from stack . If stack is empty , then this closing bracket is required bracket . ; If no matching closing bracket is found . ; Driver Code ; should be 8 ; should be 7 ; should be 12 ; No matching bracket", "dfg": [["index", 61, "comesFrom", ["index"], [14]], ["index", 161, "comesFrom", ["index"], [14]], ["index", 24, "comesFrom", ["index"], [14]], ["index", 42, "comesFrom", ["index"], [14]], ["index", 136, "comesFrom", ["index"], [14]], ["i", 63, "comesFrom", ["i"], [59]], ["i", 71, "comesFrom", ["i"], [59]], ["i", 79, "comesFrom", ["i"], [59]], ["i", 94, "comesFrom", ["i"], [59]], ["i", 103, "comesFrom", ["i"], [59]], ["i", 142, "comesFrom", ["i"], [59]], ["expression", 22, "comesFrom", ["expression"], [11]], ["expression", 65, "comesFrom", ["expression"], [11]], ["expression", 155, "comesFrom", ["expression"], [11]], ["expression", 77, "comesFrom", ["expression"], [11]], ["expression", 36, "comesFrom", ["expression"], [11]], ["expression", 92, "comesFrom", ["expression"], [11]], ["expression", 101, "comesFrom", ["expression"], [11]], ["expression", 130, "comesFrom", ["expression"], [11]], ["st", 88, "comesFrom", ["st"], [55]], ["st", 113, "comesFrom", ["st"], [55]], ["st", 121, "comesFrom", ["st"], [55]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int key ) { struct Node * node = new Node ; node -> data = key ; node -> left = node -> right = NULL ; return node ; } void convertTree ( Node * root ) { if ( root == NULL ) return ; convertTree ( root -> left ) ; convertTree ( root -> right ) ; if ( root -> left != NULL && root -> right != NULL ) root -> data = ( root -> left -> data ) & ( root -> right -> data ) ; } void printInorder ( Node * root ) { if ( root == NULL ) return ; printInorder ( root -> left ) ; printf ( \" % d ▁ \" , root -> data ) ; printInorder ( root -> right ) ; } int main ( ) { Node * root = newNode ( 0 ) ; root -> left = newNode ( 1 ) ; root -> right = newNode ( 0 ) ; root -> left -> left = newNode ( 0 ) ; root -> left -> right = newNode ( 1 ) ; root -> right -> left = newNode ( 1 ) ; root -> right -> right = newNode ( 1 ) ; printf ( \" Inorder traversal before conversion \" printInorder ( root ) ; convertTree ( root ) ; printf ( \" Inorder traversal after conversion \" printInorder ( root ) ; return 0 ; }", "docstring": "Convert a given Binary tree to a tree that holds Logical AND property | C ++ code to convert a given binary tree to a tree that holds logical AND property . ; Structure of binary tree ; function to create a new node ; Convert the given tree to a tree where each node is logical AND of its children The main idea is to do Postorder traversal ; first recur on left child ; then recur on right child ; first recur on left child ; then print the data of node ; now recur on right child ; main function ; Create following Binary Tree 1 / \\ 1 0 / \\ / \\ 0 1 1 1", "dfg": [["key", 46, "comesFrom", ["key"], [31]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findDuplicateparenthesis ( string str ) { stack < char > Stack ; for ( char ch : str ) { if ( ch == ' ) ' ) { char top = Stack . top ( ) ; Stack . pop ( ) ; int elementsInside = 0 ; while ( top != ' ( ' ) { elementsInside ++ ; top = Stack . top ( ) ; Stack . pop ( ) ; } if ( elementsInside < 1 ) { return 1 ; } } else Stack . push ( ch ) ; } return false ; } int main ( ) { string str = \" ( ( ( a + ( b ) ) + ( c + d ) ) ) \" ; if ( findDuplicateparenthesis ( str ) ) cout << \" Duplicate ▁ Found ▁ \" ; else cout << \" No ▁ Duplicates ▁ Found ▁ \" ; return 0 ; }", "docstring": "Find if an expression has duplicate parenthesis or not | C ++ program to find duplicate parenthesis in a balanced expression ; Function to find duplicate parenthesis in a balanced expression ; create a stack of characters ; Iterate through the given expression ; if current character is close parenthesis ' ) ' ; pop character from the stack ; stores the number of characters between a closing and opening parenthesis if this count is less than or equal to 1 then the brackets are redundant else not ; push open parenthesis ' ( ' , operators and operands to stack ; No duplicates found ; Driver code ; input balanced expression", "dfg": [["str", 25, "comesFrom", ["str"], [11]], ["str", 129, "comesFrom", ["str"], [119]], ["Stack", 48, "comesFrom", ["Stack"], [18]], ["Stack", 101, "comesFrom", ["Stack"], [18]], ["Stack", 42, "comesFrom", ["Stack"], [18]], ["Stack", 81, "comesFrom", ["Stack"], [18]], ["Stack", 75, "comesFrom", ["Stack"], [18]], ["top", 61, "comesFrom", ["top"], [40]], ["top", 44, "comesFrom", ["top"], [40]], ["top", 77, "comesFrom", ["top"], [73]], ["elementsInside", 90, "comesFrom", ["elementsInside"], [55]], ["elementsInside", 70, "comesFrom", ["elementsInside"], [55]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void nextGreater ( int arr [ ] , int n , int next [ ] , char order ) { stack < int > S ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! S . empty ( ) && ( ( order == ' G ' ) ? arr [ S . top ( ) ] <= arr [ i ] : arr [ S . top ( ) ] >= arr [ i ] ) ) S . pop ( ) ; if ( ! S . empty ( ) ) next [ i ] = S . top ( ) ; else next [ i ] = -1 ; S . push ( i ) ; } } void nextSmallerOfNextGreater ( int arr [ ] , int n ) { int NG [ n ] ; int RS [ n ] ; nextGreater ( arr , n , NG , ' G ' ) ; nextGreater ( arr , n , RS , ' S ' ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( NG [ i ] != -1 && RS [ NG [ i ] ] != -1 ) cout << arr [ RS [ NG [ i ] ] ] << \" ▁ \" ; else cout << \" - 1\" << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 5 , 1 , 9 , 2 , 5 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nextSmallerOfNextGreater ( arr , n ) ; return 0 ; }", "docstring": "Find next Smaller of next Greater in an array | C ++ Program to find Right smaller element of next greater element ; function find Next greater element ; create empty stack ; Traverse all array elements in reverse order order == ' G ' we compute next greater elements of every element order == ' S ' we compute right smaller element of every element ; Keep removing top element from S while the top element is smaller then or equal to arr [ i ] ( if Key is G ) element is greater then or equal to arr [ i ] ( if order is S ) ; store the next greater element of current element ; If all elements in S were smaller than arr [ i ] ; Push this element ; Function to find Right smaller element of next greater element ; stores indexes of next greater elements ; stores indexes of right smaller elements ; Find next greater element Here G indicate next greater element ; Find right smaller element using same function nextGreater ( ) Here S indicate right smaller elements ; If NG [ i ] = = - 1 then there is no smaller element on right side . We can find Right smaller of next greater by arr [ RS [ NG [ i ] ] ] ; Driver program", "dfg": [["i", 42, "comesFrom", ["i"], [36]], ["i", 46, "comesFrom", ["i"], [36]], ["i", 203, "comesFrom", ["i"], [199]], ["i", 207, "comesFrom", ["i"], [199]], ["i", 137, "comesFrom", ["i"], [36]], ["i", 116, "comesFrom", ["i"], [36]], ["i", 128, "comesFrom", ["i"], [36]], ["i", 215, "comesFrom", ["i"], [199]], ["i", 81, "comesFrom", ["i"], [36]], ["i", 95, "comesFrom", ["i"], [36]], ["i", 224, "comesFrom", ["i"], [199]], ["i", 238, "comesFrom", ["i"], [199]], ["n", 157, "comesFrom", ["n"], [151]], ["n", 163, "comesFrom", ["n"], [151]], ["n", 205, "comesFrom", ["n"], [151]], ["n", 170, "comesFrom", ["n"], [151]], ["n", 185, "comesFrom", ["n"], [151]], ["n", 306, "comesFrom", ["n"], [287]], ["n", 38, "comesFrom", ["n"], [16]], ["S", 133, "comesFrom", ["S"], [31]], ["S", 99, "comesFrom", ["S"], [31]], ["S", 108, "comesFrom", ["S"], [31]], ["S", 119, "comesFrom", ["S"], [31]], ["S", 53, "comesFrom", ["S"], [31]], ["S", 72, "comesFrom", ["S"], [31]], ["S", 86, "comesFrom", ["S"], [31]], ["order", 61, "comesFrom", ["order"], [24]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumber ( int n ) { int result = 0 ; stack < int > s ; for ( int i = 1 ; i <= 9 ; i ++ ) { if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . top ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; } int main ( ) { int n = 15 ; cout << countNumber ( n ) << endl ; return 0 ; }", "docstring": "Count natural numbers whose all permutation are greater than that number | C ++ program to count the number less than N , whose all permutation is greater than or equal to the number . ; Return the count of the number having all permutation greater than or equal to the number . ; Pushing 1 to 9 because all number from 1 to 9 have this property . ; take a number from stack and add a digit smaller than last digit of it . ; Driven Code", "dfg": [["result", 131, "comesFrom", ["result"], [15]], ["result", 54, "comesFrom", ["result"], [15]], ["result", 123, "comesFrom", ["result"], [15]], ["i", 32, "comesFrom", ["i"], [28]], ["i", 36, "comesFrom", ["i"], [28]], ["i", 42, "comesFrom", ["i"], [28]], ["i", 51, "comesFrom", ["i"], [28]], ["n", 44, "comesFrom", ["n"], [11]], ["n", 148, "comesFrom", ["n"], [140]], ["n", 113, "comesFrom", ["n"], [11]], ["j", 92, "comesFrom", ["j"], [86]], ["j", 96, "comesFrom", ["j"], [86]], ["j", 107, "comesFrom", ["j"], [86]], ["s", 47, "comesFrom", ["s"], [23]], ["s", 61, "comesFrom", ["s"], [23]], ["s", 77, "comesFrom", ["s"], [23]], ["s", 71, "comesFrom", ["s"], [23]], ["s", 116, "comesFrom", ["s"], [23]], ["tp", 88, "comesFrom", ["tp"], [69]], ["tp", 103, "comesFrom", ["tp"], [69]], ["x", 111, "comesFrom", ["x"], [101]], ["x", 120, "comesFrom", ["x"], [101]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int removeConsecutiveSame ( vector < string > v ) { int n = v . size ( ) ; for ( int i = 0 ; i < n - 1 ; ) { if ( v [ i ] . compare ( v [ i + 1 ] ) == 0 ) { v . erase ( v . begin ( ) + i ) ; v . erase ( v . begin ( ) + i ) ; if ( i > 0 ) i -- ; n = n - 2 ; } else i ++ ; } return v . size ( ) ; } int main ( ) { vector < string > v = { \" tom \" , \" jerry \" , \" jerry \" , \" tom \" } ; cout << removeConsecutiveSame ( v ) ; return 0 ; }", "docstring": "Delete consecutive same words in a sequence | C ++ program to remove consecutive same words ; Function to find the size of manipulated sequence ; Start traversing the sequence ; Compare the current string with next one Erase both if equal ; Erase function delete the element and also shifts other element that 's why  i is not updated ; Update i , as to check from previous element again ; Reduce sequence size ; Increment i , if not equal ; Return modified size ; Driver code", "dfg": [["i", 33, "comesFrom", ["i"], [29]], ["i", 104, "comesFrom", ["i"], [29]], ["i", 89, "comesFrom", ["i"], [29]], ["i", 93, "comesFrom", ["i"], [29]], ["i", 71, "comesFrom", ["i"], [29]], ["i", 84, "comesFrom", ["i"], [29]], ["i", 45, "comesFrom", ["i"], [29]], ["i", 52, "comesFrom", ["i"], [29]], ["n", 35, "comesFrom", ["n"], [18]], ["n", 98, "comesFrom", ["n"], [96]], ["v", 109, "comesFrom", ["v"], [14]], ["v", 20, "comesFrom", ["v"], [14]], ["v", 149, "comesFrom", ["v"], [125]], ["v", 61, "comesFrom", ["v"], [14]], ["v", 74, "comesFrom", ["v"], [14]], ["v", 43, "comesFrom", ["v"], [14]], ["v", 50, "comesFrom", ["v"], [14]], ["v", 65, "comesFrom", ["v"], [14]], ["v", 78, "comesFrom", ["v"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int removeConsecutiveSame ( vector < string > v ) { stack < string > st ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( st . empty ( ) ) st . push ( v [ i ] ) ; else { string str = st . top ( ) ; if ( str . compare ( v [ i ] ) == 0 ) st . pop ( ) ; else st . push ( v [ i ] ) ; } } return st . size ( ) ; } int main ( ) { vector < string > V = { \" ab \" , \" aa \" , \" aa \" , \" bcd \" , \" ab \" } ; cout << removeConsecutiveSame ( V ) ; return 0 ; }", "docstring": "Delete consecutive same words in a sequence | C ++ implementation of above method ; Function to find the size of manipulated sequence ; Start traversing the sequence ; Push the current string if the stack is empty ; compare the current string with stack top if equal , pop the top ; Otherwise push the current string ; Return stack size ; Driver code", "dfg": [["i", 30, "comesFrom", ["i"], [26]], ["i", 38, "comesFrom", ["i"], [26]], ["i", 56, "comesFrom", ["i"], [26]], ["i", 79, "comesFrom", ["i"], [26]], ["i", 98, "comesFrom", ["i"], [26]], ["st", 105, "comesFrom", ["st"], [21]], ["st", 44, "comesFrom", ["st"], [21]], ["st", 50, "comesFrom", ["st"], [21]], ["st", 65, "comesFrom", ["st"], [21]], ["st", 85, "comesFrom", ["st"], [21]], ["st", 92, "comesFrom", ["st"], [21]], ["v", 32, "comesFrom", ["v"], [14]], ["v", 54, "comesFrom", ["v"], [14]], ["v", 77, "comesFrom", ["v"], [14]], ["v", 96, "comesFrom", ["v"], [14]], ["V", 149, "comesFrom", ["V"], [121]], ["str", 73, "comesFrom", ["str"], [63]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string decode ( string str ) { stack < int > integerstack ; stack < char > stringstack ; string temp = \" \" , result = \" \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( str [ i ] >= '0' && str [ i ] <= '9' ) { while ( str [ i ] >= '0' && str [ i ] <= '9' ) { count = count * 10 + str [ i ] - '0' ; i ++ ; } i -- ; integerstack . push ( count ) ; } else if ( str [ i ] == ' ] ' ) { temp = \" \" ; count = 0 ; if ( ! integerstack . empty ( ) ) { count = integerstack . top ( ) ; integerstack . pop ( ) ; } while ( ! stringstack . empty ( ) && stringstack . top ( ) != ' [ ' ) { temp = stringstack . top ( ) + temp ; stringstack . pop ( ) ; } if ( ! stringstack . empty ( ) && stringstack . top ( ) == ' [ ' ) stringstack . pop ( ) ; for ( int j = 0 ; j < count ; j ++ ) result = result + temp ; for ( int j = 0 ; j < result . length ( ) ; j ++ ) stringstack . push ( result [ j ] ) ; result = \" \" ; } else if ( str [ i ] == ' [ ' ) { if ( str [ i - 1 ] >= '0' && str [ i - 1 ] <= '9' ) stringstack . push ( str [ i ] ) ; else { stringstack . push ( str [ i ] ) ; integerstack . push ( 1 ) ; } } else stringstack . push ( str [ i ] ) ; } while ( ! stringstack . empty ( ) ) { result = stringstack . top ( ) + result ; stringstack . pop ( ) ; } return result ; } int main ( ) { string str = \"3 [ b2 [ ca ] ] \" ; cout << decode ( str ) << endl ; return 0 ; }", "docstring": "Decode a string recursively encoded as count followed by substring | C ++ program to decode a string recursively encoded as count followed substring ; Returns decoded string for ' str ' ; Traversing the string ; If number , convert it into number and push it into integerstack . ; If closing bracket ' ] ' , pop elemment until ' [ ' opening bracket is not found in the character stack . ; Repeating the popped string ' temo ' count number of times . ; Push it in the character stack . ; If ' [ ' opening bracket , push it into character stack . ; Pop all the elmenet , make a string and return . ; Driven Program", "dfg": [["result", 416, "comesFrom", ["result"], [398]], ["result", 406, "comesFrom", ["result"], [398]], ["result", 267, "comesFrom", ["result"], [265]], ["result", 280, "comesFrom", ["result"], [265]], ["result", 293, "comesFrom", ["result"], [265]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 54, "comesFrom", ["i"], [42]], ["i", 124, "comesFrom", ["i"], [42]], ["i", 67, "comesFrom", ["i"], [42]], ["i", 76, "comesFrom", ["i"], [42]], ["i", 120, "comesFrom", ["i"], [42]], ["i", 140, "comesFrom", ["i"], [42]], ["i", 88, "comesFrom", ["i"], [42]], ["i", 97, "comesFrom", ["i"], [42]], ["i", 311, "comesFrom", ["i"], [42]], ["i", 113, "comesFrom", ["i"], [42]], ["i", 383, "comesFrom", ["i"], [42]], ["i", 351, "comesFrom", ["i"], [42]], ["i", 325, "comesFrom", ["i"], [42]], ["i", 336, "comesFrom", ["i"], [42]], ["i", 363, "comesFrom", ["i"], [42]], ["str", 48, "comesFrom", ["str"], [11]], ["str", 435, "comesFrom", ["str"], [425]], ["str", 65, "comesFrom", ["str"], [11]], ["str", 74, "comesFrom", ["str"], [11]], ["str", 138, "comesFrom", ["str"], [11]], ["str", 86, "comesFrom", ["str"], [11]], ["str", 95, "comesFrom", ["str"], [11]], ["str", 309, "comesFrom", ["str"], [11]], ["str", 111, "comesFrom", ["str"], [11]], ["str", 381, "comesFrom", ["str"], [11]], ["str", 323, "comesFrom", ["str"], [11]], ["str", 334, "comesFrom", ["str"], [11]], ["str", 349, "comesFrom", ["str"], [11]], ["str", 361, "comesFrom", ["str"], [11]], ["stringstack", 391, "comesFrom", ["stringstack"], [24]], ["stringstack", 408, "comesFrom", ["stringstack"], [24]], ["stringstack", 400, "comesFrom", ["stringstack"], [24]], ["stringstack", 245, "comesFrom", ["stringstack"], [24]], ["stringstack", 289, "comesFrom", ["stringstack"], [24]], ["stringstack", 217, "comesFrom", ["stringstack"], [24]], ["stringstack", 377, "comesFrom", ["stringstack"], [24]], ["stringstack", 188, "comesFrom", ["stringstack"], [24]], ["stringstack", 194, "comesFrom", ["stringstack"], [24]], ["stringstack", 227, "comesFrom", ["stringstack"], [24]], ["stringstack", 233, "comesFrom", ["stringstack"], [24]], ["stringstack", 345, "comesFrom", ["stringstack"], [24]], ["stringstack", 209, "comesFrom", ["stringstack"], [24]], ["stringstack", 357, "comesFrom", ["stringstack"], [24]], ["integerstack", 127, "comesFrom", ["integerstack"], [18]], ["integerstack", 163, "comesFrom", ["integerstack"], [18]], ["integerstack", 178, "comesFrom", ["integerstack"], [18]], ["integerstack", 172, "comesFrom", ["integerstack"], [18]], ["integerstack", 367, "comesFrom", ["integerstack"], [18]], ["count", 131, "comesFrom", ["count"], [105]], ["count", 260, "comesFrom", ["count"], [170]], ["count", 107, "comesFrom", ["count"], [105]], ["j", 258, "comesFrom", ["j"], [254]], ["j", 262, "comesFrom", ["j"], [254]], ["j", 278, "comesFrom", ["j"], [274]], ["j", 286, "comesFrom", ["j"], [274]], ["j", 295, "comesFrom", ["j"], [274]], ["temp", 269, "comesFrom", ["temp"], [207]], ["temp", 215, "comesFrom", ["temp"], [207]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void printAncestors ( struct Node * root , int key ) { if ( root == NULL ) return ; stack < struct Node * > st ; while ( 1 ) { while ( root && root -> data != key ) { st . push ( root ) ; root = root -> left ; } if ( root && root -> data == key ) break ; if ( st . top ( ) -> right == NULL ) { root = st . top ( ) ; st . pop ( ) ; while ( ! st . empty ( ) && st . top ( ) -> right == root ) { root = st . top ( ) ; st . pop ( ) ; } } root = st . empty ( ) ? NULL : st . top ( ) -> right ; } while ( ! st . empty ( ) ) { cout << st . top ( ) -> data << \" ▁ \" ; st . pop ( ) ; } } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 8 ) ; root -> right -> right = newNode ( 9 ) ; root -> left -> left -> left = newNode ( 4 ) ; root -> left -> right -> right = newNode ( 6 ) ; root -> right -> right -> left = newNode ( 10 ) ; int key = 6 ; printAncestors ( root , key ) ; return 0 ; }", "docstring": "Iterative method to find ancestors of a given binary tree | C ++ program to print all ancestors of a given key ; Structure for a tree node ; A utility function to create a new tree node ; Iterative Function to print all ancestors of a given key ; Create a stack to hold ancestors ; Traverse the complete tree in postorder way till we find the key ; Traverse the left side . While traversing , push the nodes into the stack so that their right subtrees can be traversed later ; push current node ; move to next node ; If the node whose ancestors are to be printed is found , then break the while loop . ; Check if right sub - tree exists for the node at top If not then pop that node because we don 't need  this node any more. ; If the popped node is right child of top , then remove the top as well . Left child of the top must have processed before . ; if stack is not empty then simply set the root as right child of top and start traversing right sub - tree . ; If stack is not empty , print contents of stack Here assumption is that the key is there in tree ; Driver program to test above functions ; Let us construct a binary tree", "dfg": [["data", 55, "comesFrom", ["data"], [29]], ["data", 53, "comesFrom", ["data"], [29]], ["data", 241, "comesFrom", ["data"], [29]], ["data", 110, "comesFrom", ["data"], [29]], ["data", 135, "comesFrom", ["data"], [29]], ["root", 263, "comesFrom", ["root"], [204]], ["root", 270, "comesFrom", ["root"], [204]], ["root", 279, "comesFrom", ["root"], [204]], ["root", 378, "comesFrom", ["root"], [204]], ["root", 288, "comesFrom", ["root"], [204]], ["root", 299, "comesFrom", ["root"], [204]], ["root", 310, "comesFrom", ["root"], [204]], ["root", 321, "comesFrom", ["root"], [204]], ["root", 131, "comesFrom", ["root"], [122]], ["root", 332, "comesFrom", ["root"], [204]], ["root", 345, "comesFrom", ["root"], [204]], ["root", 358, "comesFrom", ["root"], [204]], ["root", 124, "comesFrom", ["root"], [122]], ["root", 133, "comesFrom", ["root"], [122]], ["root", 185, "comesFrom", ["root"], [154]], ["key", 380, "comesFrom", ["key"], [372]], ["key", 112, "comesFrom", ["key"], [80]], ["key", 137, "comesFrom", ["key"], [80]], ["st", 226, "comesFrom", ["st"], [97]], ["st", 247, "comesFrom", ["st"], [97]], ["st", 115, "comesFrom", ["st"], [97]], ["st", 162, "comesFrom", ["st"], [97]], ["st", 206, "comesFrom", ["st"], [97]], ["st", 143, "comesFrom", ["st"], [97]], ["st", 156, "comesFrom", ["st"], [97]], ["st", 214, "comesFrom", ["st"], [97]], ["st", 235, "comesFrom", ["st"], [97]], ["st", 196, "comesFrom", ["st"], [97]], ["st", 171, "comesFrom", ["st"], [97]], ["st", 190, "comesFrom", ["st"], [97]], ["st", 177, "comesFrom", ["st"], [97]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; class StackWithMax { stack < int > mainStack ; stack < int > trackStack ; public : void push ( int x ) { mainStack . push ( x ) ; if ( mainStack . size ( ) == 1 ) { trackStack . push ( x ) ; return ; } if ( x > trackStack . top ( ) ) trackStack . push ( x ) ; else trackStack . push ( trackStack . top ( ) ) ; } int getMax ( ) { return trackStack . top ( ) ; } int pop ( ) { mainStack . pop ( ) ; trackStack . pop ( ) ; } } ; int main ( ) { StackWithMax s ; s . push ( 20 ) ; cout << s . getMax ( ) << endl ; s . push ( 10 ) ; cout << s . getMax ( ) << endl ; s . push ( 50 ) ; cout << s . getMax ( ) << endl ; return 0 ; }", "docstring": "Tracking current Maximum Element in a Stack | C ++ program to keep track of maximum element in a stack ; main stack ; stack to keep track of max element ; If current element is greater than the top element of track stack , push the current element to track stack otherwise push the element at top of track stack again into it . ; Driver program to test above functions", "dfg": [["s", 130, "comesFrom", ["s"], [128]], ["s", 147, "comesFrom", ["s"], [128]], ["s", 164, "comesFrom", ["s"], [128]], ["s", 139, "comesFrom", ["s"], [128]], ["s", 156, "comesFrom", ["s"], [128]], ["s", 173, "comesFrom", ["s"], [128]], ["x", 35, "comesFrom", ["x"], [28]], ["x", 61, "comesFrom", ["x"], [28]], ["x", 73, "comesFrom", ["x"], [28]], ["x", 53, "comesFrom", ["x"], [28]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; stack < int > st ; void push_digits ( int number ) { while ( number != 0 ) { st . push ( number % 10 ) ; number = number / 10 ; } } int reverse_number ( int number ) { push_digits ( number ) ; int reverse = 0 ; int i = 1 ; while ( ! st . empty ( ) ) { reverse = reverse + ( st . top ( ) * i ) ; st . pop ( ) ; i = i * 10 ; } return reverse ; } int main ( ) { int number = 39997 ; cout << reverse_number ( number ) ; return 0 ; }", "docstring": "Reverse a number using stack | CPP program to reverse the number using a stack ; Stack to maintain order of digits ; Function to push digits into stack ; Function to reverse the number ; Function call to push number 's   digits to stack ; Popping the digits and forming the reversed number ; Return the reversed number formed ; Driver program to test above function ; Function call to reverse number", "dfg": [["reverse", 104, "comesFrom", ["reverse"], [76]], ["reverse", 78, "comesFrom", ["reverse"], [76]], ["number", 22, "comesFrom", ["number"], [17]], ["number", 53, "comesFrom", ["number"], [48]], ["number", 121, "comesFrom", ["number"], [113]], ["number", 38, "comesFrom", ["number"], [36]], ["number", 31, "comesFrom", ["number"], [17]], ["st", 27, "comesFrom", ["st"], [11]], ["st", 69, "comesFrom", ["st"], [11]], ["st", 90, "comesFrom", ["st"], [11]], ["st", 81, "comesFrom", ["st"], [11]], ["i", 98, "comesFrom", ["i"], [96]], ["i", 87, "comesFrom", ["i"], [62]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * temp = new struct Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } Node * flipBinaryTree ( Node * root ) { if ( root == NULL ) return root ; if ( root -> left == NULL && root -> right == NULL ) return root ; Node * flippedRoot = flipBinaryTree ( root -> left ) ; root -> left -> left = root -> right ; root -> left -> right = root ; root -> left = root -> right = NULL ; return flippedRoot ; } void printLevelOrder ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( 1 ) { int nodeCount = q . size ( ) ; if ( nodeCount == 0 ) break ; while ( nodeCount > 0 ) { Node * node = q . front ( ) ; cout << node -> data << \" ▁ \" ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; nodeCount -- ; } cout << endl ; } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 5 ) ; cout << \" Level ▁ order ▁ traversal ▁ of ▁ given ▁ tree STRNEWLINE \" ; printLevelOrder ( root ) ; root = flipBinaryTree ( root ) ; cout << \" Level order traversal of the flipped \" STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" tree \" printLevelOrder ( root ) ; return 0 ; }", "docstring": "Flip Binary Tree | C / C ++ program to flip a binary tree ; A binary tree node structure ; Utility function to create a new Binary Tree Node ; method to flip the binary tree ; recursively call the same method ; rearranging main root Node after returning from recursive call ; Iterative method to do level order traversal line by line ; Base Case ; Create an empty queue for level order traversal ; Enqueue Root and initialize height ; nodeCount ( queue size ) indicates number of nodes at current lelvel . ; Dequeue all nodes of current level and Enqueue all nodes of next level ; Driver code", "dfg": [["data", 44, "comesFrom", ["data"], [28]], ["data", 42, "comesFrom", ["data"], [28]], ["data", 211, "comesFrom", ["data"], [28]], ["root", 355, "comesFrom", ["root"], [332]], ["root", 336, "comesFrom", ["root"], [332]], ["q", 161, "comesFrom", ["q"], [159]], ["q", 176, "comesFrom", ["q"], [159]], ["q", 217, "comesFrom", ["q"], [159]], ["q", 201, "comesFrom", ["q"], [159]], ["q", 231, "comesFrom", ["q"], [159]], ["q", 248, "comesFrom", ["q"], [159]], ["nodeCount", 184, "comesFrom", ["nodeCount"], [174]], ["nodeCount", 192, "comesFrom", ["nodeCount"], [174]], ["nodeCount", 257, "comesFrom", ["nodeCount"], [174]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool pairWiseConsecutive ( stack < int > s ) { stack < int > aux ; while ( ! s . empty ( ) ) { aux . push ( s . top ( ) ) ; s . pop ( ) ; } bool result = true ; while ( aux . size ( ) > 1 ) { int x = aux . top ( ) ; aux . pop ( ) ; int y = aux . top ( ) ; aux . pop ( ) ; if ( abs ( x - y ) != 1 ) result = false ; s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) s . push ( aux . top ( ) ) ; return result ; } int main ( ) { stack < int > s ; s . push ( 4 ) ; s . push ( 5 ) ; s . push ( -2 ) ; s . push ( -3 ) ; s . push ( 11 ) ; s . push ( 10 ) ; s . push ( 5 ) ; s . push ( 6 ) ; s . push ( 20 ) ; if ( pairWiseConsecutive ( s ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; cout << \" Stack ▁ content ▁ ( from ▁ top ) \" \" ▁ after ▁ function ▁ call STRNEWLINE \" ; while ( s . empty ( ) == false ) { cout << s . top ( ) << \" ▁ \" ; s . pop ( ) ; } return 0 ; }", "docstring": "Check if stack elements are pairwise consecutive | C ++ program to check if successive pair of numbers in the stack are consecutive or not ; Function to check if elements are pairwise consecutive in stack ; Transfer elements of s to aux . ; Traverse aux and see if elements are pairwise consecutive or not . We also need to make sure that original content is retained . ; Fetch current top two elements of aux and check if they are consecutive . ; Push the elements to original stack . ; Driver program", "dfg": [["result", 149, "comesFrom", ["result"], [108]], ["s", 163, "comesFrom", ["s"], [161]], ["s", 170, "comesFrom", ["s"], [161]], ["s", 177, "comesFrom", ["s"], [161]], ["s", 184, "comesFrom", ["s"], [161]], ["s", 191, "comesFrom", ["s"], [161]], ["s", 198, "comesFrom", ["s"], [161]], ["s", 205, "comesFrom", ["s"], [161]], ["s", 212, "comesFrom", ["s"], [161]], ["s", 219, "comesFrom", ["s"], [161]], ["s", 137, "comesFrom", ["s"], [14]], ["s", 230, "comesFrom", ["s"], [161]], ["s", 26, "comesFrom", ["s"], [14]], ["s", 44, "comesFrom", ["s"], [14]], ["s", 112, "comesFrom", ["s"], [14]], ["s", 119, "comesFrom", ["s"], [14]], ["s", 261, "comesFrom", ["s"], [161]], ["s", 282, "comesFrom", ["s"], [161]], ["s", 37, "comesFrom", ["s"], [14]], ["s", 272, "comesFrom", ["s"], [161]], ["aux", 33, "comesFrom", ["aux"], [21]], ["aux", 58, "comesFrom", ["aux"], [21]], ["aux", 76, "comesFrom", ["aux"], [21]], ["aux", 91, "comesFrom", ["aux"], [21]], ["aux", 129, "comesFrom", ["aux"], [21]], ["aux", 70, "comesFrom", ["aux"], [21]], ["aux", 85, "comesFrom", ["aux"], [21]], ["aux", 141, "comesFrom", ["aux"], [21]], ["x", 116, "comesFrom", ["x"], [68]], ["x", 101, "comesFrom", ["x"], [68]], ["y", 123, "comesFrom", ["y"], [83]], ["y", 103, "comesFrom", ["y"], [83]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; char * simplify ( string str ) { int len = str . length ( ) ; char * res = new char ( len ) ; int index = 0 , i = 0 ; stack < int > s ; s . push ( 0 ) ; while ( i < len ) { if ( str [ i ] == ' + ' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = ' - ' ; if ( s . top ( ) == 0 ) res [ index ++ ] = ' + ' ; } else if ( str [ i ] == ' - ' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = ' + ' ; else if ( s . top ( ) == 0 ) res [ index ++ ] = ' - ' ; } else if ( str [ i ] == ' ( ' && i > 0 ) { if ( str [ i - 1 ] == ' - ' ) { int x = ( s . top ( ) == 1 ) ? 0 : 1 ; s . push ( x ) ; } else if ( str [ i - 1 ] == ' + ' ) s . push ( s . top ( ) ) ; } else if ( str [ i ] == ' ) ' ) s . pop ( ) ; else res [ index ++ ] = str [ i ] ; i ++ ; } return res ; } int main ( ) { string s1 = \" a - ( b + c ) \" ; string s2 = \" a - ( b - c - ( d + e ) ) - f \" ; cout << simplify ( s1 ) << endl ; cout << simplify ( s2 ) << endl ; return 0 ; }", "docstring": "Remove brackets from an algebraic string containing + and | C ++ program to simplify algebraic string ; Function to simplify the string ; resultant string of max length equal to length of input string ; create empty stack ; If top is 1 , flip the operator ; If top is 0 , append the same operator ; x is opposite to the top of stack ; push value equal to top of the stack ; If closing parentheses pop the stack once ; copy the character to the result ; Driver program", "dfg": [["s", 49, "comesFrom", ["s"], [47]], ["s", 79, "comesFrom", ["s"], [47]], ["s", 101, "comesFrom", ["s"], [47]], ["s", 139, "comesFrom", ["s"], [47]], ["s", 285, "comesFrom", ["s"], [47]], ["s", 162, "comesFrom", ["s"], [47]], ["s", 235, "comesFrom", ["s"], [47]], ["s", 259, "comesFrom", ["s"], [47]], ["s", 263, "comesFrom", ["s"], [47]], ["s", 222, "comesFrom", ["s"], [47]], ["i", 58, "comesFrom", ["i"], [39]], ["i", 303, "comesFrom", ["i"], [39]], ["i", 67, "comesFrom", ["i"], [39]], ["i", 127, "comesFrom", ["i"], [39]], ["i", 197, "comesFrom", ["i"], [39]], ["i", 188, "comesFrom", ["i"], [39]], ["i", 276, "comesFrom", ["i"], [39]], ["i", 206, "comesFrom", ["i"], [39]], ["i", 300, "comesFrom", ["i"], [39]], ["i", 248, "comesFrom", ["i"], [39]], ["len", 60, "comesFrom", ["len"], [16]], ["len", 31, "comesFrom", ["len"], [16]], ["str", 18, "comesFrom", ["str"], [12]], ["str", 65, "comesFrom", ["str"], [12]], ["str", 125, "comesFrom", ["str"], [12]], ["str", 186, "comesFrom", ["str"], [12]], ["str", 204, "comesFrom", ["str"], [12]], ["str", 274, "comesFrom", ["str"], [12]], ["str", 298, "comesFrom", ["str"], [12]], ["str", 246, "comesFrom", ["str"], [12]], ["s1", 334, "comesFrom", ["s1"], [317]], ["s2", 343, "comesFrom", ["s2"], [324]], ["index", 89, "comesFrom", ["index"], [35]], ["index", 111, "comesFrom", ["index"], [35]], ["index", 149, "comesFrom", ["index"], [35]], ["index", 172, "comesFrom", ["index"], [35]], ["index", 294, "comesFrom", ["index"], [35]], ["x", 239, "comesFrom", ["x"], [219]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; #define BOUND  4 NEW_LINE int top = -1 ; int length = 0 ; int * create_new ( int * a ) { int * new_a = new int [ length + BOUND ] ; for ( int i = 0 ; i < length ; i ++ ) new_a [ i ] = a [ i ] ; length += BOUND ; return new_a ; } int * push ( int * a , int element ) { if ( top == length - 1 ) a = create_new ( a ) ; a [ ++ top ] = element ; return a ; } void pop ( int * a ) { top -- ; } void display ( int * a ) { if ( top == -1 ) cout << \" Stack ▁ is ▁ Empty \" << endl ; else { cout << \" Stack : ▁ \" ; for ( int i = 0 ; i <= top ; i ++ ) cout << a [ i ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int * a = create_new ( a ) ; a = push ( a , 1 ) ; a = push ( a , 2 ) ; a = push ( a , 3 ) ; a = push ( a , 4 ) ; display ( a ) ; a = push ( a , 5 ) ; a = push ( a , 6 ) ; display ( a ) ; a = push ( a , 7 ) ; a = push ( a , 8 ) ; display ( a ) ; a = push ( a , 9 ) ; display ( a ) ; return 0 ; }", "docstring": "Growable array based stack | CPP Program to implement growable array based stack using tight strategy ; constant amount at which stack is increased ; top of the stack ; length of stack ; function to create new stack ; allocate memory for new stack ; copying the content of old stack ; re - sizing the length ; function to push new element ; if stack is full , create new one ; insert element at top of the stack ; function to pop an element ; function to display ; if top is - 1 , that means stack is empty ; Driver Code ; creating initial stack ; pushing element to top of stack ; pushing more element when stack is full ; pushing more element so that stack can grow", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructBlanceArray ( int BOP [ ] , int BCP [ ] , char * str , int n ) { stack < int > stk ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) stk . push ( i ) ; else { if ( ! stk . empty ( ) ) { BCP [ i ] = 1 ; BOP [ stk . top ( ) ] = 1 ; stk . pop ( ) ; } else BCP [ i ] = 0 ; } } for ( int i = 1 ; i < n ; i ++ ) { BCP [ i ] += BCP [ i - 1 ] ; BOP [ i ] += BOP [ i - 1 ] ; } } int query ( int BOP [ ] , int BCP [ ] , int s , int e ) { if ( BOP [ s - 1 ] == BOP [ s ] ) { return ( BCP [ e ] - BOP [ s ] ) * 2 ; } else { return ( BCP [ e ] - BOP [ s ] + 1 ) * 2 ; } } int main ( ) { char str [ ] = \" ( ) ) ( ( ) ) ( ( ) ) ( \" ; int n = strlen ( str ) ; int BCP [ n + 1 ] = { 0 } ; int BOP [ n + 1 ] = { 0 } ; constructBlanceArray ( BOP , BCP , str , n ) ; int startIndex = 5 , endIndex = 11 ; cout << \" Maximum ▁ Length ▁ Correct ▁ Bracket \" \" ▁ Subsequence ▁ between ▁ \" << startIndex << \" ▁ and ▁ \" << endIndex << \" ▁ = ▁ \" << query ( BOP , BCP , startIndex , endIndex ) << endl ; startIndex = 4 , endIndex = 5 ; cout << \" Maximum ▁ Length ▁ Correct ▁ Bracket \" \" ▁ Subsequence ▁ between ▁ \" << startIndex << \" ▁ and ▁ \" << endIndex << \" ▁ = ▁ \" << query ( BOP , BCP , startIndex , endIndex ) << endl ; startIndex = 1 , endIndex = 5 ; cout << \" Maximum ▁ Length ▁ Correct ▁ Bracket \" \" ▁ Subsequence ▁ between ▁ \" << startIndex << \" ▁ and ▁ \" << endIndex << \" ▁ = ▁ \" << query ( BOP , BCP , startIndex , endIndex ) << endl ; return 0 ; }", "docstring": "Range Queries for Longest Correct Bracket Subsequence Set | 2 | CPP code to answer the query in constant time ; function for precomputation ; Create a stack and push - 1 as initial index to it . ; Initialize result ; Traverse all characters of given string ; If opening bracket , push index of it ; If closing bracket , i . e . , str [ i ] = ' ) ' ; If closing bracket , i . e . , str [ i ] = ' ) ' && stack is not empty then mark both \" open ▁ & ▁ close \" bracket indexs as 1 . Pop the previous opening bracket 's index ; If stack is empty . ; Function return output of each query in O ( 1 ) ; Driver program to test above function", "dfg": [["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 128, "comesFrom", ["i"], [124]], ["i", 132, "comesFrom", ["i"], [124]], ["i", 71, "comesFrom", ["i"], [42]], ["i", 138, "comesFrom", ["i"], [124]], ["i", 150, "comesFrom", ["i"], [124]], ["i", 58, "comesFrom", ["i"], [42]], ["i", 143, "comesFrom", ["i"], [124]], ["i", 155, "comesFrom", ["i"], [124]], ["i", 88, "comesFrom", ["i"], [42]], ["i", 114, "comesFrom", ["i"], [42]], ["n", 48, "comesFrom", ["n"], [25]], ["n", 130, "comesFrom", ["n"], [25]], ["n", 288, "comesFrom", ["n"], [249]], ["n", 259, "comesFrom", ["n"], [249]], ["n", 271, "comesFrom", ["n"], [249]], ["s", 193, "comesFrom", ["s"], [176]], ["s", 186, "comesFrom", ["s"], [176]], ["s", 206, "comesFrom", ["s"], [176]], ["s", 224, "comesFrom", ["s"], [176]], ["endIndex", 315, "comesFrom", ["endIndex"], [296]], ["endIndex", 329, "comesFrom", ["endIndex"], [296]], ["endIndex", 357, "comesFrom", ["endIndex"], [338]], ["endIndex", 371, "comesFrom", ["endIndex"], [338]], ["endIndex", 399, "comesFrom", ["endIndex"], [380]], ["endIndex", 413, "comesFrom", ["endIndex"], [380]], ["startIndex", 327, "comesFrom", ["startIndex"], [292]], ["startIndex", 369, "comesFrom", ["startIndex"], [334]], ["startIndex", 411, "comesFrom", ["startIndex"], [376]], ["startIndex", 309, "comesFrom", ["startIndex"], [292]], ["startIndex", 351, "comesFrom", ["startIndex"], [334]], ["startIndex", 393, "comesFrom", ["startIndex"], [376]], ["stk", 67, "comesFrom", ["stk"], [32]], ["stk", 79, "comesFrom", ["stk"], [32]], ["stk", 104, "comesFrom", ["stk"], [32]], ["stk", 95, "comesFrom", ["stk"], [32]], ["e", 201, "comesFrom", ["e"], [179]], ["e", 219, "comesFrom", ["e"], [179]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; void heapify ( int arr [ ] , int n , int i ) { int largest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { swap ( arr [ i ] , arr [ largest ] ) ; heapify ( arr , n , largest ) ; } } void heapSort ( int arr [ ] , int n ) { for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { swap ( arr [ 0 ] , arr [ i ] ) ; heapify ( arr , i , 0 ) ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; heapSort ( arr , n ) ; cout << \" Sorted ▁ array ▁ is ▁ STRNEWLINE \" ; printArray ( arr , n ) ; }", "docstring": "HeapSort | C ++ program for implementation of Heap Sort ; To heapify a subtree rooted with node i which is an index in arr [ ] . n is size of heap ; Initialize largest as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; If left child is larger than root ; If right child is larger than largest so far ; If largest is not root ; Recursively heapify the affected sub - tree ; main function to do heap sort ; Build heap ( rearrange array ) ; One by one extract an element from heap ; Move current root to end ; call max heapify on the reduced heap ; A utility function to print array of size n ; Driver code", "dfg": [["i", 139, "comesFrom", ["i"], [131]], ["i", 143, "comesFrom", ["i"], [131]], ["i", 164, "comesFrom", ["i"], [158]], ["i", 168, "comesFrom", ["i"], [158]], ["i", 215, "comesFrom", ["i"], [211]], ["i", 220, "comesFrom", ["i"], [211]], ["i", 89, "comesFrom", ["i"], [25]], ["i", 32, "comesFrom", ["i"], [25]], ["i", 41, "comesFrom", ["i"], [25]], ["i", 152, "comesFrom", ["i"], [131]], ["i", 189, "comesFrom", ["i"], [158]], ["i", 226, "comesFrom", ["i"], [211]], ["i", 96, "comesFrom", ["i"], [25]], ["i", 181, "comesFrom", ["i"], [158]], ["n", 217, "comesFrom", ["n"], [205]], ["n", 284, "comesFrom", ["n"], [265]], ["n", 297, "comesFrom", ["n"], [265]], ["n", 49, "comesFrom", ["n"], [16]], ["n", 69, "comesFrom", ["n"], [16]], ["n", 150, "comesFrom", ["n"], [125]], ["n", 160, "comesFrom", ["n"], [125]], ["n", 109, "comesFrom", ["n"], [16]], ["n", 133, "comesFrom", ["n"], [125]], ["l", 63, "comesFrom", ["l"], [28]], ["l", 47, "comesFrom", ["l"], [28]], ["l", 53, "comesFrom", ["l"], [28]], ["r", 83, "comesFrom", ["r"], [37]], ["r", 67, "comesFrom", ["r"], [37]], ["r", 73, "comesFrom", ["r"], [37]], ["largest", 87, "comesFrom", ["largest"], [81]], ["largest", 111, "comesFrom", ["largest"], [81]], ["largest", 58, "comesFrom", ["largest"], [23]], ["largest", 78, "comesFrom", ["largest"], [61]], ["largest", 101, "comesFrom", ["largest"], [81]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void buildMaxHeap ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ ( i - 1 ) / 2 ] ) { int j = i ; while ( arr [ j ] > arr [ ( j - 1 ) / 2 ] ) { swap ( arr [ j ] , arr [ ( j - 1 ) / 2 ] ) ; j = ( j - 1 ) / 2 ; } } } } void heapSort ( int arr [ ] , int n ) { buildMaxHeap ( arr , n ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { swap ( arr [ 0 ] , arr [ i ] ) ; int j = 0 , index ; do { index = ( 2 * j + 1 ) ; if ( arr [ index ] < arr [ index + 1 ] && index < ( i - 1 ) ) index ++ ; if ( arr [ j ] < arr [ index ] && index < i ) swap ( arr [ j ] , arr [ index ] ) ; j = index ; } while ( index < i ) ; } } int main ( ) { int arr [ ] = { 10 , 20 , 15 , 17 , 9 , 21 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Given ▁ array : ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE STRNEWLINE \" ) ; heapSort ( arr , n ) ; printf ( \" Sorted ▁ array : ▁ \" ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; return 0 ; }", "docstring": "Iterative HeapSort | C ++ program for implementation of Iterative Heap Sort ; function build Max Heap where value of each child is always smaller than value of their parent ; if child is bigger than parent ; swap child and parent until parent is smaller ; swap value of first indexed with last indexed ; maintaining heap property after each swapping ; if left child is smaller than right child point index variable to right child ; if parent is smaller than child then swapping parent with child having higher value ; Driver Code to test above ; print array after sorting", "dfg": [["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 138, "comesFrom", ["i"], [132]], ["i", 142, "comesFrom", ["i"], [132]], ["i", 300, "comesFrom", ["i"], [296]], ["i", 304, "comesFrom", ["i"], [296]], ["i", 347, "comesFrom", ["i"], [343]], ["i", 351, "comesFrom", ["i"], [343]], ["i", 241, "comesFrom", ["i"], [132]], ["i", 315, "comesFrom", ["i"], [296]], ["i", 362, "comesFrom", ["i"], [343]], ["i", 38, "comesFrom", ["i"], [22]], ["i", 155, "comesFrom", ["i"], [132]], ["i", 217, "comesFrom", ["i"], [132]], ["i", 44, "comesFrom", ["i"], [22]], ["i", 195, "comesFrom", ["i"], [132]], ["n", 28, "comesFrom", ["n"], [16]], ["n", 302, "comesFrom", ["n"], [271]], ["n", 349, "comesFrom", ["n"], [271]], ["n", 126, "comesFrom", ["n"], [119]], ["n", 330, "comesFrom", ["n"], [271]], ["n", 134, "comesFrom", ["n"], [119]], ["index", 239, "comesFrom", ["index"], [168]], ["index", 234, "comesFrom", ["index"], [168]], ["index", 200, "comesFrom", ["index"], [168]], ["index", 192, "comesFrom", ["index"], [168]], ["index", 215, "comesFrom", ["index"], [168]], ["index", 182, "comesFrom", ["index"], [168]], ["index", 212, "comesFrom", ["index"], [168]], ["index", 228, "comesFrom", ["index"], [168]], ["index", 187, "comesFrom", ["index"], [168]], ["j", 62, "comesFrom", ["j"], [54]], ["j", 173, "comesFrom", ["j"], [160]], ["j", 207, "comesFrom", ["j"], [160]], ["j", 223, "comesFrom", ["j"], [160]], ["j", 81, "comesFrom", ["j"], [54]], ["j", 99, "comesFrom", ["j"], [96]], ["j", 68, "comesFrom", ["j"], [54]], ["j", 87, "comesFrom", ["j"], [54]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * temp = new struct Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } Node * flipBinaryTree ( Node * root ) { Node * curr = root ; Node * next = NULL ; Node * temp = NULL ; Node * prev = NULL ; while ( curr ) { next = curr -> left ; curr -> left = temp ; temp = curr -> right ; curr -> right = prev ; prev = curr ; curr = next ; } return prev ; } void printLevelOrder ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( 1 ) { int nodeCount = q . size ( ) ; if ( nodeCount == 0 ) break ; while ( nodeCount > 0 ) { Node * node = q . front ( ) ; cout << node -> data << \" ▁ \" ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; nodeCount -- ; } cout << endl ; } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 5 ) ; cout << \" Level ▁ order ▁ traversal ▁ of ▁ given ▁ tree STRNEWLINE \" ; printLevelOrder ( root ) ; root = flipBinaryTree ( root ) ; cout << \" Level order traversal of the flipped \" STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL \" tree \" printLevelOrder ( root ) ; return 0 ; }", "docstring": "Flip Binary Tree | C / C ++ program to flip a binary tree ; A binary tree node structure ; Utility function to create a new Binary Tree Node ; method to flip the binary tree ; Initialization of pointers ; Iterate through all left nodes ; Swapping nodes now , need temp to keep the previous right child Making prev ' s ▁ right ▁ as ▁ curr ' s left child ; Storing curr 's right child ; Making prev as curr 's right child ; Iterative method to do level order traversal line by line ; Base Case ; Create an empty queue for level order traversal ; Enqueue Root and initialize height ; nodeCount ( queue size ) indicates number of nodes at current lelvel . ; Dequeue all nodes of current level and Enqueue all nodes of next level ; Driver code", "dfg": [["data", 44, "comesFrom", ["data"], [28]], ["data", 42, "comesFrom", ["data"], [28]], ["data", 208, "comesFrom", ["data"], [28]], ["prev", 132, "comesFrom", ["prev"], [122]], ["next", 128, "comesFrom", ["next"], [98]], ["root", 140, "comesFrom", ["root"], [73]], ["root", 145, "comesFrom", ["root"], [73]], ["root", 162, "comesFrom", ["root"], [73]], ["root", 271, "comesFrom", ["root"], [73]], ["root", 278, "comesFrom", ["root"], [73]], ["root", 287, "comesFrom", ["root"], [73]], ["root", 326, "comesFrom", ["root"], [73]], ["root", 352, "comesFrom", ["root"], [329]], ["root", 296, "comesFrom", ["root"], [73]], ["root", 307, "comesFrom", ["root"], [73]], ["root", 333, "comesFrom", ["root"], [329]], ["q", 158, "comesFrom", ["q"], [156]], ["q", 173, "comesFrom", ["q"], [156]], ["q", 214, "comesFrom", ["q"], [156]], ["q", 198, "comesFrom", ["q"], [156]], ["q", 228, "comesFrom", ["q"], [156]], ["q", 245, "comesFrom", ["q"], [156]], ["nodeCount", 181, "comesFrom", ["nodeCount"], [171]], ["nodeCount", 189, "comesFrom", ["nodeCount"], [171]], ["nodeCount", 254, "comesFrom", ["nodeCount"], [171]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE #define true  1 NEW_LINE #define false  0 NEW_LINE class node { public : int data ; node * left ; node * right ; } ; bool IsFoldableUtil ( node * n1 , node * n2 ) ; bool IsFoldable ( node * root ) { if ( root == NULL ) { return true ; } return IsFoldableUtil ( root -> left , root -> right ) ; } bool IsFoldableUtil ( node * n1 , node * n2 ) { if ( n1 == NULL && n2 == NULL ) { return true ; } if ( n1 == NULL n2 == NULL ) { return false ; } return IsFoldableUtil ( n1 -> left , n2 -> right ) && IsFoldableUtil ( n1 -> right , n2 -> left ) ; } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int main ( void ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; if ( IsFoldable ( root ) == true ) { cout << \" Tree ▁ is ▁ foldable \" ; } else { cout << \" Tree ▁ is ▁ not ▁ foldable \" ; } return 0 ; }", "docstring": "Foldable Binary Trees |  ; A binary tree node has data , pointer to left child and a pointer to right child ; A utility function that checks if trees with roots as n1 and n2 are mirror of each other ; Returns true if the given tree can be folded ; A utility function that checks if trees with roots as n1 and n2 are mirror of each other ; If both left and right subtrees are NULL , then return true ; If one of the trees is NULL and other is not , then return false ; Otherwise check if left and right subtrees are mirrors of their counterparts ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver code ; The constructed binary tree is 1 / \\ 2 3 \\ / 4 5", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; int isSumProperty ( struct node * node ) { int left_data = 0 , right_data = 0 ; if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return 1 ; else { if ( node -> left != NULL ) left_data = node -> left -> data ; if ( node -> right != NULL ) right_data = node -> right -> data ; if ( ( node -> data == left_data + right_data ) && isSumProperty ( node -> left ) && isSumProperty ( node -> right ) ) return 1 ; else return 0 ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 2 ) ; if ( isSumProperty ( root ) ) cout << \" The ▁ given ▁ tree ▁ satisfies ▁ \" << \" the ▁ children ▁ sum ▁ property ▁ \" ; else cout << \" The ▁ given ▁ tree ▁ does ▁ not ▁ satisfy ▁ \" << \" the ▁ children ▁ sum ▁ property ▁ \" ; getchar ( ) ; return 0 ; }", "docstring": "Check for Children Sum Property in a Binary Tree | Program to check children sum property ; A binary tree node has data , left child and right child ; returns 1 if children sum property holds for the given node and both of its children ; left_data is left child data and right_data is for right child data ; If node is NULL or it 's a leaf node   then return true  ; If left child is not present then 0 is used as data of left child ; If right child is not present then 0 is used as data of right child ; if the node and both of its children satisfy the property return 1 else 0 ; Helper function that allocates a new node with the given data and NULL left and right pointers . ; Driver Code", "dfg": [["data", 167, "comesFrom", ["data"], [141]], ["data", 165, "comesFrom", ["data"], [141]], ["left_data", 107, "comesFrom", ["left_data"], [76]], ["right_data", 109, "comesFrom", ["right_data"], [92]]]}
{"code": "#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE bool isHeap ( int arr [ ] , int i , int n ) { if ( i >= ( n - 2 ) / 2 ) return true ; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) return true ; return false ; } int main ( ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) - 1 ; isHeap ( arr , 0 , n ) ? printf ( \" Yes \" ) : printf ( \" No \" ) ; return 0 ; }", "docstring": "How to check if a given array represents a Binary Heap ? | C program to check whether a given array represents a max - heap or not ; Returns true if arr [ i . . n - 1 ] represents a max - heap ; If a leaf node ; If an internal node and is greater than its children , and same is recursively true for the children ; Driver program", "dfg": [["i", 23, "comesFrom", ["i"], [15]], ["i", 85, "comesFrom", ["i"], [15]], ["i", 40, "comesFrom", ["i"], [15]], ["i", 54, "comesFrom", ["i"], [15]], ["i", 72, "comesFrom", ["i"], [15]], ["i", 47, "comesFrom", ["i"], [15]], ["i", 61, "comesFrom", ["i"], [15]], ["n", 148, "comesFrom", ["n"], [128]], ["n", 89, "comesFrom", ["n"], [18]], ["n", 26, "comesFrom", ["n"], [18]], ["n", 76, "comesFrom", ["n"], [18]]]}
{"code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE bool isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; } int main ( ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; isHeap ( arr , n ) ? printf ( \" Yes \" ) : printf ( \" No \" ) ; return 0 ; }", "docstring": "How to check if a given array represents a Binary Heap ? | C program to check whether a given array represents a max - heap or not ; Returns true if arr [ i . . n - 1 ] represents a max - heap ; Start from root and go till the last internal node ; If left child is greater , return false ; If right child is greater , return false ; Driver program", "dfg": [["i", 25, "comesFrom", ["i"], [21]], ["i", 35, "comesFrom", ["i"], [21]], ["i", 52, "comesFrom", ["i"], [21]], ["i", 62, "comesFrom", ["i"], [21]], ["i", 79, "comesFrom", ["i"], [21]], ["i", 45, "comesFrom", ["i"], [21]], ["i", 72, "comesFrom", ["i"], [21]], ["n", 135, "comesFrom", ["n"], [119]], ["n", 28, "comesFrom", ["n"], [15]], ["n", 66, "comesFrom", ["n"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int arr [ ] , int n ) { priority_queue < int , vector < int > , greater < int > > pq ( arr , arr + n ) ; int res = 0 ; while ( pq . size ( ) > 1 ) { int first = pq . top ( ) ; pq . pop ( ) ; int second = pq . top ( ) ; pq . pop ( ) ; res += first + second ; pq . push ( first + second ) ; } return res ; } int main ( ) { int len [ ] = { 4 , 3 , 2 , 6 } ; int size = sizeof ( len ) / sizeof ( len [ 0 ] ) ; cout << \" Total ▁ cost ▁ for ▁ connecting ▁ ropes ▁ is ▁ \" << minCost ( len , size ) ; return 0 ; }", "docstring": "Connect n ropes with minimum cost |  ; Create a priority queue ; Initialize result ; While size of priority queue is more than 1 ; Extract shortest two ropes from pq ; Connect the ropes : update result and insert the new rope to pq ; Driver program to test above function", "dfg": [["res", 105, "comesFrom", ["res"], [88]], ["n", 39, "comesFrom", ["n"], [16]], ["size", 154, "comesFrom", ["size"], [129]], ["pq", 49, "comesFrom", ["pq"], [33]], ["pq", 67, "comesFrom", ["pq"], [33]], ["pq", 82, "comesFrom", ["pq"], [33]], ["pq", 94, "comesFrom", ["pq"], [33]], ["pq", 61, "comesFrom", ["pq"], [33]], ["pq", 76, "comesFrom", ["pq"], [33]], ["first", 90, "comesFrom", ["first"], [59]], ["first", 98, "comesFrom", ["first"], [59]], ["second", 92, "comesFrom", ["second"], [74]], ["second", 100, "comesFrom", ["second"], [74]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  4 NEW_LINE void mergeKArrays ( int arr [ ] [ n ] , int a , int output [ ] ) { int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) output [ c ++ ] = arr [ i ] [ j ] ; } sort ( output , output + n * a ) ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] [ n ] = { { 2 , 6 , 12 , 34 } , { 1 , 9 , 20 , 1000 } , { 23 , 34 , 90 , 2000 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int output [ n * k ] ; mergeKArrays ( arr , 3 , output ) ; cout << \" Merged ▁ array ▁ is ▁ \" << endl ; printArray ( output , n * k ) ; return 0 ; }", "docstring": "Merge k sorted arrays | Set 1 | C ++ program to merge k sorted arrays of size n each . ; This function takes an array of arrays as an argument and All arrays are assumed to be sorted . It merges them together and prints the final sorted output . ; traverse the matrix ; sort the array ; A utility function to print array elements ; Driver program to test above functions", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  4 NEW_LINE void mergeArrays ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 , int arr3 [ ] ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) arr3 [ k ++ ] = arr1 [ i ++ ] ; else arr3 [ k ++ ] = arr2 [ j ++ ] ; } while ( i < n1 ) arr3 [ k ++ ] = arr1 [ i ++ ] ; while ( j < n2 ) arr3 [ k ++ ] = arr2 [ j ++ ] ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } void mergeKArrays ( int arr [ ] [ n ] , int i , int j , int output [ ] ) { if ( i == j ) { for ( int p = 0 ; p < n ; p ++ ) output [ p ] = arr [ i ] [ p ] ; return ; } if ( j - i == 1 ) { mergeArrays ( arr [ i ] , arr [ j ] , n , n , output ) ; return ; } int out1 [ n * ( ( ( i + j ) / 2 ) - i + 1 ) ] , out2 [ n * ( j - ( ( i + j ) / 2 ) ) ] ; mergeKArrays ( arr , i , ( i + j ) / 2 , out1 ) ; mergeKArrays ( arr , ( i + j ) / 2 + 1 , j , out2 ) ; mergeArrays ( out1 , out2 , n * ( ( ( i + j ) / 2 ) - i + 1 ) , n * ( j - ( ( i + j ) / 2 ) ) , output ) ; } int main ( ) { int arr [ ] [ n ] = { { 2 , 6 , 12 , 34 } , { 1 , 9 , 20 , 1000 } , { 23 , 34 , 90 , 2000 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int output [ n * k ] ; mergeKArrays ( arr , 0 , 2 , output ) ; cout << \" Merged ▁ array ▁ is ▁ \" << endl ; printArray ( output , n * k ) ; return 0 ; }", "docstring": "Merge k sorted arrays | Set 1 | C ++ program to merge k sorted arrays of size n each . ; Merge arr1 [ 0. . n1 - 1 ] and arr2 [ 0. . n2 - 1 ] into arr3 [ 0. . n1 + n2 - 1 ] ; Traverse both array ; Check if current element of first array is smaller than current element of second array . If yes , store first array element and increment first array index . Otherwise do same with second array ; Store remaining elements of first array ; Store remaining elements of second array ; A utility function to print array elements ; This function takes an array of arrays as an argument and All arrays are assumed to be sorted . It merges them together and prints the final sorted output . ; if one array is in range ; if only two arrays are left them merge them ; output arrays ; divide the array into halves ; merge the output array ; Driver program to test above functions ; Change n at the top to change number of elements in an array", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generate_derangement ( int N ) { int S [ N + 1 ] ; priority_queue < int , vector < int > , greater < int > > PQ ; for ( int i = 1 ; i <= N ; i ++ ) { S [ i ] = i ; PQ . push ( S [ i ] ) ; } int D [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { int d = PQ . top ( ) ; PQ . pop ( ) ; if ( d != S [ i ] i == N ) { D [ i ] = d ; } else { D [ i ] = PQ . top ( ) ; PQ . pop ( ) ; PQ . push ( d ) ; } } if ( D [ N ] == S [ N ] ) swap ( D [ N - 1 ] , D [ N ] ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , D [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { generate_derangement ( 10 ) ; return 0 ; }", "docstring": "Smallest Derangement of Sequence | C ++ program to generate smallest derangement using priority queue . ; Generate Sequence and insert into a priority queue . ; Generate Least Derangement ; Print Derangement ; Driver code", "dfg": [["i", 45, "comesFrom", ["i"], [41]], ["i", 49, "comesFrom", ["i"], [41]], ["i", 86, "comesFrom", ["i"], [82]], ["i", 90, "comesFrom", ["i"], [82]], ["i", 192, "comesFrom", ["i"], [188]], ["i", 196, "comesFrom", ["i"], [188]], ["i", 58, "comesFrom", ["i"], [41]], ["i", 55, "comesFrom", ["i"], [41]], ["i", 117, "comesFrom", ["i"], [82]], ["i", 207, "comesFrom", ["i"], [188]], ["i", 66, "comesFrom", ["i"], [41]], ["i", 115, "comesFrom", ["i"], [82]], ["i", 124, "comesFrom", ["i"], [82]], ["i", 134, "comesFrom", ["i"], [82]], ["N", 47, "comesFrom", ["N"], [11]], ["N", 88, "comesFrom", ["N"], [11]], ["N", 194, "comesFrom", ["N"], [11]], ["N", 17, "comesFrom", ["N"], [11]], ["N", 74, "comesFrom", ["N"], [11]], ["N", 119, "comesFrom", ["N"], [11]], ["N", 162, "comesFrom", ["N"], [11]], ["N", 167, "comesFrom", ["N"], [11]], ["N", 181, "comesFrom", ["N"], [11]], ["N", 174, "comesFrom", ["N"], [11]], ["PQ", 60, "comesFrom", ["PQ"], [36]], ["PQ", 103, "comesFrom", ["PQ"], [36]], ["PQ", 97, "comesFrom", ["PQ"], [36]], ["PQ", 143, "comesFrom", ["PQ"], [36]], ["PQ", 149, "comesFrom", ["PQ"], [36]], ["PQ", 137, "comesFrom", ["PQ"], [36]], ["d", 111, "comesFrom", ["d"], [95]], ["d", 127, "comesFrom", ["d"], [95]], ["d", 153, "comesFrom", ["d"], [95]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE void generate_derangement ( int N ) { int S [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N && i % N != 0 ) { int temp = D [ N ] ; D [ N ] = D [ N - 1 ] ; D [ N - 1 ] = temp ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( \" % d ▁ \" , D [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { generate_derangement ( 10 ) ; return 0 ; }", "docstring": "Smallest Derangement of Sequence | Efficient C ++ program to find smallest derangement . ; Generate Sequence S ; Generate Derangement ; Only if i is odd Swap D [ N - 1 ] and D [ N ] ; Print Derangement ; Driver Program", "dfg": [["i", 25, "comesFrom", ["i"], [21]], ["i", 29, "comesFrom", ["i"], [21]], ["i", 54, "comesFrom", ["i"], [50]], ["i", 135, "comesFrom", ["i"], [131]], ["i", 139, "comesFrom", ["i"], [131]], ["i", 37, "comesFrom", ["i"], [21]], ["i", 34, "comesFrom", ["i"], [21]], ["i", 65, "comesFrom", ["i"], [58]], ["i", 150, "comesFrom", ["i"], [131]], ["i", 69, "comesFrom", ["i"], [58]], ["i", 124, "comesFrom", ["i"], [58]], ["i", 113, "comesFrom", ["i"], [58]], ["i", 110, "comesFrom", ["i"], [58]], ["i", 119, "comesFrom", ["i"], [58]], ["N", 27, "comesFrom", ["N"], [7]], ["N", 56, "comesFrom", ["N"], [7]], ["N", 137, "comesFrom", ["N"], [7]], ["N", 13, "comesFrom", ["N"], [7]], ["N", 42, "comesFrom", ["N"], [7]], ["N", 67, "comesFrom", ["N"], [7]], ["N", 71, "comesFrom", ["N"], [7]], ["N", 81, "comesFrom", ["N"], [7]], ["N", 86, "comesFrom", ["N"], [7]], ["N", 91, "comesFrom", ["N"], [7]], ["N", 98, "comesFrom", ["N"], [7]], ["temp", 103, "comesFrom", ["temp"], [77]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLargest ( int seq [ ] , int N ) { int res [ N ] ; std :: priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) pq . push ( seq [ i ] ) ; for ( int i = 0 ; i < N ; i ++ ) { int d = pq . top ( ) ; pq . pop ( ) ; if ( d != seq [ i ] i == N - 1 ) { res [ i ] = d ; } else { res [ i ] = pq . top ( ) ; pq . pop ( ) ; pq . push ( d ) ; } } if ( res [ N - 1 ] == seq [ N - 1 ] ) { res [ N - 1 ] = res [ N - 2 ] ; res [ N - 2 ] = seq [ N - 1 ] ; } printf ( \" Largest Derangement \" for ( int i = 0 ; i < N ; i ++ ) printf ( \" % d ▁ \" , res [ i ] ) ; } int main ( ) { int seq [ ] = { 92 , 3 , 52 , 13 , 2 , 31 , 1 } ; int n = sizeof ( seq ) / sizeof ( seq [ 0 ] ) ; printLargest ( seq , n ) ; return 0 ; }", "docstring": "Largest Derangement of a Sequence | C ++ program to find the largest derangement ; Stores result ; Insert all elements into a priority queue ; Fill Up res [ ] from left to right ; New Element poped equals the element in original sequence . Get the next largest element ; If given sequence is in descending order then we need to swap last two elements again ; Driver code", "dfg": [["i", 196, "comesFrom", ["i"], [192]], ["i", 40, "comesFrom", ["i"], [36]], ["i", 44, "comesFrom", ["i"], [36]], ["i", 64, "comesFrom", ["i"], [60]], ["i", 68, "comesFrom", ["i"], [60]], ["i", 200, "comesFrom", ["i"], [192]], ["i", 53, "comesFrom", ["i"], [36]], ["i", 95, "comesFrom", ["i"], [60]], ["i", 211, "comesFrom", ["i"], [192]], ["i", 93, "comesFrom", ["i"], [60]], ["i", 104, "comesFrom", ["i"], [60]], ["i", 114, "comesFrom", ["i"], [60]], ["N", 22, "comesFrom", ["N"], [16]], ["N", 42, "comesFrom", ["N"], [16]], ["N", 66, "comesFrom", ["N"], [16]], ["N", 198, "comesFrom", ["N"], [16]], ["N", 97, "comesFrom", ["N"], [16]], ["N", 142, "comesFrom", ["N"], [16]], ["N", 149, "comesFrom", ["N"], [16]], ["N", 157, "comesFrom", ["N"], [16]], ["N", 164, "comesFrom", ["N"], [16]], ["N", 171, "comesFrom", ["N"], [16]], ["N", 178, "comesFrom", ["N"], [16]], ["pq", 47, "comesFrom", ["pq"], [31]], ["pq", 81, "comesFrom", ["pq"], [31]], ["pq", 75, "comesFrom", ["pq"], [31]], ["pq", 123, "comesFrom", ["pq"], [31]], ["pq", 129, "comesFrom", ["pq"], [31]], ["pq", 117, "comesFrom", ["pq"], [31]], ["d", 89, "comesFrom", ["d"], [73]], ["d", 107, "comesFrom", ["d"], [73]], ["d", 133, "comesFrom", ["d"], [73]], ["n", 262, "comesFrom", ["n"], [243]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; } int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; } int main ( ) { int costPrice = 1500 , sellingPrice = 2000 ; if ( sellingPrice == costPrice ) cout << \" No ▁ profit ▁ nor ▁ Loss \" ; else if ( sellingPrice > costPrice ) cout << Profit ( costPrice , sellingPrice ) << \" ▁ Profit ▁ \" ; else cout << Loss ( costPrice , sellingPrice ) << \" ▁ Loss ▁ \" ; return 0 ; }", "docstring": "Program to calculate Profit Or Loss | C ++ code to demonstrate Profit and Loss ; Function to calculate Profit . ; Function to calculate Loss . ; Driver Code .", "dfg": [["Loss", 50, "comesFrom", ["Loss"], [41]], ["Loss", 102, "comesFrom", ["Loss"], [41]], ["profit", 27, "comesFrom", ["profit"], [18]], ["sellingPrice", 69, "comesFrom", ["sellingPrice"], [63]], ["sellingPrice", 21, "comesFrom", ["sellingPrice"], [14]], ["sellingPrice", 46, "comesFrom", ["sellingPrice"], [37]], ["sellingPrice", 82, "comesFrom", ["sellingPrice"], [63]], ["sellingPrice", 92, "comesFrom", ["sellingPrice"], [63]], ["sellingPrice", 106, "comesFrom", ["sellingPrice"], [63]], ["costPrice", 71, "comesFrom", ["costPrice"], [59]], ["costPrice", 23, "comesFrom", ["costPrice"], [11]], ["costPrice", 44, "comesFrom", ["costPrice"], [34]], ["costPrice", 84, "comesFrom", ["costPrice"], [59]], ["costPrice", 90, "comesFrom", ["costPrice"], [59]], ["costPrice", 104, "comesFrom", ["costPrice"], [59]]]}
{"code": "#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; int nextPerfectSquare ( int N ) { int nextN = floor ( sqrt ( N ) ) + 1 ; return nextN * nextN ; } int main ( ) { int n = 35 ; cout << nextPerfectSquare ( n ) ; return 0 ; }", "docstring": "Find the Next perfect square greater than a given number | C ++ implementation of above approach ; Function to find the next perfect square ; Driver Code", "dfg": [["nextN", 31, "comesFrom", ["nextN"], [18]], ["nextN", 33, "comesFrom", ["nextN"], [18]], ["n", 50, "comesFrom", ["n"], [42]], ["N", 24, "comesFrom", ["N"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubstrings ( int n ) { int s = log10 ( n ) ; int d = ( int ) ( pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n ) { while ( d ) { cout << n / d << endl ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } } int main ( ) { int n = 123 ; printSubstrings ( n ) ; return 0 ; }", "docstring": "Print all substring of a number without any conversion | C ++ implementation of above approach ; Function to print the substrings of a number ; Calculate the total number of digits ; 0.5 has been added because of it will return double value like 99.556 ; Print all the numbers from starting position ; Update the no . ; Update the no . of digits ; Driver code", "dfg": [["n", 46, "comesFrom", ["n"], [11]], ["n", 99, "comesFrom", ["n"], [93]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 71, "comesFrom", ["n"], [69]], ["n", 56, "comesFrom", ["n"], [11]], ["d", 51, "comesFrom", ["d"], [42]], ["d", 64, "comesFrom", ["d"], [62]], ["d", 58, "comesFrom", ["d"], [42]], ["k", 83, "comesFrom", ["k"], [75]], ["k", 73, "comesFrom", ["k"], [40]], ["k", 77, "comesFrom", ["k"], [75]], ["s", 33, "comesFrom", ["s"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE const ll MOD = 1e9 + 7 ; ll powerLL ( ll x , ll n ) { ll result = 1 ; while ( n ) { if ( n & 1 ) result = result * x % MOD ; n = n / 2 ; x = x * x % MOD ; } return result ; } ll powerStrings ( string sa , string sb ) { ll a = 0 , b = 0 ; for ( int i = 0 ; i < sa . length ( ) ; i ++ ) a = ( a * 10 + ( sa [ i ] - '0' ) ) % MOD ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) b = ( b * 10 + ( sb [ i ] - '0' ) ) % ( MOD - 1 ) ; return powerLL ( a , b ) ; } int main ( ) { string sa = \"2\" , sb = \"3\" ; cout << powerStrings ( sa , sb ) << endl ; return 0 ; }", "docstring": "Modulo power for large numbers represented as strings | CPP program to find ( a ^ b ) % MOD where a and b may be very large and represented as strings . ; Returns modulo exponentiation for two numbers represented as long long int . It is used by powerStrings ( ) . Its complexity is log ( n ) ; Returns modulo exponentiation for two numbers represented as strings . It is used by powerStrings ( ) ; We convert strings to number ; calculating a % MOD ; calculating b % ( MOD - 1 ) ; Now a and b are long long int . We calculate a ^ b using modulo exponentiation ; Driver code ; As numbers are very large that is it may contains upto 10 ^ 6 digits . So , we use string .", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; } int previousPowerOfTwo ( int n ) { while ( n & n - 1 ) { n = n & n - 1 ; } return n ; } bool checkSum ( int n ) { if ( n == 0 n == 1 ) return false ; else if ( isPowerOfTwo ( n ) ) { cout << \" ▁ \" << n / 2 << \" ▁ \" << n / 2 ; return true ; } else { int x = previousPowerOfTwo ( n ) ; int y = n - x ; if ( isPowerOfTwo ( y ) ) { cout << \" ▁ \" << x << \" ▁ \" << y ; return true ; } } return false ; } int main ( ) { int n1 = 20 ; if ( checkSum ( n1 ) == false ) cout << \" No \" ; cout << endl ; int n2 = 11 ; if ( checkSum ( n2 ) == false ) cout << \" No \" ; return 0 ; }", "docstring": "Check if a number can be expressed as 2 ^ x + 2 ^ y | CPP code to check if a number can be expressed as 2 ^ x + 2 ^ y ; Utility function to check if a number is power of 2 or not ; Utility function to determine the value of previous power of 2 ; function to check if n can be expressed as 2 ^ x + 2 ^ y or not ; if value of n is 0 or 1 it can not be expressed as 2 ^ x + 2 ^ y ; if a number is power of 2 then it can be expressed as 2 ^ x + 2 ^ y ; if the remainder after subtracting previous power of 2 is also a power of 2 then it can be expressed as 2 ^ x + 2 ^ y ; driver code", "dfg": [["n", 57, "comesFrom", ["n"], [47]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 40, "comesFrom", ["n"], [35]], ["n", 42, "comesFrom", ["n"], [35]], ["n", 69, "comesFrom", ["n"], [64]], ["n", 72, "comesFrom", ["n"], [64]], ["n", 49, "comesFrom", ["n"], [47]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 51, "comesFrom", ["n"], [47]], ["n", 84, "comesFrom", ["n"], [64]], ["n", 102, "comesFrom", ["n"], [64]], ["n", 23, "comesFrom", ["n"], [11]], ["n", 123, "comesFrom", ["n"], [64]], ["n", 94, "comesFrom", ["n"], [64]], ["n", 117, "comesFrom", ["n"], [64]], ["n1", 172, "comesFrom", ["n1"], [164]], ["n2", 196, "comesFrom", ["n2"], [188]], ["x", 125, "comesFrom", ["x"], [113]], ["x", 141, "comesFrom", ["x"], [113]], ["y", 131, "comesFrom", ["y"], [121]], ["y", 147, "comesFrom", ["y"], [121]]]}
{"code": "#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; int complement ( int num ) { int i , len = 0 , temp , comp ; temp = num ; while ( 1 ) { len ++ ; num = num / 10 ; if ( abs ( num ) == 0 ) break ; } num = temp ; comp = pow ( 10 , len ) - num ; return comp ; } int main ( ) { cout << complement ( 25 ) << endl ; cout << complement ( 456 ) ; return 0 ; }", "docstring": "10 's Complement of a decimal number | C ++ program to find 10 's complement ; Function to find 10 's complement ; Calculating total digits in num ; restore num ; calculate 10 's complement ; Driver code", "dfg": [["comp", 74, "comesFrom", ["comp"], [62]], ["num", 30, "comesFrom", ["num"], [14]], ["num", 71, "comesFrom", ["num"], [58]], ["num", 42, "comesFrom", ["num"], [40]], ["num", 50, "comesFrom", ["num"], [40]], ["temp", 60, "comesFrom", ["temp"], [28]], ["len", 37, "comesFrom", ["len"], [20]], ["len", 68, "comesFrom", ["len"], [20]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } int main ( ) { int a = 0 , b = 56 ; cout << \" GCD ▁ of ▁ \" << a << \" ▁ and ▁ \" << b << \" ▁ is ▁ \" << gcd ( a , b ) ; return 0 ; }", "docstring": "Program to find HCF ( Highest Common Factor ) of 2 Numbers | C ++ program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver program to test above function", "dfg": [["b", 37, "comesFrom", ["b"], [14]], ["b", 41, "comesFrom", ["b"], [14]], ["b", 52, "comesFrom", ["b"], [14]], ["b", 61, "comesFrom", ["b"], [14]], ["b", 23, "comesFrom", ["b"], [14]], ["b", 70, "comesFrom", ["b"], [14]], ["b", 78, "comesFrom", ["b"], [14]], ["b", 110, "comesFrom", ["b"], [94]], ["b", 120, "comesFrom", ["b"], [94]], ["b", 68, "comesFrom", ["b"], [14]], ["a", 46, "comesFrom", ["a"], [11]], ["a", 55, "comesFrom", ["a"], [11]], ["a", 32, "comesFrom", ["a"], [11]], ["a", 50, "comesFrom", ["a"], [11]], ["a", 59, "comesFrom", ["a"], [11]], ["a", 76, "comesFrom", ["a"], [11]], ["a", 19, "comesFrom", ["a"], [11]], ["a", 80, "comesFrom", ["a"], [11]], ["a", 118, "comesFrom", ["a"], [90]], ["a", 66, "comesFrom", ["a"], [11]], ["a", 104, "comesFrom", ["a"], [90]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOddSum ( int a [ ] , int n ) { int odd = 0 , c_odd = 0 , result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) { odd = ! odd ; } if ( odd ) { c_odd ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] & 1 ) { c_odd = ( n - i - c_odd ) ; } } return result ; } int main ( ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << \" The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ odd ▁ sum ▁ is ▁ \" << countOddSum ( ar , n ) ; return ( 0 ) ; }", "docstring": "Number of sub arrays with odd sum | C ++ program to find number of subarrays with odd sum ; Function to find number of subarrays with odd sum ; ' odd ' stores number of odd numbers upto ith index ' c _ odd ' stores number of odd sum subarrays starting at ith index ' Result ' stores the number of odd sum subarrays ; First find number of odd sum subarrays starting at 0 th index ; Find number of odd sum subarrays starting at ith index add to result ; Driver code", "dfg": [["result", 115, "comesFrom", ["result"], [88]], ["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 80, "comesFrom", ["i"], [76]], ["i", 84, "comesFrom", ["i"], [76]], ["i", 51, "comesFrom", ["i"], [35]], ["i", 96, "comesFrom", ["i"], [76]], ["i", 107, "comesFrom", ["i"], [76]], ["n", 41, "comesFrom", ["n"], [16]], ["n", 82, "comesFrom", ["n"], [16]], ["n", 168, "comesFrom", ["n"], [143]], ["n", 105, "comesFrom", ["n"], [16]], ["odd", 65, "comesFrom", ["odd"], [57]], ["odd", 60, "comesFrom", ["odd"], [57]], ["c_odd", 90, "comesFrom", ["c_odd"], [24]], ["c_odd", 68, "comesFrom", ["c_odd"], [24]], ["c_odd", 109, "comesFrom", ["c_odd"], [102]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNthRoot ( double x , int n ) { double low , high ; if ( x >= 0 and x <= 1 ) { low = x ; high = 1 ; } else { low = 1 ; high = x ; } double epsilon = 0.00000001 ; double guess = ( low + high ) / 2 ; while ( abs ( ( pow ( guess , n ) ) - x ) >= epsilon ) { if ( pow ( guess , n ) > x ) { high = guess ; } else { low = guess ; } guess = ( low + high ) / 2 ; } cout << fixed << setprecision ( 16 ) << guess ; } int main ( ) { double x = 5 ; int n = 2 ; findNthRoot ( x , n ) ; }", "docstring": "Calculating n | C ++ Program to find n - th real root of x ; Initialize boundary values ; Used for taking approximations of the answer ; Do binary search ; Driver code", "dfg": [["guess", 132, "comesFrom", ["guess"], [112]], ["guess", 102, "comesFrom", ["guess"], [59]], ["guess", 92, "comesFrom", ["guess"], [59]], ["guess", 109, "comesFrom", ["guess"], [59]], ["guess", 76, "comesFrom", ["guess"], [59]], ["epsilon", 85, "comesFrom", ["epsilon"], [54]], ["x", 152, "comesFrom", ["x"], [141]], ["x", 24, "comesFrom", ["x"], [11]], ["x", 28, "comesFrom", ["x"], [11]], ["x", 35, "comesFrom", ["x"], [11]], ["x", 50, "comesFrom", ["x"], [11]], ["x", 97, "comesFrom", ["x"], [11]], ["x", 82, "comesFrom", ["x"], [11]], ["n", 154, "comesFrom", ["n"], [146]], ["n", 94, "comesFrom", ["n"], [14]], ["n", 78, "comesFrom", ["n"], [14]], ["low", 62, "comesFrom", ["low"], [44]], ["low", 115, "comesFrom", ["low"], [107]], ["high", 64, "comesFrom", ["high"], [48]], ["high", 117, "comesFrom", ["high"], [100]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int calculateSum ( int n ) { long long int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; } int main ( ) { int n = 10 ; cout << \" ▁ Sum ▁ of ▁ all ▁ elements : \" << calculateSum ( n ) ; return 0 ; }", "docstring": "Sum of all elements up to Nth row in a Pascal triangle | C ++ program to find sum of all elements upto nth row in Pascal triangle . ; Function to find sum of all elements upto nth row . ; Initialize sum with 0 ; Loop to calculate power of 2 upto n and add them ; Driver function", "dfg": [["sum", 50, "comesFrom", ["sum"], [38]], ["sum", 40, "comesFrom", ["sum"], [38]], ["row", 30, "comesFrom", ["row"], [26]], ["row", 34, "comesFrom", ["row"], [26]], ["row", 45, "comesFrom", ["row"], [26]], ["n", 32, "comesFrom", ["n"], [13]], ["n", 71, "comesFrom", ["n"], [59]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ; } else { return pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ; } } int main ( ) { int N = 2 ; cout << findAllSequence ( N ) << endl ; return 0 ; }", "docstring": "Number of sequences which has HEAD at alternate positions to the right of the first HEAD | C ++ program to find number of sequences ; function to calculate total sequences possible ; Value of N is even ; Value of N is odd ; Driver code", "dfg": [["N", 16, "comesFrom", ["N"], [11]], ["N", 94, "comesFrom", ["N"], [86]], ["N", 39, "comesFrom", ["N"], [11]], ["N", 28, "comesFrom", ["N"], [11]], ["N", 55, "comesFrom", ["N"], [11]], ["N", 68, "comesFrom", ["N"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1000000 ; long long phi [ N + 5 ] ; void computeTotient ( ) { for ( int i = 1 ; i <= N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } } long long power ( long long x , long long y , long long p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } long long calculate ( long long x , long long k , long long mod ) { long long arr [ N ] ; long long count = 0 ; while ( mod > 1 ) { arr [ count ++ ] = mod ; mod = phi [ mod ] ; } long long result = 1 ; long long loop = count + 1 ; arr [ count ] = 1 ; for ( int i = min ( k , loop ) - 1 ; i >= 0 ; i -- ) result = power ( x , result , arr [ i ] ) ; return result ; } int main ( ) { computeTotient ( ) ; long long x = 3 , k = 2 , m = 3 ; cout << calculate ( x , k , m ) << endl ; return 0 ; }", "docstring": "Compute power of power k times % m | C ++ program to compute x ^ x ^ x ^ x . . % m ; Create an array to store phi or totient values ; Function to calculate Euler Totient values ; indicates not evaluated yet and initializes for product formula . ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to calculate ( x ^ x ^ x ^ x ... k times ) % m ; to store different mod values ; run loop in reverse to calculate result ; Driver Code ; compute euler totient function values ; Calling function to compute answer", "dfg": [["N", 17, "comesFrom", ["N"], [9]], ["N", 36, "comesFrom", ["N"], [9]], ["N", 57, "comesFrom", ["N"], [9]], ["N", 200, "comesFrom", ["N"], [9]], ["N", 93, "comesFrom", ["N"], [9]], ["res", 176, "comesFrom", ["res"], [154]], ["res", 157, "comesFrom", ["res"], [154]], ["result", 289, "comesFrom", ["result"], [274]], ["result", 280, "comesFrom", ["result"], [274]], ["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["i", 267, "comesFrom", ["i"], [256]], ["i", 271, "comesFrom", ["i"], [256]], ["i", 46, "comesFrom", ["i"], [30]], ["i", 43, "comesFrom", ["i"], [30]], ["i", 91, "comesFrom", ["i"], [85]], ["i", 284, "comesFrom", ["i"], [256]], ["i", 102, "comesFrom", ["i"], [95]], ["i", 108, "comesFrom", ["i"], [95]], ["p", 55, "comesFrom", ["p"], [51]], ["p", 59, "comesFrom", ["p"], [51]], ["p", 70, "comesFrom", ["p"], [51]], ["p", 172, "comesFrom", ["p"], [138]], ["p", 97, "comesFrom", ["p"], [51]], ["p", 162, "comesFrom", ["p"], [138]], ["p", 67, "comesFrom", ["p"], [51]], ["p", 78, "comesFrom", ["p"], [51]], ["p", 75, "comesFrom", ["p"], [51]], ["p", 89, "comesFrom", ["p"], [51]], ["p", 111, "comesFrom", ["p"], [51]], ["p", 115, "comesFrom", ["p"], [51]], ["y", 143, "comesFrom", ["y"], [134]], ["y", 150, "comesFrom", ["y"], [134]], ["mod", 211, "comesFrom", ["mod"], [193]], ["mod", 222, "comesFrom", ["mod"], [193]], ["mod", 228, "comesFrom", ["mod"], [224]], ["count", 242, "comesFrom", ["count"], [205]], ["count", 248, "comesFrom", ["count"], [205]], ["count", 218, "comesFrom", ["count"], [205]], ["x", 278, "comesFrom", ["x"], [185]], ["x", 319, "comesFrom", ["x"], [303]], ["x", 167, "comesFrom", ["x"], [164]], ["x", 169, "comesFrom", ["x"], [164]], ["x", 159, "comesFrom", ["x"], [130]], ["k", 321, "comesFrom", ["k"], [307]], ["k", 260, "comesFrom", ["k"], [189]], ["m", 323, "comesFrom", ["m"], [311]], ["loop", 262, "comesFrom", ["loop"], [240]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; } int main ( ) { int n = 13 ; cout << countOnes ( n ) ; }", "docstring": "Number of ones in the smallest repunit | CPP program to print the number of 1 s in smallest repunit multiple of the number . ; Function to find number of 1 s in smallest repunit multiple of the number ; to store number of 1 s in smallest repunit multiple of the number . ; initialize rem with 1 ; run loop until rem becomes zero ; rem * 10 + 1 here represents the repunit modulo n ; when remainder becomes 0 return count ; Driver Code ; Calling function", "dfg": [["count", 48, "comesFrom", ["count"], [15]], ["count", 43, "comesFrom", ["count"], [15]], ["rem", 26, "comesFrom", ["rem"], [20]], ["rem", 34, "comesFrom", ["rem"], [31]], ["n", 65, "comesFrom", ["n"], [57]], ["n", 41, "comesFrom", ["n"], [11]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int largestNum ( int a , int b ) { return a * ( bool ) ( a / b ) + b * ( bool ) ( b / a ) ; } int main ( ) { int a = 22 , b = 1231 ; cout << largestNum ( a , b ) ; return 0 ; }", "docstring": "Largest of two distinct numbers without using any conditional statements or operators | C ++ program for above implementation ; Function to find the largest number ; Drivers code", "dfg": [["a", 18, "comesFrom", ["a"], [11]], ["a", 59, "comesFrom", ["a"], [47]], ["a", 24, "comesFrom", ["a"], [11]], ["a", 37, "comesFrom", ["a"], [11]], ["b", 29, "comesFrom", ["b"], [14]], ["b", 61, "comesFrom", ["b"], [51]], ["b", 26, "comesFrom", ["b"], [14]], ["b", 35, "comesFrom", ["b"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { int c = a % b ; while ( c != 0 ) { a = b ; b = c ; c = a % b ; } return b ; } int numberOfmeet ( int a , int b ) { int ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( -1 ) ; if ( b < 0 ) b = b * ( -1 ) ; return ans / gcd ( a , b ) ; } int main ( ) { int a = 1 , b = -1 ; cout << numberOfmeet ( a , b ) << endl ; return 0 ; }", "docstring": "Number of Distinct Meeting Points on a Circular Road | CPP Program to find number of distinct point of meet on a circular road ; Returns the GCD of two number . ; Returns the number of distinct meeting points . ; Find the relative speed . ; convert the negative value to positive . ; Driver Code", "dfg": [["b", 47, "comesFrom", ["b"], [35]], ["b", 22, "comesFrom", ["b"], [14]], ["b", 67, "comesFrom", ["b"], [57]], ["b", 98, "comesFrom", ["b"], [57]], ["b", 33, "comesFrom", ["b"], [14]], ["b", 73, "comesFrom", ["b"], [57]], ["b", 104, "comesFrom", ["b"], [102]], ["b", 117, "comesFrom", ["b"], [102]], ["b", 43, "comesFrom", ["b"], [35]], ["b", 78, "comesFrom", ["b"], [57]], ["b", 141, "comesFrom", ["b"], [131]], ["ans", 111, "comesFrom", ["ans"], [76]], ["a", 20, "comesFrom", ["a"], [11]], ["a", 65, "comesFrom", ["a"], [54]], ["a", 84, "comesFrom", ["a"], [54]], ["a", 71, "comesFrom", ["a"], [54]], ["a", 90, "comesFrom", ["a"], [88]], ["a", 115, "comesFrom", ["a"], [88]], ["a", 41, "comesFrom", ["a"], [31]], ["a", 80, "comesFrom", ["a"], [54]], ["a", 139, "comesFrom", ["a"], [127]], ["c", 26, "comesFrom", ["c"], [18]], ["c", 37, "comesFrom", ["c"], [18]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1005 NEW_LINE void SieveOfEratosthenes ( vector < int > & primes ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) primes . push_back ( p ) ; } int minimumSquareFreeDivisors ( int N ) { vector < int > primes ; SieveOfEratosthenes ( primes ) ; int max_count = 0 ; for ( int i = 0 ; i < primes . size ( ) && primes [ i ] * primes [ i ] <= N ; i ++ ) { if ( N % primes [ i ] == 0 ) { int tmp = 0 ; while ( N % primes [ i ] == 0 ) { tmp ++ ; N /= primes [ i ] ; } max_count = max ( max_count , tmp ) ; } } if ( max_count == 0 ) max_count = 1 ; return max_count ; } int main ( ) { int N = 24 ; cout << \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is ▁ \" << minimumSquareFreeDivisors ( N ) << endl ; N = 6 ; cout << \" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is ▁ \" << minimumSquareFreeDivisors ( N ) << endl ; return 0 ; }", "docstring": "Minimum number of Square Free Divisors | CPP Program to find the minimum number of square free divisors ; Initializing MAX with SQRT ( 10 ^ 6 ) ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all prime numbers ; This function returns the minimum number of Square Free divisors ; Precomputing Prime Factors ; holds max of max power of all prime factors ; holds the max power of current prime factor ; If number itself is prime , it will be included as answer and thus minimum required answer is 1 ; Driver Code to test above functions", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxGCD ( int arr [ ] , int n , int k ) { int high = * max_element ( arr , arr + n ) ; int divisors [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] >= k ) return i ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 8 , 12 } ; int k = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxGCD ( arr , n , k ) ; return 0 ; }", "docstring": "Subsequence of size k with maximum possible GCD | CPP program to find subsequence of size k with maximum possible GCD . ; function to find GCD of sub sequence of size k with max GCD in the array ; Computing highest element ; Array to store the count of divisors i . e . Potential GCDs ; Iterating over every element ; Calculating all the divisors ; Divisor found ; Incrementing count for divisor ; Element / divisor is also a divisor Checking if both divisors are not same ; Checking the highest potential GCD ; If this divisor can divide at least k numbers , it is a GCD of at least one sub sequence of size k ; Driver code ; Array in which sub sequence with size k with max GCD is to be found", "dfg": [["i", 54, "comesFrom", ["i"], [50]], ["i", 58, "comesFrom", ["i"], [50]], ["i", 133, "comesFrom", ["i"], [129]], ["i", 137, "comesFrom", ["i"], [129]], ["i", 150, "comesFrom", ["i"], [129]], ["i", 144, "comesFrom", ["i"], [129]], ["i", 75, "comesFrom", ["i"], [50]], ["i", 87, "comesFrom", ["i"], [50]], ["i", 107, "comesFrom", ["i"], [50]], ["i", 116, "comesFrom", ["i"], [50]], ["n", 56, "comesFrom", ["n"], [16]], ["n", 204, "comesFrom", ["n"], [183]], ["n", 32, "comesFrom", ["n"], [16]], ["high", 38, "comesFrom", ["high"], [23]], ["j", 69, "comesFrom", ["j"], [65]], ["j", 79, "comesFrom", ["j"], [65]], ["j", 90, "comesFrom", ["j"], [65]], ["j", 103, "comesFrom", ["j"], [65]], ["j", 97, "comesFrom", ["j"], [65]], ["j", 110, "comesFrom", ["j"], [65]], ["j", 119, "comesFrom", ["j"], [65]], ["k", 147, "comesFrom", ["k"], [19]], ["k", 206, "comesFrom", ["k"], [178]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double determinantOfMatrix ( double mat [ 3 ] [ 3 ] ) { double ans ; ans = mat [ 0 ] [ 0 ] * ( mat [ 1 ] [ 1 ] * mat [ 2 ] [ 2 ] - mat [ 2 ] [ 1 ] * mat [ 1 ] [ 2 ] ) - mat [ 0 ] [ 1 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 2 ] - mat [ 1 ] [ 2 ] * mat [ 2 ] [ 0 ] ) + mat [ 0 ] [ 2 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 1 ] - mat [ 1 ] [ 1 ] * mat [ 2 ] [ 0 ] ) ; return ans ; } void findSolution ( double coeff [ 3 ] [ 4 ] ) { double d [ 3 ] [ 3 ] = { { coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 2 ] } , { coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 2 ] } , { coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 2 ] } , } ; double d1 [ 3 ] [ 3 ] = { { coeff [ 0 ] [ 3 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 2 ] } , { coeff [ 1 ] [ 3 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 2 ] } , { coeff [ 2 ] [ 3 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 2 ] } , } ; double d2 [ 3 ] [ 3 ] = { { coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 3 ] , coeff [ 0 ] [ 2 ] } , { coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 3 ] , coeff [ 1 ] [ 2 ] } , { coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 3 ] , coeff [ 2 ] [ 2 ] } , } ; double d3 [ 3 ] [ 3 ] = { { coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 3 ] } , { coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 3 ] } , { coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 3 ] } , } ; double D = determinantOfMatrix ( d ) ; double D1 = determinantOfMatrix ( d1 ) ; double D2 = determinantOfMatrix ( d2 ) ; double D3 = determinantOfMatrix ( d3 ) ; printf ( \" D ▁ is ▁ : ▁ % lf ▁ STRNEWLINE \" , D ) ; printf ( \" D1 ▁ is ▁ : ▁ % lf ▁ STRNEWLINE \" , D1 ) ; printf ( \" D2 ▁ is ▁ : ▁ % lf ▁ STRNEWLINE \" , D2 ) ; printf ( \" D3 ▁ is ▁ : ▁ % lf ▁ STRNEWLINE \" , D3 ) ; if ( D != 0 ) { double x = D1 / D ; double y = D2 / D ; printf ( \" Value ▁ of ▁ x ▁ is ▁ : ▁ % lf STRNEWLINE \" , x ) ; printf ( \" Value ▁ of ▁ y ▁ is ▁ : ▁ % lf STRNEWLINE \" , y ) ; printf ( \" Value ▁ of ▁ z ▁ is ▁ : ▁ % lf STRNEWLINE \" , z ) ; } else { if ( D1 == 0 && D2 == 0 && D3 == 0 ) printf ( \" Infinite ▁ solutions STRNEWLINE \" ) ; else if ( D1 != 0 D2 != 0 D3 != 0 ) printf ( \" No ▁ solutions STRNEWLINE \" ) ; } } int main ( ) { double coeff [ 3 ] [ 4 ] = { { 2 , -1 , 3 , 9 } , { 1 , 1 , 1 , 6 } , { 1 , -1 , 1 , 2 } , } ; findSolution ( coeff ) ; return 0 ; }", "docstring": "System of Linear Equations in three variables using Cramer 's Rule | CPP program to calculate solutions of linear equations using cramer 's rule ; This functions finds the determinant of Matrix ; This function finds the solution of system of linear equations using cramer 's rule ; Matrix d using coeff as given in cramer 's rule ; Matrix d1 using coeff as given in cramer 's rule ; Matrix d2 using coeff as given in cramer 's rule ; Matrix d3 using coeff as given in cramer 's rule ; Calculating Determinant of Matrices d , d1 , d2 , d3 ; Case 1 ; Coeff have a unique solution . Apply Cramer 's Rule ; double z = D3 / D ; calculating z using cramer 's rule ; Case 2 ; Driver Code ; storing coefficients of linear equations in coeff matrix", "dfg": [["ans", 152, "comesFrom", ["ans"], [23]], ["D", 566, "comesFrom", ["D"], [529]], ["D", 598, "comesFrom", ["D"], [529]], ["D", 608, "comesFrom", ["D"], [529]], ["D", 615, "comesFrom", ["D"], [529]], ["D1", 575, "comesFrom", ["D1"], [537]], ["D1", 606, "comesFrom", ["D1"], [537]], ["D1", 649, "comesFrom", ["D1"], [537]], ["D1", 671, "comesFrom", ["D1"], [537]], ["D2", 584, "comesFrom", ["D2"], [545]], ["D2", 613, "comesFrom", ["D2"], [545]], ["D2", 653, "comesFrom", ["D2"], [545]], ["D2", 674, "comesFrom", ["D2"], [545]], ["D3", 593, "comesFrom", ["D3"], [553]], ["D3", 657, "comesFrom", ["D3"], [553]], ["D3", 677, "comesFrom", ["D3"], [553]], ["x", 623, "comesFrom", ["x"], [604]], ["y", 632, "comesFrom", ["y"], [611]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printGreater ( double x , double y ) { long double X = y * log ( x ) ; long double Y = x * log ( y ) ; if ( abs ( X - Y ) < 1e-9 ) { cout << \" Equal \" ; } else if ( X > Y ) { cout << x << \" ^ \" << y ; } else { cout << y << \" ^ \" << x ; } } int main ( ) { double x = 5 , y = 8 ; printGreater ( x , y ) ; return 0 ; }", "docstring": "Find larger of x ^ y and y ^ x | C ++ program to print greater of x ^ y and y ^ x ; Driver Code", "dfg": [["y", 21, "comesFrom", ["y"], [14]], ["y", 109, "comesFrom", ["y"], [101]], ["y", 36, "comesFrom", ["y"], [14]], ["y", 74, "comesFrom", ["y"], [14]], ["y", 81, "comesFrom", ["y"], [14]], ["x", 32, "comesFrom", ["x"], [11]], ["x", 107, "comesFrom", ["x"], [97]], ["x", 25, "comesFrom", ["x"], [11]], ["x", 87, "comesFrom", ["x"], [11]], ["x", 68, "comesFrom", ["x"], [11]], ["X", 61, "comesFrom", ["X"], [19]], ["X", 43, "comesFrom", ["X"], [19]], ["Y", 63, "comesFrom", ["Y"], [30]], ["Y", 45, "comesFrom", ["Y"], [30]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; } int main ( ) { int n = 4 ; cout << sumOfSeries ( n ) ; return 0 ; }", "docstring": "n | CPP program to find the n - th term in series ; Function to find nth term ; Driver code", "dfg": [["n", 15, "comesFrom", ["n"], [11]], ["n", 60, "comesFrom", ["n"], [52]], ["n", 18, "comesFrom", ["n"], [11]], ["n", 38, "comesFrom", ["n"], [11]], ["n", 30, "comesFrom", ["n"], [11]], ["n", 36, "comesFrom", ["n"], [11]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 34, "comesFrom", ["n"], [11]], ["n", 26, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int mulmod ( long long int a , long long int b , long long int mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } long long int findProduct ( long long int N ) { long long int product = 1 , fact = 1 ; long long int MOD = 1e9 + 7 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = mulmod ( fact , i , MOD ) ; product = mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; } int main ( ) { long long int N = 3 ; cout << findProduct ( N ) << endl ; N = 5 ; cout << findProduct ( N ) << endl ; return 0 ; }", "docstring": "Product of first N factorials | CPP Program to find the product of first N factorials ; To compute ( a * b ) % MOD ; long long int res = 0 ; Initialize result ; If b is odd , add ' a ' to result ; Multiply ' a ' with 2 ; Divide b by 2 ; Return result ; This function computes factorials and product by using above function i . e . modular multiplication ; Initialize product and fact with 1 ; ith factorial ; product of first i factorials ; If at any iteration , product becomes divisible by MOD , simply return 0 ; ; Driver Code to Test above functions", "dfg": [["product", 159, "comesFrom", ["product"], [137]], ["product", 150, "comesFrom", ["product"], [137]], ["product", 141, "comesFrom", ["product"], [137]], ["res", 75, "comesFrom", ["res"], [49]], ["res", 52, "comesFrom", ["res"], [49]], ["mod", 77, "comesFrom", ["mod"], [25]], ["mod", 32, "comesFrom", ["mod"], [25]], ["mod", 67, "comesFrom", ["mod"], [25]], ["mod", 57, "comesFrom", ["mod"], [25]], ["i", 118, "comesFrom", ["i"], [114]], ["i", 122, "comesFrom", ["i"], [114]], ["i", 132, "comesFrom", ["i"], [114]], ["N", 120, "comesFrom", ["N"], [88]], ["N", 178, "comesFrom", ["N"], [170]], ["N", 191, "comesFrom", ["N"], [183]], ["a", 30, "comesFrom", ["a"], [28]], ["a", 62, "comesFrom", ["a"], [59]], ["a", 54, "comesFrom", ["a"], [28]], ["b", 36, "comesFrom", ["b"], [20]], ["b", 43, "comesFrom", ["b"], [20]], ["fact", 130, "comesFrom", ["fact"], [126]], ["fact", 143, "comesFrom", ["fact"], [126]], ["MOD", 134, "comesFrom", ["MOD"], [105]], ["MOD", 145, "comesFrom", ["MOD"], [105]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int divSum ( int n ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; return sum ; } bool areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; } int main ( ) { int num1 = 559 , num2 = 703 ; areEquivalent ( num1 , num2 ) ? cout << \" Equivalent \" : cout << \" Not ▁ Equivalent \" ; return 0 ; }", "docstring": "Check if sum of divisors of two numbers are same | C ++ program to find if two numbers are equivalent or not ; Function to calculate sum of all proper divisors num -- > given natural number ; To store sum of divisors ; Find all divisors and add them ; Function to check if both numbers are equivalent or not ; Drivers code", "dfg": [["sum", 58, "comesFrom", ["sum"], [47]], ["sum", 49, "comesFrom", ["sum"], [47]], ["n", 34, "comesFrom", ["n"], [11]], ["n", 41, "comesFrom", ["n"], [11]], ["n", 53, "comesFrom", ["n"], [11]], ["i", 36, "comesFrom", ["i"], [26]], ["i", 30, "comesFrom", ["i"], [26]], ["i", 32, "comesFrom", ["i"], [26]], ["i", 43, "comesFrom", ["i"], [26]], ["i", 51, "comesFrom", ["i"], [26]], ["i", 55, "comesFrom", ["i"], [26]], ["num1", 74, "comesFrom", ["num1"], [65]], ["num1", 99, "comesFrom", ["num1"], [89]], ["num2", 79, "comesFrom", ["num2"], [68]], ["num2", 101, "comesFrom", ["num2"], [93]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; } int main ( ) { int n = 5 ; cout << n << \" th ▁ Dodecahedral ▁ number : ▁ \" ; cout << dodecahedral_num ( n ) ; return 0 ; }", "docstring": "Dodecahedral number | C ++ program to find nth dodecahedral number ; Function to find dodecahedral number ; Formula to calculate nth dodecahedral number and return it into main function . ; Driver Code ; print result", "dfg": [["n", 48, "comesFrom", ["n"], [42]], ["n", 15, "comesFrom", ["n"], [11]], ["n", 58, "comesFrom", ["n"], [42]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 20, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int bit ( int x ) { int ans = 0 ; while ( x ) { x /= 2 ; ans ++ ; } return ans ; } bool check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; } int bs ( int n ) { int l = 1 , r = sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; } int countDivisor ( int n ) { return n - bs ( n ) + 1 ; } int main ( ) { int n = 5 ; cout << countDivisor ( n ) << endl ; return 0 ; }", "docstring": "Count of divisors having more set bits than quotient on dividing N | C ++ Program to find number of Divisors which on integer division produce quotient having less set bit than divisor ; Return the count of set bit . ; check if q and d have same number of set bit . ; Binary Search to find the point at which number of set in q is less than or equal to d . ; while left index is less than right index ; finding the middle . ; check if q and d have same number of set it or not . ; Driven Program", "dfg": [["ans", 33, "comesFrom", ["ans"], [15]], ["ans", 28, "comesFrom", ["ans"], [15]], ["x", 21, "comesFrom", ["x"], [11]], ["x", 50, "comesFrom", ["x"], [43]], ["l", 88, "comesFrom", ["l"], [75]], ["l", 136, "comesFrom", ["l"], [118]], ["l", 142, "comesFrom", ["l"], [118]], ["l", 130, "comesFrom", ["l"], [118]], ["l", 97, "comesFrom", ["l"], [75]], ["r", 90, "comesFrom", ["r"], [79]], ["r", 99, "comesFrom", ["r"], [79]], ["n", 153, "comesFrom", ["n"], [149]], ["n", 83, "comesFrom", ["n"], [71]], ["n", 132, "comesFrom", ["n"], [71]], ["n", 157, "comesFrom", ["n"], [149]], ["n", 177, "comesFrom", ["n"], [169]], ["n", 110, "comesFrom", ["n"], [71]], ["d", 57, "comesFrom", ["d"], [40]], ["d", 52, "comesFrom", ["d"], [40]], ["m", 115, "comesFrom", ["m"], [94]], ["m", 108, "comesFrom", ["m"], [94]], ["m", 120, "comesFrom", ["m"], [94]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; } int main ( ) { int x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) printf ( \" Yes \" ) ; else printf ( \" No \" ) ; return 0 ; }", "docstring": "Check if two people starting from different points ever meet | C ++ program to find if two people starting from different positions ever meet or not . ; If speed of a person at a position before other person is smaller , then return false . ; Making sure that x1 is greater ; Until one person crosses other ; first person taking one jump in each iteration ; second person taking one jump in each iteration ; Driver code", "dfg": [["x1", 51, "comesFrom", ["x1"], [11]], ["x1", 73, "comesFrom", ["x1"], [11]], ["x1", 25, "comesFrom", ["x1"], [11]], ["x1", 38, "comesFrom", ["x1"], [11]], ["x1", 130, "comesFrom", ["x1"], [110]], ["x1", 58, "comesFrom", ["x1"], [11]], ["x1", 80, "comesFrom", ["x1"], [11]], ["x1", 89, "comesFrom", ["x1"], [87]], ["x2", 53, "comesFrom", ["x2"], [14]], ["x2", 75, "comesFrom", ["x2"], [14]], ["x2", 27, "comesFrom", ["x2"], [14]], ["x2", 40, "comesFrom", ["x2"], [14]], ["x2", 132, "comesFrom", ["x2"], [118]], ["x2", 60, "comesFrom", ["x2"], [14]], ["x2", 82, "comesFrom", ["x2"], [14]], ["x2", 95, "comesFrom", ["x2"], [93]], ["v1", 29, "comesFrom", ["v1"], [17]], ["v1", 42, "comesFrom", ["v1"], [17]], ["v1", 134, "comesFrom", ["v1"], [114]], ["v1", 65, "comesFrom", ["v1"], [17]], ["v1", 91, "comesFrom", ["v1"], [17]], ["v2", 31, "comesFrom", ["v2"], [20]], ["v2", 44, "comesFrom", ["v2"], [20]], ["v2", 136, "comesFrom", ["v2"], [122]], ["v2", 67, "comesFrom", ["v2"], [20]], ["v2", 97, "comesFrom", ["v2"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( long int k , int d0 , int d1 ) { long int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } long int sum = d0 + d1 + ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return \" YES \" ; return \" NO \" ; } int main ( ) { long int k , d0 , d1 ; k = 13 ; d0 = 8 ; d1 = 1 ; cout << check ( k , d0 , d1 ) << endl ; k = 5 ; d0 = 3 ; d1 = 4 ; cout << check ( k , d0 , d1 ) << endl ; return 0 ; }", "docstring": "Divisibility by 3 where each digit is the sum of all prefix digits modulo 10 | CPP code to check divisibility by 3 ; Function to check the divisibility ; Cycle ; no of residual terms ; sum of residual terms ; if no of residue term = 0 ; if no of residue term = 1 ; if no of residue term = 2 ; if no of residue term = 3 ; sum of all digits ; divisibility check ; Driver code", "dfg": [["a", 89, "comesFrom", ["a"], [74]], ["x", 215, "comesFrom", ["x"], [154]], ["sum", 219, "comesFrom", ["sum"], [197]], ["k", 77, "comesFrom", ["k"], [12]], ["k", 265, "comesFrom", ["k"], [249]], ["k", 290, "comesFrom", ["k"], [274]], ["k", 205, "comesFrom", ["k"], [12]], ["d0", 199, "comesFrom", ["d0"], [15]], ["d0", 267, "comesFrom", ["d0"], [253]], ["d0", 292, "comesFrom", ["d0"], [278]], ["d0", 65, "comesFrom", ["d0"], [15]], ["d0", 53, "comesFrom", ["d0"], [15]], ["d0", 29, "comesFrom", ["d0"], [15]], ["d0", 41, "comesFrom", ["d0"], [15]], ["d0", 110, "comesFrom", ["d0"], [15]], ["d0", 129, "comesFrom", ["d0"], [15]], ["d0", 141, "comesFrom", ["d0"], [15]], ["d0", 184, "comesFrom", ["d0"], [15]], ["d0", 160, "comesFrom", ["d0"], [15]], ["d0", 172, "comesFrom", ["d0"], [15]], ["d1", 201, "comesFrom", ["d1"], [18]], ["d1", 269, "comesFrom", ["d1"], [257]], ["d1", 294, "comesFrom", ["d1"], [282]], ["d1", 67, "comesFrom", ["d1"], [18]], ["d1", 55, "comesFrom", ["d1"], [18]], ["d1", 31, "comesFrom", ["d1"], [18]], ["d1", 43, "comesFrom", ["d1"], [18]], ["d1", 112, "comesFrom", ["d1"], [18]], ["d1", 131, "comesFrom", ["d1"], [18]], ["d1", 143, "comesFrom", ["d1"], [18]], ["d1", 186, "comesFrom", ["d1"], [18]], ["d1", 162, "comesFrom", ["d1"], [18]], ["d1", 174, "comesFrom", ["d1"], [18]], ["s", 213, "comesFrom", ["s"], [23]]]}
{"code": "#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int main ( ) { int a = 4 ; int b = 3 ; int val = ( a / b ) + ( ( a % b ) != 0 ) ; cout << \" The ▁ ceiling ▁ value ▁ of ▁ 4/3 ▁ is ▁ \" << val << endl ; a = 6 ; b = 3 ; val = ( a / b ) + ( ( a % b ) != 0 ) ; cout << \" The ▁ ceiling ▁ value ▁ of ▁ 6/3 ▁ is ▁ \" << val << endl ; return 0 ; }", "docstring": "Find ceil of a / b without using ceil ( ) function | C ++ program to find ceil ( a / b ) without using ceil ( ) function ; Driver function ; taking input 1 ; example of perfect division taking input 2", "dfg": [["val", 50, "comesFrom", ["val"], [26]], ["val", 86, "comesFrom", ["val"], [62]], ["a", 29, "comesFrom", ["a"], [16]], ["a", 65, "comesFrom", ["a"], [54]], ["a", 36, "comesFrom", ["a"], [16]], ["a", 72, "comesFrom", ["a"], [54]], ["b", 31, "comesFrom", ["b"], [21]], ["b", 67, "comesFrom", ["b"], [58]], ["b", 38, "comesFrom", ["b"], [21]], ["b", 74, "comesFrom", ["b"], [58]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printCollatz ( int n ) { while ( n != 1 ) { cout << n << \" ▁ \" ; if ( n & 1 ) n = 3 * n + 1 ; else n = n / 2 ; } cout << n ; } int main ( ) { printCollatz ( 6 ) ; return 0 ; }", "docstring": "Program to print Collatz Sequence | CPP program to print Collatz sequence ; We simply follow steps while we do not reach 1 ; If n is odd ; If even ; Print 1 at the end ; Driver code", "dfg": [["n", 53, "comesFrom", ["n"], [44]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 23, "comesFrom", ["n"], [11]], ["n", 31, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [35]], ["n", 46, "comesFrom", ["n"], [44]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void block ( long int x ) { vector < long int > v ; cout << \" Blocks ▁ for ▁ \" << x << \" ▁ : ▁ \" ; while ( x > 0 ) { v . push_back ( x % 2 ) ; x = x / 2 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] == 1 ) { cout << i ; if ( i != v . size ( ) - 1 ) cout << \" , ▁ \" ; } } cout << endl ; } int main ( ) { block ( 71307 ) ; block ( 1213 ) ; block ( 29 ) ; block ( 100 ) ; return 0 ; }", "docstring": "Powers of 2 to required sum | CPP program to find the blocks for given number . ; Converting the decimal number into its binary equivalent . ; Displaying the output when the bit is '1' in binary equivalent of number . ; Driver Function", "dfg": [["i", 64, "comesFrom", ["i"], [60]], ["i", 72, "comesFrom", ["i"], [60]], ["i", 88, "comesFrom", ["i"], [60]], ["i", 80, "comesFrom", ["i"], [60]], ["i", 92, "comesFrom", ["i"], [60]], ["x", 28, "comesFrom", ["x"], [12]], ["x", 36, "comesFrom", ["x"], [12]], ["x", 52, "comesFrom", ["x"], [50]], ["x", 45, "comesFrom", ["x"], [12]], ["v", 66, "comesFrom", ["v"], [20]], ["v", 41, "comesFrom", ["v"], [20]], ["v", 78, "comesFrom", ["v"], [20]], ["v", 94, "comesFrom", ["v"], [20]]]}
{"code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void findNumberOfDigits ( long n , int base ) { int dig = ( int ) ( floor ( log ( n ) / log ( base ) ) + 1 ) ; cout << \" The ▁ Number ▁ of ▁ digits ▁ of ▁ \" << \" Number ▁ \" << n << \" ▁ in ▁ base ▁ \" << base << \" ▁ is ▁ \" << dig ; } int main ( ) { long n = 1446 ; int base = 7 ; findNumberOfDigits ( n , base ) ; return 0 ; }", "docstring": "Given a number N in decimal base , find number of its digits in any base ( base b ) | C ++ program to Find Number of digits in base b . ; function to print number of digits ; Calculating log using base changing property and then taking it floor and then adding 1. ; printing output ; Driver method ; taking inputs ; calling the method", "dfg": [["dig", 65, "comesFrom", ["dig"], [21]], ["n", 85, "comesFrom", ["n"], [74]], ["n", 53, "comesFrom", ["n"], [14]], ["n", 31, "comesFrom", ["n"], [14]], ["base", 87, "comesFrom", ["base"], [79]], ["base", 59, "comesFrom", ["base"], [17]], ["base", 36, "comesFrom", ["base"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; } int main ( ) { double a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) ) cout << \" Nesbitt ' s ▁ inequality ▁ satisfied . \" << \" for ▁ real ▁ numbers ▁ \" << a << \" , ▁ \" << b << \" , ▁ \" << c << \" STRNEWLINE \" ; else cout << \" Not ▁ satisfied \" ; return 0 ; }", "docstring": "Nesbitt 's Inequality | C ++ code to verify Nesbitt 's Inequality ; 3 parts of the inequality sum ; Driver code", "dfg": [["a", 23, "comesFrom", ["a"], [11]], ["a", 92, "comesFrom", ["a"], [76]], ["a", 37, "comesFrom", ["a"], [11]], ["a", 48, "comesFrom", ["a"], [11]], ["a", 109, "comesFrom", ["a"], [76]], ["b", 34, "comesFrom", ["b"], [14]], ["b", 94, "comesFrom", ["b"], [80]], ["b", 26, "comesFrom", ["b"], [14]], ["b", 50, "comesFrom", ["b"], [14]], ["b", 115, "comesFrom", ["b"], [80]], ["c", 45, "comesFrom", ["c"], [17]], ["c", 96, "comesFrom", ["c"], [84]], ["c", 121, "comesFrom", ["c"], [84]], ["c", 28, "comesFrom", ["c"], [17]], ["c", 39, "comesFrom", ["c"], [17]], ["C", 60, "comesFrom", ["C"], [43]], ["inequality", 64, "comesFrom", ["inequality"], [54]], ["A", 56, "comesFrom", ["A"], [21]], ["B", 58, "comesFrom", ["B"], [32]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > primes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } vector < int > arr ; for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) arr . push_back ( i ) ; } return arr ; } vector < int > signature ( int n ) { vector < int > r = primes ( n ) ; map < int , int > factor ; map < int , int > :: iterator it ; vector < int > sort_exp ; int k , t = n ; it = factor . begin ( ) ; for ( int i = 0 ; i < r . size ( ) ; i ++ ) { if ( n % r [ i ] == 0 ) { k = 0 ; while ( n % r [ i ] == 0 ) { n = n / r [ i ] ; k ++ ; } factor . insert ( it , pair < int , int > ( r [ i ] , k ) ) ; sort_exp . push_back ( k ) ; } } sort ( sort_exp . begin ( ) , sort_exp . end ( ) ) ; cout << \" ▁ The ▁ Ordered ▁ Prime ▁ Signature ▁ of ▁ \" << t << \" ▁ is ▁ : ▁ STRNEWLINE { ▁ \" ; for ( int i = 0 ; i < sort_exp . size ( ) ; i ++ ) { if ( i != sort_exp . size ( ) - 1 ) cout << sort_exp [ i ] << \" , ▁ \" ; else cout << sort_exp [ i ] << \" ▁ } STRNEWLINE \" ; } return sort_exp ; } void divisors ( int n ) { int f = 1 , l ; vector < int > div = signature ( n ) ; l = div . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { div [ i ] += 1 ; f *= div [ i ] ; } cout << \" The ▁ total ▁ number ▁ of ▁ divisors ▁ of ▁ \" << n << \" ▁ is ▁ \" << f << \" STRNEWLINE \" ; } int main ( ) { int n = 13 ; divisors ( n ) ; return 0 ; }", "docstring": "Ordered Prime Signature | CPP to find total number of divisors of a number , using ordered prime signature ; Finding primes upto entered number ; Finding primes by Sieve of Eratosthenes method ; If prime [ i ] is not changed , then it is prime ; Update all multiples of p ; Forming array of the prime numbers found ; Finding ordered prime signature of the number ; Map to store prime factors and the related exponents ; Declaring an iterator for map ; Finding prime factorization of the number ; Storing the prime factor and its exponent in map ; Storing the exponent in a vector ; Sorting the stored exponents ; Printing the prime signature ; Finding total number of divisors of the number ; Adding one to each element present ; in ordered prime signature ; Multiplying the elements ; Driver Method", "dfg": [["arr", 127, "comesFrom", ["arr"], [94]], ["arr", 118, "comesFrom", ["arr"], [94]], ["sort_exp", 364, "comesFrom", ["sort_exp"], [173]], ["sort_exp", 317, "comesFrom", ["sort_exp"], [173]], ["sort_exp", 283, "comesFrom", ["sort_exp"], [173]], ["sort_exp", 289, "comesFrom", ["sort_exp"], [173]], ["sort_exp", 272, "comesFrom", ["sort_exp"], [173]], ["sort_exp", 341, "comesFrom", ["sort_exp"], [173]], ["sort_exp", 331, "comesFrom", ["sort_exp"], [173]], ["sort_exp", 353, "comesFrom", ["sort_exp"], [173]], ["n", 48, "comesFrom", ["n"], [14]], ["n", 105, "comesFrom", ["n"], [14]], ["n", 20, "comesFrom", ["n"], [14]], ["n", 461, "comesFrom", ["n"], [455]], ["n", 148, "comesFrom", ["n"], [137]], ["n", 389, "comesFrom", ["n"], [371]], ["n", 436, "comesFrom", ["n"], [371]], ["n", 75, "comesFrom", ["n"], [14]], ["n", 211, "comesFrom", ["n"], [180]], ["n", 227, "comesFrom", ["n"], [180]], ["n", 239, "comesFrom", ["n"], [237]], ["i", 50, "comesFrom", ["i"], [40]], ["i", 103, "comesFrom", ["i"], [99]], ["i", 107, "comesFrom", ["i"], [99]], ["i", 197, "comesFrom", ["i"], [193]], ["i", 205, "comesFrom", ["i"], [193]], ["i", 315, "comesFrom", ["i"], [311]], ["i", 323, "comesFrom", ["i"], [311]], ["i", 407, "comesFrom", ["i"], [403]], ["i", 411, "comesFrom", ["i"], [403]], ["i", 44, "comesFrom", ["i"], [40]], ["i", 46, "comesFrom", ["i"], [40]], ["i", 329, "comesFrom", ["i"], [311]], ["i", 79, "comesFrom", ["i"], [40]], ["i", 115, "comesFrom", ["i"], [99]], ["i", 122, "comesFrom", ["i"], [99]], ["i", 417, "comesFrom", ["i"], [403]], ["i", 426, "comesFrom", ["i"], [403]], ["i", 58, "comesFrom", ["i"], [40]], ["i", 69, "comesFrom", ["i"], [40]], ["i", 215, "comesFrom", ["i"], [193]], ["i", 343, "comesFrom", ["i"], [311]], ["i", 355, "comesFrom", ["i"], [311]], ["i", 231, "comesFrom", ["i"], [193]], ["i", 243, "comesFrom", ["i"], [193]], ["i", 265, "comesFrom", ["i"], [193]], ["l", 409, "comesFrom", ["l"], [392]], ["t", 302, "comesFrom", ["t"], [178]], ["f", 442, "comesFrom", ["f"], [422]], ["factor", 184, "comesFrom", ["factor"], [157]], ["factor", 250, "comesFrom", ["factor"], [157]], ["r", 199, "comesFrom", ["r"], [144]], ["r", 213, "comesFrom", ["r"], [144]], ["r", 229, "comesFrom", ["r"], [144]], ["r", 241, "comesFrom", ["r"], [144]], ["r", 263, "comesFrom", ["r"], [144]], ["div", 394, "comesFrom", ["div"], [385]], ["div", 415, "comesFrom", ["div"], [385]], ["div", 424, "comesFrom", ["div"], [385]], ["j", 73, "comesFrom", ["j"], [67]], ["j", 83, "comesFrom", ["j"], [77]], ["it", 254, "comesFrom", ["it"], [182]], ["k", 276, "comesFrom", ["k"], [221]], ["k", 246, "comesFrom", ["k"], [221]], ["k", 268, "comesFrom", ["k"], [221]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printCubeFree ( int n ) { bool cubFree [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( int i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( int multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) cout << i << \" ▁ \" ; } } int main ( ) { printCubeFree ( 20 ) ; return 0 ; }", "docstring": "Cube Free Numbers smaller than n | Efficient C ++ Program to print all cube free numbers smaller than or equal to n . ; Initialize all numbers as not cube free ; Traverse through all possible cube roots ; If i itself is cube free ; Mark all multiples of i as not cube free ; Print all cube free numbers ; Driver code", "dfg": [["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 58, "comesFrom", ["i"], [46]], ["i", 114, "comesFrom", ["i"], [110]], ["i", 118, "comesFrom", ["i"], [110]], ["i", 54, "comesFrom", ["i"], [46]], ["i", 50, "comesFrom", ["i"], [46]], ["i", 52, "comesFrom", ["i"], [46]], ["i", 38, "comesFrom", ["i"], [25]], ["i", 66, "comesFrom", ["i"], [46]], ["i", 133, "comesFrom", ["i"], [110]], ["i", 126, "comesFrom", ["i"], [110]], ["i", 81, "comesFrom", ["i"], [46]], ["i", 77, "comesFrom", ["i"], [46]], ["i", 79, "comesFrom", ["i"], [46]], ["i", 97, "comesFrom", ["i"], [46]], ["i", 93, "comesFrom", ["i"], [46]], ["i", 95, "comesFrom", ["i"], [46]], ["n", 31, "comesFrom", ["n"], [11]], ["n", 56, "comesFrom", ["n"], [11]], ["n", 116, "comesFrom", ["n"], [11]], ["n", 17, "comesFrom", ["n"], [11]], ["n", 85, "comesFrom", ["n"], [11]], ["multiple", 87, "comesFrom", ["multiple"], [73]], ["multiple", 83, "comesFrom", ["multiple"], [73]], ["multiple", 99, "comesFrom", ["multiple"], [73]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void heapify ( int arr [ ] , int n , int i ) { int smallest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] < arr [ smallest ] ) smallest = l ; if ( r < n && arr [ r ] < arr [ smallest ] ) smallest = r ; if ( smallest != i ) { swap ( arr [ i ] , arr [ smallest ] ) ; heapify ( arr , n , smallest ) ; } } void heapSort ( int arr [ ] , int n ) { for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { swap ( arr [ 0 ] , arr [ i ] ) ; heapify ( arr , i , 0 ) ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; } int main ( ) { int arr [ ] = { 4 , 6 , 3 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; heapSort ( arr , n ) ; cout << \" Sorted ▁ array ▁ is ▁ STRNEWLINE \" ; printArray ( arr , n ) ; }", "docstring": "Heap Sort for decreasing order using min heap | C ++ program for implementation of Heap Sort ; To heapify a subtree rooted with node i which is an index in arr [ ] . n is size of heap ; Initialize smalles as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; If left child is smaller than root ; If right child is smaller than smallest so far ; If smallest is not root ; Recursively heapify the affected sub - tree ; main function to do heap sort ; Build heap ( rearrange array ) ; One by one extract an element from heap ; Move current root to end ; call max heapify on the reduced heap ; A utility function to print array of size n ; Driver program", "dfg": [["i", 139, "comesFrom", ["i"], [131]], ["i", 143, "comesFrom", ["i"], [131]], ["i", 164, "comesFrom", ["i"], [158]], ["i", 168, "comesFrom", ["i"], [158]], ["i", 215, "comesFrom", ["i"], [211]], ["i", 220, "comesFrom", ["i"], [211]], ["i", 89, "comesFrom", ["i"], [25]], ["i", 32, "comesFrom", ["i"], [25]], ["i", 41, "comesFrom", ["i"], [25]], ["i", 152, "comesFrom", ["i"], [131]], ["i", 189, "comesFrom", ["i"], [158]], ["i", 226, "comesFrom", ["i"], [211]], ["i", 96, "comesFrom", ["i"], [25]], ["i", 181, "comesFrom", ["i"], [158]], ["n", 217, "comesFrom", ["n"], [205]], ["n", 282, "comesFrom", ["n"], [263]], ["n", 295, "comesFrom", ["n"], [263]], ["n", 49, "comesFrom", ["n"], [16]], ["n", 69, "comesFrom", ["n"], [16]], ["n", 150, "comesFrom", ["n"], [125]], ["n", 160, "comesFrom", ["n"], [125]], ["n", 109, "comesFrom", ["n"], [16]], ["n", 133, "comesFrom", ["n"], [125]], ["l", 63, "comesFrom", ["l"], [28]], ["l", 47, "comesFrom", ["l"], [28]], ["l", 53, "comesFrom", ["l"], [28]], ["r", 83, "comesFrom", ["r"], [37]], ["r", 67, "comesFrom", ["r"], [37]], ["r", 73, "comesFrom", ["r"], [37]], ["smallest", 87, "comesFrom", ["smallest"], [81]], ["smallest", 111, "comesFrom", ["smallest"], [81]], ["smallest", 58, "comesFrom", ["smallest"], [23]], ["smallest", 78, "comesFrom", ["smallest"], [61]], ["smallest", 101, "comesFrom", ["smallest"], [81]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( -2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return -1 ; float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && floor ( root1 ) == root1 ) return root1 ; if ( root2 > 0 && floor ( root2 ) == root2 ) return root2 ; return -1 ; } int isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; if ( ( sr - floor ( sr ) ) == 0 ) return floor ( sr ) ; else return -1 ; } int findS ( int s ) { int sr = isPerfectSquare ( s ) ; if ( sr == -1 ) return -1 ; return isTriangular ( sr ) ; } int main ( ) { int s = 9 ; int n = findS ( s ) ; n == -1 ? cout << \" - 1\" : cout << n ; return 0 ; }", "docstring": "Squared triangular number ( Sum of cubes ) | C ++ program to check if a given number is sum of cubes of natural numbers . ; Returns root of n ( n + 1 ) / 2 = num if num is triangular ( or integerroot exists ) . Else returns - 1. ; Considering the equation n * ( n + 1 ) / 2 = num . The equation is : a ( n ^ 2 ) + bn + c = 0 \"; ; Find roots of equation ; checking if root1 is natural ; checking if root2 is natural ; Returns square root of x if it is perfect square . Else returns - 1. ; Find floating point value of square root of x . ; If square root is an integer ; Function to find if the given number is sum of the cubes of first n natural numbers ; Driver code", "dfg": [["root1", 119, "comesFrom", ["root1"], [68]], ["root1", 107, "comesFrom", ["root1"], [68]], ["root1", 116, "comesFrom", ["root1"], [68]], ["root1", 113, "comesFrom", ["root1"], [68]], ["root2", 135, "comesFrom", ["root2"], [87]], ["root2", 123, "comesFrom", ["root2"], [87]], ["root2", 132, "comesFrom", ["root2"], [87]], ["root2", 129, "comesFrom", ["root2"], [87]], ["num", 16, "comesFrom", ["num"], [11]], ["num", 29, "comesFrom", ["num"], [11]], ["d", 60, "comesFrom", ["d"], [42]], ["d", 76, "comesFrom", ["d"], [42]], ["d", 95, "comesFrom", ["d"], [42]], ["sr", 199, "comesFrom", ["sr"], [190]], ["sr", 209, "comesFrom", ["sr"], [190]], ["sr", 174, "comesFrom", ["sr"], [151]], ["sr", 161, "comesFrom", ["sr"], [151]], ["sr", 165, "comesFrom", ["sr"], [151]], ["n", 231, "comesFrom", ["n"], [224]], ["n", 243, "comesFrom", ["n"], [224]], ["x", 155, "comesFrom", ["x"], [146]], ["s", 194, "comesFrom", ["s"], [186]], ["s", 228, "comesFrom", ["s"], [219]], ["b", 45, "comesFrom", ["b"], [33]], ["b", 47, "comesFrom", ["b"], [33]], ["b", 72, "comesFrom", ["b"], [33]], ["b", 91, "comesFrom", ["b"], [33]], ["c", 55, "comesFrom", ["c"], [24]], ["a", 83, "comesFrom", ["a"], [37]], ["a", 102, "comesFrom", ["a"], [37]], ["a", 53, "comesFrom", ["a"], [37]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int trickyCase ( string s , int index ) { int index1 = -1 ; for ( int i = index - 1 ; i >= 0 ; i -- ) { int digit = s [ i ] - '0' ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == -1 ) return 2 * pow ( 10 , s . length ( ) ) ; int num = 0 ; for ( int i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; if ( s [ index1 ] % 2 == 0 ) num = num * 10 + ( s [ index1 ] - '0' + 2 ) ; else num = num * 10 + ( s [ index1 ] - '0' + 1 ) ; for ( int i = index1 + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; } int smallestNumber ( int n ) { int num = 0 ; string s = \" \" ; int duplicate = n ; while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s [ i ] - '0' ; if ( digit & 1 ) { index = i ; break ; } } if ( index == -1 ) return duplicate ; if ( s [ index ] == '9' ) { num = trickyCase ( s , index ) ; return num ; } for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' + 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; } int main ( ) { int N = 2397 ; cout << smallestNumber ( N ) ; return 0 ; }", "docstring": "Smallest even digits number not less than N | CPP program to print the smallest integer not less than N with all even digits ; function to return the answer when the first odd digit is 9 ; traverse towwars the left to find the non - 8 digit ; index digit ; if digit is not 8 , then break ; if on the left side of the '9' , no 8 is found then we return by adding a 2 and 0 's ; till non - 8 digit add all numbers ; if non - 8 is even or odd than add the next even . ; add 0 to right of 9 ; function to return the smallest number with all digits even ; convert the number to string to perform operations ; find out the first odd number ; if no odd numbers are there , than n is the answer ; if the odd number is 9 , than tricky case handles it ; add all digits till first odd ; increase the odd digit by 1 ; add 0 to the right of the odd number ; Driver Code", "dfg": [["num", 199, "comesFrom", ["num"], [192]], ["num", 411, "comesFrom", ["num"], [404]], ["num", 331, "comesFrom", ["num"], [321]], ["num", 194, "comesFrom", ["num"], [192]], ["num", 367, "comesFrom", ["num"], [365]], ["num", 406, "comesFrom", ["num"], [404]], ["num", 107, "comesFrom", ["num"], [105]], ["num", 135, "comesFrom", ["num"], [133]], ["num", 350, "comesFrom", ["num"], [348]], ["num", 155, "comesFrom", ["num"], [153]], ["i", 31, "comesFrom", ["i"], [25]], ["i", 35, "comesFrom", ["i"], [25]], ["i", 98, "comesFrom", ["i"], [94]], ["i", 102, "comesFrom", ["i"], [94]], ["i", 181, "comesFrom", ["i"], [175]], ["i", 189, "comesFrom", ["i"], [175]], ["i", 261, "comesFrom", ["i"], [257]], ["i", 269, "comesFrom", ["i"], [257]], ["i", 341, "comesFrom", ["i"], [337]], ["i", 345, "comesFrom", ["i"], [337]], ["i", 393, "comesFrom", ["i"], [387]], ["i", 401, "comesFrom", ["i"], [387]], ["i", 60, "comesFrom", ["i"], [25]], ["i", 294, "comesFrom", ["i"], [257]], ["i", 44, "comesFrom", ["i"], [25]], ["i", 278, "comesFrom", ["i"], [257]], ["i", 114, "comesFrom", ["i"], [94]], ["i", 357, "comesFrom", ["i"], [337]], ["index1", 100, "comesFrom", ["index1"], [58]], ["index1", 68, "comesFrom", ["index1"], [58]], ["index1", 177, "comesFrom", ["index1"], [58]], ["index1", 126, "comesFrom", ["index1"], [58]], ["index1", 142, "comesFrom", ["index1"], [58]], ["index1", 162, "comesFrom", ["index1"], [58]], ["n", 228, "comesFrom", ["n"], [224]], ["n", 235, "comesFrom", ["n"], [224]], ["duplicate", 307, "comesFrom", ["duplicate"], [222]], ["index", 343, "comesFrom", ["index"], [292]], ["index", 302, "comesFrom", ["index"], [292]], ["index", 27, "comesFrom", ["index"], [14]], ["index", 389, "comesFrom", ["index"], [292]], ["index", 313, "comesFrom", ["index"], [292]], ["index", 327, "comesFrom", ["index"], [292]], ["index", 374, "comesFrom", ["index"], [292]], ["s", 183, "comesFrom", ["s"], [11]], ["s", 263, "comesFrom", ["s"], [231]], ["s", 311, "comesFrom", ["s"], [231]], ["s", 395, "comesFrom", ["s"], [231]], ["s", 124, "comesFrom", ["s"], [11]], ["s", 242, "comesFrom", ["s"], [231]], ["s", 42, "comesFrom", ["s"], [11]], ["s", 276, "comesFrom", ["s"], [231]], ["s", 325, "comesFrom", ["s"], [231]], ["s", 79, "comesFrom", ["s"], [11]], ["s", 112, "comesFrom", ["s"], [11]], ["s", 355, "comesFrom", ["s"], [231]], ["s", 372, "comesFrom", ["s"], [231]], ["s", 140, "comesFrom", ["s"], [11]], ["s", 160, "comesFrom", ["s"], [11]], ["N", 428, "comesFrom", ["N"], [420]], ["digit", 53, "comesFrom", ["digit"], [40]], ["digit", 287, "comesFrom", ["digit"], [274]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return -1 ; } int main ( ) { printf ( \" % d STRNEWLINE \" , findNth ( 5 ) ) ; return 0 ; }", "docstring": "n | Simple CPP program to find n - th number with sum of digits as 10. ; Find sum of digits in current no . ; If sum is 10 , we increment count ; If count becomes n , we return current number . ; Driver Code", "dfg": [["x", 44, "comesFrom", ["x"], [40]], ["x", 50, "comesFrom", ["x"], [48]], ["x", 58, "comesFrom", ["x"], [48]], ["curr", 78, "comesFrom", ["curr"], [42]], ["sum", 64, "comesFrom", ["sum"], [54]], ["sum", 56, "comesFrom", ["sum"], [54]], ["count", 68, "comesFrom", ["count"], [15]], ["count", 73, "comesFrom", ["count"], [15]], ["n", 75, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int findSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; } int main ( ) { int n = 5 ; cout << findSum ( n ) ; return 0 ; }", "docstring": "Sum of pairwise products | Simple CPP program to find sum of given series . ; Driver code", "dfg": [["sum", 60, "comesFrom", ["sum"], [51]], ["sum", 53, "comesFrom", ["sum"], [51]], ["i", 30, "comesFrom", ["i"], [26]], ["i", 34, "comesFrom", ["i"], [26]], ["i", 55, "comesFrom", ["i"], [42]], ["n", 32, "comesFrom", ["n"], [13]], ["n", 46, "comesFrom", ["n"], [13]], ["n", 77, "comesFrom", ["n"], [69]], ["j", 44, "comesFrom", ["j"], [40]], ["j", 48, "comesFrom", ["j"], [40]], ["j", 57, "comesFrom", ["j"], [40]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int findSum ( int n ) { long long int multiTerms = n * ( n + 1 ) / 2 ; long long int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; } int main ( ) { int n = 5 ; cout << findSum ( n ) ; return 0 ; }", "docstring": "Sum of pairwise products | Efficient CPP program to find sum of given series . ; Sum of multiples of 1 is 1 * ( 1 + 2 + . . ) ; Adding sum of multiples of numbers other than 1 , starting from 2. ; Subtract previous number from current multiple . ; For example , for 2 , we get sum as ( 2 + 3 + 4 + ... . ) * 2 ; Driver code", "dfg": [["sum", 73, "comesFrom", ["sum"], [63]], ["sum", 65, "comesFrom", ["sum"], [63]], ["i", 45, "comesFrom", ["i"], [41]], ["i", 49, "comesFrom", ["i"], [41]], ["i", 69, "comesFrom", ["i"], [41]], ["i", 58, "comesFrom", ["i"], [41]], ["n", 47, "comesFrom", ["n"], [13]], ["n", 21, "comesFrom", ["n"], [13]], ["n", 90, "comesFrom", ["n"], [82]], ["n", 24, "comesFrom", ["n"], [13]], ["multiTerms", 55, "comesFrom", ["multiTerms"], [53]], ["multiTerms", 67, "comesFrom", ["multiTerms"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n < 2 ) return false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } void lemoine ( int n ) { map < int , int > pr ; map < int , int > :: iterator it ; it = pr . begin ( ) ; for ( int q = 1 ; q <= n / 2 ; q ++ ) { int p = n - 2 * q ; if ( isPrime ( p ) && isPrime ( q ) ) pr . insert ( it , pair < int , int > ( p , q ) ) ; } for ( it = pr . begin ( ) ; it != pr . end ( ) ; ++ it ) cout << n << \" ▁ = ▁ \" << it -> first << \" ▁ + ▁ ( 2 ▁ * ▁ \" << it -> second << \" ) STRNEWLINE \" ; } int main ( ) { int n = 39 ; cout << n << \" ▁ can ▁ be ▁ expressed ▁ as ▁ \" << endl ; lemoine ( n ) ; return 0 ; }", "docstring": "Lemoine 's Conjecture | C ++ code to verify Lemoine 's Conjecture for any odd number >= 7 ; Function to check if a number is prime or not ; Representing n as p + ( 2 * q ) to satisfy lemoine 's conjecture ; Declaring a map to hold pairs ( p , q ) ; Declaring an iterator for map ; Finding various values of p for each q to satisfy n = p + ( 2 * q ) ; After finding a pair that satisfies the equation , check if both p and q are prime or not ; If both p and q are prime , store them in the map ; Displaying all pairs ( p , q ) that satisfy lemoine ' s ▁ conjecture ▁ for ▁ the ▁ number ▁ ' n ' ; Driver Function ; Function calling", "dfg": [["i", 30, "comesFrom", ["i"], [26]], ["i", 37, "comesFrom", ["i"], [26]], ["i", 45, "comesFrom", ["i"], [26]], ["q", 97, "comesFrom", ["q"], [93]], ["q", 103, "comesFrom", ["q"], [93]], ["q", 114, "comesFrom", ["q"], [93]], ["q", 125, "comesFrom", ["q"], [93]], ["q", 143, "comesFrom", ["q"], [93]], ["it", 158, "comesFrom", ["it"], [150]], ["it", 167, "comesFrom", ["it"], [150]], ["it", 185, "comesFrom", ["it"], [150]], ["it", 132, "comesFrom", ["it"], [82]], ["it", 177, "comesFrom", ["it"], [150]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 99, "comesFrom", ["n"], [61]], ["n", 216, "comesFrom", ["n"], [200]], ["n", 34, "comesFrom", ["n"], [11]], ["n", 206, "comesFrom", ["n"], [200]], ["n", 110, "comesFrom", ["n"], [61]], ["n", 43, "comesFrom", ["n"], [11]], ["n", 171, "comesFrom", ["n"], [61]], ["pr", 84, "comesFrom", ["pr"], [70]], ["pr", 152, "comesFrom", ["pr"], [70]], ["pr", 160, "comesFrom", ["pr"], [70]], ["pr", 128, "comesFrom", ["pr"], [70]], ["p", 120, "comesFrom", ["p"], [108]], ["p", 141, "comesFrom", ["p"], [108]]]}
{"code": "#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = pow ( 10 , digit - 1 ) ; int lastnum = pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; } int main ( ) { int n = 3 , number = 7 ; cout << totalSumDivisibleByNum ( n , number ) ; return 0 ; }", "docstring": "Sum of n digit numbers divisible by a given number | Efficient CPP program to find the sum divisible numbers . ; find the Sum of having n digit and divisible by the number ; compute the first and last term ; first number which is divisible by given number ; last number which is divisible by given number ; total divisible number ; return the total sum ; Driver code", "dfg": [["number", 52, "comesFrom", ["number"], [17]], ["number", 113, "comesFrom", ["number"], [103]], ["number", 61, "comesFrom", ["number"], [17]], ["number", 74, "comesFrom", ["number"], [17]], ["number", 49, "comesFrom", ["number"], [17]], ["digit", 39, "comesFrom", ["digit"], [14]], ["digit", 27, "comesFrom", ["digit"], [14]], ["lastnum", 57, "comesFrom", ["lastnum"], [54]], ["lastnum", 59, "comesFrom", ["lastnum"], [54]], ["lastnum", 82, "comesFrom", ["lastnum"], [54]], ["lastnum", 69, "comesFrom", ["lastnum"], [54]], ["count", 87, "comesFrom", ["count"], [65]], ["n", 111, "comesFrom", ["n"], [99]], ["firstnum", 45, "comesFrom", ["firstnum"], [42]], ["firstnum", 47, "comesFrom", ["firstnum"], [42]], ["firstnum", 84, "comesFrom", ["firstnum"], [42]], ["firstnum", 71, "comesFrom", ["firstnum"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; } int main ( ) { int a = 2 ; int d = 1 ; int N = 5 ; cout << \" The ▁ \" << N << \" th ▁ term ▁ of ▁ the ▁ series ▁ is ▁ : ▁ \" << Nth_of_AP ( a , d , N ) ; return 0 ; }", "docstring": "Program for N | CPP Program to find nth term of Arithmetic progression ; using formula to find the Nth term t ( n ) = a ( 1 ) + ( n - 1 ) * d ; Driver code ; starting number ; Common difference ; N th term to be find ; Display the output", "dfg": [["a", 22, "comesFrom", ["a"], [11]], ["a", 68, "comesFrom", ["a"], [40]], ["d", 30, "comesFrom", ["d"], [14]], ["d", 70, "comesFrom", ["d"], [45]], ["N", 60, "comesFrom", ["N"], [50]], ["N", 72, "comesFrom", ["N"], [50]], ["N", 25, "comesFrom", ["N"], [17]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; bool checkFibinnary ( int n ) { int prev_last = 0 ; while ( n ) { if ( ( n & 1 ) && prev_last ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; } int main ( ) { int n = 10 ; if ( checkFibinnary ( n ) ) cout << \" YES \" ; else cout << \" NO \" ; return 0 ; }", "docstring": "Fibbinary Numbers ( No consecutive 1 s in binary ) | CPP program to check if a number is fibinnary number or not ; function to check if binary representation of an integer has consecutive 1 s ; stores the previous last bit initially as 0 ; if current last bit and previous last bit is 1 ; stores the last bit ; right shift the number ; Driver code to check above function", "dfg": [["n", 21, "comesFrom", ["n"], [11]], ["n", 66, "comesFrom", ["n"], [58]], ["n", 39, "comesFrom", ["n"], [11]], ["n", 27, "comesFrom", ["n"], [11]], ["prev_last", 32, "comesFrom", ["prev_last"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfSeries ( int n ) { return 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ; } int main ( ) { int n = 2 ; cout << sumOfSeries ( n ) ; return 0 ; }", "docstring": "Sum of the series 5 + 55 + 555 + . . up to n terms | C ++ program for sum of the series 5 + 55 + 555. . ... n ; function which return the the sum of series ; Driver code", "dfg": [["n", 30, "comesFrom", ["n"], [11]], ["n", 47, "comesFrom", ["n"], [39]], ["n", 22, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; } int main ( ) { int n = 10 ; cout << Nonagonal ( n ) ; return 0 ; }", "docstring": "Nonagonal number | CPP Program to find nth nonagonal number . ; Function to find nth nonagonal number . ; Formula to find nth nonagonal number . ; Driver function .", "dfg": [["n", 15, "comesFrom", ["n"], [11]], ["n", 42, "comesFrom", ["n"], [34]], ["n", 20, "comesFrom", ["n"], [11]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; bool divisibleBy20 ( string num ) { int lastTwoDigits = stoi ( num . substr ( num . length ( ) - 2 , num . length ( ) - 1 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; } int main ( ) { string num = \"63284689320\" ; if ( divisibleBy20 ( num ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }", "docstring": "Check if a large number is divisible by 20 | CPP program to check if a large number is divisible by 20. ; Get number with last two digits ; Check if the number formed by last two digits is divisible by 5 and 4. ; Driver Program", "dfg": [["num", 77, "comesFrom", ["num"], [67]], ["num", 19, "comesFrom", ["num"], [11]], ["num", 23, "comesFrom", ["num"], [11]], ["num", 31, "comesFrom", ["num"], [11]], ["lastTwoDigits", 44, "comesFrom", ["lastTwoDigits"], [15]], ["lastTwoDigits", 52, "comesFrom", ["lastTwoDigits"], [15]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; bool isDvisibleBy12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num [ num . length ( ) - 1 ] ; if ( d1 % 2 != 0 ) return ( 0 ) ; int d2 = ( int ) num [ num . length ( ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = stoi ( num ) ; return ( number % 12 == 0 ) ; } } int main ( ) { string num = \"12244824607284961224\" ; if ( isDvisibleBy12 ( num ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }", "docstring": "Divisibility by 12 for a large number | C ++ Program to check if number is divisible by 12 ; if number greater then 3 ; find last digit ; no is odd ; find second last digit ; find sum of all digits ; if number is less then or equal to 100 ; Driver function", "dfg": [["i", 84, "comesFrom", ["i"], [80]], ["i", 92, "comesFrom", ["i"], [80]], ["i", 99, "comesFrom", ["i"], [80]], ["num", 161, "comesFrom", ["num"], [151]], ["num", 16, "comesFrom", ["num"], [11]], ["num", 31, "comesFrom", ["num"], [11]], ["num", 61, "comesFrom", ["num"], [11]], ["num", 86, "comesFrom", ["num"], [11]], ["num", 97, "comesFrom", ["num"], [11]], ["num", 131, "comesFrom", ["num"], [11]], ["num", 33, "comesFrom", ["num"], [11]], ["num", 63, "comesFrom", ["num"], [11]], ["d1", 44, "comesFrom", ["d1"], [26]], ["d1", 115, "comesFrom", ["d1"], [26]], ["sum", 104, "comesFrom", ["sum"], [95]], ["number", 136, "comesFrom", ["number"], [127]], ["d2", 111, "comesFrom", ["d2"], [56]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int n ) { int d = sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } int largestNonPerfectSquareNumber ( int a [ ] , int n ) { int maxi = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = max ( a [ i ] , maxi ) ; } return maxi ; } int main ( ) { int a [ ] = { 16 , 20 , 25 , 2 , 3 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << largestNonPerfectSquareNumber ( a , n ) ; return 0 ; }", "docstring": "Largest number that is not a perfect square | CPP program to find the largest non perfect square number among n numbers ; takes the sqrt of the number ; checks if it is a perfect square number ; function to find the largest non perfect square number ; stores the maximum of all non perfect square numbers ; traverse for all elements in the array ; store the maximum if not a perfect square ; driver code to check the above functions ; function call", "dfg": [["maxi", 94, "comesFrom", ["maxi"], [80]], ["maxi", 89, "comesFrom", ["maxi"], [80]], ["i", 61, "comesFrom", ["i"], [57]], ["i", 65, "comesFrom", ["i"], [57]], ["i", 76, "comesFrom", ["i"], [57]], ["i", 86, "comesFrom", ["i"], [57]], ["n", 63, "comesFrom", ["n"], [46]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 19, "comesFrom", ["n"], [11]], ["n", 143, "comesFrom", ["n"], [122]], ["d", 24, "comesFrom", ["d"], [15]], ["d", 26, "comesFrom", ["d"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { cout << curr_term << \" ▁ \" ; curr_term = curr_term + d ; } } int main ( ) { int a = 2 ; int d = 1 ; int n = 5 ; printAP ( a , d , n ) ; return 0 ; }", "docstring": "Program to print Arithmetic Progression series | CPP Program to print an arithmetic progression series ; Printing AP by simply adding d to previous term . ; Driver code ; starting number ; Common difference ; N th term to be find", "dfg": [["a", 25, "comesFrom", ["a"], [11]], ["a", 80, "comesFrom", ["a"], [64]], ["i", 34, "comesFrom", ["i"], [30]], ["i", 38, "comesFrom", ["i"], [30]], ["n", 36, "comesFrom", ["n"], [17]], ["n", 84, "comesFrom", ["n"], [74]], ["d", 82, "comesFrom", ["d"], [69]], ["d", 54, "comesFrom", ["d"], [14]], ["curr_term", 44, "comesFrom", ["curr_term"], [23]], ["curr_term", 52, "comesFrom", ["curr_term"], [50]]]}
{"code": "#include <assert.h> NEW_LINE #include <math.h> NEW_LINE #include <stdio.h> NEW_LINE void printNonSquare ( int n ) { int curr_count = 2 , num = 2 , count = 0 ; while ( count < n ) { for ( int i = 0 ; i < curr_count && count < n ; i ++ ) { printf ( \" % d ▁ \" , num ) ; count ++ ; num ++ ; } num ++ ; curr_count += 2 ; } } int main ( ) { int n = 10 ; printNonSquare ( n ) ; return 0 ; }", "docstring": "Program to print non square numbers | CPP program to print first n non square number ; Print curr_count numbers . curr_count is current gap between two square numbers . ; skip a square number . ; Count of next non - square numbers is next even number . ; Driver code", "dfg": [["count", 31, "comesFrom", ["count"], [25]], ["count", 47, "comesFrom", ["count"], [25]], ["count", 64, "comesFrom", ["count"], [25]], ["n", 33, "comesFrom", ["n"], [13]], ["n", 92, "comesFrom", ["n"], [86]], ["n", 49, "comesFrom", ["n"], [13]], ["i", 51, "comesFrom", ["i"], [39]], ["i", 43, "comesFrom", ["i"], [39]], ["num", 71, "comesFrom", ["num"], [21]], ["num", 67, "comesFrom", ["num"], [21]], ["num", 61, "comesFrom", ["num"], [21]], ["curr_count", 45, "comesFrom", ["curr_count"], [17]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int countZeros ( int a [ ] , int n ) { int count2 = 0 , count5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = a [ i ] / 2 ; count2 ++ ; } while ( a [ i ] % 5 == 0 ) { a [ i ] = a [ i ] / 5 ; count5 ++ ; } } return ( count2 < count5 ) ? count2 : count5 ; } int main ( ) { int a [ ] = { 10 , 100 , 20 , 30 , 50 , 90 , 12 , 80 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countZeros ( a , n ) ; return 0 ; }", "docstring": "Count number of trailing zeros in product of array | CPP program for count total zero in product of array ; Returns count of zeros in product of array ; count number of 2 s in each element ; count number of 5 s in each element ; return the minimum ; Driven Program", "dfg": [["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 47, "comesFrom", ["i"], [31]], ["i", 57, "comesFrom", ["i"], [31]], ["i", 75, "comesFrom", ["i"], [31]], ["i", 85, "comesFrom", ["i"], [31]], ["i", 62, "comesFrom", ["i"], [31]], ["i", 90, "comesFrom", ["i"], [31]], ["n", 37, "comesFrom", ["n"], [16]], ["n", 162, "comesFrom", ["n"], [141]], ["count2", 107, "comesFrom", ["count2"], [20]], ["count2", 102, "comesFrom", ["count2"], [20]], ["count2", 67, "comesFrom", ["count2"], [20]], ["count5", 109, "comesFrom", ["count5"], [24]], ["count5", 104, "comesFrom", ["count5"], [24]], ["count5", 95, "comesFrom", ["count5"], [24]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; } int main ( ) { cout << squareSum ( 8 ) ; return 0 ; }", "docstring": "Sum of square of first n even numbers | Efficient C ++ method to find sum of square of first n even numbers . ; Driver code", "dfg": [["n", 17, "comesFrom", ["n"], [11]], ["n", 20, "comesFrom", ["n"], [11]], ["n", 28, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned pwr [ 10 ] ; bool isMunchhausen ( unsigned n ) { unsigned sum = 0 ; int temp = n ; while ( temp ) { sum += pwr [ ( temp % 10 ) ] ; temp /= 10 ; } return ( sum == n ) ; } void printMunchhausenNumbers ( int n ) { for ( int i = 0 ; i < 10 ; i ++ ) pwr [ i ] = ( unsigned ) pow ( ( float ) i , ( float ) i ) ; for ( unsigned i = 1 ; i <= n ; i ++ ) if ( isMunchhausen ( i ) ) cout << i << \" STRNEWLINE \" ; } int main ( ) { int n = 10000 ; printMunchhausenNumbers ( n ) ; return 0 ; }", "docstring": "MÃ ¼ nchhausen Number | C ++ code for MA14nchhausen Number ; pwr [ i ] is going to store i raised to power i . ; Function to check out whether the number is MA14nchhausen Number or not ; Precompute i raised to power i for every i ; The input here is fixed i . e . it will check up to n ; check the integer for MA14nchhausen Number , if yes then print out the number ; Driver Code", "dfg": [["temp", 32, "comesFrom", ["temp"], [26]], ["temp", 40, "comesFrom", ["temp"], [26]], ["i", 73, "comesFrom", ["i"], [69]], ["i", 77, "comesFrom", ["i"], [69]], ["i", 108, "comesFrom", ["i"], [104]], ["i", 112, "comesFrom", ["i"], [104]], ["i", 82, "comesFrom", ["i"], [69]], ["i", 119, "comesFrom", ["i"], [104]], ["i", 124, "comesFrom", ["i"], [104]], ["i", 93, "comesFrom", ["i"], [69]], ["i", 98, "comesFrom", ["i"], [69]], ["n", 110, "comesFrom", ["n"], [63]], ["n", 55, "comesFrom", ["n"], [28]], ["n", 143, "comesFrom", ["n"], [137]], ["sum", 53, "comesFrom", ["sum"], [35]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int kthdigit ( int a , int b , int k ) { int p = pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; } int main ( ) { int a = 5 , b = 2 ; int k = 1 ; cout << kthdigit ( a , b , k ) ; return 0 ; }", "docstring": "K | CPP program for finding k - th digit in a ^ b ; To compute k - th digit in a ^ b ; computing a ^ b ; getting last digit ; increasing count by 1 ; if current number is required digit ; remove last digit ; Driver code", "dfg": [["a", 25, "comesFrom", ["a"], [11]], ["a", 99, "comesFrom", ["a"], [82]], ["b", 27, "comesFrom", ["b"], [14]], ["b", 101, "comesFrom", ["b"], [86]], ["p", 37, "comesFrom", ["p"], [21]], ["p", 49, "comesFrom", ["p"], [21]], ["p", 67, "comesFrom", ["p"], [65]], ["count", 41, "comesFrom", ["count"], [31]], ["count", 53, "comesFrom", ["count"], [31]], ["count", 58, "comesFrom", ["count"], [31]], ["k", 43, "comesFrom", ["k"], [17]], ["k", 103, "comesFrom", ["k"], [91]], ["k", 60, "comesFrom", ["k"], [17]], ["rem", 63, "comesFrom", ["rem"], [47]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long digSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } long PowDigSum ( long n , long x ) { long sum = digSum ( n ) ; long rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( ( long ) pow ( sum , 6 ) ) ; else return digSum ( ( long ) pow ( sum , rem ) ) ; } int main ( ) { int n = 33333 ; int x = 332654 ; cout << PowDigSum ( n , x ) ; return 0 ; }", "docstring": "Recursive sum of digit in n ^ x , where n and x are very large | CPP Code for Sum of digit of n ^ x where n and x are very large ; function to get sum of digits of a number ; function to return sum ; Find sum of digits in n ; Find remainder of exponent ; Driver code", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 35, "comesFrom", ["n"], [11]], ["n", 56, "comesFrom", ["n"], [45]], ["n", 160, "comesFrom", ["n"], [147]], ["n", 25, "comesFrom", ["n"], [11]], ["x", 62, "comesFrom", ["x"], [48]], ["x", 77, "comesFrom", ["x"], [48]], ["x", 162, "comesFrom", ["x"], [152]], ["x", 87, "comesFrom", ["x"], [48]], ["x", 97, "comesFrom", ["x"], [48]], ["sum", 92, "comesFrom", ["sum"], [52]], ["sum", 69, "comesFrom", ["sum"], [52]], ["sum", 72, "comesFrom", ["sum"], [52]], ["sum", 119, "comesFrom", ["sum"], [52]], ["sum", 134, "comesFrom", ["sum"], [52]], ["rem", 107, "comesFrom", ["rem"], [60]], ["rem", 136, "comesFrom", ["rem"], [60]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int maxArea ( int A [ ] , int len ) { int l = 0 ; int r = len - 1 ; int area = 0 ; while ( l < r ) { area = max ( area , min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; } int main ( ) { int a [ ] = { 1 , 5 , 4 , 3 } ; int b [ ] = { 3 , 1 , 2 , 4 , 5 } ; int len1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxArea ( a , len1 ) ; int len2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << endl << maxArea ( b , len2 ) ; }", "docstring": "Container with Most Water | C ++ code for Max Water Container ; Calculating the max area ; Driver code", "dfg": [["area", 92, "comesFrom", ["area"], [43]], ["area", 47, "comesFrom", ["area"], [43]], ["len", 27, "comesFrom", ["len"], [16]], ["l", 38, "comesFrom", ["l"], [20]], ["l", 73, "comesFrom", ["l"], [20]], ["l", 65, "comesFrom", ["l"], [20]], ["l", 53, "comesFrom", ["l"], [20]], ["r", 40, "comesFrom", ["r"], [25]], ["r", 78, "comesFrom", ["r"], [25]], ["r", 63, "comesFrom", ["r"], [25]], ["r", 58, "comesFrom", ["r"], [25]], ["len1", 154, "comesFrom", ["len1"], [133]], ["len2", 181, "comesFrom", ["len2"], [158]]]}
{"code": "# include <bits/stdc++.h> NEW_LINE using namespace std ; int mobius ( int n ) { int p = 0 ; if ( n % 2 == 0 ) { n = n / 2 ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? -1 : 1 ; } int main ( ) { int N = 17 ; cout << \" Mobius ▁ Functions ▁ M ( N ) ▁ at ▁ N ▁ = ▁ \" << N << \" ▁ is : ▁ \" << mobius ( N ) << endl ; cout << \" Mobius ▁ Functions ▁ M ( N ) ▁ at ▁ N ▁ = ▁ \" << 25 << \" ▁ is : ▁ \" << mobius ( 25 ) << endl ; cout << \" Mobius ▁ Functions ▁ M ( N ) ▁ at ▁ N ▁ = ▁ \" << 6 << \" ▁ is : ▁ \" << mobius ( 6 ) << endl ; }", "docstring": "Program for Mobius Function | Program to print all prime factors ; Returns value of mobius ( ) ; Handling 2 separately ; If 2 ^ 2 also divides N ; Check for all other prime factors ; If i divides n ; If i ^ 2 also divides N ; Driver code", "dfg": [["i", 56, "comesFrom", ["i"], [52]], ["i", 65, "comesFrom", ["i"], [63]], ["i", 74, "comesFrom", ["i"], [63]], ["i", 83, "comesFrom", ["i"], [63]], ["i", 92, "comesFrom", ["i"], [63]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 60, "comesFrom", ["n"], [28]], ["n", 30, "comesFrom", ["n"], [28]], ["n", 39, "comesFrom", ["n"], [28]], ["n", 72, "comesFrom", ["n"], [28]], ["n", 81, "comesFrom", ["n"], [79]], ["n", 90, "comesFrom", ["n"], [79]], ["p", 34, "comesFrom", ["p"], [15]], ["p", 103, "comesFrom", ["p"], [15]], ["p", 85, "comesFrom", ["p"], [15]], ["N", 131, "comesFrom", ["N"], [121]], ["N", 139, "comesFrom", ["N"], [121]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int start , int end ) { int res = 1 ; for ( int i = start ; i <= end ; i ++ ) res *= i ; return res ; } int sumofsquare ( int n ) { return factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ; } int main ( ) { int n = 4 ; cout << sumofsquare ( n ) << endl ; return 0 ; }", "docstring": "Sum of squares of binomial coefficients | CPP Program to find the sum of square of binomial coefficient . ; function to return product of number from start to end . ; Return the sum of square of binomial coefficient ; Driven Program", "dfg": [["res", 41, "comesFrom", ["res"], [36]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 38, "comesFrom", ["i"], [25]], ["end", 31, "comesFrom", ["end"], [14]], ["n", 67, "comesFrom", ["n"], [48]], ["n", 54, "comesFrom", ["n"], [48]], ["n", 60, "comesFrom", ["n"], [48]], ["n", 85, "comesFrom", ["n"], [77]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double PHI = 1.6180339 ; int f [ 6 ] = { 0 , 1 , 1 , 2 , 3 , 5 } ; int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 , fn = 5 ; while ( t < n ) { fn = round ( fn * PHI ) ; t ++ ; } return fn ; } int main ( ) { int n = 9 ; cout << n << \" th ▁ Fibonacci ▁ Number ▁ = ▁ \" << fib ( n ) << endl ; return 0 ; }", "docstring": "Find nth Fibonacci number using Golden ratio | CPP program to find n - th Fibonacci number ; Approximate value of golden ratio ; Fibonacci numbers upto n = 5 ; Function to find nth Fibonacci number ; Fibonacci numbers for n < 6 ; Else start counting from 5 th term ; driver code", "dfg": [["fn", 81, "comesFrom", ["fn"], [67]], ["fn", 71, "comesFrom", ["fn"], [67]], ["n", 41, "comesFrom", ["n"], [36]], ["n", 64, "comesFrom", ["n"], [36]], ["n", 48, "comesFrom", ["n"], [36]], ["n", 96, "comesFrom", ["n"], [90]], ["n", 104, "comesFrom", ["n"], [90]], ["t", 62, "comesFrom", ["t"], [52]], ["t", 76, "comesFrom", ["t"], [52]], ["PHI", 73, "comesFrom", ["PHI"], [8]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; float func ( float x , float y ) { return ( x + y + x * y ) ; } void euler ( float x0 , float y , float h , float x ) { float temp = -0 ; while ( x0 < x ) { temp = y ; y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } cout << \" Approximate ▁ solution ▁ at ▁ x ▁ = ▁ \" << x << \" ▁ is ▁ \" << y << endl ; } int main ( ) { float x0 = 0 ; float y0 = 1 ; float h = 0.025 ; float x = 0.1 ; euler ( x0 , y0 , h , x ) ; return 0 ; }", "docstring": "Euler Method for solving differential equation | CPP Program to find approximation of a ordinary differential equation using euler method . ; Consider a differential equation dy / dx = ( x + y + xy ) ; Function for Euler formula ; Iterating till the point at which we need approximation ; Printing approximation ; Driver program ; Initial Values ; Value of x at which we need approximation", "dfg": [["x0", 52, "comesFrom", ["x0"], [33]], ["x0", 125, "comesFrom", ["x0"], [104]], ["x0", 76, "comesFrom", ["x0"], [74]], ["x0", 69, "comesFrom", ["x0"], [33]], ["x", 54, "comesFrom", ["x"], [42]], ["x", 131, "comesFrom", ["x"], [119]], ["x", 19, "comesFrom", ["x"], [11]], ["x", 23, "comesFrom", ["x"], [11]], ["x", 87, "comesFrom", ["x"], [42]], ["y", 93, "comesFrom", ["y"], [61]], ["y", 21, "comesFrom", ["y"], [14]], ["y", 25, "comesFrom", ["y"], [14]], ["y", 59, "comesFrom", ["y"], [36]], ["y", 63, "comesFrom", ["y"], [61]], ["y", 71, "comesFrom", ["y"], [61]], ["y0", 127, "comesFrom", ["y0"], [109]], ["h", 129, "comesFrom", ["h"], [114]], ["h", 78, "comesFrom", ["h"], [39]], ["h", 65, "comesFrom", ["h"], [39]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { cout << \" x ▁ = ▁ \" << i << \" , ▁ y ▁ = ▁ \" << ( n - ( i * a ) ) / b ; return ; } } cout << \" No ▁ solution \" ; } int main ( ) { int a = 2 , b = 3 , n = 7 ; solution ( a , b , n ) ; return 0 ; }", "docstring": "Find x and y satisfying ax + by = n | CPP program to find solution of ax + by = n ; function to find the solution ; traverse for all possible values ; check if it is satisfying the equation ; driver program to test the above function", "dfg": [["n", 31, "comesFrom", ["n"], [17]], ["n", 113, "comesFrom", ["n"], [103]], ["n", 40, "comesFrom", ["n"], [17]], ["n", 67, "comesFrom", ["n"], [17]], ["i", 33, "comesFrom", ["i"], [23]], ["i", 27, "comesFrom", ["i"], [23]], ["i", 60, "comesFrom", ["i"], [23]], ["i", 43, "comesFrom", ["i"], [23]], ["i", 70, "comesFrom", ["i"], [23]], ["a", 29, "comesFrom", ["a"], [11]], ["a", 109, "comesFrom", ["a"], [95]], ["a", 45, "comesFrom", ["a"], [11]], ["a", 72, "comesFrom", ["a"], [11]], ["b", 111, "comesFrom", ["b"], [99]], ["b", 49, "comesFrom", ["b"], [14]], ["b", 76, "comesFrom", ["b"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeffSum ( int n ) { return ( 1 << n ) ; } int main ( ) { int n = 4 ; printf ( \" % d \" , binomialCoeffSum ( n ) ) ; return 0 ; }", "docstring": "Sum of Binomial coefficients | CPP Program to find sum of Binomial Coefficient . ; Returns value of Binomial Coefficient Sum which is 2 raised to power n . ; Driver program to test above function", "dfg": [["n", 18, "comesFrom", ["n"], [11]], ["n", 40, "comesFrom", ["n"], [28]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { cout << \" Infinite \" << endl ; return ; } if ( x == 0 ) { cout << 0 << endl ; return ; } if ( n <= 0 ) { cout << x / y << endl ; return ; } if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { cout << \" - \" ; x = x > 0 ? x : - x ; y = y > 0 ? y : - y ; } int d = x / y ; for ( int i = 0 ; i <= n ; i ++ ) { cout << d ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) cout << \" . \" ; } } int main ( ) { int x = 22 , y = 7 , n = 15 ; precisionCompute ( x , y , n ) ; return 0 ; }", "docstring": "Program to compute division upto n decimal places | CPP program to compute division upto n decimal places . ; Base cases ; Since n <= 0 , don 't compute after  the decimal ; Handling negative numbers ; Integral division ; Now one by print digits after dot using school division method . ; Driver Program", "dfg": [["i", 146, "comesFrom", ["i"], [142]], ["i", 150, "comesFrom", ["i"], [142]], ["i", 190, "comesFrom", ["i"], [142]], ["n", 148, "comesFrom", ["n"], [17]], ["n", 56, "comesFrom", ["n"], [17]], ["n", 226, "comesFrom", ["n"], [216]], ["y", 22, "comesFrom", ["y"], [14]], ["y", 137, "comesFrom", ["y"], [120]], ["y", 224, "comesFrom", ["y"], [212]], ["y", 126, "comesFrom", ["y"], [120]], ["y", 186, "comesFrom", ["y"], [120]], ["y", 65, "comesFrom", ["y"], [14]], ["y", 122, "comesFrom", ["y"], [120]], ["y", 129, "comesFrom", ["y"], [120]], ["y", 82, "comesFrom", ["y"], [14]], ["y", 96, "comesFrom", ["y"], [14]], ["y", 163, "comesFrom", ["y"], [120]], ["x", 40, "comesFrom", ["x"], [11]], ["x", 135, "comesFrom", ["x"], [109]], ["x", 222, "comesFrom", ["x"], [208]], ["x", 115, "comesFrom", ["x"], [109]], ["x", 160, "comesFrom", ["x"], [158]], ["x", 170, "comesFrom", ["x"], [158]], ["x", 178, "comesFrom", ["x"], [176]], ["x", 184, "comesFrom", ["x"], [176]], ["x", 63, "comesFrom", ["x"], [11]], ["x", 111, "comesFrom", ["x"], [109]], ["x", 118, "comesFrom", ["x"], [109]], ["x", 76, "comesFrom", ["x"], [11]], ["x", 90, "comesFrom", ["x"], [11]], ["d", 156, "comesFrom", ["d"], [133]], ["d", 165, "comesFrom", ["d"], [133]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void quadrant ( int x , int y ) { if ( x > 0 and y > 0 ) cout << \" lies ▁ in ▁ First ▁ quadrant \" ; else if ( x < 0 and y > 0 ) cout << \" lies ▁ in ▁ Second ▁ quadrant \" ; else if ( x < 0 and y < 0 ) cout << \" lies ▁ in ▁ Third ▁ quadrant \" ; else if ( x > 0 and y < 0 ) cout << \" lies ▁ in ▁ Fourth ▁ quadrant \" ; else if ( x == 0 and y > 0 ) cout << \" lies ▁ at ▁ positive ▁ y ▁ axis \" ; else if ( x == 0 and y < 0 ) cout << \" lies ▁ at ▁ negative ▁ y ▁ axis \" ; else if ( y == 0 and x < 0 ) cout << \" lies ▁ at ▁ negative ▁ x ▁ axis \" ; else if ( y == 0 and x > 0 ) cout << \" lies ▁ at ▁ positive ▁ x ▁ axis \" ; else cout << \" lies ▁ at ▁ origin \" ; } int main ( ) { int x = 1 , y = 1 ; quadrant ( x , y ) ; return 0 ; }", "docstring": "Program to determine the quadrant of the cartesian plane | CPP program to check quadrant ; Function to check quadrant ; Driver code ; Function call", "dfg": [["x", 176, "comesFrom", ["x"], [166]], ["x", 19, "comesFrom", ["x"], [11]], ["x", 36, "comesFrom", ["x"], [11]], ["x", 53, "comesFrom", ["x"], [11]], ["x", 70, "comesFrom", ["x"], [11]], ["x", 87, "comesFrom", ["x"], [11]], ["x", 104, "comesFrom", ["x"], [11]], ["x", 125, "comesFrom", ["x"], [11]], ["x", 142, "comesFrom", ["x"], [11]], ["y", 178, "comesFrom", ["y"], [170]], ["y", 23, "comesFrom", ["y"], [14]], ["y", 40, "comesFrom", ["y"], [14]], ["y", 57, "comesFrom", ["y"], [14]], ["y", 74, "comesFrom", ["y"], [14]], ["y", 91, "comesFrom", ["y"], [14]], ["y", 108, "comesFrom", ["y"], [14]], ["y", 121, "comesFrom", ["y"], [14]], ["y", 138, "comesFrom", ["y"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkDigits ( int n ) { while ( n ) { int dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n /= 10 ; } return true ; } bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } int isFullPrime ( int n ) { return ( checkDigits ( n ) && prime ( n ) ) ; } int main ( ) { int n = 53 ; if ( isFullPrime ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "docstring": "Check if a number is Full Prime | CPP program for checking of full prime ; function to check digits ; check all digits are prime or not ; check if digits are prime or not ; To check if n is prime or not ; check for all factors ; To check if n is Full Prime ; The order is important here for efficiency . ; Driver code to check the above function", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 83, "comesFrom", ["n"], [60]], ["n", 65, "comesFrom", ["n"], [60]], ["n", 140, "comesFrom", ["n"], [132]], ["n", 22, "comesFrom", ["n"], [11]], ["n", 116, "comesFrom", ["n"], [109]], ["n", 121, "comesFrom", ["n"], [109]], ["n", 91, "comesFrom", ["n"], [60]], ["i", 85, "comesFrom", ["i"], [75]], ["i", 79, "comesFrom", ["i"], [75]], ["i", 81, "comesFrom", ["i"], [75]], ["i", 93, "comesFrom", ["i"], [75]], ["dig", 40, "comesFrom", ["dig"], [20]], ["dig", 36, "comesFrom", ["dig"], [20]], ["dig", 28, "comesFrom", ["dig"], [20]], ["dig", 32, "comesFrom", ["dig"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; string getResult ( string st ) { int sum = 0 ; int length = st . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + pow ( st [ i ] - '0' , length ) ; } int number = stoi ( st ) ; if ( number == sum ) return \" yes \" ; else return \" no \" ; } int main ( ) { string st = \"153\" ; cout << getResult ( st ) ; return 0 ; }", "docstring": "Narcissistic number | CPP program for checking of Narcissistic number ; Traversing through the string ; Since ascii value of numbers starts from 48 so we subtract it from sum ; Converting string to integer ; Comparing number and sum ; Driver Code", "dfg": [["i", 38, "comesFrom", ["i"], [34]], ["i", 42, "comesFrom", ["i"], [34]], ["i", 54, "comesFrom", ["i"], [34]], ["length", 40, "comesFrom", ["length"], [23]], ["length", 27, "comesFrom", ["length"], [23]], ["length", 61, "comesFrom", ["length"], [23]], ["number", 75, "comesFrom", ["number"], [66]], ["sum", 77, "comesFrom", ["sum"], [46]], ["sum", 48, "comesFrom", ["sum"], [46]], ["st", 25, "comesFrom", ["st"], [14]], ["st", 70, "comesFrom", ["st"], [14]], ["st", 107, "comesFrom", ["st"], [97]], ["st", 52, "comesFrom", ["st"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE #define MAX  500 NEW_LINE using namespace std ; int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; } int main ( ) { int n = 6 ; int dp [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; cout << nthSHN ( n , dp ) << endl ; return 0 ; }", "docstring": "SchrÃ ¶ derâ €“ Hipparchus number | A memoization based optimized CPP program to find n - th SchrAderaHipparchus number ; Driven Program", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; } int main ( ) { int n = 20 ; cout << \" Sum ▁ of ▁ first ▁ \" << n << \" ▁ Even ▁ numbers ▁ is : ▁ \" << evenSum ( n ) ; return 0 ; }", "docstring": "Sum of first n even numbers | C ++ implementation to find sum of first n even numbers ; function to find sum of first n even numbers ; sum of first n even numbers ; next even number ; required sum ; Driver program to test above", "dfg": [["sum", 48, "comesFrom", ["sum"], [38]], ["i", 30, "comesFrom", ["i"], [26]], ["i", 34, "comesFrom", ["i"], [26]], ["n", 32, "comesFrom", ["n"], [11]], ["n", 67, "comesFrom", ["n"], [57]], ["n", 75, "comesFrom", ["n"], [57]], ["curr", 40, "comesFrom", ["curr"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; } int main ( ) { int n = 20 ; cout << \" Sum ▁ of ▁ first ▁ \" << n << \" ▁ Even ▁ numbers ▁ is : ▁ \" << evenSum ( n ) ; return 0 ; }", "docstring": "Sum of first n even numbers | C ++ implementation to find sum of first n even numbers ; function to find sum of first n even numbers ; required sum ; Driver program to test above", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 42, "comesFrom", ["n"], [32]], ["n", 50, "comesFrom", ["n"], [32]], ["n", 19, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double kmphTOmph ( double kmph ) { return 0.6214 * kmph ; } double mphTOkmph ( double mph ) { return mph * 1.60934 ; } int main ( ) { double kmph = 150 ; double mph = 100 ; cout << \" the ▁ speed ▁ in ▁ mph ▁ is ▁ \" << kmphTOmph ( kmph ) << endl ; cout << \" the ▁ speed ▁ in ▁ kmph ▁ is ▁ \" << mphTOkmph ( mph ) ; return 0 ; }", "docstring": "Program to Convert Km / hr to miles / hr and vice versa | Cpp program for conversion of kmph to mph and vice versa ; Function to convert kmph to mph ; Function to convert mph to kmph ; Driver code to check the above function", "dfg": [["kmph", 17, "comesFrom", ["kmph"], [11]], ["kmph", 56, "comesFrom", ["kmph"], [39]], ["mph", 28, "comesFrom", ["mph"], [24]], ["mph", 69, "comesFrom", ["mph"], [44]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long subsequences ( int a [ ] , int n , int r ) { unordered_map < int , int > left , right ; long long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int i = 0 ; i < n ; i ++ ) { long long c1 = 0 , c2 = 0 ; if ( a [ i ] % r == 0 ) c1 = left [ a [ i ] / r ] ; right [ a [ i ] ] -- ; c2 = right [ a [ i ] * r ] ; ans += c1 * c2 ; left [ a [ i ] ] ++ ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 6 , 2 , 3 , 6 , 9 , 18 , 3 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int r = 3 ; cout << subsequences ( a , n , r ) ; return 0 ; }", "docstring": "Number of GP ( Geometric Progression ) subsequences of size 3 | C ++ program to count GP subsequences of size 3. ; Returns count of G . P . subsequences with length 3 and common ratio r ; hashing to maintain left and right array elements to the main count ; stores the answer ; traverse through the elements ; traverse through all elements and find out the number of elements as k1 * k2 ; keep the count of left and right elements left is a [ i ] / r and right a [ i ] * r ; if the current element is divisible by k , count elements in left hash . ; decrease the count in right hash ; number of right elements ; calculate the answer ; left count of a [ i ] ; returns answer ; driver program", "dfg": [["ans", 139, "comesFrom", ["ans"], [122]], ["i", 46, "comesFrom", ["i"], [42]], ["i", 50, "comesFrom", ["i"], [42]], ["i", 60, "comesFrom", ["i"], [56]], ["i", 64, "comesFrom", ["i"], [56]], ["i", 82, "comesFrom", ["i"], [56]], ["i", 105, "comesFrom", ["i"], [56]], ["i", 132, "comesFrom", ["i"], [56]], ["i", 116, "comesFrom", ["i"], [56]], ["i", 95, "comesFrom", ["i"], [56]], ["n", 48, "comesFrom", ["n"], [17]], ["n", 62, "comesFrom", ["n"], [17]], ["n", 201, "comesFrom", ["n"], [175]], ["r", 203, "comesFrom", ["r"], [191]], ["r", 85, "comesFrom", ["r"], [20]], ["r", 119, "comesFrom", ["r"], [20]], ["r", 98, "comesFrom", ["r"], [20]], ["right", 101, "comesFrom", ["right"], [31]], ["right", 112, "comesFrom", ["right"], [31]], ["c1", 124, "comesFrom", ["c1"], [89]], ["c2", 126, "comesFrom", ["c2"], [110]], ["left", 128, "comesFrom", ["left"], [29]], ["left", 91, "comesFrom", ["left"], [29]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int findNumber ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return -1 ; } int main ( ) { int arr [ ] = { 2 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findNumber ( arr , n ) << endl ; return 0 ; }", "docstring": "Find element in array that divides all array elements | CPP program to find such number in the array that all array elements are divisible by it ; Returns gcd of two numbers . ; Function to return the desired number if exists ; Find GCD of array ; Check if GCD is present in array ; Driver Function", "dfg": [["b", 24, "comesFrom", ["b"], [14]], ["b", 29, "comesFrom", ["b"], [14]], ["i", 64, "comesFrom", ["i"], [60]], ["i", 68, "comesFrom", ["i"], [60]], ["i", 90, "comesFrom", ["i"], [86]], ["i", 94, "comesFrom", ["i"], [86]], ["i", 101, "comesFrom", ["i"], [86]], ["i", 79, "comesFrom", ["i"], [60]], ["n", 66, "comesFrom", ["n"], [46]], ["n", 92, "comesFrom", ["n"], [46]], ["n", 153, "comesFrom", ["n"], [132]], ["a", 19, "comesFrom", ["a"], [11]], ["a", 33, "comesFrom", ["a"], [11]], ["a", 31, "comesFrom", ["a"], [11]], ["ans", 107, "comesFrom", ["ans"], [71]], ["ans", 104, "comesFrom", ["ans"], [71]], ["ans", 75, "comesFrom", ["ans"], [71]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > primes ; void SieveofEratosthenes ( int n ) { bool visited [ n ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( int j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . push_back ( i ) ; } } bool specialPrimeNumbers ( int n , int k ) { SieveofEratosthenes ( n ) ; int count = 0 ; for ( int i = 0 ; i < primes . size ( ) ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; } int main ( ) { int n = 27 , k = 2 ; if ( specialPrimeNumbers ( n , k ) ) cout << \" YES \" << endl ; else cout << \" NO \" << endl ; return 0 ; }", "docstring": "Special prime numbers | CPP program to check whether there exist at least k or not in range [ 2. . n ] ; Generating all the prime numbers from 2 to n . ; If a prime number is Special prime number , then we increments the value of k . ; If at least k Special prime numbers are present , then we return 1. else we return 0 from outside of the outer loop . ; Driver function", "dfg": [["n", 23, "comesFrom", ["n"], [17]], ["n", 35, "comesFrom", ["n"], [17]], ["n", 98, "comesFrom", ["n"], [90]], ["n", 203, "comesFrom", ["n"], [191]], ["n", 62, "comesFrom", ["n"], [17]], ["i", 33, "comesFrom", ["i"], [29]], ["i", 39, "comesFrom", ["i"], [29]], ["i", 113, "comesFrom", ["i"], [109]], ["i", 121, "comesFrom", ["i"], [109]], ["i", 68, "comesFrom", ["i"], [29]], ["i", 134, "comesFrom", ["i"], [109]], ["i", 47, "comesFrom", ["i"], [29]], ["i", 81, "comesFrom", ["i"], [29]], ["i", 56, "comesFrom", ["i"], [29]], ["i", 58, "comesFrom", ["i"], [29]], ["i", 160, "comesFrom", ["i"], [109]], ["primes", 115, "comesFrom", ["primes"], [11]], ["primes", 77, "comesFrom", ["primes"], [11]], ["primes", 158, "comesFrom", ["primes"], [11]], ["primes", 144, "comesFrom", ["primes"], [11]], ["primes", 149, "comesFrom", ["primes"], [11]], ["j", 132, "comesFrom", ["j"], [128]], ["j", 138, "comesFrom", ["j"], [128]], ["j", 60, "comesFrom", ["j"], [54]], ["j", 72, "comesFrom", ["j"], [66]], ["j", 146, "comesFrom", ["j"], [128]], ["j", 151, "comesFrom", ["j"], [128]], ["k", 205, "comesFrom", ["k"], [195]], ["k", 175, "comesFrom", ["k"], [93]], ["count", 173, "comesFrom", ["count"], [102]], ["count", 164, "comesFrom", ["count"], [102]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void factorize ( long long n ) { int count = 0 ; while ( ! ( n % 2 ) ) { count ++ ; } if ( count ) cout << 2 << \" ▁ \" << count << endl ; for ( long long i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count ) cout << i << \" ▁ \" << count << endl ; } if ( n > 2 ) cout << n << \" ▁ \" << 1 << endl ; } int main ( ) { long long n = 1000000000000000000 ; factorize ( n ) ; return 0 ; }", "docstring": "Prime factors of a big number | CPP program to print prime factors and their powers . ; function to calculate all the prime factors and count of every prime factor ; count the number of times 2 divides ; n >>= 1 ; equivalent to n = n / 2 ; ; if 2 divides it ; check for all the possible numbers that can divide it ; if n at the end is a prime number . ; driver program to test the above function", "dfg": [["count", 36, "comesFrom", ["count"], [16]], ["count", 30, "comesFrom", ["count"], [16]], ["count", 46, "comesFrom", ["count"], [16]], ["count", 95, "comesFrom", ["count"], [70]], ["count", 83, "comesFrom", ["count"], [70]], ["count", 105, "comesFrom", ["count"], [70]], ["i", 58, "comesFrom", ["i"], [54]], ["i", 78, "comesFrom", ["i"], [65]], ["i", 90, "comesFrom", ["i"], [65]], ["i", 99, "comesFrom", ["i"], [65]], ["n", 112, "comesFrom", ["n"], [86]], ["n", 142, "comesFrom", ["n"], [136]], ["n", 62, "comesFrom", ["n"], [12]], ["n", 24, "comesFrom", ["n"], [12]], ["n", 76, "comesFrom", ["n"], [12]], ["n", 118, "comesFrom", ["n"], [86]], ["n", 88, "comesFrom", ["n"], [86]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumMoves ( int A [ ] , int N ) { int one = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; int minimum = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { int g = A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = min ( minimum , j - i ) ; break ; } } } if ( minimum == INT_MAX ) return -1 ; else return N + minimum - 1 ; } int main ( ) { int A [ ] = { 2 , 4 , 3 , 9 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minimumMoves ( A , N ) ; return 0 ; }", "docstring": "Minimum gcd operations to make all array elements one | CPP program to find minimum GCD operations to make all array elements one . ; Function to count number of moves . ; Counting Number of ones . ; If there is a one ; Find smallest subarray with GCD equals to one . ; to calculate GCD ; Not Possible ; Final answer ; Driver code", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 73, "comesFrom", ["i"], [69]], ["i", 77, "comesFrom", ["i"], [69]], ["i", 42, "comesFrom", ["i"], [27]], ["i", 86, "comesFrom", ["i"], [69]], ["i", 94, "comesFrom", ["i"], [69]], ["i", 133, "comesFrom", ["i"], [69]], ["N", 33, "comesFrom", ["N"], [16]], ["N", 75, "comesFrom", ["N"], [16]], ["N", 57, "comesFrom", ["N"], [16]], ["N", 100, "comesFrom", ["N"], [16]], ["N", 201, "comesFrom", ["N"], [180]], ["N", 152, "comesFrom", ["N"], [16]], ["one", 52, "comesFrom", ["one"], [20]], ["one", 59, "comesFrom", ["one"], [20]], ["one", 47, "comesFrom", ["one"], [20]], ["minimum", 143, "comesFrom", ["minimum"], [125]], ["minimum", 154, "comesFrom", ["minimum"], [125]], ["minimum", 129, "comesFrom", ["minimum"], [125]], ["INT_MAX", 145, "comesFrom", ["INT_MAX"], [64]], ["j", 98, "comesFrom", ["j"], [92]], ["j", 102, "comesFrom", ["j"], [92]], ["j", 112, "comesFrom", ["j"], [92]], ["j", 131, "comesFrom", ["j"], [92]], ["g", 120, "comesFrom", ["g"], [106]], ["g", 115, "comesFrom", ["g"], [106]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void series ( int n , int d ) { if ( d == 0 ) { for ( int i = 0 ; i < n ; i ++ ) cout << \"0 ▁ \" ; cout << endl ; return ; } if ( n % 2 == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << pow ( -1 , i ) * d << \" ▁ \" ; } cout << endl ; } else { float m = n ; float r = ( m / ( m - 1 ) ) ; float g = ( float ) ( d * ( float ) sqrtf ( r ) ) ; cout << \"0 ▁ \" ; for ( int i = 1 ; i < n ; i ++ ) { cout << pow ( -1 , i ) * g << \" ▁ \" ; } cout << endl ; } } int main ( ) { int n = 3 , d = 3 ; series ( n , d ) ; return 0 ; }", "docstring": "Given N and Standard Deviation , find N elements | CPP program to find n elements ; function to print series of n elements ; if S . D . is 0 then print all elements as 0. ; print n 0 's ; if S . D . is even ; print - SD , + SD , - SD , + SD ; if odd ; convert n to a float integer ; print one element to be 0 ; print ( n - 1 ) elements as xi derived from the formula ; driver program to test the above function", "dfg": [["d", 19, "comesFrom", ["d"], [14]], ["d", 195, "comesFrom", ["d"], [187]], ["d", 84, "comesFrom", ["d"], [14]], ["d", 123, "comesFrom", ["d"], [14]], ["n", 193, "comesFrom", ["n"], [183]], ["n", 33, "comesFrom", ["n"], [11]], ["n", 53, "comesFrom", ["n"], [11]], ["n", 69, "comesFrom", ["n"], [11]], ["n", 149, "comesFrom", ["n"], [101]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 67, "comesFrom", ["i"], [63]], ["i", 71, "comesFrom", ["i"], [63]], ["i", 147, "comesFrom", ["i"], [143]], ["i", 151, "comesFrom", ["i"], [143]], ["i", 81, "comesFrom", ["i"], [63]], ["i", 161, "comesFrom", ["i"], [143]], ["m", 107, "comesFrom", ["m"], [99]], ["m", 110, "comesFrom", ["m"], [99]], ["g", 164, "comesFrom", ["g"], [117]], ["r", 130, "comesFrom", ["r"], [104]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { string str = to_string ( i ) ; countr += count ( str . begin ( ) , str . end ( ) , '1' ) ; } return countr ; } int main ( ) { int n = 13 ; cout << countDigitOne ( n ) << endl ; n = 131 ; cout << countDigitOne ( n ) << endl ; n = 159 ; cout << countDigitOne ( n ) << endl ; return 0 ; }", "docstring": "Total no of 1 's in numbers | c ++ code to count the frequency of 1 in numbers less than or equal to the given number . ; driver function", "dfg": [["countr", 65, "comesFrom", ["countr"], [42]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 30, "comesFrom", ["i"], [22]], ["i", 39, "comesFrom", ["i"], [22]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 82, "comesFrom", ["n"], [74]], ["n", 95, "comesFrom", ["n"], [87]], ["n", 108, "comesFrom", ["n"], [100]], ["str", 46, "comesFrom", ["str"], [35]], ["str", 52, "comesFrom", ["str"], [35]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long exponentiation ( long base , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * base ) % N ; base = ( base * base ) % N ; exp /= 2 ; } return t % N ; } int main ( ) { long base = 5 ; long exp = 100000 ; long modulo = exponentiation ( base , exp ) ; cout << ( modulo ) ; return 0 ; }", "docstring": "Exponential Squaring ( Fast Modulo Multiplication ) | C ++ program to compute exponential value using ( 2 ^ k ) - ary method . ; # define N 1000000007L ; prime modulo value ; for cases where exponent is not an even value ; Driver code", "dfg": [["t", 63, "comesFrom", ["t"], [37]], ["t", 40, "comesFrom", ["t"], [37]], ["exp", 24, "comesFrom", ["exp"], [14]], ["exp", 90, "comesFrom", ["exp"], [79]], ["exp", 31, "comesFrom", ["exp"], [14]], ["modulo", 96, "comesFrom", ["modulo"], [84]], ["base", 88, "comesFrom", ["base"], [74]], ["base", 50, "comesFrom", ["base"], [47]], ["base", 52, "comesFrom", ["base"], [47]], ["base", 42, "comesFrom", ["base"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int x ) { if ( x <= 1 ) return 1 ; int res = 2 ; for ( int i = 3 ; i <= x ; i ++ ) res = res * i ; return res ; } int gcdOfFactorial ( int m , int n ) { return factorial ( min ( m , n ) ) ; } int main ( ) { int m = 5 , n = 9 ; cout << gcdOfFactorial ( m , n ) ; return 0 ; }", "docstring": "GCD of factorials of two numbers | CPP program to find GCD of factorial of two numbers . ; Driver program to test above functions", "dfg": [["res", 49, "comesFrom", ["res"], [42]], ["res", 44, "comesFrom", ["res"], [42]], ["i", 35, "comesFrom", ["i"], [31]], ["i", 39, "comesFrom", ["i"], [31]], ["i", 46, "comesFrom", ["i"], [31]], ["x", 37, "comesFrom", ["x"], [11]], ["x", 16, "comesFrom", ["x"], [11]], ["m", 92, "comesFrom", ["m"], [80]], ["m", 67, "comesFrom", ["m"], [56]], ["n", 94, "comesFrom", ["n"], [84]], ["n", 69, "comesFrom", ["n"], [59]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int recDigSum ( int n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } } void check ( int n ) { n = recDigSum ( n ) ; if ( n == 2 or n == 3 or n == 5 or n == 7 ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int n = 5602 ; check ( n ) ; }", "docstring": "Recursive sum of digits of a number is prime or not | CPP code to check if recursive sum of digits is prime or not . ; Function for recursive digit sum ; function to check if prime or not the single digit ; calls function which returns sum till single digit ; checking prime ; Driver code", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 102, "comesFrom", ["n"], [96]], ["n", 55, "comesFrom", ["n"], [51]], ["n", 72, "comesFrom", ["n"], [51]], ["n", 68, "comesFrom", ["n"], [51]], ["n", 60, "comesFrom", ["n"], [51]], ["n", 64, "comesFrom", ["n"], [51]], ["n", 27, "comesFrom", ["n"], [11]], ["n", 38, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumber ( int n ) { int x = ( int ) floor ( ( -1 + sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; } int main ( ) { int n = 55 ; cout << findNumber ( n ) << endl ; return 0 ; }", "docstring": "Find n | CPP program to find the value at n - th place in the given sequence ; Definition of findNumber function ; Finding x from equation n = x ( x + 1 ) / 2 + 1 ; Base of current block ; Value of n - th element ; Driver code", "dfg": [["n", 58, "comesFrom", ["n"], [11]], ["n", 79, "comesFrom", ["n"], [71]], ["n", 31, "comesFrom", ["n"], [11]], ["base", 60, "comesFrom", ["base"], [41]], ["x", 44, "comesFrom", ["x"], [15]], ["x", 47, "comesFrom", ["x"], [15]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; } int main ( ) { int n = 10 ; cout << weightedMean ( n ) ; return 0 ; }", "docstring": "Program for weighted mean of natural numbers . | Program to find weighted mean of first n natural numbers using formula . ; Returns weighted mean assuming for numbers { 1 , 2 , . . n } and weights { 1 , 2 , . . n } ; Driver program to test the function .", "dfg": [["n", 40, "comesFrom", ["n"], [32]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = floor ( a [ i ] / mul ) ; cout << x << \" ▁ \" ; } } int main ( ) { int a [ ] = { 5 , 100 , 8 } ; int b [ ] = { 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; calculate ( a , b , n , m ) ; return 0 ; }", "docstring": "Divide every element of one array by other array elements | CPP program to find quotient of array elements ; Function to calculate the quotient of every element of the array ; Calculate the product of all elements ; To calculate the quotient of every array element ; Driver code", "dfg": [["i", 39, "comesFrom", ["i"], [35]], ["i", 43, "comesFrom", ["i"], [35]], ["i", 71, "comesFrom", ["i"], [67]], ["i", 75, "comesFrom", ["i"], [67]], ["i", 50, "comesFrom", ["i"], [35]], ["i", 61, "comesFrom", ["i"], [35]], ["i", 86, "comesFrom", ["i"], [67]], ["m", 41, "comesFrom", ["m"], [24]], ["m", 171, "comesFrom", ["m"], [148]], ["n", 73, "comesFrom", ["n"], [21]], ["n", 169, "comesFrom", ["n"], [132]], ["mul", 57, "comesFrom", ["mul"], [55]], ["mul", 89, "comesFrom", ["mul"], [55]], ["x", 94, "comesFrom", ["x"], [80]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPowerOfP ( int n , int p ) { int count = 0 ; int r = p ; while ( r <= n ) { count += ( n / r ) ; r = r * p ; } return count ; } vector < pair < int , int > > primeFactorsofK ( int k ) { vector < pair < int , int > > ans ; for ( int i = 2 ; k != 1 ; i ++ ) { if ( k % i == 0 ) { int count = 0 ; while ( k % i == 0 ) { k = k / i ; count ++ ; } ans . push_back ( make_pair ( i , count ) ) ; } } return ans ; } int largestPowerOfK ( int n , int k ) { vector < pair < int , int > > vec ; vec = primeFactorsofK ( k ) ; int ans = INT_MAX ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) ans = min ( ans , findPowerOfP ( n , vec [ i ] . first ) / vec [ i ] . second ) ; return ans ; } int main ( ) { cout << largestPowerOfK ( 7 , 2 ) << endl ; cout << largestPowerOfK ( 10 , 9 ) << endl ; return 0 ; }", "docstring": "Largest power of k in n ! ( factorial ) where k may not be prime | CPP program to find the largest power of k that divides n ! ; To find the power of a prime p in factorial N ; calculating floor ( n / r ) and adding to the count ; increasing the power of p from 1 to 2 to 3 and so on ; returns all the prime factors of k ; vector to store all the prime factors along with their number of occurrence in factorization of k ; Returns largest power of k that divides n ! ; calculating minimum power of all the prime factors of k ; Driver code", "dfg": [["count", 50, "comesFrom", ["count"], [34]], ["count", 123, "comesFrom", ["count"], [104]], ["count", 135, "comesFrom", ["count"], [104]], ["ans", 142, "comesFrom", ["ans"], [77]], ["ans", 223, "comesFrom", ["ans"], [196]], ["ans", 200, "comesFrom", ["ans"], [196]], ["ans", 127, "comesFrom", ["ans"], [77]], ["k", 86, "comesFrom", ["k"], [65]], ["k", 170, "comesFrom", ["k"], [152]], ["k", 96, "comesFrom", ["k"], [65]], ["k", 110, "comesFrom", ["k"], [65]], ["k", 119, "comesFrom", ["k"], [117]], ["i", 90, "comesFrom", ["i"], [82]], ["i", 185, "comesFrom", ["i"], [181]], ["i", 193, "comesFrom", ["i"], [181]], ["i", 98, "comesFrom", ["i"], [82]], ["i", 112, "comesFrom", ["i"], [82]], ["i", 121, "comesFrom", ["i"], [82]], ["i", 133, "comesFrom", ["i"], [82]], ["i", 216, "comesFrom", ["i"], [181]], ["i", 208, "comesFrom", ["i"], [181]], ["r", 29, "comesFrom", ["r"], [23]], ["r", 44, "comesFrom", ["r"], [42]], ["r", 39, "comesFrom", ["r"], [23]], ["n", 31, "comesFrom", ["n"], [11]], ["n", 37, "comesFrom", ["n"], [11]], ["n", 204, "comesFrom", ["n"], [149]], ["vec", 187, "comesFrom", ["vec"], [166]], ["vec", 214, "comesFrom", ["vec"], [166]], ["vec", 206, "comesFrom", ["vec"], [166]], ["p", 46, "comesFrom", ["p"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void print ( int n ) { cout << n + n / 2 << endl ; for ( int i = 2 ; i <= n ; i += 2 ) cout << i << \" ▁ \" ; for ( int i = 1 ; i <= n ; i += 2 ) cout << i << \" ▁ \" ; for ( int i = 2 ; i <= n ; i += 2 ) cout << i << \" ▁ \" ; } int main ( ) { int n = 3 ; print ( n ) ; return 0 ; }", "docstring": "Minimum number of bombs | CPP program to find number of bombings required to kill all aliens . ; function to print where to shoot ; no . of bombs required ; bomb all the even positions ; bomb all the odd positions ; bomb all the even positions again ; driver program", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 54, "comesFrom", ["i"], [50]], ["i", 77, "comesFrom", ["i"], [73]], ["i", 41, "comesFrom", ["i"], [35]], ["i", 64, "comesFrom", ["i"], [58]], ["i", 87, "comesFrom", ["i"], [81]], ["n", 33, "comesFrom", ["n"], [11]], ["n", 56, "comesFrom", ["n"], [11]], ["n", 79, "comesFrom", ["n"], [11]], ["n", 106, "comesFrom", ["n"], [100]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 18, "comesFrom", ["n"], [11]]]}
{"code": "#include <iostream> NEW_LINE #include <boost/math/common_factor.hpp> NEW_LINE using namespace std ; int digitLCM ( int n ) { int lcm = 1 ; while ( n > 0 ) { lcm = boost :: math :: lcm ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = n / 10 ; } return lcm ; } int main ( ) { long n = 397 ; cout << digitLCM ( n ) ; return 0 ; }", "docstring": "LCM of digits of a given number | CPP program to find LCM of digits of a number ; define lcm function ; If at any point LCM become 0. return it ; driver code", "dfg": [["lcm", 61, "comesFrom", ["lcm"], [29]], ["lcm", 46, "comesFrom", ["lcm"], [29]], ["lcm", 41, "comesFrom", ["lcm"], [29]], ["lcm", 35, "comesFrom", ["lcm"], [29]], ["n", 24, "comesFrom", ["n"], [14]], ["n", 78, "comesFrom", ["n"], [70]], ["n", 55, "comesFrom", ["n"], [53]], ["n", 37, "comesFrom", ["n"], [14]]]}
{"code": "#include <iostream> NEW_LINE #include <time.h> NEW_LINE #define e  2.71828 NEW_LINE using namespace std ; int roundNo ( float num ) { return num < 0 ? num - 0.5 : num + 0.5 ; } void printBestCandidate ( int candidate [ ] , int n ) { int sample_size = roundNo ( n / e ) ; cout << \" Sample size is \" int best = 0 ; for ( int i = 1 ; i < sample_size ; i ++ ) if ( candidate [ i ] > candidate [ best ] ) best = i ; for ( int i = sample_size ; i < n ; i ++ ) if ( candidate [ i ] >= candidate [ best ] ) { best = i ; break ; } if ( best >= sample_size ) cout << endl << \" Best ▁ candidate ▁ found ▁ is ▁ \" << best + 1 << \" ▁ with ▁ talent ▁ \" << candidate [ best ] << endl ; else cout << \" Couldn ' t ▁ find ▁ a ▁ best ▁ candidate STRNEWLINE \" ; } int main ( ) { int n = 8 ; int candidate [ n ] ; srand ( time ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) candidate [ i ] = 1 + rand ( ) % 8 ; cout << \" Candidate ▁ : ▁ \" ; for ( int i = 0 ; i < n ; i ++ ) cout << i + 1 << \" ▁ \" ; cout << endl ; cout << \" ▁ Talents ▁ : ▁ \" ; for ( int i = 0 ; i < n ; i ++ ) cout << candidate [ i ] << \" ▁ \" ; printBestCandidate ( candidate , n ) ; return 0 ; }", "docstring": "Secretary Problem ( A Optimal Stopping Problem ) | C ++ Program to test 1 / e law for Secretary Problem : ; To find closest integer of num . ; Finds best candidate using n / e rule . candidate [ ] represents talents of n candidates . ; Calculating sample size for benchmarking . ; Finding best candidate in sample size ; Finding the first best candidate that is better than benchmark set . ; Driver Code ; n = 8 candidates and candidate array contains talents of n candidate where the largest number means highest talented candidate . ; generating random numbers between 1 to 8 for talent of candidate", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float u_cal ( float u , int n ) { float temp = u ; for ( int i = 1 ; i < n ; i ++ ) temp = temp * ( u + i ) ; return temp ; } int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } int main ( ) { int n = 5 ; float x [ ] = { 1891 , 1901 , 1911 , 1921 , 1931 } ; float y [ n ] [ n ] ; y [ 0 ] [ 0 ] = 46 ; y [ 1 ] [ 0 ] = 66 ; y [ 2 ] [ 0 ] = 81 ; y [ 3 ] [ 0 ] = 93 ; y [ 4 ] [ 0 ] = 101 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= i ; j -- ) y [ j ] [ i ] = y [ j ] [ i - 1 ] - y [ j - 1 ] [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) cout << setw ( 4 ) << y [ i ] [ j ] << \" TABSYMBOL \" ; cout << endl ; } float value = 1925 ; float sum = y [ n - 1 ] [ 0 ] ; float u = ( value - x [ n - 1 ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { sum = sum + ( u_cal ( u , i ) * y [ n - 1 ] [ i ] ) / fact ( i ) ; } cout << \" Value at \" ▁ < < ▁ value ▁ < < ▁ \" is \" << sum << endl ; return 0 ; }", "docstring": "Newton Forward And Backward Interpolation | CPP Program to interpolate using newton backward interpolation ; Calculation of u mentioned in formula ; Calculating factorial of given n ; Driver code ; number of values given ; y [ ] [ ] is used for difference table and y [ ] [ 0 ] used for input ; Calculating the backward difference table ; Displaying the backward difference table ; Value to interpolate at ; Initializing u and sum", "dfg": [["temp", 47, "comesFrom", ["temp"], [36]], ["temp", 38, "comesFrom", ["temp"], [36]], ["f", 81, "comesFrom", ["f"], [76]], ["i", 29, "comesFrom", ["i"], [25]], ["i", 33, "comesFrom", ["i"], [25]], ["i", 69, "comesFrom", ["i"], [65]], ["i", 73, "comesFrom", ["i"], [65]], ["i", 177, "comesFrom", ["i"], [173]], ["i", 181, "comesFrom", ["i"], [173]], ["i", 239, "comesFrom", ["i"], [235]], ["i", 243, "comesFrom", ["i"], [235]], ["i", 336, "comesFrom", ["i"], [332]], ["i", 340, "comesFrom", ["i"], [332]], ["i", 78, "comesFrom", ["i"], [65]], ["i", 196, "comesFrom", ["i"], [173]], ["i", 256, "comesFrom", ["i"], [235]], ["i", 43, "comesFrom", ["i"], [25]], ["i", 206, "comesFrom", ["i"], [173]], ["i", 369, "comesFrom", ["i"], [332]], ["i", 214, "comesFrom", ["i"], [173]], ["i", 226, "comesFrom", ["i"], [173]], ["i", 270, "comesFrom", ["i"], [235]], ["i", 353, "comesFrom", ["i"], [332]], ["i", 363, "comesFrom", ["i"], [332]], ["n", 31, "comesFrom", ["n"], [14]], ["n", 71, "comesFrom", ["n"], [54]], ["n", 117, "comesFrom", ["n"], [90]], ["n", 179, "comesFrom", ["n"], [90]], ["n", 241, "comesFrom", ["n"], [90]], ["n", 338, "comesFrom", ["n"], [90]], ["n", 114, "comesFrom", ["n"], [90]], ["n", 190, "comesFrom", ["n"], [90]], ["n", 295, "comesFrom", ["n"], [90]], ["n", 311, "comesFrom", ["n"], [90]], ["n", 358, "comesFrom", ["n"], [90]], ["value", 383, "comesFrom", ["value"], [286]], ["value", 307, "comesFrom", ["value"], [286]], ["j", 194, "comesFrom", ["j"], [188]], ["j", 198, "comesFrom", ["j"], [188]], ["j", 254, "comesFrom", ["j"], [250]], ["j", 258, "comesFrom", ["j"], [250]], ["j", 203, "comesFrom", ["j"], [188]], ["j", 273, "comesFrom", ["j"], [250]], ["j", 211, "comesFrom", ["j"], [188]], ["j", 221, "comesFrom", ["j"], [188]], ["sum", 393, "comesFrom", ["sum"], [344]], ["sum", 346, "comesFrom", ["sum"], [344]], ["u", 41, "comesFrom", ["u"], [20]], ["u", 351, "comesFrom", ["u"], [304]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumDigitSquare ( int n ) { int sq = 0 ; while ( n ) { int digit = n % 10 ; sq += digit * digit ; n = n / 10 ; } return sq ; } bool isHappy ( int n ) { while ( 1 ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } return false ; } int main ( ) { int n = 23 ; if ( isHappy ( n ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }", "docstring": "Happy Numbers | A space optimized CPP program to check if a number is happy number ; Returns sum of squares of digits of a number n . For example for n = 12 it returns 1 + 4 = 5 ; Returns true if n is Happy number else returns false . ; Keep replacing n with sum of squares of digits until we either reach 1 or we end up in a cycle ; Number is Happy if we reach 1 ; Replace n with sum of squares of digits ; Number is not Happy if we reach 4 ; Driver code", "dfg": [["sq", 45, "comesFrom", ["sq"], [31]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 104, "comesFrom", ["n"], [96]], ["n", 27, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [37]], ["n", 62, "comesFrom", ["n"], [52]], ["n", 78, "comesFrom", ["n"], [69]], ["n", 73, "comesFrom", ["n"], [69]], ["digit", 33, "comesFrom", ["digit"], [25]], ["digit", 35, "comesFrom", ["digit"], [25]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; } int main ( ) { int n = 3 ; cout << findSumSubsets ( n ) ; return 0 ; }", "docstring": "Sum of all subsets of a set formed by first n natural numbers | CPP program to find sum of all subsets of a set . ; sum of subsets is ( n * ( n + 1 ) / 2 ) * pow ( 2 , n - 1 ) ; Driver code", "dfg": [["n", 54, "comesFrom", ["n"], [46]], ["n", 18, "comesFrom", ["n"], [13]], ["n", 33, "comesFrom", ["n"], [13]], ["n", 21, "comesFrom", ["n"], [13]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) int x = exp ( sum / n ) ; return x + 1 ; } int main ( ) { int a [ ] = { 3 , 2 , 1 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findMin ( a , n ) ; }", "docstring": "Minimum element whose n | CPP program to find minimum element whose n - th power is greater than product of an array of size n ; function to find the minimum element ; loop to traverse and store the sum of log ; calculates the elements according to formula . ; returns the minimal element ; Driver program to test above function ; initialised array ; computes the size of array ; prints out the minimal element", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 96, "comesFrom", ["n"], [75]], ["n", 45, "comesFrom", ["n"], [16]], ["x", 49, "comesFrom", ["x"], [39]], ["sum", 43, "comesFrom", ["sum"], [20]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countdigits ( int N ) { int count = 0 ; while ( N ) { count ++ ; N = N / 10 ; } return count ; } void cyclic ( int N ) { int num = N ; int n = countdigits ( N ) ; while ( 1 ) { cout << num << endl ; int rem = num % 10 ; int div = num / 10 ; num = ( pow ( 10 , n - 1 ) ) * rem + div ; if ( num == N ) break ; } } int main ( ) { int N = 5674 ; cyclic ( N ) ; return 0 ; }", "docstring": "Generate all cyclic permutations of a number | Program to generate all cyclic permutations of number ; Function to count the total number of digits in a number . ; Function to generate all cyclic permutations of a number ; Following three lines generates a circular pirmutation of a number . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Program", "dfg": [["count", 35, "comesFrom", ["count"], [15]], ["count", 24, "comesFrom", ["count"], [15]], ["N", 21, "comesFrom", ["N"], [11]], ["N", 122, "comesFrom", ["N"], [116]], ["N", 55, "comesFrom", ["N"], [48]], ["N", 29, "comesFrom", ["N"], [27]], ["N", 104, "comesFrom", ["N"], [48]], ["num", 65, "comesFrom", ["num"], [46]], ["num", 72, "comesFrom", ["num"], [46]], ["num", 79, "comesFrom", ["num"], [46]], ["num", 102, "comesFrom", ["num"], [83]], ["div", 98, "comesFrom", ["div"], [77]], ["rem", 96, "comesFrom", ["rem"], [70]], ["n", 90, "comesFrom", ["n"], [51]]]}
{"code": "#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool checkCircular ( int N ) { int count = 0 , temp = N ; while ( temp ) { count ++ ; temp /= 10 ; } int num = N ; while ( isPrime ( num ) ) { int rem = num % 10 ; int div = num / 10 ; num = ( pow ( 10 , count - 1 ) ) * rem + div ; if ( num == N ) return true ; } return false ; } int main ( ) { int N = 1193 ; if ( checkCircular ( N ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }", "docstring": "Check whether a number is circular prime or not | Program to check if a number is circular prime or not . ; Function to check if a number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is circular prime or not . ; Count digits . ; Following three lines generate the next circular permutation of a number . We move last digit to first position . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Program", "dfg": [["n", 62, "comesFrom", ["n"], [14]], ["n", 19, "comesFrom", ["n"], [14]], ["n", 28, "comesFrom", ["n"], [14]], ["n", 37, "comesFrom", ["n"], [14]], ["n", 42, "comesFrom", ["n"], [14]], ["n", 72, "comesFrom", ["n"], [14]], ["n", 78, "comesFrom", ["n"], [14]], ["temp", 113, "comesFrom", ["temp"], [107]], ["i", 58, "comesFrom", ["i"], [54]], ["i", 60, "comesFrom", ["i"], [54]], ["i", 66, "comesFrom", ["i"], [64]], ["i", 74, "comesFrom", ["i"], [64]], ["i", 81, "comesFrom", ["i"], [64]], ["count", 116, "comesFrom", ["count"], [103]], ["count", 158, "comesFrom", ["count"], [103]], ["num", 133, "comesFrom", ["num"], [125]], ["num", 140, "comesFrom", ["num"], [125]], ["num", 147, "comesFrom", ["num"], [125]], ["num", 170, "comesFrom", ["num"], [151]], ["N", 196, "comesFrom", ["N"], [188]], ["N", 172, "comesFrom", ["N"], [127]], ["div", 166, "comesFrom", ["div"], [145]], ["rem", 164, "comesFrom", ["rem"], [138]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; } int main ( ) { int p1 = 4 , s1 = 4 , p2 = 8 , s2 = 2 ; sackRace ( p1 , s1 , p2 , s2 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }", "docstring": "Find if two people ever meet after same number of jumps | C ++ program to find any one of them can overtake the other ; function to find if any one of them can overtake the other ; Since starting points are always different , they will meet if following conditions are met . ( 1 ) Speeds are not same ( 2 ) Difference between speeds divide the total distance between initial points . ; driver program", "dfg": [["p1", 91, "comesFrom", ["p1"], [73]], ["p1", 33, "comesFrom", ["p1"], [11]], ["p1", 51, "comesFrom", ["p1"], [11]], ["s1", 93, "comesFrom", ["s1"], [77]], ["s1", 26, "comesFrom", ["s1"], [14]], ["s1", 48, "comesFrom", ["s1"], [14]], ["s1", 37, "comesFrom", ["s1"], [14]], ["s1", 59, "comesFrom", ["s1"], [14]], ["p2", 95, "comesFrom", ["p2"], [81]], ["p2", 31, "comesFrom", ["p2"], [17]], ["p2", 53, "comesFrom", ["p2"], [17]], ["s2", 97, "comesFrom", ["s2"], [85]], ["s2", 28, "comesFrom", ["s2"], [20]], ["s2", 46, "comesFrom", ["s2"], [20]], ["s2", 39, "comesFrom", ["s2"], [20]], ["s2", 57, "comesFrom", ["s2"], [20]]]}
{"code": "#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; void solve ( int n ) { float a = ( float ) n / 2 ; if ( n % 2 != 0 ) cout << ceil ( a ) - 1 << \" ▁ \" << floor ( a ) + 1 << endl ; else { if ( ( int ) a % 2 == 0 ) { cout << ceil ( a ) - 1 << \" ▁ \" << floor ( a ) + 1 << endl ; } else { cout << ceil ( a ) - 2 << \" ▁ \" << floor ( a ) + 2 << endl ; } } } int main ( ) { int n = 34 ; solve ( n ) ; return 0 ; }", "docstring": "Largest proper fraction with sum of numerator and denominator equal to a given number | CPP program to find the largest fraction a / b such that a + b is equal to given number and a < b . ; Calculate N / 2 ; ; Check if N is odd or even ; If N is odd answer will be ceil ( n / 2 ) - 1 and floor ( n / 2 ) + 1 ; If N is even check if N / 2 i . e a is even or odd ; If N / 2 is even apply the previous formula ; If N / 2 is odd answer will be ceil ( N / 2 ) - 2 and floor ( N / 2 ) + 2 ; driver function", "dfg": [["n", 133, "comesFrom", ["n"], [127]], ["n", 23, "comesFrom", ["n"], [14]], ["n", 29, "comesFrom", ["n"], [14]], ["a", 50, "comesFrom", ["a"], [18]], ["a", 64, "comesFrom", ["a"], [18]], ["a", 39, "comesFrom", ["a"], [18]], ["a", 86, "comesFrom", ["a"], [18]], ["a", 111, "comesFrom", ["a"], [18]], ["a", 75, "comesFrom", ["a"], [18]], ["a", 100, "comesFrom", ["a"], [18]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int main ( ) { float P = 1 , R = 1 , T = 1 ; float SI = ( P * T * R ) / 100 ; cout << \" Simple ▁ Interest ▁ = ▁ \" << SI ; return 0 ; }", "docstring": "Program to find simple interest | CPP program to find simple interest for given principal amount , time and rate of interest . ; We can change values here for different inputs ; Calculate simple interest ; Print the resultant value of SI", "dfg": [["SI", 44, "comesFrom", ["SI"], [26]], ["R", 33, "comesFrom", ["R"], [17]], ["P", 29, "comesFrom", ["P"], [13]], ["T", 31, "comesFrom", ["T"], [21]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; } int main ( ) { int a = 33 ; int b = -24 ; cout << \" Number ▁ of ▁ digits ▁ = ▁ \" << countDigits ( a , b ) ; return 0 ; }", "docstring": "Number of digits in the product of two numbers | C ++ implementation to count number of digits in the product of two numbers ; function to count number of digits in the product of two numbers ; absolute value of the product of two numbers ; if product is 0 ; count number of digits in the product ' p ' ; required count of digits ; Driver program to test above", "dfg": [["count", 59, "comesFrom", ["count"], [18]], ["count", 48, "comesFrom", ["count"], [18]], ["p", 34, "comesFrom", ["p"], [23]], ["p", 43, "comesFrom", ["p"], [23]], ["p", 53, "comesFrom", ["p"], [51]], ["a", 85, "comesFrom", ["a"], [68]], ["a", 27, "comesFrom", ["a"], [11]], ["b", 87, "comesFrom", ["b"], [73]], ["b", 29, "comesFrom", ["b"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) cout << \"1\" ; else cout << \"0\" ; } int mul = pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; cout << ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; } int main ( ) { int a = 349 , b = 1 , x = 4 ; multiple ( a , b , x ) ; return 0 ; }", "docstring": "Find multiple of x closest to or a ^ b ( a raised to power b ) | C ++ Program to find closest multiple of x to a ^ b ; function to find closest multiple of x to a ^ b ; calculate a ^ b / x ; Answer is either ( ans * x ) or ( ans + 1 ) * x ; Printing nearest answer ; Driver Program", "dfg": [["b", 22, "comesFrom", ["b"], [14]], ["b", 131, "comesFrom", ["b"], [119]], ["b", 58, "comesFrom", ["b"], [14]], ["mul", 64, "comesFrom", ["mul"], [52]], ["mul", 91, "comesFrom", ["mul"], [52]], ["mul", 99, "comesFrom", ["mul"], [52]], ["x", 66, "comesFrom", ["x"], [17]], ["x", 71, "comesFrom", ["x"], [17]], ["x", 78, "comesFrom", ["x"], [17]], ["x", 133, "comesFrom", ["x"], [123]], ["x", 33, "comesFrom", ["x"], [17]], ["ans", 73, "comesFrom", ["ans"], [62]], ["ans", 81, "comesFrom", ["ans"], [62]], ["a", 129, "comesFrom", ["a"], [115]], ["a", 56, "comesFrom", ["a"], [11]], ["a", 29, "comesFrom", ["a"], [11]], ["ans1", 103, "comesFrom", ["ans1"], [69]], ["ans1", 93, "comesFrom", ["ans1"], [69]], ["ans2", 105, "comesFrom", ["ans2"], [76]], ["ans2", 97, "comesFrom", ["ans2"], [76]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; } int main ( ) { int n = 3 ; cout << maxSum ( n ) ; return 0 ; }", "docstring": "Maximum sum of difference of adjacent elements | CPP program to find maximum sum of adjacent elements of permutation of n ; To find max sum of permutation ; Base case ; Otherwise max sum will be ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; Driver program to test maxSum ( )", "dfg": [["n", 16, "comesFrom", ["n"], [11]], ["n", 58, "comesFrom", ["n"], [50]], ["n", 39, "comesFrom", ["n"], [11]], ["n", 26, "comesFrom", ["n"], [11]], ["n", 29, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int compute_average ( int a , int b ) { return ( a + b ) / 2 ; } int main ( ) { int a = INT_MAX , b = INT_MAX ; cout << \" Actual ▁ average ▁ : ▁ \" << INT_MAX << endl ; cout << \" Computed ▁ average ▁ : ▁ \" << compute_average ( a , b ) ; return 0 ; }", "docstring": "Compute average of two numbers without overflow | C ++ code to compute average of two numbers ; Function to compute average of two numbers ; Driver code ; Assigning maximum integer value ; Average of two equal numbers is the same number ; Function to get the average of 2 numbers", "dfg": [["INT_MAX", 47, "comesFrom", ["INT_MAX"], [39]], ["a", 19, "comesFrom", ["a"], [11]], ["a", 59, "comesFrom", ["a"], [33]], ["b", 21, "comesFrom", ["b"], [14]], ["b", 61, "comesFrom", ["b"], [37]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int minNum ( int arr [ ] , int n ) { bool odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minNum ( arr , n ) << \" n \" ; return 0 ; }", "docstring": "Add minimum number to an array so that the sum becomes even | CPP program to add minimum number so that the sum of array becomes even ; Function to find out minimum number ; Count odd number of terms in array ; Driver code", "dfg": [["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 42, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 115, "comesFrom", ["n"], [94]], ["odd", 54, "comesFrom", ["odd"], [47]], ["odd", 50, "comesFrom", ["odd"], [47]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; } int main ( ) { int num = -1234 ; if ( checkJumbled ( num ) ) cout << \" True ▁ STRNEWLINE \" ; else cout << \" False ▁ STRNEWLINE \" ; num = -1247 ; if ( checkJumbled ( num ) ) cout << \" True ▁ STRNEWLINE \" ; else cout << \" False ▁ STRNEWLINE \" ; return 0 ; }", "docstring": "Check if a number is jumbled or not | CPP code to check if a number is jumbled or not ; Function to check if a number is jumbled or not ; Single digit number ; Checking every digit through a loop ; All digits were checked ; Digit at index i ; Digit at index i - 1 ; If difference is greater than 1 ; Number checked ; Driver code ; - 1234 to be checked ; 287 to be checked", "dfg": [["num", 27, "comesFrom", ["num"], [11]], ["num", 16, "comesFrom", ["num"], [11]], ["num", 100, "comesFrom", ["num"], [92]], ["num", 124, "comesFrom", ["num"], [116]], ["num", 46, "comesFrom", ["num"], [11]], ["num", 77, "comesFrom", ["num"], [75]], ["num", 34, "comesFrom", ["num"], [11]], ["num", 54, "comesFrom", ["num"], [11]], ["digit2", 65, "comesFrom", ["digit2"], [51]], ["digit1", 67, "comesFrom", ["digit1"], [44]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; } int josephify ( int n ) { int position = msbPos ( n ) ; int j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; } int main ( ) { int n = 41 ; cout << josephify ( n ) ; return 0 ;", "docstring": "Josephus Problem Using Bit Magic | C ++ program for josephus problem ; function to find the position of the Most Significant Bit ; keeps shifting bits to the right until we are left with 0 ; function to return at which place Josephus should sit to avoid being killed ; Getting the position of the Most Significant Bit ( MSB ) . The leftmost '1' . If the number is '41' then its binary is '101001' . So msbPos ( 41 ) = 6 ; ' j ' stores the number with which to XOR the number ' n ' . Since we need '100000' We will do 1 << 6 - 1 to get '100000' ; Toggling the Most Significant Bit . Changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 ) ; Left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 ) ; Toggling the '0' at the end to '1' which is essentially the same as putting the MSB at the rightmost place . 010010 | 1 = 010011 ( 19 ) ; hard coded driver main function to run the program", "dfg": [["pos", 37, "comesFrom", ["pos"], [15]], ["pos", 26, "comesFrom", ["pos"], [15]], ["n", 85, "comesFrom", ["n"], [78]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 68, "comesFrom", ["n"], [66]], ["n", 74, "comesFrom", ["n"], [72]], ["n", 80, "comesFrom", ["n"], [78]], ["n", 52, "comesFrom", ["n"], [44]], ["n", 102, "comesFrom", ["n"], [94]], ["n", 31, "comesFrom", ["n"], [29]], ["j", 70, "comesFrom", ["j"], [56]], ["position", 61, "comesFrom", ["position"], [48]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countXorPair ( arr , n ) ; return 0 ; }", "docstring": "Count pairs with Odd XOR | C ++ program to count pairs in array whose XOR is odd ; A function will return number of pair whose XOR is odd ; To store count of XOR pair ; If XOR is odd increase count ; Return count ; Driver program to test countXorPair ( )", "dfg": [["count", 78, "comesFrom", ["count"], [20]], ["count", 73, "comesFrom", ["count"], [20]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 44, "comesFrom", ["i"], [27]], ["i", 60, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 50, "comesFrom", ["n"], [16]], ["n", 121, "comesFrom", ["n"], [100]], ["j", 48, "comesFrom", ["j"], [42]], ["j", 52, "comesFrom", ["j"], [42]], ["j", 65, "comesFrom", ["j"], [42]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int powmod ( int x , int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) sqrt ( m ) + 1 ; unordered_map < int , int > value ; for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) { int cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] ) { int ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return -1 ; } int main ( ) { int a = 2 , b = 3 , m = 5 ; cout << discreteLogarithm ( a , b , m ) << endl ; a = 3 , b = 7 , m = 11 ; cout << discreteLogarithm ( a , b , m ) ; }", "docstring": "Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | C ++ program to calculate discrete logarithm ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to calculate k for given a , b , m ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; If collision occurs i . e . , LHS = RHS ; Check whether ans lies below m or not ; Driver code", "dfg": [["res", 55, "comesFrom", ["res"], [33]], ["res", 36, "comesFrom", ["res"], [33]], ["i", 99, "comesFrom", ["i"], [95]], ["i", 104, "comesFrom", ["i"], [95]], ["i", 120, "comesFrom", ["i"], [95]], ["i", 112, "comesFrom", ["i"], [95]], ["j", 129, "comesFrom", ["j"], [125]], ["j", 134, "comesFrom", ["j"], [125]], ["j", 173, "comesFrom", ["j"], [125]], ["j", 145, "comesFrom", ["j"], [125]], ["n", 131, "comesFrom", ["n"], [97]], ["n", 114, "comesFrom", ["n"], [97]], ["n", 171, "comesFrom", ["n"], [97]], ["y", 22, "comesFrom", ["y"], [14]], ["y", 29, "comesFrom", ["y"], [14]], ["value", 106, "comesFrom", ["value"], [90]], ["value", 157, "comesFrom", ["value"], [90]], ["value", 166, "comesFrom", ["value"], [90]], ["a", 237, "comesFrom", ["a"], [221]], ["a", 212, "comesFrom", ["a"], [196]], ["a", 110, "comesFrom", ["a"], [62]], ["a", 143, "comesFrom", ["a"], [62]], ["b", 239, "comesFrom", ["b"], [225]], ["b", 214, "comesFrom", ["b"], [200]], ["b", 150, "comesFrom", ["b"], [65]], ["m", 241, "comesFrom", ["m"], [229]], ["m", 153, "comesFrom", ["m"], [68]], ["m", 216, "comesFrom", ["m"], [204]], ["m", 79, "comesFrom", ["m"], [68]], ["m", 116, "comesFrom", ["m"], [68]], ["m", 179, "comesFrom", ["m"], [68]], ["m", 147, "comesFrom", ["m"], [68]], ["p", 51, "comesFrom", ["p"], [17]], ["p", 41, "comesFrom", ["p"], [17]], ["cur", 159, "comesFrom", ["cur"], [138]], ["cur", 168, "comesFrom", ["cur"], [138]], ["ans", 182, "comesFrom", ["ans"], [164]], ["ans", 177, "comesFrom", ["ans"], [164]], ["x", 46, "comesFrom", ["x"], [43]], ["x", 48, "comesFrom", ["x"], [43]], ["x", 38, "comesFrom", ["x"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; unordered_map < int , int > value ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( ! value [ cur ] ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return -1 ; } int main ( ) { int a = 2 , b = 3 , m = 5 ; cout << discreteLogarithm ( a , b , m ) << endl ; a = 3 , b = 7 , m = 11 ; cout << discreteLogarithm ( a , b , m ) ; }", "docstring": "Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | C ++ program to calculate discrete logarithm ; Calculate a ^ n ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; Driver code", "dfg": [["i", 45, "comesFrom", ["i"], [41]], ["i", 50, "comesFrom", ["i"], [41]], ["i", 81, "comesFrom", ["i"], [73]], ["i", 86, "comesFrom", ["i"], [73]], ["i", 126, "comesFrom", ["i"], [118]], ["i", 131, "comesFrom", ["i"], [118]], ["i", 102, "comesFrom", ["i"], [73]], ["i", 152, "comesFrom", ["i"], [118]], ["n", 47, "comesFrom", ["n"], [21]], ["n", 83, "comesFrom", ["n"], [21]], ["n", 128, "comesFrom", ["n"], [21]], ["n", 150, "comesFrom", ["n"], [21]], ["m", 60, "comesFrom", ["m"], [17]], ["m", 230, "comesFrom", ["m"], [218]], ["m", 112, "comesFrom", ["m"], [17]], ["m", 172, "comesFrom", ["m"], [17]], ["m", 205, "comesFrom", ["m"], [193]], ["m", 28, "comesFrom", ["m"], [17]], ["m", 158, "comesFrom", ["m"], [17]], ["a", 226, "comesFrom", ["a"], [210]], ["a", 201, "comesFrom", ["a"], [185]], ["a", 57, "comesFrom", ["a"], [11]], ["a", 169, "comesFrom", ["a"], [11]], ["b", 228, "comesFrom", ["b"], [214]], ["b", 203, "comesFrom", ["b"], [189]], ["value", 136, "comesFrom", ["value"], [68]], ["value", 92, "comesFrom", ["value"], [68]], ["value", 97, "comesFrom", ["value"], [68]], ["value", 145, "comesFrom", ["value"], [68]], ["an", 55, "comesFrom", ["an"], [52]], ["an", 109, "comesFrom", ["an"], [79]], ["cur", 138, "comesFrom", ["cur"], [122]], ["cur", 94, "comesFrom", ["cur"], [77]], ["cur", 99, "comesFrom", ["cur"], [77]], ["cur", 107, "comesFrom", ["cur"], [104]], ["cur", 167, "comesFrom", ["cur"], [164]], ["cur", 147, "comesFrom", ["cur"], [122]], ["ans", 161, "comesFrom", ["ans"], [143]], ["ans", 156, "comesFrom", ["ans"], [143]]]}
{"code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; string nthprimedigitsnumber ( int number ) { int rem ; string num ; while ( number ) { rem = number % 4 ; switch ( rem ) { case 1 : num . push_back ( '2' ) ; break ; case 2 : num . push_back ( '3' ) ; break ; case 3 : num . push_back ( '5' ) ; break ; case 0 : num . push_back ( '7' ) ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } reverse ( num . begin ( ) , num . end ( ) ) ; return num ; } int main ( ) { int number = 21 ; cout << nthprimedigitsnumber ( 10 ) << \" STRNEWLINE \" ; cout << nthprimedigitsnumber ( 21 ) << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Finding n | CPP program to find n - th number with prime digits 2 , 3 and 7 ; remainder for check element position ; if number is 1 st position in tree ; if number is 2 nd position in tree ; if number is 3 rd position in tree ; if number is 4 th position in tree ; Driver code", "dfg": [["num", 133, "comesFrom", ["num"], [24]], ["num", 119, "comesFrom", ["num"], [24]], ["num", 125, "comesFrom", ["num"], [24]], ["num", 45, "comesFrom", ["num"], [24]], ["num", 59, "comesFrom", ["num"], [24]], ["num", 73, "comesFrom", ["num"], [24]], ["num", 87, "comesFrom", ["num"], [24]], ["number", 28, "comesFrom", ["number"], [17]], ["number", 33, "comesFrom", ["number"], [17]], ["number", 107, "comesFrom", ["number"], [17]], ["number", 112, "comesFrom", ["number"], [110]], ["number", 101, "comesFrom", ["number"], [17]], ["rem", 39, "comesFrom", ["rem"], [31]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= cbrt ( N ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; } int main ( ) { for ( int i = 1 ; i <= 10 ; i ++ ) cout << \" For ▁ n ▁ = ▁ \" << i << \" , ▁ \" << countPairs ( i ) << \" ▁ pair ▁ exists STRNEWLINE \" ; return 0 ; }", "docstring": "Count pairs ( a , b ) whose sum of cubes is N ( a ^ 3 + b ^ 3 = N ) | C ++ program to count pairs whose sum cubes is N ; Function to count the pairs satisfying a ^ 3 + b ^ 3 = N ; Check for each number 1 to cbrt ( N ) ; Store cube of a number ; Subtract the cube from given N ; Check if the difference is also a perfect cube ; If yes , then increment count ; Return count ; Driver program ; Loop to Count no . of pairs satisfying a ^ 3 + b ^ 3 = i for N = 1 to 10", "dfg": [["count", 76, "comesFrom", ["count"], [15]], ["count", 71, "comesFrom", ["count"], [15]], ["i", 26, "comesFrom", ["i"], [22]], ["i", 33, "comesFrom", ["i"], [22]], ["i", 91, "comesFrom", ["i"], [87]], ["i", 95, "comesFrom", ["i"], [87]], ["i", 44, "comesFrom", ["i"], [22]], ["i", 40, "comesFrom", ["i"], [22]], ["i", 42, "comesFrom", ["i"], [22]], ["i", 104, "comesFrom", ["i"], [87]], ["i", 112, "comesFrom", ["i"], [87]], ["N", 30, "comesFrom", ["N"], [11]], ["N", 49, "comesFrom", ["N"], [11]], ["cb", 51, "comesFrom", ["cb"], [38]], ["diff", 69, "comesFrom", ["diff"], [47]], ["diff", 58, "comesFrom", ["diff"], [47]], ["cbrtDiff", 67, "comesFrom", ["cbrtDiff"], [54]], ["cbrtDiff", 63, "comesFrom", ["cbrtDiff"], [54]], ["cbrtDiff", 65, "comesFrom", ["cbrtDiff"], [54]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ull  unsigned long long NEW_LINE map < ull , int > primeFactors ( ull num ) { map < ull , int > ans ; for ( ull i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { num /= i ; ans [ i ] ++ ; } } if ( num > 1 ) ans [ num ] ++ ; return ans ; } ull legendre ( ull factor , ull num ) { ull count = 0 , fac2 = factor ; while ( num >= factor ) { count += num / factor ; factor *= fac2 ; } return count ; } bool possible ( map < ull , int > & factors , ull num ) { for ( map < ull , int > :: iterator it = factors . begin ( ) ; it != factors . end ( ) ; ++ it ) { if ( legendre ( it -> first , num ) < it -> second ) return false ; } return true ; } ull search ( ull start , ull end , map < ull , int > & factors ) { ull mid = ( start + end ) / 2 ; if ( ! possible ( factors , mid ) ) return search ( mid + 1 , end , factors ) ; if ( start == mid ) return mid ; return search ( start , mid , factors ) ; } ull findFact ( ull num ) { map < ull , int > factors = primeFactors ( num ) ; return search ( 1 , num , factors ) ; } int main ( ) { cout << findFact ( 6 ) << \" n \" ; cout << findFact ( 997587429953 ) << \" n \" ; return 0 ; }", "docstring": "Smallest number S such that N is a factor of S factorial or S ! | Program to find factorial that N belongs to ; Calculate prime factors for a given number ; Container for prime factors ; Iterate from 2 to i ^ 2 finding all factors ; If we still have a remainder it is also a prime factor ; Calculate occurrence of an element in factorial of a number ; Iterate through prime factors ; Check if factorial contains less occurrences of prime factor ; Function to binary search 1 to N ; Prime factors are not in the factorial Increase the lowerbound ; We have reached smallest occurrence ; Smaller factorial satisfying requirements may exist , decrease upperbound ; Calculate prime factors and search ; Driver function", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printEqualModNumbers ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { cout << \" Infinite ▁ solution \" ; return ; } vector < int > v ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . push_back ( i ) ; if ( i != d / i ) v . push_back ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) cout << v [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 38 , 6 , 34 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printEqualModNumbers ( arr , n ) ; return 0 ; }", "docstring": "Finding ' k ' such that its modulus with each array element is same | C ++ implementation of finding all k such that arr [ i ] % k is same for each i ; Prints all k such that arr [ i ] % k is same for all i ; sort the numbers ; max difference will be the difference between first and last element of sorted array ; Case when all the array elements are same ; Find all divisors of d and store in a vector v [ ] ; check for each v [ i ] if its modulus with each array element is same or not ; checking for each array element if its modulus with k is equal to k or not ; if check is true print v [ i ] ; Driver function", "dfg": [["d", 76, "comesFrom", ["d"], [29]], ["d", 45, "comesFrom", ["d"], [29]], ["d", 84, "comesFrom", ["d"], [29]], ["d", 102, "comesFrom", ["d"], [29]], ["d", 110, "comesFrom", ["d"], [29]], ["i", 78, "comesFrom", ["i"], [68]], ["i", 124, "comesFrom", ["i"], [120]], ["i", 132, "comesFrom", ["i"], [120]], ["i", 72, "comesFrom", ["i"], [68]], ["i", 74, "comesFrom", ["i"], [68]], ["i", 86, "comesFrom", ["i"], [68]], ["i", 95, "comesFrom", ["i"], [68]], ["i", 100, "comesFrom", ["i"], [68]], ["i", 146, "comesFrom", ["i"], [120]], ["i", 104, "comesFrom", ["i"], [68]], ["i", 191, "comesFrom", ["i"], [120]], ["i", 112, "comesFrom", ["i"], [68]], ["i", 174, "comesFrom", ["i"], [120]], ["n", 238, "comesFrom", ["n"], [219]], ["n", 25, "comesFrom", ["n"], [16]], ["n", 160, "comesFrom", ["n"], [16]], ["n", 185, "comesFrom", ["n"], [16]], ["n", 33, "comesFrom", ["n"], [16]], ["v", 126, "comesFrom", ["v"], [63]], ["v", 144, "comesFrom", ["v"], [63]], ["v", 91, "comesFrom", ["v"], [63]], ["v", 189, "comesFrom", ["v"], [63]], ["v", 106, "comesFrom", ["v"], [63]], ["v", 172, "comesFrom", ["v"], [63]], ["j", 158, "comesFrom", ["j"], [154]], ["j", 162, "comesFrom", ["j"], [154]], ["j", 183, "comesFrom", ["j"], [154]], ["j", 169, "comesFrom", ["j"], [154]], ["temp", 177, "comesFrom", ["temp"], [137]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int FirstDigit ( int arr [ ] , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - floor ( S ) ; int ans = pow ( 10 , fract_S ) ; return ans ; } int main ( ) { int arr [ ] = { 5 , 8 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << FirstDigit ( arr , n ) << endl ; return 0 ; }", "docstring": "First digit in product of an array of numbers | C ++ implementation of finding first digit of product of n numbers ; returns the first digit of product of elements of arr [ ] ; stores the logarithm of product of elements of arr [ ] ; fractional ( s ) = s - floor ( s ) ; ans = 10 ^ fract_s ; Driver function", "dfg": [["ans", 73, "comesFrom", ["ans"], [63]], ["i", 31, "comesFrom", ["i"], [27]], ["i", 35, "comesFrom", ["i"], [27]], ["i", 46, "comesFrom", ["i"], [27]], ["n", 33, "comesFrom", ["n"], [16]], ["n", 118, "comesFrom", ["n"], [97]], ["S", 55, "comesFrom", ["S"], [38]], ["S", 40, "comesFrom", ["S"], [38]], ["S", 59, "comesFrom", ["S"], [38]], ["fract_S", 69, "comesFrom", ["fract_S"], [53]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; } int main ( ) { int n = 1012 ; cout << countDigit ( n ) << endl ; return 0 ; }", "docstring": "Find count of digits in a number that divide the number | C ++ program to count number of digits that divides the number . ; Return the number of digits that divides the number . ; Fetching each digit of the number ; Checking if digit is greater than 0 and can divides n . ; Driven Program", "dfg": [["count", 58, "comesFrom", ["count"], [19]], ["count", 53, "comesFrom", ["count"], [19]], ["temp", 25, "comesFrom", ["temp"], [15]], ["temp", 33, "comesFrom", ["temp"], [15]], ["n", 75, "comesFrom", ["n"], [67]], ["n", 47, "comesFrom", ["n"], [17]], ["d", 43, "comesFrom", ["d"], [31]], ["d", 49, "comesFrom", ["d"], [31]]]}
{"code": "#include <iostream> NEW_LINE using namespace std ; int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int resul = 1 ; while ( n % 2 == 0 ) { n /= 2 ; resul *= 2 ; } return resul ; } int main ( ) { int n = 36 ; cout << makeOdd ( n ) ; return 0 ; }", "docstring": "Minimum positive integer to divide a number such that the result is an odd | C ++ program to make a number odd ; Function to find the value ; Return 1 if already odd ; Check how many times it is divided by 2 ; Driver code", "dfg": [["resul", 49, "comesFrom", ["resul"], [43]], ["n", 16, "comesFrom", ["n"], [11]], ["n", 32, "comesFrom", ["n"], [11]], ["n", 66, "comesFrom", ["n"], [58]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; } int main ( ) { int n = 9 , x = 4 ; printf ( \" % d \" , closestMultiple ( n , x ) ) ; return 0 ; }", "docstring": "Multiple of x closest to n | CPP program to calculate the smallest multiple of x closest to a given number ; Function to calculate the smallest multiple ; driver program", "dfg": [["n", 45, "comesFrom", ["n"], [34]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 28, "comesFrom", ["n"], [26]], ["n", 36, "comesFrom", ["n"], [34]], ["n", 39, "comesFrom", ["n"], [34]], ["n", 70, "comesFrom", ["n"], [54]], ["x", 24, "comesFrom", ["x"], [14]], ["x", 19, "comesFrom", ["x"], [14]], ["x", 30, "comesFrom", ["x"], [14]], ["x", 41, "comesFrom", ["x"], [14]], ["x", 72, "comesFrom", ["x"], [58]]]}
{"code": "#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void printCubes ( int a , int b ) { int acrt = cbrt ( a ) ; int bcrt = cbrt ( b ) ; for ( int i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) cout << i * i * i << \" ▁ \" ; } int main ( ) { int a = 24 , b = 576 ; cout << \" Perfect ▁ cubes ▁ in ▁ given ▁ range : STRNEWLINE \" << printCubes ( a , b ) ; return 0 ; }", "docstring": "Perfect cubes in a range | Efficient method to print cubes between a and b ; An efficient solution to print perfect cubes between a and b ; Find cube root of both a and b ; Print cubes between acrt and bcrt ; Driver code", "dfg": [["i", 43, "comesFrom", ["i"], [39]], ["i", 47, "comesFrom", ["i"], [39]], ["i", 56, "comesFrom", ["i"], [39]], ["i", 64, "comesFrom", ["i"], [39]], ["i", 74, "comesFrom", ["i"], [39]], ["i", 52, "comesFrom", ["i"], [39]], ["i", 54, "comesFrom", ["i"], [39]], ["i", 60, "comesFrom", ["i"], [39]], ["i", 62, "comesFrom", ["i"], [39]], ["i", 70, "comesFrom", ["i"], [39]], ["i", 72, "comesFrom", ["i"], [39]], ["bcrt", 45, "comesFrom", ["bcrt"], [29]], ["a", 25, "comesFrom", ["a"], [14]], ["a", 103, "comesFrom", ["a"], [87]], ["a", 58, "comesFrom", ["a"], [14]], ["b", 33, "comesFrom", ["b"], [17]], ["b", 105, "comesFrom", ["b"], [91]], ["b", 66, "comesFrom", ["b"], [17]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int number0f2s ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = n / 10 ; } return count ; } int numberOf2sinRange ( int n ) { int count = 0 ; for ( int i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; } int main ( ) { cout << numberOf2sinRange ( 22 ) ; cout << endl ; cout << numberOf2sinRange ( 100 ) ; return 0 ; }", "docstring": "Number of occurrences of 2 as a digit in numbers from 0 to n | C ++ program to count 2 s from 0 to n ; Counts the number of '2' digits in a single number ; Counts the number of '2' digits between 0 and n ; Initialize result ; Count 2 's in every number  from 2 to n ; Driver Code", "dfg": [["count", 45, "comesFrom", ["count"], [15]], ["count", 82, "comesFrom", ["count"], [74]], ["count", 34, "comesFrom", ["count"], [15]], ["i", 67, "comesFrom", ["i"], [63]], ["i", 71, "comesFrom", ["i"], [63]], ["i", 78, "comesFrom", ["i"], [63]], ["n", 69, "comesFrom", ["n"], [52]], ["n", 21, "comesFrom", ["n"], [11]], ["n", 39, "comesFrom", ["n"], [37]], ["n", 28, "comesFrom", ["n"], [11]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minToggle ( int arr [ ] , int n ) { int zero [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minToggle ( arr , n ) << \" STRNEWLINE \" ; return 0 ; }", "docstring": "Minimum toggles to partition a binary array so that it has first 0 s then 1 s | C ++ program to find minimum toggle required ; Function to calculate minimum toggling required by using Dynamic programming ; Fill entries in zero [ ] such that zero [ i ] stores count of zeroes to the left of i ( exl ; If zero found update zero [ ] array ; Finding the minimum toggle required from every index ( 0 to n - 1 ) ; Driver Program", "dfg": [["ans", 132, "comesFrom", ["ans"], [107]], ["ans", 111, "comesFrom", ["ans"], [107]], ["i", 41, "comesFrom", ["i"], [37]], ["i", 46, "comesFrom", ["i"], [37]], ["i", 100, "comesFrom", ["i"], [96]], ["i", 105, "comesFrom", ["i"], [96]], ["i", 62, "comesFrom", ["i"], [37]], ["i", 53, "comesFrom", ["i"], [37]], ["i", 77, "comesFrom", ["i"], [37]], ["i", 113, "comesFrom", ["i"], [96]], ["i", 127, "comesFrom", ["i"], [96]], ["i", 67, "comesFrom", ["i"], [37]], ["i", 82, "comesFrom", ["i"], [37]], ["i", 117, "comesFrom", ["i"], [96]], ["n", 43, "comesFrom", ["n"], [16]], ["n", 102, "comesFrom", ["n"], [91]], ["n", 22, "comesFrom", ["n"], [16]], ["n", 179, "comesFrom", ["n"], [158]], ["n", 122, "comesFrom", ["n"], [91]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str ) { int n = str . length ( ) ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; } int main ( ) { string str = \"1332\" ; check ( str ) ? cout << \" Yes \" : cout << \" No ▁ \" ; return 0 ; }", "docstring": "Check if a large number is divisible by 6 or not | C ++ program to find if a number is divisible by 6 or not ; Function to find that number divisible by 6 or not ; Return false if number is not divisible by 2. ; Compute sum of digits ; Check if sum of digits is divisible by 3 ; Driver code", "dfg": [["i", 57, "comesFrom", ["i"], [53]], ["i", 61, "comesFrom", ["i"], [53]], ["i", 69, "comesFrom", ["i"], [53]], ["n", 59, "comesFrom", ["n"], [15]], ["n", 28, "comesFrom", ["n"], [15]], ["str", 17, "comesFrom", ["str"], [11]], ["str", 101, "comesFrom", ["str"], [93]], ["str", 67, "comesFrom", ["str"], [11]], ["str", 26, "comesFrom", ["str"], [11]], ["digitSum", 79, "comesFrom", ["digitSum"], [64]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int res = 0 ; int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) floor ( pow ( num , 1.0 / n ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) pow ( i , n ) , i , n ) ; } return res ; } int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; } int main ( ) { cout << ( check ( 10 , 2 ) ) ; return 0 ; }", "docstring": "Find ways an Integer can be expressed as sum of n | C ++ program to find number of ways to express a number as sum of n - th powers of numbers . ; Wrapper over checkRecursive ( ) ; Driver Code", "dfg": [["res", 116, "comesFrom", ["res"], [8]], ["res", 34, "comesFrom", ["res"], [8]], ["i", 64, "comesFrom", ["i"], [58]], ["i", 68, "comesFrom", ["i"], [58]], ["i", 109, "comesFrom", ["i"], [58]], ["i", 82, "comesFrom", ["i"], [58]], ["i", 104, "comesFrom", ["i"], [58]], ["r", 66, "comesFrom", ["r"], [38]], ["x", 30, "comesFrom", ["x"], [19]], ["x", 132, "comesFrom", ["x"], [123]], ["x", 134, "comesFrom", ["x"], [123]], ["x", 75, "comesFrom", ["x"], [19]], ["x", 97, "comesFrom", ["x"], [19]], ["n", 138, "comesFrom", ["n"], [126]], ["n", 111, "comesFrom", ["n"], [25]], ["n", 51, "comesFrom", ["n"], [25]], ["n", 84, "comesFrom", ["n"], [25]], ["n", 106, "comesFrom", ["n"], [25]], ["k", 60, "comesFrom", ["k"], [22]], ["a", 89, "comesFrom", ["a"], [73]], ["num", 95, "comesFrom", ["num"], [16]], ["num", 47, "comesFrom", ["num"], [16]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverseNum ( int n ) { int rem , rev = 0 ; while ( n ) { rem = n % 10 ; rev = rev * 10 + rem ; n /= 10 ; } return rev ; } bool isPalindrom ( int num ) { return num == reverseNum ( num ) ; } int nthPalindrome ( int n , int k ) { int num = ( int ) pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( ! n ) break ; ++ num ; } return num ; } int main ( ) { int n = 6 , k = 5 ; printf ( \" % dth ▁ palindrome ▁ of ▁ % d ▁ digit ▁ = ▁ % d STRNEWLINE \" , n , k , nthPalindrome ( n , k ) ) ; n = 10 , k = 6 ; printf ( \" % dth ▁ palindrome ▁ of ▁ % d ▁ digit ▁ = ▁ % d \" , n , k , nthPalindrome ( n , k ) ) ; return 0 ; }", "docstring": "N 'th palindrome of K digits | A naive approach of C ++ program of finding nth palindrome of k digit ; Utility function to reverse the number n ; Boolean Function to check for palindromic number ; Function for finding nth palindrome of k digits ; Get the smallest k digit number ; check the number is palindrom or not ; if n 'th palindrome found break the loop ; Increment number for checking next palindrome ; Driver code", "dfg": [["rev", 46, "comesFrom", ["rev"], [32]], ["rev", 34, "comesFrom", ["rev"], [32]], ["num", 117, "comesFrom", ["num"], [76]], ["num", 57, "comesFrom", ["num"], [53]], ["num", 61, "comesFrom", ["num"], [53]], ["num", 113, "comesFrom", ["num"], [76]], ["num", 99, "comesFrom", ["num"], [76]], ["n", 23, "comesFrom", ["n"], [11]], ["n", 140, "comesFrom", ["n"], [126]], ["n", 166, "comesFrom", ["n"], [152]], ["n", 28, "comesFrom", ["n"], [11]], ["n", 103, "comesFrom", ["n"], [69]], ["n", 108, "comesFrom", ["n"], [69]], ["n", 146, "comesFrom", ["n"], [126]], ["n", 172, "comesFrom", ["n"], [152]], ["k", 142, "comesFrom", ["k"], [130]], ["k", 168, "comesFrom", ["k"], [156]], ["k", 148, "comesFrom", ["k"], [130]], ["k", 174, "comesFrom", ["k"], [156]], ["k", 85, "comesFrom", ["k"], [72]], ["rem", 38, "comesFrom", ["rem"], [26]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) pow ( 10 , temp ) ; palindrome += n - 1 ; printf ( \" % d \" , palindrome ) ; if ( k & 1 ) palindrome /= 10 ; while ( palindrome ) { printf ( \" % d \" , palindrome % 10 ) ; palindrome /= 10 ; } printf ( \" STRNEWLINE \" ) ; } int main ( ) { int n = 6 , k = 5 ; printf ( \" % dth ▁ palindrome ▁ of ▁ % d ▁ digit ▁ = ▁ \" , n , k ) ; nthPalindrome ( n , k ) ; n = 10 , k = 6 ; printf ( \" % dth ▁ palindrome ▁ of ▁ % d ▁ digit ▁ = ▁ \" , n , k ) ; nthPalindrome ( n , k ) ; return 0 ; }", "docstring": "N 'th palindrome of K digits | C ++ program of finding nth palindrome of k digit ; Determine the first half digits ; Print the first half digits of palindrome ; If k is odd , truncate the last digit ; print the last half digits of palindrome ; Driver code", "dfg": [["palindrome", 80, "comesFrom", ["palindrome"], [74]], ["palindrome", 65, "comesFrom", ["palindrome"], [53]], ["palindrome", 89, "comesFrom", ["palindrome"], [74]], ["n", 55, "comesFrom", ["n"], [11]], ["n", 127, "comesFrom", ["n"], [113]], ["n", 134, "comesFrom", ["n"], [113]], ["n", 153, "comesFrom", ["n"], [139]], ["n", 160, "comesFrom", ["n"], [139]], ["k", 70, "comesFrom", ["k"], [14]], ["k", 129, "comesFrom", ["k"], [117]], ["k", 136, "comesFrom", ["k"], [117]], ["k", 155, "comesFrom", ["k"], [143]], ["k", 162, "comesFrom", ["k"], [143]], ["k", 21, "comesFrom", ["k"], [14]], ["k", 27, "comesFrom", ["k"], [14]], ["k", 33, "comesFrom", ["k"], [14]], ["temp", 50, "comesFrom", ["temp"], [18]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMax ( int n , int a [ ] , int b [ ] , int k [ ] , int m ) { int arr [ n ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) res = max ( res , arr [ i ] ) ; return res ; } int main ( ) { int n = 5 ; int a [ ] = { 0 , 1 , 2 } ; int b [ ] = { 1 , 4 , 3 } ; int k [ ] = { 100 , 100 , 100 } ; int m = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << \" Maximum ▁ value ▁ after ▁ ' m ' ▁ operations ▁ is ▁ \" << findMax ( n , a , b , k , m ) ; return 0 ; }", "docstring": "Maximum value in an array after m range increment operations | C ++ implementation of simple approach to find maximum value after m range increments . ; Function to find the maximum element after m operations ; start performing m operations ; Store lower and upper index i . e . range ; Add ' k [ i ] ' value at this operation to whole range ; Find maximum value after all operations and return ; Driver code ; Number of values ; value of k to be added at each operation", "dfg": [["res", 138, "comesFrom", ["res"], [125]], ["res", 129, "comesFrom", ["res"], [125]], ["n", 35, "comesFrom", ["n"], [11]], ["n", 120, "comesFrom", ["n"], [11]], ["n", 214, "comesFrom", ["n"], [147]], ["i", 57, "comesFrom", ["i"], [53]], ["i", 61, "comesFrom", ["i"], [53]], ["i", 118, "comesFrom", ["i"], [114]], ["i", 122, "comesFrom", ["i"], [114]], ["i", 70, "comesFrom", ["i"], [53]], ["i", 78, "comesFrom", ["i"], [53]], ["i", 102, "comesFrom", ["i"], [53]], ["i", 133, "comesFrom", ["i"], [114]], ["m", 59, "comesFrom", ["m"], [29]], ["m", 222, "comesFrom", ["m"], [191]], ["j", 88, "comesFrom", ["j"], [84]], ["j", 92, "comesFrom", ["j"], [84]], ["j", 97, "comesFrom", ["j"], [84]], ["upperbound", 90, "comesFrom", ["upperbound"], [74]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE long long phi [ MAX ] , result [ MAX ] ; void computeTotient ( ) { phi [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( ! phi [ i ] ) { phi [ i ] = i - 1 ; for ( int j = ( i << 1 ) ; j < MAX ; j += i ) { if ( ! phi [ j ] ) phi [ j ] = j ; phi [ j ] = ( phi [ j ] / i ) * ( i - 1 ) ; } } } } void sumOfGcdPairs ( ) { computeTotient ( ) ; for ( int i = 1 ; i < MAX ; ++ i ) { for ( int j = 2 ; i * j < MAX ; ++ j ) result [ i * j ] += i * phi [ j ] ; } for ( int i = 2 ; i < MAX ; i ++ ) result [ i ] += result [ i - 1 ] ; } int main ( ) { sumOfGcdPairs ( ) ; int N = 4 ; cout << \" Summation ▁ of ▁ \" << N << \" ▁ = ▁ \" << result [ N ] << endl ; ; N = 12 ; cout << \" Summation ▁ of ▁ \" << N << \" ▁ = ▁ \" << result [ N ] << endl ; N = 5000 ; cout << \" Summation ▁ of ▁ \" << N << \" ▁ = ▁ \" << result [ N ] ; return 0 ; }", "docstring": "Summation of GCD of all the pairs up to N | C ++ approach of finding sum of GCD of all pairs ; phi [ i ] stores euler totient function for i result [ j ] stores result for value j ; Precomputation of phi [ ] numbers . Refer below link for details : https : goo . gl / LUqdtY ; Refer https : goo . gl / LUqdtY ; Precomputes result for all numbers till MAX ; Precompute all phi value ; Iterate throght all the divisors of i . ; Add summation of previous calculated sum ; Driver code ; Function to calculate sum of all the GCD pairs", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ; vector < int > solve ( int v [ ] ) { vector < int > res ; int all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] ; res . push_back ( all3 - v [ 1 ] * 2 ) ; res . push_back ( all3 - v [ 2 ] * 2 ) ; res . push_back ( all3 - v [ 0 ] * 2 ) ; return res ; } void findVertex ( int xmid [ ] , int ymid [ ] ) { vector < int > V1 = solve ( xmid ) ; vector < int > V2 = solve ( ymid ) ; for ( int i = 0 ; i < 3 ; i ++ ) cout << V1 [ i ] << \" ▁ \" << V2 [ i ] << endl ; } int main ( ) { int xmid [ N ] = { 5 , 4 , 5 } ; int ymid [ N ] = { 3 , 4 , 5 } ; findVertex ( xmid , ymid ) ; return 0 ; }", "docstring": "Find coordinates of the triangle given midpoint of each side | C ++ program to find coordinate of the triangle given midpoint of each side ; Return after solving the equations and finding the vertices coordinate . ; Finding sum of all three coordinate . ; Solving the equation . ; Finds vertices of a triangles from given middle vertices . ; Find X coordinates of vertices . ; Find Y coordinates of vertices . ; Output the solution . ; Driver code", "dfg": []}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthElement ( int a , int b , int n ) { vector < int > seq ; for ( int i = 1 ; i <= n ; i ++ ) seq . push_back ( a * i ) ; sort ( seq . begin ( ) , seq . end ( ) ) ; for ( int i = 1 , k = n ; i <= n && k ; i ++ ) { if ( ! binary_search ( seq . begin ( ) , seq . end ( ) , b * i ) ) { seq . push_back ( b * i ) ; sort ( seq . begin ( ) , seq . end ( ) ) ; k -- ; } } return seq [ n - 1 ] ; } int main ( ) { int a = 3 , b = 5 , n = 5 ; cout << nthElement ( a , b , n ) << endl ; return 0 ; }", "docstring": "N | C ++ program to find n - th number in the sorted list of multiples of two numbers . ; Return the n - th number in the sorted list of multiples of two numbers . ; Generating first n multiple of a . ; Sorting the sequence . ; Generating and storing first n multiple of b and storing if not present in the sequence . ; If not present in the sequence ; Storing in the sequence . ; Driven Program", "dfg": [["i", 33, "comesFrom", ["i"], [29]], ["i", 37, "comesFrom", ["i"], [29]], ["i", 81, "comesFrom", ["i"], [67]], ["i", 75, "comesFrom", ["i"], [67]], ["i", 46, "comesFrom", ["i"], [29]], ["i", 104, "comesFrom", ["i"], [67]], ["i", 114, "comesFrom", ["i"], [67]], ["n", 35, "comesFrom", ["n"], [17]], ["n", 77, "comesFrom", ["n"], [73]], ["n", 140, "comesFrom", ["n"], [73]], ["n", 172, "comesFrom", ["n"], [160]], ["k", 79, "comesFrom", ["k"], [71]], ["k", 132, "comesFrom", ["k"], [71]], ["seq", 138, "comesFrom", ["seq"], [24]], ["seq", 40, "comesFrom", ["seq"], [24]], ["seq", 51, "comesFrom", ["seq"], [24]], ["seq", 57, "comesFrom", ["seq"], [24]], ["seq", 108, "comesFrom", ["seq"], [24]], ["seq", 90, "comesFrom", ["seq"], [24]], ["seq", 96, "comesFrom", ["seq"], [24]], ["seq", 119, "comesFrom", ["seq"], [24]], ["seq", 125, "comesFrom", ["seq"], [24]], ["a", 44, "comesFrom", ["a"], [11]], ["a", 168, "comesFrom", ["a"], [152]], ["b", 170, "comesFrom", ["b"], [156]], ["b", 102, "comesFrom", ["b"], [14]], ["b", 112, "comesFrom", ["b"], [14]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; } int countGCD ( int L , int R , int g ) { L = ( L + g - 1 ) / g ; R = R / g ; int ans = 0 ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; } int main ( ) { int L = 1 , R = 11 , g = 5 ; cout << countGCD ( L , R , g ) << endl ; return 0 ; }", "docstring": "Count pairs of natural numbers with GCD equal to given number | C ++ program to count pair in range of natural number having GCD equal to given number . ; Return the GCD of two numbers . ; Return the count of pairs having GCD equal to g . ; Setting the value of L , R . ; For each possible pair check if GCD is 1. ; Driven Program", "dfg": [["ans", 111, "comesFrom", ["ans"], [64]], ["ans", 107, "comesFrom", ["ans"], [64]], ["b", 18, "comesFrom", ["b"], [14]], ["b", 22, "comesFrom", ["b"], [14]], ["b", 26, "comesFrom", ["b"], [14]], ["a", 29, "comesFrom", ["a"], [11]], ["a", 24, "comesFrom", ["a"], [11]], ["i", 75, "comesFrom", ["i"], [71]], ["i", 79, "comesFrom", ["i"], [71]], ["i", 100, "comesFrom", ["i"], [71]], ["R", 77, "comesFrom", ["R"], [57]], ["R", 59, "comesFrom", ["R"], [57]], ["R", 91, "comesFrom", ["R"], [57]], ["R", 138, "comesFrom", ["R"], [124]], ["g", 55, "comesFrom", ["g"], [42]], ["g", 61, "comesFrom", ["g"], [42]], ["g", 140, "comesFrom", ["g"], [128]], ["g", 50, "comesFrom", ["g"], [42]], ["j", 89, "comesFrom", ["j"], [85]], ["j", 93, "comesFrom", ["j"], [85]], ["j", 102, "comesFrom", ["j"], [85]], ["L", 136, "comesFrom", ["L"], [120]], ["L", 48, "comesFrom", ["L"], [45]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dig [ ] = { 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 } ; int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; } int main ( ) { int n = 14 ; cout << lastNon0Digit ( n ) ; return 0 ; }", "docstring": "Last non | C ++ program to find last non - zero digit in n ! ; Initialize values of last non - zero digit of numbers from 0 to 9 ; Check whether tens ( or second last ) digit is odd or even If n = 375 , So n / 10 = 37 and ( n / 10 ) % 10 = 7 Applying formula for even and odd cases . ; Driver code", "dfg": [["n", 43, "comesFrom", ["n"], [38]], ["n", 50, "comesFrom", ["n"], [38]], ["n", 127, "comesFrom", ["n"], [119]], ["n", 57, "comesFrom", ["n"], [38]], ["n", 82, "comesFrom", ["n"], [38]], ["n", 75, "comesFrom", ["n"], [38]], ["n", 104, "comesFrom", ["n"], [38]], ["n", 97, "comesFrom", ["n"], [38]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; } int main ( void ) { int x = 16 ; cout << firstFactorialDivisibleNumber ( x ) ; return 0 ; }", "docstring": "Find the first natural number whose factorial is divisible by x | C ++ program to find first natural number whose factorial divides x . ; GCD function to compute the greatest divisor among a and b ; Returns first number whose factorial divides x . ; int i = 1 ; Result ; Remove common factors ; We found first i . ; Driver code", "dfg": [["i", 86, "comesFrom", ["i"], [55]], ["i", 59, "comesFrom", ["i"], [55]], ["i", 63, "comesFrom", ["i"], [55]], ["i", 71, "comesFrom", ["i"], [55]], ["b", 28, "comesFrom", ["b"], [14]], ["b", 33, "comesFrom", ["b"], [14]], ["b", 37, "comesFrom", ["b"], [14]], ["b", 22, "comesFrom", ["b"], [14]], ["x", 61, "comesFrom", ["x"], [51]], ["x", 104, "comesFrom", ["x"], [96]], ["a", 35, "comesFrom", ["a"], [11]], ["a", 20, "comesFrom", ["a"], [11]], ["new_x", 78, "comesFrom", ["new_x"], [67]], ["new_x", 73, "comesFrom", ["new_x"], [67]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sieve ( bool prime [ ] , int n ) { prime [ 0 ] = prime [ 1 ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } int maxDigitInPrimes ( int L , int R ) { bool prime [ R + 1 ] ; memset ( prime , 0 , sizeof ( prime ) ) ; sieve ( prime , R ) ; int freq [ 10 ] = { 0 } ; int val ; for ( int i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p ) { freq [ p % 10 ] ++ ; p /= 10 ; } } } int max = freq [ 0 ] , ans = 0 ; for ( int j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ( max != 0 ) ? ans : -1 ; } int main ( ) { int L = 1 , R = 20 ; cout << maxDigitInPrimes ( L , R ) << endl ; return 0 ; }", "docstring": "Find the highest occurring digit in prime numbers in a range | C ++ program to find the highest occurring digit in prime numbers in a range L to R . ; Sieve of Eratosthenes ; Returns maximum occurring digits in primes from l to r . ; Finding the prime number up to R . ; Initialise frequency of all digit to 0. ; For all number between L to R , check if prime or not . If prime , incrementing the frequency of digits present in the prime number . ; int p = i ; If i is prime ; Finding digit with highest frequency . ; Driven Program", "dfg": [["n", 42, "comesFrom", ["n"], [16]], ["n", 68, "comesFrom", ["n"], [16]], ["p", 44, "comesFrom", ["p"], [34]], ["p", 38, "comesFrom", ["p"], [34]], ["p", 40, "comesFrom", ["p"], [34]], ["p", 72, "comesFrom", ["p"], [34]], ["p", 159, "comesFrom", ["p"], [34]], ["p", 52, "comesFrom", ["p"], [34]], ["p", 62, "comesFrom", ["p"], [34]], ["p", 164, "comesFrom", ["p"], [34]], ["i", 140, "comesFrom", ["i"], [136]], ["i", 144, "comesFrom", ["i"], [136]], ["i", 66, "comesFrom", ["i"], [60]], ["i", 153, "comesFrom", ["i"], [136]], ["i", 76, "comesFrom", ["i"], [70]], ["R", 142, "comesFrom", ["R"], [90]], ["R", 96, "comesFrom", ["R"], [90]], ["R", 117, "comesFrom", ["R"], [90]], ["R", 259, "comesFrom", ["R"], [249]], ["j", 196, "comesFrom", ["j"], [192]], ["j", 200, "comesFrom", ["j"], [192]], ["j", 223, "comesFrom", ["j"], [192]], ["j", 210, "comesFrom", ["j"], [192]], ["j", 218, "comesFrom", ["j"], [192]], ["ans", 234, "comesFrom", ["ans"], [221]], ["max", 229, "comesFrom", ["max"], [214]], ["max", 206, "comesFrom", ["max"], [178]], ["L", 257, "comesFrom", ["L"], [245]]]}
{"code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool arr [ 1001 ] ; void simpleSieve ( ) { memset ( arr , true , sizeof ( arr ) ) ; for ( int p = 2 ; p * p < 1001 ; p ++ ) { if ( arr [ p ] ) { for ( int i = p * 2 ; i < 1001 ; i = i + p ) arr [ i ] = false ; } } } int find_sphene ( int N ) { int arr1 [ 8 ] = { 0 } ; int count = 0 ; int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( N % i == 0 && count < 9 ) { count ++ ; arr1 [ j ++ ] = i ; } } if ( count == 8 && ( arr [ arr1 [ 1 ] ] && arr [ arr1 [ 2 ] ] && arr [ arr1 [ 3 ] ] ) ) return 1 ; return 0 ; } int main ( ) { int n = 60 ; simpleSieve ( ) ; int ans = find_sphene ( n ) ; if ( ans ) cout << \" Yes \" ; else cout << \" NO \" ; }", "docstring": "Sphenic Number | C ++ program to check whether a number is a Sphenic number or not ; create a global array of size 10001 ; ; This functions finds all primes smaller than ' limit ' using simple sieve of eratosthenes . ; initialize all entries of it as true . A value in mark [ p ] will finally be false if ' p ' is Not a prime , else true . ; One by one traverse all numbers so that their multiples can be marked as composite . ; If p is not changed , then it is a prime ; Update all multiples of p ; to store the 8 divisors ; to count the number of divisor ; finally check if there re 8 divisor and all the numbers are distinct prime no return 1 else return 0 ; Driver program to test above function", "dfg": [["p", 43, "comesFrom", ["p"], [33]], ["p", 37, "comesFrom", ["p"], [33]], ["p", 39, "comesFrom", ["p"], [33]], ["p", 51, "comesFrom", ["p"], [33]], ["p", 72, "comesFrom", ["p"], [33]], ["p", 60, "comesFrom", ["p"], [33]], ["i", 118, "comesFrom", ["i"], [114]], ["i", 122, "comesFrom", ["i"], [114]], ["i", 64, "comesFrom", ["i"], [58]], ["i", 148, "comesFrom", ["i"], [114]], ["i", 70, "comesFrom", ["i"], [68]], ["i", 130, "comesFrom", ["i"], [114]], ["i", 76, "comesFrom", ["i"], [68]], ["N", 120, "comesFrom", ["N"], [88]], ["N", 128, "comesFrom", ["N"], [88]], ["ans", 215, "comesFrom", ["ans"], [206]], ["count", 154, "comesFrom", ["count"], [102]], ["count", 134, "comesFrom", ["count"], [102]], ["count", 139, "comesFrom", ["count"], [102]], ["n", 210, "comesFrom", ["n"], [197]], ["j", 144, "comesFrom", ["j"], [107]]]}
